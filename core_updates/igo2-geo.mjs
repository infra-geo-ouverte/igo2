import * as i0 from '@angular/core';
import { Injectable, Component, ChangeDetectionStrategy, Input, ViewChildren, EventEmitter, Output, Directive, Self, HostListener, ContentChild, Optional, NgModule, ViewEncapsulation, Inject, Pipe, ViewChild, ChangeDetectorRef, Injector, InjectionToken, APP_INITIALIZER } from '@angular/core';
import * as i2$2 from '@angular/common';
import { CommonModule, DOCUMENT } from '@angular/common';
import * as i6 from '@angular/material/badge';
import { MatBadgeModule } from '@angular/material/badge';
import * as i2$3 from '@angular/material/icon';
import { MatIconModule } from '@angular/material/icon';
import * as i5 from '@angular/material/list';
import { MatListModule } from '@angular/material/list';
import * as i4 from '@angular/material/tooltip';
import { MatTooltipModule } from '@angular/material/tooltip';
import * as i9$1 from '@igo2/common';
import { SecureImagePipe, getEntityId, getEntityTitle, getEntityProperty, getEntityRevision, getEntityIcon, EntityStore, EntityStoreStrategy, IgoListModule, IgoCollapsibleModule, IgoImageModule, IgoPanelModule, IgoMatBadgeIconModule, IgoCustomHtmlModule, EntityStoreWatcher, EntityTableColumnRenderer, IgoEntityTableModule, IgoKeyValueModule, IgoFormModule, IgoFormFieldComponent, DOMService, EntityStoreFilterSelectionStrategy, IgoEntityModule, IgoDOMModule, DragAndDropDirective, IgoSpinnerModule, IgoDrapDropModule, IgoConfirmDialogModule, getEntityTitleHtml, EntityStoreFilterCustomFuncStrategy, IgoStopPropagationModule, ColorPickerFormFieldModule, IgoFlexibleModule, WidgetService, Workspace, ActionStore, IgoWidgetModule } from '@igo2/common';
import * as i4$1 from '@angular/material/button';
import { MatButtonModule } from '@angular/material/button';
import * as i2 from '@igo2/core';
import { IgoLanguageModule, Media, StorageScope, ConfigService, IgoMessageModule, LanguageService, StorageService } from '@igo2/core';
import * as i2$1 from '@angular/forms';
import { ReactiveFormsModule, FormsModule, Validators, UntypedFormControl } from '@angular/forms';
import * as i11 from '@angular/material/checkbox';
import { MatCheckboxModule } from '@angular/material/checkbox';
import * as i9$2 from '@angular/material/divider';
import { MatDividerModule } from '@angular/material/divider';
import * as i8 from '@angular/material/form-field';
import { MatFormFieldModule } from '@angular/material/form-field';
import * as i9$3 from '@angular/material/input';
import { MatInputModule } from '@angular/material/input';
import * as i7$1 from '@angular/material/menu';
import { MatMenuModule } from '@angular/material/menu';
import * as i15 from '@angular/material/select';
import { MatSelectModule, MAT_SELECT_CONFIG } from '@angular/material/select';
import * as i7 from '@angular/material/slide-toggle';
import { MatSlideToggleModule } from '@angular/material/slide-toggle';
import * as i8$1 from '@angular/material/slider';
import { MatSliderModule, MatSlider } from '@angular/material/slider';
import OlFeature from 'ol/Feature';
import * as olStyle from 'ol/style';
import { NumberUtils, ObjectUtils, uuid, Watcher, SubjectStatus, strEnum, Clipboard, userAgent, ChangeUtils, downloadContent, customCacheHasher } from '@igo2/utils';
import { MAC } from 'ol/has';
import * as olproj from 'ol/proj';
import { transform } from 'ol/proj';
import { asArray } from 'ol/color';
import { forkJoin, of, Observable, BehaviorSubject, combineLatest, ReplaySubject, EMPTY, timer, debounceTime as debounceTime$1, pairwise, interval, Subject, skipWhile as skipWhile$1, fromEvent, zip, Subscription, throwError, first as first$1, take as take$1 } from 'rxjs';
import * as i1 from '@angular/common/http';
import { HttpParams, HttpClient, HttpHeaders } from '@angular/common/http';
import { map, catchError, debounce, debounceTime, concatMap, skipWhile, skip, distinctUntilChanged, switchMap, first, delay, take, mergeMap, takeUntil, startWith } from 'rxjs/operators';
import { __decorate, __metadata } from 'tslib';
import olAttribution from 'ol/control/Attribution';
import * as olformat from 'ol/format';
import { WMSCapabilities, WMTSCapabilities, EsriJSON } from 'ol/format';
import { optionsFromCapabilities } from 'ol/source/WMTS.js';
import { Cacheable } from 'ts-cacheable';
import olSourceImageWMS from 'ol/source/ImageWMS';
import olFormatWFS from 'ol/format/WFS';
import olWKT from 'ol/format/WKT';
import * as olfilter from 'ol/format/filter';
import moment from 'moment';
import { Md5 } from 'ts-md5';
import olFormatGML2 from 'ol/format/GML2';
import olFormatGML3 from 'ol/format/GML3';
import olFormatGML32 from 'ol/format/GML32';
import olFormatOSMXML from 'ol/format/OSMXML';
import * as i9 from '@angular/material/core';
import { MatOptionModule, MAT_DATE_LOCALE, MatNativeDateModule } from '@angular/material/core';
import * as i10 from '@ngx-translate/core';
import * as olextent from 'ol/extent';
import { getCenter } from 'ol/extent';
import scrollIntoView from 'scroll-into-view-if-needed';
import { getUid } from 'ol/util';
import olLayerImage from 'ol/layer/Image';
import olLayerTile from 'ol/layer/Tile';
import * as olObservable from 'ol/Observable';
import { unByKey } from 'ol/Observable';
import * as oleasing from 'ol/easing';
import { easeOut } from 'ol/easing';
import OlVectorLayer from 'ol/layer/Vector';
import olProjection from 'ol/proj/Projection';
import { getVectorContext, getRenderPixel } from 'ol/render';
import OlVectorSource from 'ol/source/Vector';
import olMap from 'ol/Map';
import olView from 'ol/View';
import olControlScaleLine from 'ol/control/ScaleLine';
import * as olInteraction from 'ol/interaction';
import * as olproj4 from 'ol/proj/proj4';
import proj4 from 'proj4';
import OlGeoJSON from 'ol/format/GeoJSON';
import OlLineString from 'ol/geom/LineString';
import OlPoint from 'ol/geom/Point';
import OlPolygon, { fromCircle, circular } from 'ol/geom/Polygon';
import olSourceOSM from 'ol/source/OSM';
import olSourceXYZ from 'ol/source/XYZ';
import * as OlLoadingStrategy from 'ol/loadingstrategy';
import olSourceWMTS from 'ol/source/WMTS';
import { getWidth, getTopLeft } from 'ol/extent.js';
import olTileGridWMTS from 'ol/tilegrid/WMTS';
import olSourceCarto from 'ol/source/CartoDB';
import olFormatEsriJSON from 'ol/format/EsriJSON';
import ImageArcGISRest from 'ol/source/ImageArcGISRest';
import olSourceTileArcGISRest from 'ol/source/TileArcGISRest';
import TileDebug from 'ol/source/TileDebug';
import TileGrid from 'ol/tilegrid/TileGrid';
import olFormatMVT from 'ol/format/MVT';
import olSourceVectorTile from 'ol/source/VectorTile';
import olSourceCluster from 'ol/source/Cluster';
import OlDragBoxInteraction from 'ol/interaction/DragBox';
import { Document as Document$1 } from 'flexsearch';
import olGeolocation from 'ol/Geolocation';
import * as olgeom from 'ol/geom';
import { Point } from 'ol/geom';
import OlCircle from 'ol/geom/Circle';
import * as olSphere from 'ol/sphere';
import { getLength, getArea, getDistance } from 'ol/sphere';
import olLayerVectorTile from 'ol/layer/VectorTile';
import RenderFeature from 'ol/render/Feature';
import * as i6$1 from '@igo2/auth';
import { AuthService } from '@igo2/auth';
import { stylefunction } from 'ol-mapbox-style';
import * as i1$1 from 'ngx-indexed-db';
import { DBMode } from 'ngx-indexed-db';
import * as i1$2 from '@angular/material/dialog';
import { MAT_DIALOG_DATA, MatDialogModule } from '@angular/material/dialog';
import * as i6$2 from '@angular/material/autocomplete';
import { MatAutocompleteModule, MAT_AUTOCOMPLETE_DEFAULT_OPTIONS } from '@angular/material/autocomplete';
import * as i3 from '@angular/cdk/drag-drop';
import { moveItemInArray, DragDropModule } from '@angular/cdk/drag-drop';
import html2canvas from 'html2canvas';
import jsPDF from 'jspdf';
import 'jspdf-autotable';
import { saveAs } from 'file-saver';
import JSZip from 'jszip';
import pointOnFeature from '@turf/point-on-feature';
import * as olCondition from 'ol/events/condition';
import { doubleClick } from 'ol/events/condition';
import NoSleep from 'nosleep.js';
import { trigger, state, style, transition, animate } from '@angular/animations';
import { bearingToAzimuth, lineString } from '@turf/helpers';
import striptags from 'striptags';
import * as i5$1 from '@angular/material/button-toggle';
import { MatButtonToggleModule } from '@angular/material/button-toggle';
import * as i8$2 from '@angular/material/radio';
import { MatRadioModule } from '@angular/material/radio';
import * as i2$4 from '@angular/platform-browser';
import { BrowserModule } from '@angular/platform-browser';
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
import OlOverlay from 'ol/Overlay';
import OlDraw from 'ol/interaction/Draw';
import OlModify from 'ol/interaction/Modify';
import OlSelect from 'ol/interaction/Select';
import lineIntersect from '@turf/line-intersect';
import * as i12 from '@angular/material/datepicker';
import { MatDatepickerModule } from '@angular/material/datepicker';
import * as i9$4 from '@angular/material/table';
import { MatTableModule } from '@angular/material/table';
import * as i4$2 from '@angular/material/tabs';
import { MatTabsModule } from '@angular/material/tabs';
import * as i10$1 from '@angular/material/tree';
import { MatTreeNestedDataSource, MatTreeModule } from '@angular/material/tree';
import * as i12$1 from '@mat-datetimepicker/core';
import { MatDatetimepickerModule, MatNativeDatetimeModule } from '@mat-datetimepicker/core';
import OlStyle from 'ol/style/Style';
import OlLinearRing from 'ol/geom/LinearRing';
import OlTranslate from 'ol/interaction/Translate';
import { SelectionModel } from '@angular/cdk/collections';
import { NestedTreeControl } from '@angular/cdk/tree';
import { encode } from 'windows-1252';
import Circle from 'ol/style/Circle';
import Fill from 'ol/style/Fill';
import Stroke from 'ol/style/Stroke';
import Collection from 'ol/Collection';
import { BehaviorSubject as BehaviorSubject$1 } from 'rxjs/internal/BehaviorSubject';

/**
 * This method extracts a coordinate tuple from a string.
 * @param str Any string
 * @param mapProjection string Map Projection
 * @param opts.forceNA boolean Force North America Zone
 * @returns object:
 *             lonLat: Coordinate,
 *             message: Message of error,
 *             radius: radius of the confience of coordinate,
 *             conf: confidence of the coordinate}
 */
function stringToLonLat(str, mapProjection, opts = {}) {
    let lonLat;
    let coordStr;
    let negativeLon;
    let degreesLon;
    let minutesLon;
    let secondsLon;
    let directionLon;
    let decimalLon;
    let negativeLat;
    let degreesLat;
    let minutesLat;
    let secondsLat;
    let directionLat;
    let decimalLat;
    let zone;
    let radius;
    let conf;
    let lon;
    let lat;
    const projectionPattern = '(\\s*;\\s*[\\d]{4,6})';
    const toProjection = '4326';
    let projectionStr;
    const projectionRegex = new RegExp(projectionPattern, 'g');
    const lonlatCoord = '([-+])?([\\d]{1,3})([,.](\\d+))?';
    const lonLatPattern = `${lonlatCoord}[\\s,]+${lonlatCoord}`;
    const lonLatRegex = new RegExp(`^${lonLatPattern}$`, 'g');
    const dmsCoord = '([0-9]{1,2})[:|°]?\\s*([0-9]{1,2})?[:|\'|′|’]?\\s*([0-9]{1,2}(?:.[0-9]+){0,1})?\\s*["|″|”]?\\s*';
    const dmsCoordPattern = `${dmsCoord}([N|S|E|W|O]),?\\s*${dmsCoord}([N|S|E|W|O])`;
    const dmsRegex = new RegExp(`^${dmsCoordPattern}$`, 'gi');
    const patternUtm = '(UTM)-?(\\d{1,2})[\\s,]*(\\d+[.,]?\\d+)[\\s,]+(\\d+[.,]?\\d+)';
    const utmRegex = new RegExp(`^${patternUtm}`, 'gi');
    const patternMtm = '(MTM)-?(\\d{1,2})[\\s,]*(\\d+[.,]?\\d+)[\\s,]+(\\d+[.,]?\\d+)';
    const mtmRegex = new RegExp(`^${patternMtm}`, 'gi');
    const ddCoord = '([-+])?(\\d{1,3})[,.](\\d+)';
    const patternDd = `${ddCoord}\\s*[,]?\\s*${ddCoord}`;
    const ddRegex = new RegExp(`^${patternDd}`, 'g');
    const dmdCoord = '([-+])?(\\d{1,3})[\\s,.]{1}(\\d{1,2})[\\s,.]{1}(\\d{1,2})[.,]?(\\d{1,5})?';
    const patternDmd = `${dmdCoord}\\s*[,.]?\\s*${dmdCoord}`;
    const dmdRegex = new RegExp(`^${patternDmd}`, 'g');
    /* eslint-disable max-len */
    const patternBELL = 'LAT\\s*[\\s:]*\\s*([-+])?(\\d{1,2})[\\s.,]?(\\d+)?[\\s.,]?\\s*(\\d{1,2}([.,]\\d+)?)?\\s*(N|S|E|W)?\\s*LONG\\s*[\\s:]*\\s*([-+])?(\\d{1,3})[\\s.,]?(\\d+)?[\\s.,]?\\s*(\\d{1,2}([.,]\\d+)?)?\\s*(N|S|E|W)?\\s*UNC\\s*[\\s:]?\\s*(\\d+)\\s*CONF\\s*[\\s:]?\\s*(\\d{1,3})';
    const bellRegex = new RegExp(`^${patternBELL}?`, 'gi');
    const mmCoord = '([-+]?\\d+)[,.]?(\\d+)?';
    const mmPattern = `${mmCoord}[\\s,]+${mmCoord}`;
    const mmRegex = new RegExp(`^${mmPattern}$`, 'g');
    let isXYCoords = false;
    str = str.toLocaleUpperCase().trim();
    // Extract projection
    if (projectionRegex.test(str)) {
        [coordStr, projectionStr] = str.split(';').map((s) => s.trim());
    }
    else {
        coordStr = str;
    }
    if (lonLatRegex.test(coordStr)) {
        [, negativeLon, lon, , decimalLon, negativeLat, lat, , decimalLat] =
            coordStr.match(lonLatPattern);
        lon = parseFloat((negativeLon ? negativeLon : '') + lon + '.' + decimalLon);
        lat = parseFloat((negativeLat ? negativeLat : '') + lat + '.' + decimalLat);
    }
    else if (dmsRegex.test(coordStr)) {
        [
            ,
            degreesLon,
            minutesLon,
            secondsLon,
            directionLon,
            degreesLat,
            minutesLat,
            secondsLat,
            directionLat
        ] = coordStr.match(dmsCoordPattern);
        if (directionLon === 'S' || directionLon === 'N') {
            degreesLon = [degreesLat, (degreesLat = degreesLon)][0];
            minutesLon = [minutesLat, (minutesLat = minutesLon)][0];
            secondsLon = [secondsLat, (secondsLat = secondsLon)][0];
            directionLon = [directionLat, (directionLat = directionLon)][0];
        }
        lon = convertDMSToDD(parseFloat(degreesLon), parseFloat(minutesLon), parseFloat(secondsLon), directionLon);
        lat = convertDMSToDD(parseFloat(degreesLat), parseFloat(minutesLat), parseFloat(secondsLat), directionLat);
    }
    else if (utmRegex.test(coordStr)) {
        isXYCoords = true;
        [, , zone, lon, lat] = coordStr.match(patternUtm);
        const epsgUtm = Number(zone) < 10 ? `EPSG:3260${zone}` : `EPSG:326${zone}`;
        [lon, lat] = olproj.transform([parseFloat(lon), parseFloat(lat)], epsgUtm, 'EPSG:4326');
    }
    else if (mtmRegex.test(coordStr)) {
        isXYCoords = true;
        [, , zone, lon, lat] = coordStr.match(patternMtm);
        const epsgMtm = Number(zone) < 10 ? `EPSG:3218${zone}` : `EPSG:321${80 + Number(zone)}`;
        [lon, lat] = olproj.transform([parseFloat(lon), parseFloat(lat)], epsgMtm, 'EPSG:4326');
    }
    else if (dmdRegex.test(coordStr)) {
        [
            ,
            negativeLon,
            degreesLon,
            minutesLon,
            secondsLon,
            decimalLon,
            negativeLat,
            degreesLat,
            minutesLat,
            secondsLat,
            decimalLat
        ] = coordStr.match(patternDmd);
        lon = convertDMSToDD(parseFloat((negativeLon ? negativeLon : '') + degreesLon), parseFloat(minutesLon), parseFloat(secondsLon), directionLon);
        lat = convertDMSToDD(parseFloat((negativeLat ? negativeLat : '') + degreesLat), parseFloat(minutesLat), parseFloat(secondsLat), directionLat);
    }
    else if (ddRegex.test(coordStr)) {
        [
            ,
            negativeLon,
            degreesLon,
            decimalLon,
            negativeLat,
            degreesLat,
            decimalLat
        ] = coordStr.match(patternDd);
        lon = convertDMSToDD(parseFloat((negativeLon ? negativeLon : '') + degreesLon), parseFloat(minutesLon), parseFloat(secondsLon), directionLon);
        lat = convertDMSToDD(parseFloat((negativeLat ? negativeLat : '') + degreesLat), parseFloat(minutesLat), parseFloat(secondsLat), directionLat);
    }
    else if (bellRegex.test(coordStr)) {
        [
            ,
            negativeLat,
            degreesLat,
            minutesLat,
            secondsLat,
            ,
            directionLat,
            negativeLon,
            degreesLon,
            minutesLon,
            secondsLon,
            ,
            directionLon,
            radius,
            conf
        ] = coordStr.match(patternBELL);
        // Set default value for North America
        if (!directionLon) {
            directionLon = 'W';
        }
        // Check if real minutes or decimals
        if (minutesLon && minutesLon.length > 2) {
            lon = parseFloat((negativeLon ? negativeLon : '') + degreesLon + '.' + minutesLon);
        }
        else {
            lon = convertDMSToDD(parseFloat(degreesLon), parseFloat(minutesLon), parseFloat(secondsLon), directionLon);
        }
        if (minutesLat && minutesLat.length > 2) {
            lat = parseFloat((negativeLat ? negativeLat : '') + degreesLat + '.' + minutesLat);
        }
        else {
            lat = convertDMSToDD(parseFloat(degreesLat), parseFloat(minutesLat), parseFloat(secondsLat), directionLat);
        }
    }
    else if (mmRegex.test(coordStr)) {
        isXYCoords = true;
        [, lon, decimalLon, lat, decimalLat] = coordStr.match(mmPattern);
        if (decimalLon) {
            lon = parseFloat(lon + '.' + decimalLon);
        }
        if (decimalLat) {
            lat = parseFloat(lat + '.' + decimalLat);
        }
    }
    else {
        return {
            lonLat: undefined,
            message: '',
            radius: undefined,
            conf: undefined
        };
    }
    if (opts.forceNA && !isXYCoords) {
        // Set a negative coordinate for North America zone
        if (lon > 0 && lat > 0) {
            if (lon > lat) {
                lon = -lon;
            }
            else {
                lat = -lat;
            }
        }
        // Reverse coordinate to respect lonLat convention
        if (lon > lat) {
            lon = [lat, (lat = lon)][0];
        }
    }
    lonLat = [Number(lon), Number(lat)];
    // Reproject the coordinate if projection parameter have been set and coord is not 4326
    if ((projectionStr !== undefined && projectionStr !== toProjection) ||
        lonLat[0] > 180 ||
        lonLat[0] < -180 ||
        lonLat[1] > 90 ||
        lonLat[1] < -90) {
        const source = projectionStr ? 'EPSG:' + projectionStr : mapProjection;
        const dest = 'EPSG:' + toProjection;
        try {
            lonLat = olproj.transform(lonLat, source, dest);
        }
        catch (e) {
            return {
                lonLat: undefined,
                message: 'Projection ' + source + ' not supported',
                radius: undefined,
                conf: undefined
            };
        }
    }
    if (Math.abs(lonLat[0]) <= 180 && Math.abs(lonLat[1]) <= 90) {
        return {
            lonLat,
            message: '',
            radius: radius ? parseInt(radius, 10) : undefined,
            conf: conf ? parseInt(conf, 10) : undefined
        };
    }
    else {
        return {
            lonLat: undefined,
            message: 'Coordinate out of Longitude/Latitude bounds',
            radius: undefined,
            conf: undefined
        };
    }
}
/**
 * Convert degrees minutes seconds to dd
 * @param degrees Degrees
 * @param minutes Minutes
 * @param seconds Seconds
 * @param direction Direction
 */
function convertDMSToDD(degrees, minutes, seconds, direction) {
    minutes = minutes || 0;
    seconds = seconds || 0;
    const neg = degrees < 0;
    let dd = Math.abs(degrees) + minutes / 60 + seconds / 3600;
    if (neg || direction === 'S' || direction === 'W') {
        dd = -dd;
    } // Don't do anything for N or E
    return dd;
}
/**
 * Convert dd to degrees minutes seconds
 * @param lonLatDD longitude and latitude in dd
 * @param decimal number of decimals for seconds
 * @returns longitude and latitude in dms
 */
function convertDDToDMS(lonLatDD, decimal = 3) {
    const lonLatDMS = [];
    lonLatDD.forEach((dd) => {
        const degrees = dd < 0 ? Math.ceil(dd) : Math.floor(dd);
        const int = dd < 0 ? (degrees - dd) * 60 : (dd - degrees) * 60;
        const minutes = Math.floor(int);
        const seconds = ((int - minutes) * 60).toFixed(decimal);
        lonLatDMS.push(`${degrees}° ${minutes}' ${seconds}"`);
    });
    return lonLatDMS;
}
/**
 * Return true of two view states are equal.
 * @param state1 View state
 * @param state2 View state
 * @returns True if the view states are equal
 */
function viewStatesAreEqual(state1, state2) {
    if (state1 === undefined || state2 === undefined) {
        return false;
    }
    const tolerance = 1 / 10000;
    return (state1.zoom === state2.zoom &&
        Math.trunc(state1.center[0] / tolerance) ===
            Math.trunc(state2.center[0] / tolerance) &&
        Math.trunc(state1.center[1] / tolerance) ===
            Math.trunc(state2.center[1] / tolerance));
}
/**
 * Format the scale to a human readable text
 * @param Scale of the map
 * @returns Human readable scale text
 */
function formatScale(scale) {
    scale = Math.round(scale);
    if (scale < 10000) {
        return scale + '';
    }
    scale = Math.round(scale / 1000);
    if (scale < 1000) {
        return scale + 'K';
    }
    scale = Math.round(scale / 1000);
    return scale + 'M';
}
/**
 * Return the resolution from a scale denom
 * @param scale Scale denom
 * @param dpi DPI
 * @returns Resolution
 */
function getResolutionFromScale(scale, dpi = 96) {
    const inchesPerMeter = 39.3701;
    return scale / (inchesPerMeter * dpi);
}
/**
 * Return the resolution from a scale denom
 * @param Scale denom
 * @returns Resolution
 */
function getScaleFromResolution(resolution, unit = 'm', dpi = 96) {
    const inchesPerMeter = 39.3701;
    return resolution * olproj.METERS_PER_UNIT[unit] * inchesPerMeter * dpi;
}
/**
 * Returns true if the CTRL key is pushed during an Ol MapBrowserPointerEvent
 * @param event OL MapBrowserPointerEvent
 * @returns Whether the CTRL key is pushed
 */
function ctrlKeyDown(event) {
    const originalEvent = event.originalEvent;
    return (!originalEvent.altKey &&
        (MAC ? originalEvent.metaKey : originalEvent.ctrlKey) &&
        !originalEvent.shiftKey);
}
function roundCoordTo(coord, decimal = 3) {
    return [
        NumberUtils.roundToNDecimal(coord[0], decimal),
        NumberUtils.roundToNDecimal(coord[1], decimal)
    ];
}
function roundCoordToString(coord, decimal = 3) {
    return roundCoordTo(coord, decimal).map((r) => r.toString());
}
/**
 * Returns an array of converted coordinates.
 * Conversion is done for every configured projections
 * and for the current UTM zone and MTM zone.
 * @param lonLat [number, number] array of the coordinate to transform.
 * @param projections  Projection[] Array of destination projection.
 * @param reverseCoords To reverse coords from latLon to lonLat (search option)
 * @returns Returns an array of converted coordinates.
 */
function lonLatConversion(lonLat, projections) {
    const rawCoord3857 = olproj.transform(lonLat, 'EPSG:4326', 'EPSG:3857');
    const convertedLonLat = [
        {
            code: 'EPSG:3857',
            alias: 'Web Mercator',
            coord: rawCoord3857,
            igo2CoordFormat: `${roundCoordTo(rawCoord3857).join(', ')} ; 3857`
        }
    ];
    // detect the current utm zone.
    const utmZone = utmZoneFromLonLat(lonLat);
    const epsgUtm = utmZone < 10 ? `EPSG:3260${utmZone}` : `EPSG:326${utmZone}`;
    const utmName = `UTM-${utmZone}`;
    const rawCoordUtm = olproj.transform(lonLat, 'EPSG:4326', epsgUtm);
    convertedLonLat.push({
        code: epsgUtm,
        alias: 'UTM',
        coord: rawCoordUtm,
        igo2CoordFormat: `${utmName} ${roundCoordTo(rawCoordUtm).join(', ')}`
    });
    // detect the current mtm zone.
    const mtmZone = mtmZoneFromLonLat(lonLat);
    if (mtmZone) {
        const epsgMtm = mtmZone < 10 ? `EPSG:3218${mtmZone}` : `EPSG:321${80 + mtmZone}`;
        const mtmName = `MTM-${mtmZone}`;
        const rawCoordMtm = olproj.transform(lonLat, 'EPSG:4326', epsgMtm);
        convertedLonLat.push({
            code: epsgMtm,
            alias: 'MTM',
            coord: rawCoordMtm,
            igo2CoordFormat: `${mtmName} ${roundCoordTo(rawCoordMtm).join(', ')}`
        });
    }
    projections.forEach((projection) => {
        const rawCoord = olproj.transform(lonLat, 'EPSG:4326', projection.code);
        const numericEpsgCode = projection.code.split(':')[1];
        convertedLonLat.push({
            code: projection.code,
            alias: projection.alias || projection.code,
            coord: rawCoord,
            igo2CoordFormat: `${roundCoordTo(rawCoord).join(', ')} ; ${numericEpsgCode}`
        });
    });
    return convertedLonLat;
}
/**
 * Detect the current utm zone of the lon/lat coordinate.
 * @param lonLat [number, number] array of the coordinate to detect the UTM zone.
 * @returns number The UTM zone.
 */
function utmZoneFromLonLat(lonLat) {
    return Math.ceil((lonLat[0] + 180) / 6);
}
/**
 * Detect the current mtm zone of the lon/lat coordinate.
 * @param lonLat [number, number] array of the coordinate to detect the MTM zone.
 * @returns number The MTM zone. Undefined if outside of the mtm application zone.
 */
function mtmZoneFromLonLat(lonLat) {
    const long = lonLat[0];
    let mtmZone;
    if (long < -51 && long > -54) {
        mtmZone = 1;
    }
    if (long < -54 && long > -57) {
        mtmZone = 2;
    }
    if (long < -57 && long > -60) {
        mtmZone = 3;
    }
    if (long < -60 && long > -63) {
        mtmZone = 4;
    }
    if (long < -63 && long > -66) {
        mtmZone = 5;
    }
    if (long < -66 && long > -69) {
        mtmZone = 6;
    }
    if (long < -69 && long > -72) {
        mtmZone = 7;
    }
    if (long < -72 && long > -75) {
        mtmZone = 8;
    }
    if (long < -75 && long > -78) {
        mtmZone = 9;
    }
    if (long < -78 && long > -81) {
        mtmZone = 10;
    }
    return mtmZone;
}

/**
 * Create a marker style for points
 * @returns Style
 */
function createOverlayMarkerStyle({ text, opacity = 1, markerColor = [0, 161, 222], markerOutlineColor = [255, 255, 255] } = {}) {
    let iconColor;
    let svgIconColor;
    let svgOutlineColor;
    let svg;
    const newColor = asArray(markerColor).slice(0);
    const newOutlineColor = asArray(markerOutlineColor).slice(0);
    if (newColor.length === 4 &&
        (typeof markerColor !== 'string' ||
            /^#[0-9A-F]{8}$/i.test(markerColor))) {
        opacity = newColor[3];
    }
    svgIconColor = `"rgba(${newColor[0]},${newColor[1]},${newColor[2]},${opacity})"`;
    iconColor = markerColor;
    svgOutlineColor = `"rgb(${newOutlineColor[0]},${newOutlineColor[1]},${newOutlineColor[2]})"`;
    svg =
        'data:image/svg+xml;utf8,<svg version="1.1" xmlns="http://www.w3.org/2000/svg" height="36" width="36" viewBox="0 0 36 36">' +
            '<path fill=' +
            svgIconColor +
            ' stroke=' +
            svgOutlineColor +
            ` stroke-width="2" d="M 17.692635,32.565644 C 15.71852,30.330584 13.290925,27.058065 11.6766,24.455732 9.3398623,20.688851 7.8905694,17.205334 7.6297492,14.728733 7.5616025,14.081649 7.5739557,12.528552 7.6513363,12.014724 8.1013861,9.0262716 9.8047068,6.3655569 12.310675,4.7364878 c 1.113691,-0.7239832 2.508083,-1.2834131 3.776687,-1.5152052 0.242945,-0.044389 0.451656,-0.09393 0.463804,-0.1100911 0.01215,-0.016161 0.638282,-0.025502 1.391411,-0.02076 1.088235,0.00685 1.450932,0.024316 1.766871,0.085071 2.650763,0.5097353 4.947142,1.8701891 6.498786,3.8501033 0.628018,0.8013587 1.297046,2.0200608 1.640967,2.9891872 0.191065,0.538399 0.427644,1.447408 0.477391,1.834287 0.0164,0.127546 0.0434,0.231902 0.06,0.231902 0.0166,0 0.03122,0.626135 0.03249,1.391411 0.0013,0.765276 -0.011,1.391411 -0.02726,1.391411 -0.01626,0 -0.05449,0.154049 -0.08495,0.342331 -0.08815,0.544879 -0.387235,1.721449 -0.604837,2.379406 -1.209421,3.656888 -4.014463,8.349762 -7.849521,13.132357 -0.790496,0.985807 -1.795217,2.167992 -1.842543,2.167992 -0.01896,0 -0.161766,-0.144111 -0.317336,-0.320246 z m 1.066937,-15.36525 c 0.133519,-0.02121 0.248766,-0.05657 0.256105,-0.07859 0.0073,-0.02202 0.04918,-0.03066 0.09298,-0.0192 0.0438,0.01145 0.107628,-0.0072 0.141834,-0.04137 0.03421,-0.03421 0.08456,-0.05474 0.111888,-0.04563 0.02733,0.0091 0.07703,-0.01077 0.110429,-0.04417 0.03341,-0.03341 0.08416,-0.05293 0.112796,-0.04338 0.02863,0.0095 0.08974,-0.01867 0.135802,-0.06271 0.04606,-0.04403 0.111902,-0.08625 0.146319,-0.09381 0.204084,-0.04483 0.762371,-0.519108 1.079463,-0.917027 0.26749,-0.335672 0.570987,-0.878795 0.529019,-0.946701 -0.01496,-0.0242 -0.0067,-0.044 0.01835,-0.044 0.05645,0 0.196809,-0.467982 0.158801,-0.529481 -0.01521,-0.02461 -0.0043,-0.04475 0.02427,-0.04475 0.03157,0 0.04365,-0.04329 0.03082,-0.11043 -0.01161,-0.06074 -0.0066,-0.110429 0.01124,-0.110429 0.01779,0 0.03235,-0.258405 0.03235,-0.574233 0,-0.315829 -0.01545,-0.574234 -0.03434,-0.574234 -0.01889,0 -0.02437,-0.03811 -0.01219,-0.08469 0.04412,-0.168712 -0.336329,-1.152668 -0.481536,-1.245401 -0.02327,-0.01486 -0.04022,-0.03992 -0.03765,-0.05568 0.01222,-0.07498 -0.156557,-0.318365 -0.406379,-0.586027 -0.295921,-0.317054 -0.773059,-0.690104 -0.83427,-0.652274 -0.0206,0.01273 -0.03745,0.0024 -0.03745,-0.02289 0,-0.06107 -0.433076,-0.2789369 -0.487546,-0.245273 -0.02338,0.01445 -0.04251,0.0068 -0.04251,-0.01695 0,-0.056281 -0.393995,-0.1865457 -0.613804,-0.2029397 -0.0943,-0.00703 -0.188579,-0.023183 -0.209503,-0.035888 -0.02092,-0.012705 -0.276571,-0.023337 -0.568105,-0.023627 -0.534044,-5.301e-4 -1.12638,0.091025 -1.12638,0.1741017 0,0.023781 -0.01713,0.032648 -0.03808,0.019705 -0.05054,-0.031232 -0.403641,0.1088602 -0.403641,0.1601422 0,0.02204 -0.01988,0.02779 -0.04417,0.01278 -0.0243,-0.01501 -0.04417,-0.0051 -0.04417,0.02209 0,0.02716 -0.01988,0.0371 -0.04417,0.02209 -0.0243,-0.01501 -0.04417,-0.0051 -0.04417,0.02209 0,0.02716 -0.01915,0.03755 -0.04256,0.02308 -0.02341,-0.01447 -0.08138,0.01252 -0.128834,0.05997 -0.04745,0.04745 -0.0974,0.07515 -0.111001,0.06155 -0.0136,-0.0136 -0.03722,0.0078 -0.05248,0.0476 -0.01526,0.03978 -0.0411,0.06408 -0.0574,0.054 -0.03277,-0.02025 -0.462299,0.323995 -0.491977,0.394291 -0.01026,0.02429 -0.07454,0.0912 -0.142856,0.148686 -0.248033,0.208705 -0.730279,0.974169 -0.672565,1.067553 0.0145,0.02346 0.0059,0.04266 -0.01914,0.04266 -0.05907,0 -0.241471,0.599428 -0.208527,0.685278 0.01385,0.0361 0.0044,0.06564 -0.02098,0.06564 -0.02539,0 -0.04169,0.0646 -0.03622,0.143558 0.0055,0.07896 -0.0042,0.213129 -0.02144,0.29816 -0.04741,0.233576 0.0511,1.055502 0.167516,1.397721 0.126048,0.370516 0.310099,0.740163 0.426484,0.856548 0.04776,0.04776 0.07554,0.08684 0.06174,0.08684 -0.0138,0 0.01516,0.05653 0.06436,0.125632 0.131301,0.184396 0.499365,0.587266 0.518785,0.567846 0.0092,-0.0092 0.09821,0.06081 0.197812,0.155562 0.09961,0.09475 0.190589,0.162786 0.202187,0.151188 0.0116,-0.0116 0.05991,0.01774 0.107361,0.06519 0.04745,0.04745 0.105426,0.07444 0.128834,0.05997 0.02341,-0.01447 0.04256,-0.0057 0.04256,0.01958 0,0.06106 0.344664,0.23496 0.399061,0.201341 0.02346,-0.0145 0.04266,-0.0059 0.04266,0.01914 0,0.05907 0.599429,0.241471 0.685279,0.208527 0.0361,-0.01385 0.06564,-0.0065 0.06564,0.01645 0,0.05196 1.079115,0.04833 1.413314,-0.0048 z"></path>` +
            '</svg>';
    return new olStyle.Style({
        image: new olStyle.Icon({
            src: svg,
            opacity,
            anchor: [0.5, 0.92]
        }),
        text: new olStyle.Text({
            text,
            font: '12px Calibri,sans-serif',
            fill: new olStyle.Fill({ color: '#000' }),
            stroke: new olStyle.Stroke({ color: '#fff', width: 3 }),
            overflow: true
        })
    });
}

class StyleService {
    style;
    /**
     * Create a style based on a object as
     * style: {
     *       "stroke": {
     *         "color": "blue",
     *         "lineDash": [10, 5]
     *       },
     *       "text": {
     *         "minScaleDenom": 50000,
     *         "maxScaleDenom": 200000,
     *         "minResolution": 100,
     *         "maxResolution": 400,
     *         "attribute": "THE COLUMN NAME TO RETRIEVE THE LABEL VALUE",
     *         "text": "MY HARCODED TEXT",
     *         "stroke": {
     *           "color": "blue",
     *           "width": 0.75
     *         },
     *         "fill": {
     *           "color": "black"
     *         },
     *         "font": "20px sans-serif",
     *         "overflow": true,
     *         "offsetX": 10,
     *         "offsetY": 20,
     *         "padding": [2.5, 2.5, 2.5, 2.5]
     *       },
     *       "width": 5
     *     }
     *
     * @param options
     * @param feature feature to apply style on
     * @param resolution current map resolution, to control label resolution range
     * @returns
     */
    createStyle(options, feature, resolution) {
        if (!options) {
            return createOverlayMarkerStyle();
        }
        if (typeof options === 'function' || options instanceof olStyle.Style) {
            return options;
        }
        const parsedStyle = this.parseStyle('style', options);
        if (parsedStyle.getText()) {
            let labelMinResolution = 0;
            let labelMaxResolution = Infinity;
            if (options.text) {
                const labelMinResolutionFromScale = options.text?.minScaleDenom
                    ? getResolutionFromScale(Number(options.text.minScaleDenom))
                    : undefined;
                const labelMaxResolutionFromScale = options.text?.maxScaleDenom
                    ? getResolutionFromScale(Number(options.text.maxScaleDenom))
                    : undefined;
                const minResolution = options.text?.minResolution
                    ? options.text.minResolution
                    : 0;
                const maxResolution = options.text?.maxResolution
                    ? options.text.maxResolution
                    : Infinity;
                labelMinResolution = labelMinResolutionFromScale || minResolution;
                labelMaxResolution = labelMaxResolutionFromScale || maxResolution;
            }
            if (options.text?.minScaleDenom ||
                options.text?.maxScaleDenom ||
                options.text?.minResolution ||
                options.text?.maxResolution) {
                if (feature &&
                    resolution >= labelMinResolution &&
                    resolution <= labelMaxResolution) {
                    if (feature && options.text.attribute) {
                        parsedStyle
                            .getText()
                            .setText(this.getLabel(feature, options.text.attribute));
                    }
                }
                else {
                    parsedStyle.setText();
                }
            }
        }
        return parsedStyle;
    }
    parseStyle(key, value) {
        const styleOptions = {};
        const olCls = this.getOlCls(key);
        if (olCls && value instanceof Object) {
            Object.keys(value).forEach((_key) => {
                const olKey = this.getOlKey(_key);
                styleOptions[olKey] = this.parseStyle(_key, value[_key]);
            });
            return new olCls(styleOptions);
        }
        else {
            return value;
        }
    }
    getOlKey(key) {
        let olKey;
        switch (key.toLowerCase()) {
            case 'circle':
            case 'regularshape':
            case 'icon':
                olKey = 'image';
                break;
            default:
                break;
        }
        return olKey || key;
    }
    getOlCls(key) {
        let olCls = olStyle[key.charAt(0).toUpperCase() + key.slice(1)];
        if (key === 'regularshape') {
            olCls = olStyle.RegularShape;
        }
        if (key === 'backgroundFill') {
            olCls = olStyle.Fill;
        }
        if (key === 'backgroundStroke') {
            olCls = olStyle.Stroke;
        }
        return olCls;
    }
    createStyleByAttribute(feature, styleByAttribute, resolution) {
        let style;
        const type = styleByAttribute.type
            ? styleByAttribute.type
            : this.guessTypeFeature(feature);
        const attribute = styleByAttribute.attribute;
        const data = styleByAttribute.data;
        const stroke = styleByAttribute.stroke;
        const width = styleByAttribute.width;
        const fill = styleByAttribute.fill;
        const anchor = styleByAttribute.anchor;
        const radius = styleByAttribute.radius;
        const icon = styleByAttribute.icon;
        const scale = styleByAttribute.scale;
        const size = data ? data.length : 0;
        const label = styleByAttribute.label
            ? styleByAttribute.label.attribute
            : undefined;
        const labelMinResolutionFromScale = styleByAttribute.label?.minScaleDenom
            ? getResolutionFromScale(Number(styleByAttribute.label.minScaleDenom))
            : undefined;
        const labelMaxResolutionFromScale = styleByAttribute.label?.maxScaleDenom
            ? getResolutionFromScale(Number(styleByAttribute.label.maxScaleDenom))
            : undefined;
        const minResolution = styleByAttribute.label?.minResolution
            ? styleByAttribute.label.minResolution
            : 0;
        const maxResolution = styleByAttribute.label?.maxResolution
            ? styleByAttribute.label.maxResolution
            : Infinity;
        const labelMinResolution = labelMinResolutionFromScale || minResolution;
        const labelMaxResolution = labelMaxResolutionFromScale || maxResolution;
        let labelStyle = styleByAttribute.label?.style
            ? this.parseStyle('text', styleByAttribute.label.style)
            : undefined;
        if (!labelStyle && label) {
            labelStyle = new olStyle.Text();
        }
        const baseStyle = styleByAttribute.baseStyle;
        if (labelStyle) {
            if (resolution >= labelMinResolution &&
                resolution <= labelMaxResolution) {
                labelStyle.setText(this.getLabel(feature, label));
            }
            else {
                labelStyle.setText('');
            }
        }
        if (type === 'circle') {
            for (let i = 0; i < size; i++) {
                const val = typeof feature.get(attribute) !== 'undefined' &&
                    feature.get(attribute) !== null
                    ? feature.get(attribute)
                    : '';
                if (val === data[i] ||
                    val.toString().match(new RegExp(data[i], 'gmi'))) {
                    if (icon) {
                        style = [
                            new olStyle.Style({
                                image: new olStyle.Icon({
                                    color: fill ? fill[i] : undefined,
                                    src: icon[i],
                                    scale: scale ? scale[i] : 1,
                                    anchor: anchor ? anchor[i] : [0.5, 0.5]
                                }),
                                text: labelStyle instanceof olStyle.Text ? labelStyle : undefined
                            })
                        ];
                        return style;
                    }
                    style = [
                        new olStyle.Style({
                            image: new olStyle.Circle({
                                radius: radius ? radius[i] : 4,
                                stroke: new olStyle.Stroke({
                                    color: stroke ? stroke[i] : 'black',
                                    width: width ? width[i] : 1
                                }),
                                fill: new olStyle.Fill({
                                    color: fill ? fill[i] : 'black'
                                })
                            }),
                            text: labelStyle instanceof olStyle.Text ? labelStyle : undefined
                        })
                    ];
                    return style;
                }
            }
            if (!feature.getStyle()) {
                if (baseStyle) {
                    style = this.createStyle(baseStyle, feature, resolution);
                    if (labelStyle) {
                        style.setText(labelStyle);
                    }
                    return style;
                }
                style = [
                    new olStyle.Style({
                        image: new olStyle.Circle({
                            radius: 4,
                            stroke: new olStyle.Stroke({
                                color: 'black'
                            }),
                            fill: new olStyle.Fill({
                                color: '#bbbbf2'
                            })
                        })
                    })
                ];
                return style;
            }
        }
        else if (type === 'regular') {
            for (let i = 0; i < size; i++) {
                const val = typeof feature.get(attribute) !== 'undefined' &&
                    feature.get(attribute) !== null
                    ? feature.get(attribute)
                    : '';
                if (val === data[i] ||
                    val.toString().match(new RegExp(data[i], 'gmi'))) {
                    style = [
                        new olStyle.Style({
                            stroke: new olStyle.Stroke({
                                color: stroke ? stroke[i] : 'black',
                                width: width ? width[i] : 1
                            }),
                            fill: new olStyle.Fill({
                                color: fill ? fill[i] : 'rgba(255,255,255,0.4)'
                            }),
                            text: labelStyle instanceof olStyle.Text ? labelStyle : undefined
                        })
                    ];
                    return style;
                }
            }
            if (feature instanceof OlFeature) {
                if (!feature.getStyle()) {
                    if (baseStyle) {
                        style = this.createStyle(baseStyle, feature, resolution);
                        if (labelStyle) {
                            style.setText(labelStyle);
                        }
                        return style;
                    }
                    style = [
                        new olStyle.Style({
                            stroke: new olStyle.Stroke({
                                color: 'black'
                            }),
                            fill: new olStyle.Fill({
                                color: '#bbbbf2'
                            })
                        })
                    ];
                    return style;
                }
            }
        }
    }
    createClusterStyle(feature, resolution, clusterParam = {}, layerStyle) {
        let style;
        const size = feature.get('features').length;
        if (size !== 1) {
            if (clusterParam.clusterRanges) {
                for (const r of clusterParam.clusterRanges) {
                    if ((!r.minRadius || r.minRadius <= size) &&
                        (!r.maxRadius || r.maxRadius >= size)) {
                        style = this.createStyle(r.style);
                        if (r.showRange) {
                            const text = new olStyle.Text({
                                text: size.toString(),
                                fill: new olStyle.Fill({
                                    color: '#fff'
                                })
                            });
                            style.setText(text);
                        }
                        if (r.dynamicRadius) {
                            let clusterRadius;
                            const radiusMin = style.getRadius();
                            clusterRadius = 5 * Math.log(size);
                            if (clusterRadius < radiusMin) {
                                clusterRadius = radiusMin;
                            }
                            style.image_.setRadius(clusterRadius);
                        }
                        break;
                    }
                }
            }
            if (!style) {
                let clusterRadius;
                if (clusterParam.radiusCalc) {
                    clusterRadius = clusterParam.radiusCalc(size);
                }
                else {
                    const radiusMin = 6;
                    clusterRadius = 5 * Math.log(size);
                    if (clusterRadius < radiusMin) {
                        clusterRadius = radiusMin;
                    }
                }
                style = [
                    new olStyle.Style({
                        image: new olStyle.Circle({
                            radius: clusterRadius,
                            stroke: new olStyle.Stroke({
                                color: 'black'
                            }),
                            fill: new olStyle.Fill({
                                color: 'rgba(24, 134, 45, 0.5)'
                            })
                        }),
                        text: new olStyle.Text({
                            text: size.toString(),
                            fill: new olStyle.Fill({
                                color: '#fff'
                            })
                        })
                    })
                ];
            }
        }
        else {
            style = this.createStyle(layerStyle, feature, resolution);
        }
        return style;
    }
    getLabel(feature, labelMatch) {
        let label = labelMatch;
        if (!label) {
            return;
        }
        const labelToGet = Array.from(labelMatch.matchAll(/\$\{([^\{\}]+)\}/g));
        labelToGet.forEach((v) => {
            label = label.replace(v[0], feature.get(v[1]));
        });
        // Nothing done? check feature's attribute
        if (labelToGet.length === 0 && label === labelMatch) {
            label = feature.get(labelMatch) || labelMatch;
        }
        return label;
    }
    guessTypeFeature(feature) {
        switch (feature.getGeometry().getType()) {
            case 'Point':
            case 'MultiPoint':
            case 'Circle':
                return 'circle';
            default:
                return 'regular';
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: StyleService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: StyleService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: StyleService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });

/**
 * Whether a layer is queryable
 * @param layer Layer
 * @returns True if the layer s squeryable
 */
function layerIsQueryable(layer) {
    const dataSource = layer.dataSource;
    return dataSource.options.queryable === true;
}
/**
 * Whether an OL layer is queryable
 * @param layer Layer
 * @returns True if the ol layer is queryable
 */
function olLayerIsQueryable(olLayer) {
    const layer = olLayer.get('_layer');
    return layer === undefined ? false : layerIsQueryable(layer);
}
/**
 * Whether a layer's feature is queryable
 * @param layer Layer
 * @returns True if the layer's feature is queryable
 */
function layerFeatureIsQueryable(layer) {
    const dataSource = layer.dataSource;
    return dataSource.options.queryLayerFeatures !== undefined
        ? dataSource.options.queryLayerFeatures === true
        : true;
}
/**
 * Whether an OL Vector layer is queryable
 * @param layer Layer
 * @returns True if the ol vector layer is queryable
 */
function olLayerFeatureIsQueryable(olLayer) {
    const layer = olLayer.get('_layer');
    return layer === undefined
        ? false
        : layerIsQueryable(layer) && layerFeatureIsQueryable(layer);
}

var LinkedProperties;
(function (LinkedProperties) {
    LinkedProperties["OPACITY"] = "opacity";
    LinkedProperties["VISIBLE"] = "visible";
    LinkedProperties["OGCFILTERS"] = "ogcFilters";
    LinkedProperties["MINRESOLUTION"] = "minResolution";
    LinkedProperties["MAXRESOLUTION"] = "maxResolution";
    LinkedProperties["ZINDEX"] = "zIndex";
    LinkedProperties["TIMEFILTER"] = "timeFilter";
})(LinkedProperties || (LinkedProperties = {}));
var TooltipType;
(function (TooltipType) {
    TooltipType["TITLE"] = "title";
    TooltipType["ABSTRACT"] = "abstract";
    TooltipType["CUSTOM"] = "custom";
})(TooltipType || (TooltipType = {}));

var TimeFilterType;
(function (TimeFilterType) {
    TimeFilterType["DATE"] = "date";
    TimeFilterType["TIME"] = "time";
    TimeFilterType["DATETIME"] = "datetime";
    TimeFilterType["YEAR"] = "year";
})(TimeFilterType || (TimeFilterType = {}));
var TimeFilterStyle;
(function (TimeFilterStyle) {
    TimeFilterStyle["CALENDAR"] = "calendar";
    TimeFilterStyle["SLIDER"] = "slider";
})(TimeFilterStyle || (TimeFilterStyle = {}));

/**
 * MapService
 *
 * This service tracks the IgoMap instance, if any.
 * Currently, only one map instance is supported
 * but support for multiple maps may be added in the future.
 * This will impact other services such as the OverlayService
 * because these maps won't be sharing overlayed features.
 */
class MapService {
    map;
    constructor() { }
    getMap() {
        return this.map;
    }
    setMap(map) {
        this.map = map;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: MapService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: MapService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: MapService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return []; } });

var QueryFormat;
(function (QueryFormat) {
    QueryFormat["GML2"] = "gml2";
    QueryFormat["GML3"] = "gml3";
    QueryFormat["JSON"] = "json";
    QueryFormat["GEOJSON"] = "geojson";
    QueryFormat["GEOJSON2"] = "geojson2";
    QueryFormat["ESRIJSON"] = "esrijson";
    QueryFormat["TEXT"] = "text";
    QueryFormat["HTML"] = "html";
    QueryFormat["HTMLGML2"] = "htmlgml2";
})(QueryFormat || (QueryFormat = {}));
var QueryFormatMimeType;
(function (QueryFormatMimeType) {
    QueryFormatMimeType["GML2"] = "application/vnd.ogc.gml";
    QueryFormatMimeType["GML3"] = "application/vnd.ogc.gml/3.1.1";
    QueryFormatMimeType["JSON"] = "application/json";
    QueryFormatMimeType["GEOJSON"] = "application/geojson";
    QueryFormatMimeType["GEOJSON2"] = "geojson";
    QueryFormatMimeType["ESRIJSON"] = "application/json";
    QueryFormatMimeType["TEXT"] = "text/plain";
    QueryFormatMimeType["HTML"] = "text/html";
    QueryFormatMimeType["HTMLGML2"] = "text/html";
})(QueryFormatMimeType || (QueryFormatMimeType = {}));
var QueryHtmlTarget;
(function (QueryHtmlTarget) {
    QueryHtmlTarget["IFRAME"] = "iframe";
    QueryHtmlTarget["BLANK"] = "_blank";
})(QueryHtmlTarget || (QueryHtmlTarget = {}));

class EsriStyleGenerator {
    _converters;
    _renderers;
    constructor() {
        this._converters = {};
        this._converters.esriPMS = EsriStyleGenerator._convertEsriPMS;
        this._converters.esriSFS = EsriStyleGenerator._convertEsriSFS;
        this._converters.esriSLS = EsriStyleGenerator._convertEsriSLS;
        this._converters.esriSMS = EsriStyleGenerator._convertEsriSMS;
        this._converters.esriTS = EsriStyleGenerator._convertEsriTS;
        this._renderers = {};
        this._renderers.uniqueValue = this._renderUniqueValue;
        this._renderers.simple = this._renderSimple;
        this._renderers.classBreaks = this._renderClassBreaks;
    }
    static _convertPointToPixel(point) {
        return point / 0.75;
    }
    static _transformColor(color) {
        // alpha channel is different, runs from 0-255 but in ol3 from 0-1
        return [color[0], color[1], color[2], color[3] / 255];
    }
    static _getResolutionForScale(scale, units) {
        const dpi = 96;
        const mpu = olproj.METERS_PER_UNIT[units];
        const inchesPerMeter = 39.3701;
        return parseFloat(scale) / (mpu * inchesPerMeter * dpi);
    }
    /* convert an Esri Text Symbol */
    static _convertEsriTS(symbol) {
        const rotation = EsriStyleGenerator._transformAngle(symbol.angle);
        const text = symbol.text !== undefined ? symbol.text : undefined;
        return new olStyle.Style({
            text: new olStyle.Text({
                fill: new olStyle.Fill({
                    color: EsriStyleGenerator._transformColor(symbol.color)
                }),
                font: symbol.font.style +
                    ' ' +
                    symbol.font.weight +
                    ' ' +
                    symbol.font.size +
                    ' px ' +
                    symbol.font.family,
                textBaseline: symbol.verticalAlignment,
                textAlign: symbol.horizontalAlignment,
                offsetX: EsriStyleGenerator._convertPointToPixel(symbol.xoffset),
                offsetY: EsriStyleGenerator._convertPointToPixel(symbol.yoffset),
                rotation,
                text
            })
        });
    }
    /* convert an Esri Picture Marker Symbol */
    static _convertEsriPMS(symbol) {
        const src = 'data:' + symbol.contentType + ';base64, ' + symbol.imageData;
        const rotation = EsriStyleGenerator._transformAngle(symbol.angle);
        return new olStyle.Style({
            image: new olStyle.Icon({
                src,
                rotation
            })
        });
    }
    /* convert an Esri Simple Fill Symbol */
    static _convertEsriSFS(symbol) {
        // there is no support in openlayers currently for fill patterns, so style is not interpreted
        const fill = new olStyle.Fill({
            color: EsriStyleGenerator._transformColor(symbol.color)
        });
        const stroke = symbol.outline
            ? EsriStyleGenerator._convertOutline(symbol.outline)
            : undefined;
        return new olStyle.Style({
            fill,
            stroke
        });
    }
    static _convertOutline(outline) {
        let lineDash;
        const color = EsriStyleGenerator._transformColor(outline.color);
        if (outline.style === 'esriSLSDash') {
            lineDash = [5];
        }
        else if (outline.style === 'esriSLSDashDot') {
            lineDash = [5, 5, 1, 2];
        }
        else if (outline.style === 'esriSLSDashDotDot') {
            lineDash = [5, 5, 1, 2, 1, 2];
        }
        else if (outline.style === 'esriSLSDot') {
            lineDash = [1, 2];
        }
        else if (outline.style === 'esriSLSNull') {
            // line not visible, make color fully transparent
            color[3] = 0;
        }
        return new olStyle.Stroke({
            color,
            lineDash,
            width: EsriStyleGenerator._convertPointToPixel(outline.width)
        });
    }
    /* convert an Esri Simple Line Symbol */
    static _convertEsriSLS(symbol) {
        return new olStyle.Style({
            stroke: EsriStyleGenerator._convertOutline(symbol)
        });
    }
    static _transformAngle(angle) {
        if (angle === 0 || angle === undefined) {
            return undefined;
        }
        const normalRad = (angle * Math.PI) / 180;
        const ol3Rad = -normalRad + Math.PI / 2;
        if (ol3Rad < 0) {
            return 2 * Math.PI + ol3Rad;
        }
        else {
            return ol3Rad;
        }
    }
    /* convert an Esri Simple Marker Symbol */
    static _convertEsriSMS(symbol) {
        const fill = new olStyle.Fill({
            color: EsriStyleGenerator._transformColor(symbol.color)
        });
        const stroke = symbol.outline
            ? EsriStyleGenerator._convertOutline(symbol.outline)
            : undefined;
        const radius = EsriStyleGenerator._convertPointToPixel(symbol.size) / 2;
        const rotation = EsriStyleGenerator._transformAngle(symbol.angle);
        if (symbol.style === 'esriSMSCircle') {
            return new olStyle.Style({
                image: new olStyle.Circle({
                    radius,
                    fill,
                    stroke
                })
            });
        }
        else if (symbol.style === 'esriSMSCross') {
            return new olStyle.Style({
                image: new olStyle.RegularShape({
                    fill,
                    stroke,
                    points: 4,
                    radius,
                    radius2: 0,
                    angle: 0,
                    rotation
                })
            });
        }
        else if (symbol.style === 'esriSMSDiamond') {
            return new olStyle.Style({
                image: new olStyle.RegularShape({
                    fill,
                    stroke,
                    points: 4,
                    radius,
                    rotation
                })
            });
        }
        else if (symbol.style === 'esriSMSSquare') {
            return new olStyle.Style({
                image: new olStyle.RegularShape({
                    fill,
                    stroke,
                    points: 4,
                    radius,
                    angle: Math.PI / 4,
                    rotation
                })
            });
        }
        else if (symbol.style === 'esriSMSX') {
            return new olStyle.Style({
                image: new olStyle.RegularShape({
                    fill,
                    stroke,
                    points: 4,
                    radius,
                    radius2: 0,
                    angle: Math.PI / 4,
                    rotation
                })
            });
        }
        else if (symbol.style === 'esriSMSTriangle') {
            return new olStyle.Style({
                image: new olStyle.RegularShape({
                    fill,
                    stroke,
                    points: 3,
                    radius,
                    angle: 0,
                    rotation
                })
            });
        }
    }
    _convertLabelingInfo(labelingInfo, mapUnits) {
        const styles = [];
        for (let i = 0, ii = labelingInfo.length; i < ii; ++i) {
            const labelExpression = labelingInfo[i].labelExpression;
            // only limited support for label expressions
            const field = labelExpression.substr(labelExpression.indexOf('[') + 1, labelExpression.indexOf(']') - 1);
            const symbol = labelingInfo[i].symbol;
            const maxScale = labelingInfo[i].maxScale;
            const minScale = labelingInfo[i].minScale;
            let minResolution = null;
            if (maxScale !== 0) {
                minResolution = EsriStyleGenerator._getResolutionForScale(maxScale, mapUnits);
            }
            let maxResolution = null;
            if (minScale !== 0) {
                maxResolution = EsriStyleGenerator._getResolutionForScale(minScale, mapUnits);
            }
            const style = this._converters[symbol.type].call(this, symbol);
            styles.push((() => {
                return function (feature, resolution) {
                    let visible = true;
                    if (this.minResolution !== null && this.maxResolution !== null) {
                        visible =
                            resolution < this.maxResolution &&
                                resolution >= this.minResolution;
                    }
                    else if (this.minResolution !== null) {
                        visible = resolution >= this.minResolution;
                    }
                    else if (this.maxResolution !== null) {
                        visible = resolution < this.maxResolution;
                    }
                    if (visible) {
                        const value = feature.get(this.field);
                        this.style.getText().setText(value);
                        return [this.style];
                    }
                };
            })().bind({
                minResolution,
                maxResolution,
                field,
                style
            }));
        }
        return styles;
    }
    _renderSimple(renderer) {
        const style = this._converters[renderer.symbol.type].call(this, renderer.symbol);
        return (() => {
            return () => {
                return [style];
            };
        })();
    }
    _renderClassBreaks(renderer) {
        const defaultSymbol = renderer.defaultSymbol;
        const defaultStyle = this._converters[defaultSymbol.type].call(this, defaultSymbol);
        const field = renderer.field;
        const classes = [];
        for (let i = 0, ii = renderer.classBreakInfos.length; i < ii; ++i) {
            const classBreakInfo = renderer.classBreakInfos[i];
            let min;
            if (classBreakInfo.classMinValue === null ||
                classBreakInfo.classMinValue === undefined) {
                if (i === 0) {
                    min = renderer.minValue;
                }
                else {
                    min = renderer.classBreakInfos[i - 1].classMaxValue;
                }
            }
            else {
                min = classBreakInfo.classMinValue;
            }
            const max = classBreakInfo.classMaxValue;
            const symbol = classBreakInfo.symbol;
            const style = this._converters[symbol.type].call(this, symbol);
            classes.push({ min, max, style });
        }
        return (() => {
            return (feature) => {
                const value = feature.get(field);
                for (let i = 0, ii = classes.length; i < ii; ++i) {
                    let condition;
                    if (i === 0) {
                        condition = value >= classes[i].min && value <= classes[i].max;
                    }
                    else {
                        condition = value > classes[i].min && value <= classes[i].max;
                    }
                    if (condition) {
                        return [classes[i].style];
                    }
                }
                return [defaultStyle];
            };
        })();
    }
    _renderUniqueValue(renderer) {
        const defaultSymbol = renderer.defaultSymbol;
        let defaultStyle = [];
        if (defaultSymbol) {
            defaultStyle = [
                this._converters[defaultSymbol.type].call(this, defaultSymbol)
            ];
        }
        const field = renderer.field1;
        const infos = renderer.uniqueValueInfos;
        const me = this;
        return (() => {
            const hash = {};
            for (let i = 0, ii = infos.length; i < ii; ++i) {
                const info = infos[i];
                const symbol = info.symbol;
                hash[info.value] = [me._converters[symbol.type].call(me, symbol)];
            }
            return (feature) => {
                const style = hash[feature.get(field)];
                return style ? style : defaultStyle;
            };
        })();
    }
    generateStyle(layerInfo, mapUnits) {
        const drawingInfo = layerInfo.drawingInfo;
        let styleFunctions = [];
        const drawingInfoStyle = this._renderers[drawingInfo.renderer.type].call(this, drawingInfo.renderer);
        if (drawingInfoStyle !== undefined) {
            styleFunctions.push(drawingInfoStyle);
        }
        if (layerInfo.labelingInfo) {
            const labelingInfoStyleFunctions = this._convertLabelingInfo(layerInfo.labelingInfo, mapUnits);
            styleFunctions = styleFunctions.concat(labelingInfoStyleFunctions);
        }
        if (styleFunctions.length === 1) {
            return styleFunctions[0];
        }
        else {
            return (() => {
                return (feature, resolution) => {
                    let styles = [];
                    for (let i = 0, ii = styleFunctions.length; i < ii; ++i) {
                        const result = styleFunctions[i].call(null, feature, resolution);
                        if (result) {
                            styles = styles.concat(result);
                        }
                    }
                    return styles;
                };
            })();
        }
    }
}

var TypeCapabilities;
(function (TypeCapabilities) {
    TypeCapabilities["wms"] = "wms";
    TypeCapabilities["wmts"] = "wmts";
    TypeCapabilities["arcgisrest"] = "esriJSON";
    TypeCapabilities["imagearcgisrest"] = "esriJSON";
    TypeCapabilities["tilearcgisrest"] = "esriJSON";
})(TypeCapabilities || (TypeCapabilities = {}));

class CapabilitiesService {
    http;
    mapService;
    parsers = {
        wms: new WMSCapabilities(),
        wmts: new WMTSCapabilities(),
        esriJSON: new EsriJSON()
    };
    constructor(http, mapService) {
        this.http = http;
        this.mapService = mapService;
    }
    getWMSOptions(baseOptions) {
        const url = baseOptions.url;
        const version = baseOptions.params.VERSION;
        return this.getCapabilities('wms', url, version).pipe(map((capabilities) => {
            return capabilities
                ? this.parseWMSOptions(baseOptions, capabilities)
                : undefined;
        }));
    }
    getWMTSOptions(baseOptions) {
        const url = baseOptions.url;
        const version = baseOptions.version;
        const options = this.getCapabilities('wmts', url, version).pipe(map((capabilities) => {
            return capabilities
                ? this.parseWMTSOptions(baseOptions, capabilities)
                : undefined;
        }));
        return options;
    }
    getCartoOptions(baseOptions) {
        const baseUrl = 'https://' +
            baseOptions.account +
            '.carto.com/api/v2/viz/' +
            baseOptions.mapId +
            '/viz.json';
        return this.http
            .jsonp(baseUrl, 'callback')
            .pipe(map((cartoOptions) => this.parseCartoOptions(baseOptions, cartoOptions)));
    }
    getArcgisOptions(baseOptions) {
        const baseUrl = baseOptions.url + '/' + baseOptions.layer + '?f=json';
        const serviceCapabilities = this.getCapabilities('arcgisrest', baseOptions.url);
        const arcgisOptions = this.http.get(baseUrl);
        return forkJoin([arcgisOptions, serviceCapabilities]).pipe(map((res) => {
            return this.parseArcgisOptions(baseOptions, res[0], res[1]);
        }));
    }
    getImageArcgisOptions(baseOptions) {
        const baseUrl = baseOptions.url + '/' + baseOptions.layer + '?f=json';
        const legendUrl = baseOptions.url + '/legend?f=json';
        const serviceCapabilities = this.getCapabilities('imagearcgisrest', baseOptions.url);
        const arcgisOptions = this.http.get(baseUrl);
        const legend = this.http.get(legendUrl).pipe(map((res) => res), catchError((err) => {
            console.log('No legend associated with this Image Service');
            return of(err);
        }));
        return forkJoin([arcgisOptions, legend, serviceCapabilities]).pipe(map((res) => {
            return this.parseTileOrImageArcgisOptions(baseOptions, res[0], res[1], res[2]);
        }));
    }
    getTileArcgisOptions(baseOptions) {
        const baseUrl = baseOptions.url + '/' + baseOptions.layer + '?f=json';
        const legendUrl = baseOptions.url + '/legend?f=json';
        const serviceCapabilities = this.getCapabilities('tilearcgisrest', baseOptions.url);
        const arcgisOptions = this.http.get(baseUrl);
        const legendInfo = this.http.get(legendUrl).pipe(map((res) => res), catchError((err) => {
            console.log('No legend associated with this Tile Service');
            return of(err);
        }));
        return forkJoin([arcgisOptions, legendInfo, serviceCapabilities]).pipe(map((res) => this.parseTileOrImageArcgisOptions(baseOptions, res[0], res[1], res[2])));
    }
    getCapabilities(service, baseUrl, version) {
        const params = new HttpParams({
            fromObject: {
                request: 'GetCapabilities',
                service: service.toUpperCase(),
                version: version || '1.3.0',
                _i: 'true'
            }
        });
        let request;
        if (TypeCapabilities[service] === 'esriJSON') {
            request = this.http.get(baseUrl + '?f=json');
        }
        else {
            request = this.http.get(baseUrl, {
                params,
                responseType: 'text'
            });
        }
        return request.pipe(map((res) => {
            if (TypeCapabilities[service] === 'esriJSON') {
                return res;
            }
            if (String(res).toLowerCase().includes('serviceexception') &&
                String(res).toLowerCase().includes('access denied')) {
                throw {
                    error: {
                        message: 'Service error getCapabilities: Access is denied'
                    }
                };
            }
            else {
                return this.parsers[service].read(res);
            }
        }), catchError((e) => {
            if (typeof e.error !== 'undefined') {
                e.error.caught = true;
            }
            throw e;
        }));
    }
    parseWMSOptions(baseOptions, capabilities) {
        const layers = baseOptions.params.LAYERS;
        const layer = this.findDataSourceInCapabilities(capabilities.Capability.Layer, layers);
        if (!layer) {
            throw {
                error: {
                    message: 'Layer not found'
                }
            };
        }
        const metadata = layer.DataURL ? layer.DataURL[0] : undefined;
        const abstract = layer.Abstract ? layer.Abstract : undefined;
        const keywordList = layer.KeywordList ? layer.KeywordList : undefined;
        let queryable = layer.queryable;
        const timeFilter = this.getTimeFilter(layer);
        const timeFilterable = timeFilter && Object.keys(timeFilter).length > 0;
        const legendOptions = layer.Style ? this.getStyle(layer.Style) : undefined;
        let isExtentInGeographic = true;
        if (layer.EX_GeographicBoundingBox) {
            layer.EX_GeographicBoundingBox.forEach((coord, index) => {
                if (index < 2 && (coord > 180 || coord < -180)) {
                    isExtentInGeographic = false;
                }
                if (index >= 2 && (coord > 90 || coord < -90)) {
                    isExtentInGeographic = false;
                }
            });
        }
        else {
            isExtentInGeographic = false;
        }
        const extent = isExtentInGeographic
            ? olproj.transformExtent(layer.EX_GeographicBoundingBox, 'EPSG:4326', this.mapService.getMap().projection)
            : undefined;
        let queryFormat;
        const queryFormatMimeTypePriority = [
            QueryFormatMimeType.GEOJSON,
            QueryFormatMimeType.GEOJSON2,
            QueryFormatMimeType.GML3,
            QueryFormatMimeType.GML2,
            QueryFormatMimeType.JSON,
            QueryFormatMimeType.HTML
        ];
        for (const mimeType of queryFormatMimeTypePriority) {
            if (capabilities.Capability.Request.GetFeatureInfo.Format.indexOf(mimeType) !== -1) {
                const keyEnum = Object.keys(QueryFormatMimeType).find((key) => QueryFormatMimeType[key] === mimeType);
                queryFormat = QueryFormat[keyEnum];
                break;
            }
        }
        if (!queryFormat) {
            queryable = false;
        }
        const options = ObjectUtils.removeUndefined({
            _layerOptionsFromSource: {
                title: layer.Title,
                maxResolution: getResolutionFromScale(layer.MaxScaleDenominator),
                minResolution: getResolutionFromScale(layer.MinScaleDenominator),
                extent,
                metadata: {
                    url: metadata ? metadata.OnlineResource : undefined,
                    extern: metadata ? true : undefined,
                    abstract,
                    keywordList
                },
                legendOptions
            },
            queryable,
            queryFormat,
            timeFilter: timeFilterable ? timeFilter : undefined,
            timeFilterable: timeFilterable ? true : undefined,
            minDate: timeFilterable ? timeFilter.min : undefined,
            maxDate: timeFilterable ? timeFilter.max : undefined,
            stepDate: timeFilterable ? timeFilter.step : undefined
        });
        return ObjectUtils.mergeDeep(options, baseOptions);
    }
    parseWMTSOptions(baseOptions, capabilities) {
        // Put Title source in _layerOptionsFromSource. (For source & catalog in _layerOptionsFromSource, if not already on config)
        const layer = capabilities.Contents.Layer.find((el) => el.Identifier === baseOptions.layer);
        const options = optionsFromCapabilities(capabilities, baseOptions);
        const ouputOptions = Object.assign(options, baseOptions);
        const sourceOptions = ObjectUtils.removeUndefined({
            _layerOptionsFromSource: {
                title: layer.Title
            }
        });
        return ObjectUtils.mergeDeep(sourceOptions, ouputOptions);
    }
    parseCartoOptions(baseOptions, cartoOptions) {
        const layers = [];
        const params = cartoOptions.layers[1].options.layer_definition;
        params.layers.forEach((element) => {
            layers.push({
                type: element.type.toLowerCase(),
                options: element.options,
                legend: element.legend
            });
        });
        const options = ObjectUtils.removeUndefined({
            config: {
                version: params.version,
                layers
            }
        });
        return ObjectUtils.mergeDeep(options, baseOptions);
    }
    parseArcgisOptions(baseOptions, arcgisOptions, serviceCapabilities) {
        const title = arcgisOptions.name;
        let legendInfo;
        if (arcgisOptions.drawingInfo?.renderer) {
            legendInfo = arcgisOptions.drawingInfo.renderer;
        }
        else {
            legendInfo = undefined;
        }
        let style;
        if (arcgisOptions.drawingInfo) {
            const styleGenerator = new EsriStyleGenerator();
            const units = arcgisOptions.units === 'esriMeters' ? 'm' : 'degrees';
            style = styleGenerator.generateStyle(arcgisOptions, units);
        }
        const attributions = new olAttribution({
            target: arcgisOptions.copyrightText
        });
        let timeExtent;
        let timeFilter;
        if (arcgisOptions.timeInfo) {
            const time = arcgisOptions.timeInfo.timeExtent;
            timeExtent = time[0] + ',' + time[1];
            const min = new Date();
            min.setTime(time[0]);
            const max = new Date();
            max.setTime(time[1]);
            timeFilter = {
                min: min.toUTCString(),
                max: max.toUTCString(),
                range: true,
                type: TimeFilterType.DATETIME,
                style: TimeFilterStyle.CALENDAR
            };
        }
        const params = Object.assign({}, {
            style,
            LAYERS: baseOptions.layer ? 'show:' + baseOptions.layer : undefined,
            time: timeExtent
        });
        const options = ObjectUtils.removeUndefined({
            params,
            _layerOptionsFromSource: {
                title,
                minResolution: getResolutionFromScale(arcgisOptions.maxScale),
                maxResolution: getResolutionFromScale(arcgisOptions.minScale),
                metadata: {
                    extern: false,
                    abstract: arcgisOptions.description || serviceCapabilities.serviceDescription
                }
            },
            legendInfo,
            timeFilter,
            sourceFields: arcgisOptions.fields,
            queryTitle: arcgisOptions.displayField
        });
        options.attributions = attributions;
        return ObjectUtils.mergeDeep(options, baseOptions);
    }
    parseTileOrImageArcgisOptions(baseOptions, arcgisOptions, legend, serviceCapabilities) {
        const title = arcgisOptions.name;
        const legendInfo = legend.layers
            ? legend.layers.find((x) => x.layerName === title)
            : undefined;
        const attributions = new olAttribution({
            target: arcgisOptions.copyrightText
        });
        let timeExtent;
        let timeFilter;
        if (arcgisOptions.timeInfo) {
            const time = arcgisOptions.timeInfo.timeExtent;
            timeExtent = time[0] + ',' + time[1];
            const min = new Date();
            min.setTime(time[0]);
            const max = new Date();
            max.setTime(time[1]);
            timeFilter = {
                min: min.toUTCString(),
                max: max.toUTCString(),
                range: true,
                type: TimeFilterType.DATETIME,
                style: TimeFilterStyle.CALENDAR
            };
        }
        const params = Object.assign({}, {
            LAYERS: baseOptions.layer ? 'show:' + baseOptions.layer : undefined,
            time: timeExtent
        });
        const options = ObjectUtils.removeUndefined({
            params,
            _layerOptionsFromSource: {
                title,
                minResolution: getResolutionFromScale(arcgisOptions.maxScale),
                maxResolution: getResolutionFromScale(arcgisOptions.minScale),
                metadata: {
                    extern: false,
                    abstract: arcgisOptions.description || serviceCapabilities.serviceDescription
                }
            },
            legendInfo,
            timeFilter,
            sourceFields: arcgisOptions.fields,
            queryTitle: arcgisOptions.displayField
        });
        options.attributions = attributions;
        return ObjectUtils.mergeDeep(options, baseOptions);
    }
    findDataSourceInCapabilities(layerArray, name) {
        if (Array.isArray(layerArray)) {
            let layer;
            layerArray.find((value) => {
                layer = this.findDataSourceInCapabilities(value, name);
                return layer !== undefined;
            }, this);
            return layer;
        }
        else if (layerArray.Layer) {
            return this.findDataSourceInCapabilities(layerArray.Layer, name);
        }
        else {
            if (layerArray.Name && layerArray.Name === name) {
                return layerArray;
            }
            return undefined;
        }
    }
    getTimeFilter(layer) {
        let dimension;
        if (layer.Dimension) {
            const timeFilter = {};
            dimension = layer.Dimension[0];
            if (dimension.values) {
                const minMaxDim = dimension.values.split('/');
                timeFilter.min = minMaxDim[0] !== undefined ? minMaxDim[0] : undefined;
                timeFilter.max = minMaxDim[1] !== undefined ? minMaxDim[1] : undefined;
                timeFilter.step = minMaxDim[2] !== undefined ? minMaxDim[2] : undefined;
            }
            if (dimension.default) {
                timeFilter.value = dimension.default;
            }
            return timeFilter;
        }
    }
    getStyle(Style) {
        const styleOptions = Style.map((style) => {
            return {
                name: style.Name,
                title: style.Title
            };
        })
            // Handle repeat the style "default" in output  (MapServer or OpenLayer)
            .filter((item, index, self) => self.findIndex((i) => i.name === item.name) ===
            index);
        const legendOptions = {
            stylesAvailable: styleOptions
        };
        return legendOptions;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CapabilitiesService, deps: [{ token: i1.HttpClient }, { token: MapService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CapabilitiesService, providedIn: 'root' });
}
__decorate([
    Cacheable({
        maxCacheCount: 20
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Observable)
], CapabilitiesService.prototype, "getArcgisOptions", null);
__decorate([
    Cacheable({
        maxCacheCount: 20
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Observable)
], CapabilitiesService.prototype, "getImageArcgisOptions", null);
__decorate([
    Cacheable({
        maxCacheCount: 20
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Observable)
], CapabilitiesService.prototype, "getTileArcgisOptions", null);
__decorate([
    Cacheable({
        maxCacheCount: 20
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String]),
    __metadata("design:returntype", Observable)
], CapabilitiesService.prototype, "getCapabilities", null);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CapabilitiesService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: MapService }]; }, propDecorators: { getArcgisOptions: [], getImageArcgisOptions: [], getTileArcgisOptions: [], getCapabilities: [] } });

var OgcFilterOperatorType;
(function (OgcFilterOperatorType) {
    OgcFilterOperatorType["BasicNumericOperator"] = "basicnumericoperator";
    OgcFilterOperatorType["Basic"] = "basic";
    OgcFilterOperatorType["BasicAndSpatial"] = "basicandspatial";
    OgcFilterOperatorType["Spatial"] = "spatial";
    OgcFilterOperatorType["All"] = "all";
    OgcFilterOperatorType["Time"] = "time";
})(OgcFilterOperatorType || (OgcFilterOperatorType = {}));
var OgcFilterOperator;
(function (OgcFilterOperator) {
    OgcFilterOperator["BBOX"] = "BBox";
    OgcFilterOperator["PropertyIsBetween"] = "PropertyIsBetween";
    OgcFilterOperator["Contains"] = "Contains";
    OgcFilterOperator["During"] = "During";
    OgcFilterOperator["PropertyIsEqualTo"] = "PropertyIsEqualTo";
    OgcFilterOperator["PropertyIsGreaterThan"] = "PropertyIsGreaterThan";
    OgcFilterOperator["PropertyIsGreaterThanOrEqualTo"] = "PropertyIsGreaterThanOrEqualTo";
    OgcFilterOperator["Intersects"] = "Intersects";
    OgcFilterOperator["PropertyIsNull"] = "PropertyIsNull";
    OgcFilterOperator["PropertyIsLessThan"] = "PropertyIsLessThan";
    OgcFilterOperator["PropertyIsLessThanOrEqualTo"] = "PropertyIsLessThanOrEqualTo";
    OgcFilterOperator["PropertyIsLike"] = "PropertyIsLike";
    OgcFilterOperator["PropertyIsNotEqualTo"] = "PropertyIsNotEqualTo";
    OgcFilterOperator["Within"] = "Within";
    OgcFilterOperator["And"] = "And";
    OgcFilterOperator["Or"] = "Or";
    OgcFilterOperator["Not"] = "Not";
})(OgcFilterOperator || (OgcFilterOperator = {}));

class OgcFilterWriter {
    filterSequence = [];
    operators = {
        [OgcFilterOperator.PropertyIsEqualTo]: {
            spatial: false,
            fieldRestrict: []
        },
        [OgcFilterOperator.PropertyIsNotEqualTo]: {
            spatial: false,
            fieldRestrict: []
        },
        [OgcFilterOperator.PropertyIsLike]: {
            spatial: false,
            fieldRestrict: ['string']
        },
        [OgcFilterOperator.PropertyIsGreaterThan]: {
            spatial: false,
            fieldRestrict: ['number']
        },
        [OgcFilterOperator.PropertyIsGreaterThanOrEqualTo]: {
            spatial: false,
            fieldRestrict: ['number']
        },
        [OgcFilterOperator.PropertyIsLessThan]: {
            spatial: false,
            fieldRestrict: ['number']
        },
        [OgcFilterOperator.PropertyIsLessThanOrEqualTo]: {
            spatial: false,
            fieldRestrict: ['number']
        },
        [OgcFilterOperator.PropertyIsBetween]: {
            spatial: false,
            fieldRestrict: ['number']
        },
        [OgcFilterOperator.During]: { spatial: false, fieldRestrict: [] },
        [OgcFilterOperator.PropertyIsNull]: {
            spatial: false,
            fieldRestrict: []
        },
        [OgcFilterOperator.Intersects]: {
            spatial: true,
            fieldRestrict: []
        },
        [OgcFilterOperator.Within]: { spatial: true, fieldRestrict: [] },
        [OgcFilterOperator.Contains]: { spatial: true, fieldRestrict: [] }
    };
    defineOgcFiltersDefaultOptions(ogcFiltersOptions, fieldNameGeometry, srcType) {
        let ogcFiltersDefaultValue = true; // default values for wfs.
        if (srcType && srcType === 'wms') {
            ogcFiltersDefaultValue = false;
        }
        ogcFiltersOptions = ogcFiltersOptions || {};
        ogcFiltersOptions.enabled =
            ogcFiltersOptions.enabled === undefined
                ? ogcFiltersDefaultValue
                : ogcFiltersOptions.enabled;
        ogcFiltersOptions.editable =
            ogcFiltersOptions.editable === undefined
                ? ogcFiltersDefaultValue
                : ogcFiltersOptions.editable;
        ogcFiltersOptions.geometryName = fieldNameGeometry;
        ogcFiltersOptions.advancedOgcFilters = true;
        if (ogcFiltersOptions.enabled &&
            (ogcFiltersOptions.pushButtons ||
                ogcFiltersOptions.checkboxes ||
                ogcFiltersOptions.radioButtons ||
                ogcFiltersOptions.select ||
                ogcFiltersOptions.autocomplete)) {
            ogcFiltersOptions.advancedOgcFilters = false;
        }
        return ogcFiltersOptions;
    }
    buildFilter(filters, extent, proj, fieldNameGeometry, options) {
        let ourBboxFilter;
        let enableBbox;
        if (/intersects|contains|within/gi.test(JSON.stringify(filters))) {
            enableBbox = false;
        }
        else {
            enableBbox = true;
        }
        if (filters) {
            fieldNameGeometry =
                filters.geometryName !== undefined
                    ? filters.geometryName
                    : fieldNameGeometry;
        }
        if (extent && filters) {
            ourBboxFilter = olfilter.bbox(fieldNameGeometry, extent, proj.getCode());
        }
        let filterAssembly;
        if (filters) {
            filters = this.checkIgoFiltersProperties(filters, fieldNameGeometry, proj);
            if (extent && enableBbox) {
                filterAssembly = olfilter.and(ourBboxFilter, this.bundleFilter(filters, options));
            }
            else {
                filterAssembly = this.bundleFilter(filters, options);
            }
        }
        else {
            return 'bbox=' + extent.join(',') + ',' + proj.getCode();
        }
        const wfsOptions = {
            srsName: '',
            featureNS: '',
            featurePrefix: '',
            featureTypes: ['featureTypes'],
            filter: filterAssembly,
            outputFormat: '',
            geometryName: fieldNameGeometry
        };
        const query = new olFormatWFS().writeGetFeature(wfsOptions);
        const str = new XMLSerializer().serializeToString(query);
        const regexp1 = /typenames *=|typename *=\"featureTypes\" *>/gi;
        const regexp2 = /<\/Query><\/GetFeature>/gi;
        return 'filter=' + str.split(regexp1)[1].split(regexp2)[0];
    }
    bundleFilter(filterObject, options) {
        if (filterObject instanceof Array) {
            const logicalArray = [];
            filterObject.forEach((element) => {
                logicalArray.push(this.bundleFilter(element, options));
            });
            return logicalArray;
        }
        else {
            if (filterObject.hasOwnProperty('logical')) {
                return this.createFilter({
                    operator: filterObject.logical,
                    logicalArray: this.bundleFilter(filterObject.filters, options)
                }, options);
            }
            else if (filterObject.hasOwnProperty('operator')) {
                return this.createFilter(filterObject, options);
            }
        }
    }
    createFilter(filterOptions, options) {
        const operator = filterOptions.operator;
        const logicalArray = filterOptions.logicalArray;
        const wfsPropertyName = filterOptions.propertyName;
        const wfsPattern = filterOptions.pattern;
        const wfsMatchCase = filterOptions.matchCase
            ? filterOptions.matchCase
            : true;
        const wfsWildCard = filterOptions.wildCard ? filterOptions.wildCard : '*';
        const wfsSingleChar = filterOptions.singleChar
            ? filterOptions.singleChar
            : '.';
        const wfsEscapeChar = filterOptions.escapeChar
            ? filterOptions.escapeChar
            : '!';
        const wfsLowerBoundary = filterOptions.lowerBoundary;
        const wfsUpperBoundary = filterOptions.upperBoundary;
        const wfsGeometryName = filterOptions.geometryName;
        const wfsExtent = filterOptions.extent;
        const wfsWktGeometry = filterOptions.wkt_geometry;
        const wfsSrsName = filterOptions.srsName
            ? filterOptions.srsName
            : 'EPSG:3857';
        const wfsBegin = this.parseFilterOptionDate(filterOptions.begin, options ? options.minDate : undefined);
        const wfsEnd = this.parseFilterOptionDate(filterOptions.end, options ? options.maxDate : undefined);
        const wfsExpression = filterOptions.expression;
        let geometry;
        if (wfsWktGeometry) {
            const wkt = new olWKT();
            geometry = wkt.readGeometry(wfsWktGeometry, {
                dataProjection: wfsSrsName,
                featureProjection: wfsSrsName || 'EPSG:3857'
            });
        }
        switch (operator.toLowerCase()) {
            case OgcFilterOperator.BBOX.toLowerCase():
                return olfilter.bbox(wfsGeometryName, wfsExtent, wfsSrsName);
            case OgcFilterOperator.PropertyIsBetween.toLowerCase():
                return olfilter.between(wfsPropertyName, wfsLowerBoundary || 1e40 * -1, wfsUpperBoundary || 1e40);
            case OgcFilterOperator.Contains.toLowerCase():
                return olfilter.contains(wfsGeometryName, geometry, wfsSrsName);
            case OgcFilterOperator.During.toLowerCase():
                return olfilter.during(wfsPropertyName, wfsBegin, wfsEnd);
            case OgcFilterOperator.PropertyIsEqualTo.toLowerCase():
                return olfilter.equalTo(wfsPropertyName, wfsExpression, wfsMatchCase);
            case OgcFilterOperator.PropertyIsGreaterThan.toLowerCase():
                return olfilter.greaterThan(wfsPropertyName, wfsExpression);
            case OgcFilterOperator.PropertyIsGreaterThanOrEqualTo.toLowerCase():
                return olfilter.greaterThanOrEqualTo(wfsPropertyName, wfsExpression);
            case OgcFilterOperator.Intersects.toLowerCase():
                return olfilter.intersects(wfsGeometryName, geometry, wfsSrsName);
            case OgcFilterOperator.PropertyIsNull.toLowerCase():
                return olfilter.isNull(wfsPropertyName);
            case OgcFilterOperator.PropertyIsLessThan.toLowerCase():
                return olfilter.lessThan(wfsPropertyName, wfsExpression);
            case OgcFilterOperator.PropertyIsLessThanOrEqualTo.toLowerCase():
                return olfilter.lessThanOrEqualTo(wfsPropertyName, wfsExpression);
            case OgcFilterOperator.PropertyIsLike.toLowerCase():
                return olfilter.like(wfsPropertyName, wfsPattern
                    ? wfsPattern.replace(/[()_]/gi, wfsSingleChar)
                    : wfsWildCard, wfsWildCard, wfsSingleChar, wfsEscapeChar, wfsMatchCase);
            case OgcFilterOperator.PropertyIsNotEqualTo.toLowerCase():
                return olfilter.notEqualTo(wfsPropertyName, wfsExpression, wfsMatchCase);
            case OgcFilterOperator.Within.toLowerCase():
                return olfilter.within(wfsGeometryName, geometry, wfsSrsName);
            // LOGICAL
            case OgcFilterOperator.And.toLowerCase():
                return olfilter.and.apply(null, logicalArray);
            case OgcFilterOperator.Or.toLowerCase():
                return olfilter.or.apply(null, logicalArray);
            case OgcFilterOperator.Not.toLowerCase():
                return olfilter.not.apply(null, logicalArray);
            default:
                return undefined;
        }
    }
    defineInterfaceFilterSequence(filterObject, geometryName, logical = '', level = -1) {
        if (filterObject instanceof Array) {
            filterObject.forEach((element) => {
                this.filterSequence.concat(this.defineInterfaceFilterSequence(element, geometryName, logical, level));
            });
        }
        else {
            if (filterObject.hasOwnProperty('logical')) {
                level = level + 1;
                this.filterSequence.concat(this.defineInterfaceFilterSequence(filterObject.filters, geometryName, filterObject.logical, level));
            }
            else if (filterObject.hasOwnProperty('operator')) {
                this.filterSequence.push(this.addInterfaceFilter(filterObject, geometryName, level, logical));
            }
        }
        return this.filterSequence;
    }
    computeAllowedOperators(fields, propertyName, defaultOperatorsType) {
        let effectiveOperators = {};
        let allowedOperators;
        let fieldsHasSpatialOperator;
        let includeContains;
        if (fields && propertyName) {
            const srcField = fields.find((field) => field.name === propertyName);
            allowedOperators =
                srcField && srcField.allowedOperatorsType
                    ? srcField.allowedOperatorsType
                    : defaultOperatorsType;
        }
        if (fields) {
            fields.map((field) => {
                if (!field.allowedOperatorsType) {
                    return;
                }
                const allowedOperatorsType = field.allowedOperatorsType.toLowerCase();
                if (allowedOperatorsType === OgcFilterOperatorType.All.toLowerCase() ||
                    allowedOperatorsType ===
                        OgcFilterOperatorType.Spatial.toLowerCase() ||
                    allowedOperatorsType ===
                        OgcFilterOperatorType.BasicAndSpatial.toLowerCase()) {
                    fieldsHasSpatialOperator = true;
                    if (allowedOperatorsType === OgcFilterOperatorType.All.toLowerCase()) {
                        includeContains = true;
                    }
                }
            });
        }
        allowedOperators = allowedOperators
            ? allowedOperators
            : OgcFilterOperatorType.BasicAndSpatial;
        switch (allowedOperators.toLowerCase()) {
            case OgcFilterOperatorType.All:
                effectiveOperators = this.operators;
                break;
            case OgcFilterOperatorType.Spatial:
                effectiveOperators = {
                    [OgcFilterOperator.Intersects]: { spatial: true, fieldRestrict: [] },
                    [OgcFilterOperator.Within]: { spatial: true, fieldRestrict: [] }
                };
                break;
            case OgcFilterOperatorType.BasicAndSpatial:
                effectiveOperators = {
                    [OgcFilterOperator.PropertyIsEqualTo]: {
                        spatial: false,
                        fieldRestrict: []
                    },
                    [OgcFilterOperator.PropertyIsNotEqualTo]: {
                        spatial: false,
                        fieldRestrict: []
                    },
                    [OgcFilterOperator.Intersects]: { spatial: true, fieldRestrict: [] },
                    [OgcFilterOperator.Within]: { spatial: true, fieldRestrict: [] }
                };
                break;
            case OgcFilterOperatorType.Basic:
                effectiveOperators = {
                    [OgcFilterOperator.PropertyIsEqualTo]: {
                        spatial: false,
                        fieldRestrict: []
                    },
                    [OgcFilterOperator.PropertyIsNotEqualTo]: {
                        spatial: false,
                        fieldRestrict: []
                    }
                };
                break;
            case OgcFilterOperatorType.Time:
                effectiveOperators = {
                    [OgcFilterOperator.During]: { spatial: false, fieldRestrict: [] }
                };
                break;
            case OgcFilterOperatorType.BasicNumericOperator:
                effectiveOperators = {
                    [OgcFilterOperator.PropertyIsEqualTo]: {
                        spatial: false,
                        fieldRestrict: []
                    },
                    [OgcFilterOperator.PropertyIsNotEqualTo]: {
                        spatial: false,
                        fieldRestrict: []
                    },
                    [OgcFilterOperator.PropertyIsGreaterThan]: {
                        spatial: false,
                        fieldRestrict: ['number']
                    },
                    [OgcFilterOperator.PropertyIsGreaterThanOrEqualTo]: {
                        spatial: false,
                        fieldRestrict: ['number']
                    },
                    [OgcFilterOperator.PropertyIsLessThan]: {
                        spatial: false,
                        fieldRestrict: ['number']
                    },
                    [OgcFilterOperator.PropertyIsLessThanOrEqualTo]: {
                        spatial: false,
                        fieldRestrict: ['number']
                    }
                };
                break;
            default:
                effectiveOperators = {
                    [OgcFilterOperator.PropertyIsEqualTo]: {
                        spatial: false,
                        fieldRestrict: []
                    },
                    [OgcFilterOperator.PropertyIsNotEqualTo]: {
                        spatial: false,
                        fieldRestrict: []
                    },
                    [OgcFilterOperator.Intersects]: { spatial: true, fieldRestrict: [] },
                    [OgcFilterOperator.Within]: { spatial: true, fieldRestrict: [] }
                };
        }
        if (fieldsHasSpatialOperator) {
            effectiveOperators.Intersects = {
                spatial: true,
                fieldRestrict: []
            };
            effectiveOperators.Within = { spatial: true, fieldRestrict: [] };
            if (includeContains) {
                effectiveOperators.Contains = {
                    spatial: true,
                    fieldRestrict: []
                };
            }
        }
        return effectiveOperators;
    }
    addInterfaceFilter(igoOgcFilterObject, geometryName, level = 0, parentLogical = 'Or') {
        if (!igoOgcFilterObject) {
            igoOgcFilterObject = { operator: 'PropertyIsEqualTo' };
        }
        const f = {
            propertyName: '',
            operator: '',
            active: '',
            filterid: uuid(),
            step: '',
            begin: '',
            end: '',
            sliderOptions: {},
            lowerBoundary: '',
            upperBoundary: '',
            expression: '',
            pattern: '',
            wildCard: '*',
            singleChar: '.',
            escapeChar: '!',
            matchCase: true,
            igoSpatialSelector: '',
            igoSNRC: '',
            geometryName: '',
            geometry: '',
            wkt_geometry: '',
            extent: '',
            srsName: '',
            parentLogical: '',
            level: 0
        };
        return Object.assign(f, {
            parentLogical,
            level,
            geometryName
        }, igoOgcFilterObject);
    }
    checkIgoFiltersProperties(filterObject, fieldNameGeometry, proj, active = false) {
        const filterArray = [];
        if (filterObject instanceof Array) {
            filterObject.forEach((element) => {
                filterArray.push(this.checkIgoFiltersProperties(element, fieldNameGeometry, proj, active));
            });
            return filterArray;
        }
        else {
            if (filterObject.hasOwnProperty('logical')) {
                return Object.assign({}, {
                    logical: filterObject.logical,
                    filters: this.checkIgoFiltersProperties(filterObject.filters, fieldNameGeometry, proj, active)
                });
            }
            else if (filterObject.hasOwnProperty('operator')) {
                return this.addFilterProperties(filterObject, fieldNameGeometry, proj, active);
            }
        }
    }
    addFilterProperties(igoOgcFilterObject, fieldNameGeometry, proj, active = false) {
        const filterid = igoOgcFilterObject.hasOwnProperty('filterid')
            ? igoOgcFilterObject.filterid
            : uuid();
        const status = igoOgcFilterObject.hasOwnProperty('active')
            ? igoOgcFilterObject.active
            : active;
        const srsName = igoOgcFilterObject.hasOwnProperty('srsName')
            ? igoOgcFilterObject.srsName
            : proj
                ? proj.getCode()
                : 'EPSG:3857';
        return Object.assign({}, {
            filterid,
            active: status,
            igoSpatialSelector: 'fixedExtent',
            srsName
        }, igoOgcFilterObject, { geometryName: fieldNameGeometry });
    }
    rebuiltIgoOgcFilterObjectFromSequence(sequence) {
        if (sequence instanceof Array) {
            if (sequence.length >= 1) {
                let lastParentLogical = sequence[0].parentLogical;
                let nextElement;
                let logicalArray = [];
                let lastProcessedFilter;
                sequence.forEach((uiFilter) => {
                    const element = Object.assign({}, uiFilter);
                    const index = sequence.indexOf(uiFilter);
                    if (index >= 0 && index < sequence.length - 1) {
                        nextElement = sequence[index + 1];
                    }
                    else {
                        nextElement = element;
                    }
                    delete element.active;
                    delete element.filterid;
                    delete element.parentLogical;
                    logicalArray.push(element);
                    if (sequence.length === 1) {
                        lastProcessedFilter = element;
                    }
                    else if (lastParentLogical !== nextElement.parentLogical) {
                        if (logicalArray.length === 1) {
                            console.log('You must set at ' +
                                'least two operator in a logical (' +
                                lastParentLogical +
                                ')');
                        }
                        else {
                            lastProcessedFilter = Object.assign({}, { logical: lastParentLogical, filters: logicalArray });
                            logicalArray = [lastProcessedFilter];
                            lastParentLogical = nextElement.parentLogical;
                        }
                    }
                });
                return lastProcessedFilter;
            }
            else {
                return undefined;
            }
        }
        else {
            return undefined;
        }
    }
    computeIgoSelector(selectors) {
        if (selectors.groups.every((group) => group.computedSelectors !== undefined)) {
            return selectors;
        }
        let selector;
        if (selectors.groups && selectors.bundles) {
            if (!selectors.bundles.every((bundle) => bundle.id !== undefined)) {
                throw new Error('You must set an id for each of your bundles');
            }
            selector = ObjectUtils.copyDeep(selectors);
            selector.groups.forEach((group) => {
                group.title = group.title ? group.title : group.name;
                group.enabled = group.enabled ? group.enabled : false;
                group.computedSelectors = ObjectUtils.copyDeep(selector.bundles.filter((b) => group.ids.includes(b.id)));
            });
        }
        else if (!selectors.groups && selectors.bundles) {
            selector = ObjectUtils.copyDeep(selectors);
            selector.groups = [
                {
                    title: 'group1',
                    name: 'group1',
                    computedSelectors: ObjectUtils.copyDeep(selector.bundles)
                }
            ];
        }
        else {
            selector = {
                bundles: selectors,
                groups: [
                    {
                        title: 'group1',
                        name: 'group1',
                        computedSelectors: ObjectUtils.copyDeep(selectors)
                    }
                ],
                selectorType: selector.selectorType
            };
        }
        if (!selector.groups.find((selectorGroup) => selectorGroup.enabled)) {
            selector.groups[0].enabled = true;
        }
        return selector;
    }
    handleOgcFiltersAppliedValue(options, fieldNameGeometry, extent, proj) {
        const ogcFilters = options.ogcFilters;
        if (!ogcFilters) {
            return;
        }
        const conditions = [];
        let filterQueryStringSelector = '';
        let filterQueryStringAdvancedFilters = '';
        if (ogcFilters.enabled &&
            (ogcFilters.pushButtons ||
                ogcFilters.checkboxes ||
                ogcFilters.radioButtons ||
                ogcFilters.select ||
                ogcFilters.autocomplete)) {
            let selectors;
            if (ogcFilters.pushButtons) {
                selectors = ogcFilters.pushButtons;
                const pushConditions = this.formatGroupAndFilter(ogcFilters, selectors);
                for (const condition of pushConditions) {
                    conditions.push(condition);
                }
            }
            if (ogcFilters.checkboxes) {
                selectors = ogcFilters.checkboxes;
                const checkboxConditions = this.formatGroupAndFilter(ogcFilters, selectors);
                for (const condition of checkboxConditions) {
                    conditions.push(condition);
                }
            }
            if (ogcFilters.radioButtons) {
                selectors = ogcFilters.radioButtons;
                const selectorsCorr = this.verifyMultipleEnableds(selectors);
                const radioConditions = this.formatGroupAndFilter(ogcFilters, selectorsCorr);
                for (const condition of radioConditions) {
                    conditions.push(condition);
                }
            }
            if (ogcFilters.select) {
                selectors = ogcFilters.select;
                const selectorsCorr = this.verifyMultipleEnableds(selectors);
                const selectConditions = this.formatGroupAndFilter(ogcFilters, selectorsCorr);
                for (const condition of selectConditions) {
                    conditions.push(condition);
                }
            }
            if (ogcFilters.autocomplete) {
                selectors = ogcFilters.autocomplete;
                const selectConditions = this.formatGroupAndFilter(ogcFilters, selectors);
                for (const condition of selectConditions) {
                    conditions.push(condition);
                }
            }
            if (conditions.length >= 1) {
                filterQueryStringSelector = this.buildFilter(conditions.length === 1
                    ? conditions[0]
                    : { logical: 'And', filters: conditions }, extent, proj, ogcFilters.geometryName);
            }
        }
        if (ogcFilters.enabled && ogcFilters.filters) {
            ogcFilters.geometryName = ogcFilters.geometryName || fieldNameGeometry;
            const igoFilters = ogcFilters.filters;
            filterQueryStringAdvancedFilters = this.buildFilter(igoFilters, extent, proj, ogcFilters.geometryName, options);
        }
        let filterQueryString = ogcFilters.advancedOgcFilters
            ? filterQueryStringAdvancedFilters
            : filterQueryStringSelector;
        if (options.type === 'wms') {
            filterQueryString = this.formatProcessedOgcFilter(filterQueryString, options.params.LAYERS);
        }
        if (options.type === 'wfs') {
            filterQueryString = this.formatProcessedOgcFilter(filterQueryString, options.params.featureTypes);
        }
        return filterQueryString;
    }
    verifyMultipleEnableds(selectors) {
        selectors.bundles.forEach((bundle) => {
            if (!bundle.multiple && bundle.selectors) {
                const enableds = bundle.selectors.reduce((list, filter, index) => filter.enabled === true ? list.concat(index) : list, []);
                if (enableds.length > 1) {
                    enableds.splice(0, 1);
                    enableds.forEach((index) => {
                        bundle.selectors[index].enabled = false;
                    });
                }
            }
        });
        return selectors;
    }
    formatGroupAndFilter(ogcFilters, selectors) {
        selectors = this.computeIgoSelector(selectors);
        const selectorBundle = selectors.groups.find((g) => g.enabled).computedSelectors;
        const conditions = [];
        selectorBundle.map((bundle) => {
            const bundleCondition = [];
            const selectorsType = bundle.selectors;
            if (!selectorsType) {
                return;
            }
            selectorsType
                .filter((ogcselector) => ogcselector.enabled === true)
                .forEach((enabledSelector) => bundleCondition.push(enabledSelector.filters));
            if (bundleCondition.length === 1) {
                conditions.push(bundleCondition[0]);
            }
            else if (bundleCondition.length > 1) {
                conditions.push({
                    logical: bundle.logical,
                    filters: bundleCondition
                });
            }
        });
        if (selectors.selectorType === 'pushButton') {
            ogcFilters.pushButtons = selectors;
        }
        else if (selectors.selectorType === 'checkbox') {
            ogcFilters.checkboxes = selectors;
        }
        else if (selectors.selectorType === 'radioButton') {
            ogcFilters.radioButtons = selectors;
        }
        else if (selectors.selectorType === 'select') {
            ogcFilters.select = selectors;
        }
        else if (selectors.selectorType === 'autocomplete') {
            ogcFilters.autocomplete = selectors;
        }
        return conditions;
    }
    formatProcessedOgcFilter(processedFilter, layersOrTypenames) {
        if (!processedFilter) {
            return undefined;
        }
        let appliedFilter = '';
        if (processedFilter.length === 0 && layersOrTypenames.indexOf(',') === -1) {
            appliedFilter = processedFilter;
        }
        else {
            layersOrTypenames.split(',').forEach((layerOrTypenames) => {
                appliedFilter = `${appliedFilter}(${processedFilter.replace('filter=', '')})`;
            });
        }
        appliedFilter = appliedFilter.replace(/\(\)/g, '');
        const filterValue = appliedFilter.length > 0
            ? appliedFilter.replace('filter=', '')
            : undefined;
        return filterValue;
    }
    parseFilterOptionDate(value, defaultValue) {
        if (!value) {
            return defaultValue;
        }
        else if (value === 'today') {
            return undefined;
        }
        else if (moment(value).isValid()) {
            return value;
        }
        else {
            return undefined;
        }
    }
}

/**
 * Generate a id from it's datasource options.
 * @param options Data source options
 * @returns A id
 */
function generateIdFromSourceOptions(options) {
    const generators = {
        wms: generateWMSIdFromSourceOptions,
        wmts: generateWMTSIdFromSourceOptions,
        xyz: generateXYZIdFromSourceOptions,
        feature: generateFeatureIdFromSourceOptions,
        wfs: generateWfsIdFromSourceOptions,
        arcgisrest: generateArcgisRestIdFromSourceOptions,
        imagearcgisrest: generateArcgisRestIdFromSourceOptions,
        tilearcgisrest: generateArcgisRestIdFromSourceOptions,
        osm: (_options) => 'OSM',
        tiledebug: (_options) => 'tiledebug'
    };
    const generator = generators[options.type] || generateId;
    return generator(options);
}
/**
 * Generate a id from WMS data source options
 * @param options WMS data source options
 * @returns A md5 hash of the the url and layers
 */
function generateWMSIdFromSourceOptions(options) {
    const layers = options.params.LAYERS;
    const url = standardizeUrl(options.url);
    const chain = 'wms' + url + layers;
    return Md5.hashStr(chain);
}
/**
 * Generate a id from WMTS data source options
 * @param options WMTS data source options
 * @returns A md5 hash of the the url and layer
 */
function generateWMTSIdFromSourceOptions(options) {
    const layer = options.layer;
    const url = standardizeUrl(options.url);
    const chain = 'wmts' + url + layer;
    return Md5.hashStr(chain);
}
/**
 * Generate a id from XYZ data source options
 * @param options XYZ data source options
 * @returns A md5 hash of the the url and layer
 */
function generateXYZIdFromSourceOptions(options) {
    const url = standardizeUrl(options.url);
    const chain = 'xyz' + url;
    return Md5.hashStr(chain);
}
/**
 * Generate a id from feature data source options
 * @param options XYZ data source options
 * @returns A md5 hash of the the url and layer
 */
function generateFeatureIdFromSourceOptions(options) {
    if (!options.url) {
        return generateId(options);
    }
    const url = standardizeUrl(options.url);
    const chain = 'feature' + url;
    return Md5.hashStr(chain);
}
/**
 * Generate a id from feature data source options
 * @param options XYZ data source options
 * @returns A md5 hash of the the url and layer
 */
function generateWfsIdFromSourceOptions(options) {
    if (!options.url || !options.params) {
        return generateId(options);
    }
    const url = standardizeUrl(options.url);
    const chain = 'wfs' + url + options.params.featureTypes;
    return Md5.hashStr(chain);
}
/**
 * Generate a id from ArcGIS Rest data source options
 * @param options ArcGIS Rest data source options
 * @returns A md5 hash of the url and layers
 */
function generateArcgisRestIdFromSourceOptions(options) {
    const layers = options.layer;
    const url = standardizeUrl(options.url);
    const chain = (options.type || 'arcgis') + url + layers;
    return Md5.hashStr(chain);
}
/**
 * Generate a unique id
 * @returns A uuid
 */
function generateId(_options) {
    return uuid();
}
function standardizeUrl(url) {
    const absUrl = url.charAt(0) === '/' ? window.location.origin + url : url;
    const urlDecomposed = absUrl.split(/[?&]/);
    let urlStandardized = urlDecomposed.shift();
    const paramsToKeep = urlDecomposed.filter((p) => p.length !== 0 && p.charAt(0) !== '_');
    if (paramsToKeep.length) {
        urlStandardized += '?' + paramsToKeep.join('&');
    }
    return urlStandardized;
}

class DataSource {
    options;
    dataService;
    id;
    ol;
    legend;
    constructor(options = {}, dataService) {
        this.options = options;
        this.dataService = dataService;
        this.options = options;
        this.id = this.options.id || this.generateId();
        this.ol = this.createOlSource();
    }
    generateId() {
        return generateIdFromSourceOptions(this.options);
    }
    getLegend(style, view) {
        return this.legend ? this.legend : [];
    }
    setLegend(options) {
        if (options.url) {
            this.legend = [{ url: options.url }];
        }
        else if (options.html) {
            this.legend = [{ html: options.html }];
        }
        else {
            this.legend = [];
        }
        return this.legend;
    }
}

const defaultEpsg = 'EPSG:3857';
const defaultMaxFeatures = 5000;
const defaultWfsVersion = '2.0.0';
const defaultFieldNameGeometry = 'geometry';
const gmlRegex = new RegExp(/(.*)?gml(.*)?/gi);
const jsonRegex = new RegExp(/(.*)?json(.*)?/gi);
/**
 * This method build the WFS URL based on the layer property.
 * @param options  WFSDataSourceOptions The common wfs datasource options interface
 * @param extent  An extent like array [number, number, number, number]
 * @param proj  olProjection
 * @param ogcFilters  OgcFiltersOptions
 * @returns A string representing the datasource options, based on filter and views
 */
function buildUrl(options, extent, proj, ogcFilters, randomParam) {
    const paramsWFS = options.paramsWFS;
    const queryStringValues = formatWFSQueryString(options, undefined, options.paramsWFS.srsName);
    let igoFilters;
    if (ogcFilters?.enabled) {
        igoFilters = ogcFilters?.filters;
    }
    const ogcFilterWriter = new OgcFilterWriter();
    const filterOrBox = ogcFilterWriter.buildFilter(igoFilters, extent, proj, ogcFilters?.geometryName, options);
    let filterOrPush = ogcFilterWriter.handleOgcFiltersAppliedValue(options, ogcFilters?.geometryName, extent, proj);
    let prefix = 'filter';
    if (!filterOrPush) {
        prefix = 'bbox';
        filterOrPush = extent.join(',') + ',' + proj.getCode();
    }
    paramsWFS.xmlFilter = ogcFilters?.advancedOgcFilters
        ? filterOrBox
        : `${prefix}=${filterOrPush}`;
    let baseUrl = queryStringValues.find((f) => f.name === 'getfeature').value;
    const patternFilter = /(filter|bbox)=.*/gi;
    baseUrl = patternFilter.test(paramsWFS.xmlFilter)
        ? `${baseUrl}&${paramsWFS.xmlFilter}`
        : baseUrl;
    options.download = Object.assign({}, options.download, {
        dynamicUrl: baseUrl
    });
    if (randomParam) {
        baseUrl += `$&_t${new Date().getTime()}`;
    }
    return baseUrl.replace(/&&/g, '&');
}
/**
 * This method build/standardize WFS call query params based on the layer property.
 * @param wfsDataSourceOptions  WFSDataSourceOptions The common wfs datasource options interface
 * @param count  Number: Used to control the number of feature. Used to bypass whe wfs datasource options interface (maxFeatures)
 * @param epsg  String: Used to control the EPSG code (es: 'EPSG3857'). Used to bypass whe wfs datasource options interface (srsName)
 * @param properties  String: Used to control the queried fields  (WFS service).
 * @returns An array array of {name: '', value: ''} of predefined query params.
 */
function formatWFSQueryString(dataSourceOptions, count, epsg, properties, startIndex = 0, forceDefaultOutputFormat = false) {
    const versionWfs200 = '2.0.0'; // not the same usage as defaultWfsVersion.
    const url = dataSourceOptions.urlWfs;
    const paramsWFS = dataSourceOptions.paramsWFS;
    const effectiveCount = count || defaultMaxFeatures;
    const effectiveStartIndex = paramsWFS.version === versionWfs200 ? `startIndex=${startIndex}` : '';
    const epsgCode = epsg || defaultEpsg;
    let outputFormat = paramsWFS.outputFormat
        ? `outputFormat=${paramsWFS.outputFormat}`
        : '';
    let version = paramsWFS.version
        ? `version=${paramsWFS.version}`
        : `version=${defaultWfsVersion}`;
    const paramTypename = paramsWFS.version === versionWfs200 ? 'typenames' : 'typename';
    const featureTypes = `${paramTypename}=${paramsWFS.featureTypes}`;
    const paramMaxFeatures = paramsWFS.version === versionWfs200 ? 'count' : 'maxFeatures';
    let cnt = count
        ? `${paramMaxFeatures}=${effectiveCount}`
        : paramsWFS.maxFeatures
            ? `${paramMaxFeatures}=${paramsWFS.maxFeatures}`
            : `${paramMaxFeatures}=${effectiveCount}`;
    if (forceDefaultOutputFormat) {
        outputFormat = '';
        version = 'version=1.1.0';
        cnt = cnt.replace('count', 'maxFeatures');
    }
    const srs = epsg
        ? `srsname=${epsgCode}`
        : paramsWFS.srsName
            ? 'srsname=' + paramsWFS.srsName
            : `srsname=${epsgCode}`;
    let propertyName = '';
    let valueReference = '';
    if (properties) {
        propertyName = `propertyName=${properties}`;
        valueReference = `valueReference=${properties}`;
    }
    const sourceFields = dataSourceOptions.sourceFields;
    if (!propertyName && sourceFields && sourceFields.length > 0) {
        const fieldsNames = [];
        dataSourceOptions.sourceFields.forEach((sourcefield) => {
            fieldsNames.push(sourcefield.name);
        });
        propertyName = `propertyName=${fieldsNames.join(',')},${paramsWFS.fieldNameGeometry}`;
    }
    const separator = url.indexOf('?') === -1 ? '?' : '&';
    const getCapabilities = `${url}${separator}service=WFS&request=GetCapabilities&${version}`;
    let getFeature = `${url}${separator}service=WFS&request=GetFeature&${version}&${featureTypes}&`;
    getFeature += `${outputFormat}&${srs}&${cnt}&${propertyName}&${effectiveStartIndex}`;
    let getpropertyvalue = `${url}?service=WFS&request=GetPropertyValue&version=${versionWfs200}&${featureTypes}&`;
    getpropertyvalue += `&${cnt}&${valueReference}`;
    return [
        { name: 'outputformat', value: outputFormat },
        { name: 'version', value: version },
        { name: 'typename', value: featureTypes },
        { name: 'count', value: cnt },
        { name: 'srsname', value: srs },
        { name: 'propertyname', value: propertyName },
        { name: 'valuereference', value: valueReference },
        { name: 'getcapabilities', value: getCapabilities.replace(/&&/g, '&') },
        { name: 'getfeature', value: getFeature.replace(/&&/g, '&') },
        { name: 'getpropertyvalue', value: getpropertyvalue.replace(/&&/g, '&') }
    ];
}
/**
 * Validate/Modify layer's wfs options based on :
 * 1- an Openlayers's issue with GML provided from WFS. Refer to
 * https://github.com/openlayers/openlayers/pull/6400
 * 2- Set default values for optionals parameters.
 * @param wfsDataSourceOptions  WFSDataSourceOptions The common wfs datasource options interface
 * @returns An array array of {name: '', value: ''} of predefined query params.
 */
function checkWfsParams(wfsDataSourceOptions, srcType) {
    if (srcType && srcType === 'wfs') {
        // reassignation of params to paramsWFS and url to urlWFS to have a common interface with wms-wfs datasources
        wfsDataSourceOptions.paramsWFS = wfsDataSourceOptions.params;
    }
    const paramsWFS = wfsDataSourceOptions.paramsWFS;
    wfsDataSourceOptions.urlWfs =
        wfsDataSourceOptions.urlWfs || wfsDataSourceOptions.url;
    paramsWFS.version = paramsWFS.version || defaultWfsVersion;
    paramsWFS.fieldNameGeometry =
        paramsWFS.fieldNameGeometry || defaultFieldNameGeometry;
    paramsWFS.maxFeatures = paramsWFS.maxFeatures || defaultMaxFeatures;
    let outputFormat;
    if (paramsWFS.outputFormat) {
        outputFormat = paramsWFS.outputFormat;
    }
    if (gmlRegex.test(outputFormat) || !outputFormat) {
        paramsWFS.version = '1.1.0';
    }
    return Object.assign({}, wfsDataSourceOptions);
}
function getFormatFromOptions(options) {
    const wfsOptions = options;
    let olFormatCls;
    const outputFormat = wfsOptions.paramsWFS.outputFormat
        ? wfsOptions.paramsWFS.outputFormat
        : undefined;
    if (!outputFormat) {
        olFormatCls = olformat.WFS;
        return new olFormatCls(wfsOptions.formatOptions);
    }
    if (olformat[outputFormat]) {
        olFormatCls = olformat[outputFormat];
        return new olFormatCls(wfsOptions.formatOptions);
    }
    else if (outputFormat.toLowerCase().match('gml2')) {
        olFormatCls = olformat.WFS;
        return new olFormatCls({
            ...wfsOptions.formatOptions,
            ...{ gmlFormat: olFormatGML2 }
        });
    }
    else if (outputFormat.toLowerCase().match('gml32')) {
        olFormatCls = olformat.WFS;
        return new olFormatCls({
            ...wfsOptions.formatOptions,
            ...{ gmlFormat: olFormatGML32 }
        });
    }
    else if (outputFormat.toLowerCase().match('gml3')) {
        olFormatCls = olformat.WFS;
        return new olFormatCls({
            ...wfsOptions.formatOptions,
            ...{ gmlFormat: olFormatGML3 }
        });
    }
    else if (outputFormat.toLowerCase().match('topojson')) {
        olFormatCls = olformat.TopoJSON;
        return new olFormatCls(wfsOptions.formatOptions);
    }
    else if (outputFormat.toLowerCase().match('geojson')) {
        olFormatCls = olformat.GeoJSON;
        return new olFormatCls(wfsOptions.formatOptions);
    }
    else if (outputFormat.toLowerCase().match('esrijson')) {
        olFormatCls = olformat.EsriJSON;
        return new olFormatCls(wfsOptions.formatOptions);
    }
    else if (outputFormat.toLowerCase().match('json')) {
        olFormatCls = olformat.GeoJSON;
        return new olFormatCls(wfsOptions.formatOptions);
    }
    else if (outputFormat.toLowerCase().match('gpx')) {
        olFormatCls = olformat.GPX;
        return new olFormatCls(wfsOptions.formatOptions);
    }
    else if (outputFormat.toLowerCase().match('WKT')) {
        olFormatCls = olformat.WKT;
        return new olFormatCls(wfsOptions.formatOptions);
    }
    else if (outputFormat.toLowerCase().match('osmxml')) {
        olFormatCls = olFormatOSMXML;
        return new olFormatCls(wfsOptions.formatOptions);
    }
    else if (outputFormat.toLowerCase().match('kml')) {
        olFormatCls = olformat.KML;
        return new olFormatCls(wfsOptions.formatOptions);
    }
    return new olFormatCls();
}

class WMSDataSource extends DataSource {
    options;
    wfsService;
    get params() {
        return this.options.params;
    }
    get queryTitle() {
        return this.options.queryTitle
            ? this.options.queryTitle
            : 'title';
    }
    get mapLabel() {
        return this.options.mapLabel;
    }
    get queryHtmlTarget() {
        return this.options.queryHtmlTarget
            ? this.options.queryHtmlTarget
            : QueryHtmlTarget.BLANK;
    }
    set ogcFilters(value) {
        this.options.ogcFilters = value;
    }
    get ogcFilters() {
        return this.options.ogcFilters;
    }
    set timeFilter(value) {
        this.options.timeFilter = value;
    }
    get timeFilter() {
        return this.options.timeFilter;
    }
    timeFilter$ = new BehaviorSubject(undefined);
    constructor(options, wfsService) {
        super(options);
        this.options = options;
        this.wfsService = wfsService;
        const sourceParams = options.params;
        const dpi = sourceParams.DPI || 96;
        sourceParams.DPI = dpi;
        sourceParams.MAP_RESOLUTION = dpi;
        sourceParams.FORMAT_OPTIONS = 'dpi:' + dpi;
        if (options.refreshIntervalSec && options.refreshIntervalSec > 0) {
            setInterval(() => {
                this.refresh();
            }, options.refreshIntervalSec * 1000); // Convert seconds to MS
        }
        let fieldNameGeometry = defaultFieldNameGeometry;
        // ####   START if paramsWFS
        if (options.paramsWFS) {
            const wfsCheckup = checkWfsParams(options, 'wms');
            ObjectUtils.mergeDeep(options.paramsWFS, wfsCheckup.paramsWFS);
            fieldNameGeometry =
                options.paramsWFS.fieldNameGeometry || fieldNameGeometry;
            options.download = Object.assign({}, options.download, {
                dynamicUrl: this.buildDynamicDownloadUrlFromParamsWFS(options)
            });
        } //  ####   END  if paramsWFS
        if (!options.sourceFields || options.sourceFields.length === 0) {
            options.sourceFields = [];
        }
        else {
            options.sourceFields.forEach((sourceField) => {
                sourceField.alias = sourceField.alias
                    ? sourceField.alias
                    : sourceField.name;
                // to allow only a list of sourcefield with names
            });
        }
        const initOgcFilters = options
            .ogcFilters;
        const ogcFilterWriter = new OgcFilterWriter();
        if (!initOgcFilters) {
            options.ogcFilters =
                ogcFilterWriter.defineOgcFiltersDefaultOptions(initOgcFilters, fieldNameGeometry, 'wms');
        }
        else {
            initOgcFilters.advancedOgcFilters =
                initOgcFilters.pushButtons ||
                    initOgcFilters.checkboxes ||
                    initOgcFilters.radioButtons ||
                    initOgcFilters.select ||
                    initOgcFilters.autocomplete
                    ? false
                    : true;
            if (initOgcFilters.advancedOgcFilters && initOgcFilters.filters) {
                const filterDuring = initOgcFilters.filters;
                if (filterDuring.calendarModeYear) {
                    initOgcFilters.advancedOgcFilters = false;
                }
            }
            if (initOgcFilters.pushButtons) {
                initOgcFilters.pushButtons.selectorType = 'pushButton';
            }
            if (initOgcFilters.checkboxes) {
                initOgcFilters.checkboxes.selectorType = 'checkbox';
            }
            if (initOgcFilters.radioButtons) {
                initOgcFilters.radioButtons.selectorType = 'radioButton';
            }
            if (initOgcFilters.select) {
                initOgcFilters.select.selectorType = 'select';
            }
            if (initOgcFilters.autocomplete) {
                initOgcFilters.autocomplete.selectorType = 'autocomplete';
            }
        }
        if (sourceParams.LAYERS.split(',').length > 1 &&
            initOgcFilters &&
            initOgcFilters.enabled) {
            console.log('*******************************');
            console.log('BE CAREFULL, YOUR WMS LAYERS (' +
                sourceParams.LAYERS +
                ') MUST SHARE THE SAME FIELDS TO ALLOW ogcFilters TO WORK !! ');
            console.log('*******************************');
        }
        if (options.paramsWFS &&
            initOgcFilters &&
            initOgcFilters.enabled &&
            initOgcFilters.editable &&
            (options.sourceFields || []).filter((sf) => !sf.values).length > 0) {
            this.wfsService.getSourceFieldsFromWFS(options);
        }
        const filterQueryString = ogcFilterWriter.handleOgcFiltersAppliedValue(options, fieldNameGeometry);
        sourceParams.FILTER = filterQueryString;
        this.ol.updateParams({ FILTER: sourceParams.FILTER });
        this.setOgcFilters(initOgcFilters, true);
        const timeFilterableDataSourceOptions = options;
        if (timeFilterableDataSourceOptions?.timeFilterable &&
            timeFilterableDataSourceOptions?.timeFilter) {
            this.setTimeFilter(timeFilterableDataSourceOptions.timeFilter, true);
        }
    }
    refresh() {
        this.ol.updateParams({ igoRefresh: Math.random() });
    }
    buildDynamicDownloadUrlFromParamsWFS(asWFSDataSourceOptions) {
        const queryStringValues = formatWFSQueryString(asWFSDataSourceOptions);
        const downloadUrl = queryStringValues.find((f) => f.name === 'getfeature').value;
        return downloadUrl;
    }
    createOlSource() {
        return new olSourceImageWMS(Object.assign({ ratio: 1 }, this.options));
    }
    setOgcFilters(ogcFilters, triggerEvent = false) {
        this.ogcFilters = ogcFilters;
        if (triggerEvent) {
            this.ol.notify('ogcFilters', this.ogcFilters);
        }
    }
    setTimeFilter(timeFilter, triggerEvent = false) {
        this.timeFilter = timeFilter;
        if (triggerEvent) {
            this.timeFilter$.next(this.timeFilter);
            this.ol.notify('timeFilter', this.ogcFilters);
        }
    }
    getLegend(style, view) {
        let legend = super.getLegend();
        if (legend.length > 0 && style === undefined && !view?.scale) {
            return legend;
        }
        let contentDependent = false;
        let projParam;
        if (view?.size &&
            view?.extent &&
            view?.projection &&
            this.options.contentDependentLegend) {
            projParam =
                this.params.VERSION === '1.3.0' || this.params.VERSION === undefined
                    ? 'CRS'
                    : 'SRS';
            contentDependent = true;
        }
        const sourceParams = this.params;
        let layers = [];
        if (sourceParams.LAYERS !== undefined) {
            layers = sourceParams.LAYERS.split(',');
        }
        const baseUrl = this.options.url.replace(/\?$/, '');
        const params = [
            'REQUEST=GetLegendGraphic',
            'SERVICE=WMS',
            'FORMAT=image/png',
            'SLD_VERSION=1.1.0',
            `VERSION=${sourceParams.VERSION || '1.3.0'}`
        ];
        if (style !== undefined) {
            params.push(`STYLE=${style}`);
        }
        if (view?.scale !== undefined) {
            params.push(`SCALE=${view.scale}`);
        }
        if (contentDependent) {
            params.push(`WIDTH=${view.size[0]}`);
            params.push(`HEIGHT=${view.size[1]}`);
            params.push(`BBOX=${view.extent.join(',')}`);
            params.push(`${projParam}=${view.projection}`);
        }
        legend = layers.map((layer) => {
            const separator = baseUrl.match(/\?/) ? '&' : '?';
            return {
                url: `${baseUrl}${separator}${params.join('&')}&LAYER=${layer}`,
                title: layers.length > 1 ? layer : undefined,
                currentStyle: style === undefined ? undefined : style
            };
        });
        return legend;
    }
    onUnwatch() { }
}

class Layer {
    options;
    messageService;
    authInterceptor;
    geoDBService;
    layerDBService;
    collapsed;
    dataSource;
    legend;
    legendCollapsed = true;
    firstLoadComponent = true;
    map;
    ol;
    olLoadingProblem = false;
    status$;
    hasBeenVisible$ = new BehaviorSubject(undefined);
    hasBeenVisible$$;
    resolution$$;
    /**
     * Define if a layer is generated by code OR defined by layer/context user layer.
     * Useful for filtering layers list in mapOffline.directive or in the sharemap...
     * return false by default.
     */
    get isIgoInternalLayer() {
        return this.options.isIgoInternalLayer || false;
    }
    get id() {
        return this.options.id || this.dataSource.id;
    }
    get alias() {
        return this.options.alias;
    }
    get title() {
        return this.options.title;
    }
    set title(title) {
        this.options.title = title;
    }
    get zIndex() {
        return this.ol.getZIndex();
    }
    set zIndex(zIndex) {
        this.ol.setZIndex(zIndex);
    }
    get baseLayer() {
        return this.options.baseLayer;
    }
    set baseLayer(baseLayer) {
        this.options.baseLayer = baseLayer;
    }
    get opacity() {
        return this.ol.get('opacity');
    }
    set opacity(opacity) {
        this.ol.setOpacity(opacity);
    }
    set isInResolutionsRange(value) {
        this.isInResolutionsRange$.next(value);
    }
    get isInResolutionsRange() {
        return this.isInResolutionsRange$.value;
    }
    isInResolutionsRange$ = new BehaviorSubject(false);
    set maxResolution(value) {
        this.ol.setMaxResolution(value === 0 ? 0 : value || Infinity);
        this.updateInResolutionsRange();
    }
    get maxResolution() {
        return this.ol.getMaxResolution();
    }
    set minResolution(value) {
        this.ol.setMinResolution(value || 0);
        this.updateInResolutionsRange();
    }
    get minResolution() {
        return this.ol.getMinResolution();
    }
    set visible(value) {
        this.ol.setVisible(value);
        this.visible$.next(value);
        if (!this.hasBeenVisible$.value && value) {
            this.hasBeenVisible$.next(value);
        }
        if (this.options?.messages && value) {
            this.options?.messages
                .filter((m) => m.options?.showOnEachLayerVisibility)
                .map((message) => this.showMessage(message));
        }
    }
    get visible() {
        return this.visible$.value;
    }
    visible$ = new BehaviorSubject(undefined);
    get displayed() {
        return this.visible && this.isInResolutionsRange;
    }
    displayed$ = combineLatest([
        this.isInResolutionsRange$,
        this.visible$
    ]).pipe(map((bunch) => bunch[0] && bunch[1]));
    get showInLayerList() {
        return this.options.showInLayerList !== false;
    }
    constructor(options, messageService, authInterceptor, geoDBService, layerDBService) {
        this.options = options;
        this.messageService = messageService;
        this.authInterceptor = authInterceptor;
        this.geoDBService = geoDBService;
        this.layerDBService = layerDBService;
        this.dataSource = options.source;
        this.ol = this.createOlLayer();
        if (options.zIndex !== undefined) {
            this.zIndex = options.zIndex;
        }
        if (options.baseLayer && options.visible === undefined) {
            options.visible = false;
        }
        this.maxResolution =
            options.maxResolution ||
                getResolutionFromScale(Number(options.maxScaleDenom));
        this.minResolution =
            options.minResolution ||
                getResolutionFromScale(Number(options.minScaleDenom));
        this.visible = options.visible === undefined ? true : options.visible;
        this.opacity = options.opacity === undefined ? 1 : options.opacity;
        if (options.legendOptions &&
            (options.legendOptions.url || options.legendOptions.html)) {
            this.legend = this.dataSource.setLegend(options.legendOptions);
        }
        this.legendCollapsed = options.legendOptions
            ? options.legendOptions.collapsed
                ? options.legendOptions.collapsed
                : true
            : true;
        this.ol.set('_layer', this, true);
    }
    setMap(map) {
        this.map = map;
        this.unobserveResolution();
        if (map !== undefined) {
            this.observeResolution();
            this.hasBeenVisible$$ = this.hasBeenVisible$.subscribe(() => {
                if (this.options.messages && this.visible) {
                    this.options.messages.map((message) => {
                        this.showMessage(message);
                    });
                }
            });
        }
    }
    showMessage(message) {
        if (!this.messageService) {
            return;
        }
        message.title = message.title;
        message.text = message.text;
        this.messageService.message(message);
    }
    observeResolution() {
        this.resolution$$ = this.map.viewController.resolution$.subscribe(() => this.updateInResolutionsRange());
    }
    unobserveResolution() {
        if (this.resolution$$ !== undefined) {
            this.resolution$$.unsubscribe();
            this.resolution$$ = undefined;
        }
    }
    updateInResolutionsRange() {
        if (this.map !== undefined) {
            const resolution = this.map.viewController.getResolution();
            const minResolution = this.minResolution;
            const maxResolution = this.maxResolution === undefined ? Infinity : this.maxResolution;
            this.isInResolutionsRange =
                resolution >= minResolution && resolution <= maxResolution;
        }
        else {
            this.isInResolutionsRange = false;
        }
    }
}

class LayerLegendComponent {
    capabilitiesService;
    languageService;
    configService;
    http;
    cdRef;
    updateLegendOnResolutionChange = false;
    /**
     * Observable of the legend items
     */
    legendItems$ = new BehaviorSubject([]);
    /**
     * Subscription to the map's resolution
     */
    state$$;
    /**
     * The available styles
     */
    styles;
    /**
     * The style used to make the legend
     */
    currentStyle;
    /**
     * The scale used to make the legend
     */
    scale = undefined;
    /**
     * The extent used to make the legend
     */
    view = undefined;
    /**
     * Get list of images display
     */
    renderedLegends;
    /**
     * List of size of images displayed
     */
    imagesHeight = {};
    /**
     * Layer
     */
    layer;
    /**
     * if getLegendGraphic is authorized
     */
    getLegend = true;
    /**
     * activeLegend
     */
    constructor(capabilitiesService, languageService, configService, http, cdRef) {
        this.capabilitiesService = capabilitiesService;
        this.languageService = languageService;
        this.configService = configService;
        this.http = http;
        this.cdRef = cdRef;
    }
    /**
     * On init, subscribe to the map's resolution and update the legend accordingly
     */
    ngOnInit() {
        let lastlLegend = this.layer.legend;
        this.styles = this.listStyles();
        const sourceOptions = this.layer.options.source.options;
        if (sourceOptions && sourceOptions.params && sourceOptions.params.STYLES) {
            // if a styles is provided into the layers wms params
            this.currentStyle = this.styles.find((style) => style.name === sourceOptions.params.STYLES).name;
        }
        else if (!lastlLegend) {
            // if no legend is manually provided
            if (this.styles && this.styles.length > 1) {
                this.currentStyle = this.styles[0].name;
            }
        }
        else if (this.styles && this.styles.length > 1) {
            this.currentStyle = lastlLegend[0].currentStyle;
        }
        if (typeof this.layer.options.legendOptions !== 'undefined' &&
            this.layer.options.legendOptions.display === false) {
            lastlLegend = [];
        }
        else {
            lastlLegend = this.layer.dataSource.getLegend(this.currentStyle, this.view);
        }
        if (this.updateLegendOnResolutionChange ||
            sourceOptions.contentDependentLegend) {
            const state$ = this.layer.map.viewController.state$;
            this.state$$ = state$.subscribe(() => this.onViewControllerStateChange());
        }
        else if (lastlLegend && lastlLegend.length !== 0) {
            this.legendItems$.next(lastlLegend);
            for (const legend of lastlLegend) {
                this.getLegendGraphic(legend);
            }
        }
    }
    /**
     * On destroy, unsubscribe to the map's view state
     */
    ngOnDestroy() {
        if (this.state$$ !== undefined) {
            this.state$$.unsubscribe();
        }
    }
    getLegendGraphic(item) {
        if (item.url) {
            const secureIMG = new SecureImagePipe(this.http, this.configService);
            secureIMG
                .transform(item.url)
                .pipe(catchError((err) => {
                if (err.error) {
                    err.error.caught = true;
                    this.getLegend = false;
                    this.cdRef.detectChanges();
                    return err;
                }
            }))
                .subscribe((obsLegGraph) => {
                const idx = this.legendItems$.value.findIndex((leg) => leg.title === item.title);
                const legendGraph = obsLegGraph;
                this.legendItems$.value[idx].imgGraphValue = legendGraph;
                this.cdRef.detectChanges();
            });
        }
    }
    toggleLegendItem(collapsed, item) {
        item.collapsed = collapsed;
    }
    transfertToggleLegendItem(newLegends) {
        const outLegends = newLegends;
        const lastLegends = this.layer.legend;
        for (let i = 0; i < lastLegends.length; i++) {
            outLegends[i].collapsed = lastLegends[i].collapsed;
        }
        return outLegends;
    }
    computeItemTitle(layerLegend) {
        const layerOptions = this.layer.dataSource.options;
        if (layerOptions.type !== 'wms') {
            return of(layerLegend.title);
        }
        const layers = layerOptions.params.LAYERS.split(',');
        const localLayerOptions = JSON.parse(JSON.stringify(layerOptions)); // to avoid to alter the original options.
        localLayerOptions.params.LAYERS = layers.find((layer) => layer === layerLegend.title);
        return this.capabilitiesService.getWMSOptions(localLayerOptions).pipe(map((wmsDataSourceOptions) => {
            return wmsDataSourceOptions._layerOptionsFromSource.title;
        }));
    }
    /**
     * On resolution change, compute the effective scale level and update the
     * legend accordingly.
     * @param resolution Map resolution
     */
    onViewControllerStateChange() {
        this.view = {
            resolution: this.layer.map.viewController.getResolution(),
            extent: this.layer.map.viewController.getExtent(),
            projection: this.layer.map.viewController.getOlProjection().getCode(),
            scale: this.layer.map.viewController.getScale(),
            size: this.layer.map.ol.getSize()
        };
        this.updateLegend();
    }
    /**
     * Update the legend with scale level and style define
     */
    updateLegend() {
        let legendItems = this.layer.dataSource.getLegend(this.currentStyle, this.view);
        if (this.layer.legend && this.layer.legend.length > 1) {
            legendItems = this.transfertToggleLegendItem(legendItems);
        }
        this.layer.legend = legendItems;
        if (legendItems.length === 0 && this.legendItems$.value.length === 0) {
            return;
        }
        this.legendItems$.next(legendItems);
        for (const legend of this.legendItems$.value) {
            this.getLegendGraphic(legend);
        }
    }
    listStyles() {
        const layerOptions = this.layer.options;
        if (layerOptions && layerOptions.legendOptions) {
            const translate = this.languageService.translate;
            const title = translate.instant('igo.geo.layer.legend.default');
            let stylesAvailable = [{ name: '', title }];
            if (layerOptions.legendOptions.stylesAvailable) {
                stylesAvailable = stylesAvailable.concat(layerOptions.legendOptions.stylesAvailable.filter((sA) => sA.name.normalize('NFD').replace(/[\u0300-\u036f]/gi, '') !==
                    'default' &&
                    sA.name.normalize('NFD').replace(/[\u0300-\u036f]/gi, '') !==
                        'defaut'));
            }
            stylesAvailable
                .filter((sa) => !sa.title)
                .map((sa) => (sa.title = sa.name));
            stylesAvailable.map((s) => (s.title =
                s.title.charAt(0).toUpperCase() +
                    s.title.slice(1).replace(/_/g, ' ')));
            return stylesAvailable;
        }
        return;
    }
    onChangeStyle() {
        this.updateLegend();
        let STYLES = '';
        if (this.layer.dataSource instanceof WMSDataSource) {
            this.layer.dataSource.ol
                .getParams()
                .LAYERS.split(',')
                .map((layer) => (STYLES += this.currentStyle + ','));
            STYLES = STYLES.slice(0, -1);
            this.layer.dataSource.ol.updateParams({ STYLES });
        }
    }
    onLoadImage(id) {
        let elemRef;
        if (this.renderedLegends.length === 1) {
            elemRef = this.renderedLegends.first.nativeElement;
        }
        else {
            elemRef = this.renderedLegends.find((renderedLegend) => renderedLegend.nativeElement.id === id).nativeElement;
        }
        this.imagesHeight[id] = elemRef.height;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LayerLegendComponent, deps: [{ token: CapabilitiesService }, { token: i2.LanguageService }, { token: i2.ConfigService }, { token: i1.HttpClient }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: LayerLegendComponent, selector: "igo-layer-legend", inputs: { updateLegendOnResolutionChange: "updateLegendOnResolutionChange", layer: "layer" }, viewQueries: [{ propertyName: "renderedLegends", predicate: ["renderedLegend"], descendants: true }], ngImport: i0, template: "<ng-container *ngIf=\"legendItems$ | async as items\">\n  <ng-container *ngIf=\"items.length; else noItems\">\n    <ng-container *ngFor=\"let item of items.slice().reverse()\" #renderedLegends>\n      <div *ngIf=\"getLegend; else noItems\">\n        <mat-list-item *ngIf=\"item.title\">\n          <mat-icon\n            id=\"legend-toggle\"\n            class=\"igo-chevron\"\n            matListItemIcon\n            igoCollapse\n            [target]=\"legend\"\n            [collapsed]=\"item.collapsed\"\n            (toggle)=\"toggleLegendItem($event, item)\"\n            svgIcon=\"chevron-up\"\n          >\n          </mat-icon>\n          <span matListItemTitle>{{ computeItemTitle(item) | async }} </span>\n        </mat-list-item>\n        <div\n          #legend\n          class=\"igo-layer-legend\"\n          [ngClass]=\"{ 'with-title': item.title }\"\n        >\n          <div *ngIf=\"currentStyle !== undefined\">\n            <mat-form-field>\n              <mat-select\n                tooltip-position=\"below\"\n                matTooltipShowDelay=\"500\"\n                [matTooltip]=\"'igo.geo.layer.legend.selectStyle' | translate\"\n                [(ngModel)]=\"currentStyle\"\n                (selectionChange)=\"onChangeStyle()\"\n              >\n                <mat-option *ngFor=\"let style of styles\" [value]=\"style.name\">{{\n                  style.title\n                }}</mat-option>\n              </mat-select>\n            </mat-form-field>\n          </div>\n          <div *ngIf=\"!item.collapsed\">\n            <div *ngIf=\"item.url\">\n              <img\n                igoImageError\n                *ngIf=\"item.imgGraphValue\"\n                hideError=\"true\"\n                #renderedLegend\n                id=\"{{ item.title }}\"\n                (load)=\"onLoadImage(item.title)\"\n                [src]=\"item.imgGraphValue\"\n                alt=\"{{ 'igo.geo.layer.legend.loadingLegendText' | translate }}\"\n              />\n              <small *ngIf=\"imagesHeight[item.title] < 16\">\n                {{ 'igo.geo.layer.legend.noLegendScale' | translate }}\n              </small>\n            </div>\n            <div\n              [ngStyle]=\"item.style\"\n              [innerHTML]=\"item.html | sanitizeHtml\"\n              *ngIf=\"item.html\"\n            ></div>\n          </div>\n        </div>\n      </div>\n    </ng-container>\n  </ng-container>\n\n  <ng-template #noItems>\n    <small>\n      {{ 'igo.geo.layer.legend.noLegendText' | translate }}\n    </small>\n  </ng-template>\n</ng-container>\n", styles: [":host .igo-layer-legend.with-title{padding-left:18px}:host img{max-width:100%}:host img:after{content:\" \";position:relative;height:17px;float:left;width:17px;top:-3px;right:19px;background-color:#fff;border:3px solid #f3f3f3;border-radius:50%;animation:2s linear infinite spin}@-moz-document url-prefix(){:host img:after{margin-left:19px}}@keyframes spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}\n"], dependencies: [{ kind: "component", type: i8.MatFormField, selector: "mat-form-field", inputs: ["hideRequiredMarker", "color", "floatLabel", "appearance", "subscriptSizing", "hintLabel"], exportAs: ["matFormField"] }, { kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2$2.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: i2$1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i15.MatSelect, selector: "mat-select", inputs: ["disabled", "disableRipple", "tabIndex", "panelWidth", "hideSingleSelectionIndicator"], exportAs: ["matSelect"] }, { kind: "component", type: i9.MatOption, selector: "mat-option", exportAs: ["matOption"] }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "component", type: i5.MatListItem, selector: "mat-list-item, a[mat-list-item], button[mat-list-item]", inputs: ["activated"], exportAs: ["matListItem"] }, { kind: "directive", type: i5.MatListItemIcon, selector: "[matListItemIcon]" }, { kind: "directive", type: i5.MatListItemTitle, selector: "[matListItemTitle]" }, { kind: "directive", type: i9$1.CollapseDirective, selector: "[igoCollapse]", inputs: ["target", "collapsed"], outputs: ["toggle"] }, { kind: "directive", type: i9$1.ImageErrorDirective, selector: "[igoImageError]", inputs: ["errorImageUrl", "hideError"] }, { kind: "pipe", type: i2$2.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }, { kind: "pipe", type: i9$1.SanitizeHtmlPipe, name: "sanitizeHtml" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LayerLegendComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-layer-legend', changeDetection: ChangeDetectionStrategy.OnPush, template: "<ng-container *ngIf=\"legendItems$ | async as items\">\n  <ng-container *ngIf=\"items.length; else noItems\">\n    <ng-container *ngFor=\"let item of items.slice().reverse()\" #renderedLegends>\n      <div *ngIf=\"getLegend; else noItems\">\n        <mat-list-item *ngIf=\"item.title\">\n          <mat-icon\n            id=\"legend-toggle\"\n            class=\"igo-chevron\"\n            matListItemIcon\n            igoCollapse\n            [target]=\"legend\"\n            [collapsed]=\"item.collapsed\"\n            (toggle)=\"toggleLegendItem($event, item)\"\n            svgIcon=\"chevron-up\"\n          >\n          </mat-icon>\n          <span matListItemTitle>{{ computeItemTitle(item) | async }} </span>\n        </mat-list-item>\n        <div\n          #legend\n          class=\"igo-layer-legend\"\n          [ngClass]=\"{ 'with-title': item.title }\"\n        >\n          <div *ngIf=\"currentStyle !== undefined\">\n            <mat-form-field>\n              <mat-select\n                tooltip-position=\"below\"\n                matTooltipShowDelay=\"500\"\n                [matTooltip]=\"'igo.geo.layer.legend.selectStyle' | translate\"\n                [(ngModel)]=\"currentStyle\"\n                (selectionChange)=\"onChangeStyle()\"\n              >\n                <mat-option *ngFor=\"let style of styles\" [value]=\"style.name\">{{\n                  style.title\n                }}</mat-option>\n              </mat-select>\n            </mat-form-field>\n          </div>\n          <div *ngIf=\"!item.collapsed\">\n            <div *ngIf=\"item.url\">\n              <img\n                igoImageError\n                *ngIf=\"item.imgGraphValue\"\n                hideError=\"true\"\n                #renderedLegend\n                id=\"{{ item.title }}\"\n                (load)=\"onLoadImage(item.title)\"\n                [src]=\"item.imgGraphValue\"\n                alt=\"{{ 'igo.geo.layer.legend.loadingLegendText' | translate }}\"\n              />\n              <small *ngIf=\"imagesHeight[item.title] < 16\">\n                {{ 'igo.geo.layer.legend.noLegendScale' | translate }}\n              </small>\n            </div>\n            <div\n              [ngStyle]=\"item.style\"\n              [innerHTML]=\"item.html | sanitizeHtml\"\n              *ngIf=\"item.html\"\n            ></div>\n          </div>\n        </div>\n      </div>\n    </ng-container>\n  </ng-container>\n\n  <ng-template #noItems>\n    <small>\n      {{ 'igo.geo.layer.legend.noLegendText' | translate }}\n    </small>\n  </ng-template>\n</ng-container>\n", styles: [":host .igo-layer-legend.with-title{padding-left:18px}:host img{max-width:100%}:host img:after{content:\" \";position:relative;height:17px;float:left;width:17px;top:-3px;right:19px;background-color:#fff;border:3px solid #f3f3f3;border-radius:50%;animation:2s linear infinite spin}@-moz-document url-prefix(){:host img:after{margin-left:19px}}@keyframes spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}\n"] }]
        }], ctorParameters: function () { return [{ type: CapabilitiesService }, { type: i2.LanguageService }, { type: i2.ConfigService }, { type: i1.HttpClient }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { updateLegendOnResolutionChange: [{
                type: Input
            }], renderedLegends: [{
                type: ViewChildren,
                args: ['renderedLegend']
            }], layer: [{
                type: Input
            }] } });

class LayerItemComponent {
    networkService;
    renderer;
    elRef;
    cdRef;
    focusedCls = 'igo-layer-item-focused';
    get activeLayer() {
        return this._activeLayer;
    }
    set activeLayer(value) {
        if (value &&
            this.layer &&
            value.id === this.layer.id &&
            !this.selectionMode) {
            this.layerTool$.next(true);
            this.renderer.addClass(this.elRef.nativeElement, this.focusedCls);
        }
        else {
            this.renderer.removeClass(this.elRef.nativeElement, this.focusedCls);
        }
    }
    _activeLayer;
    layerTool$ = new BehaviorSubject(false);
    showLegend$ = new BehaviorSubject(true);
    inResolutionRange$ = new BehaviorSubject(true);
    queryBadgeHidden$ = new BehaviorSubject(true);
    tooltipText;
    state;
    get selectAll() {
        return this._selectAll;
    }
    set selectAll(value) {
        this._selectAll = value;
        if (value === true) {
            this.layerCheck = true;
        }
    }
    _selectAll = false;
    layerCheck;
    resolution$$;
    network$$;
    layers$$;
    layers$ = new BehaviorSubject(undefined);
    get layer() {
        return this._layer;
    }
    set layer(value) {
        this._layer = value;
        this.layers$.next(value);
    }
    _layer;
    toggleLegendOnVisibilityChange = false;
    expandLegendIfVisible = false;
    updateLegendOnResolutionChange = false;
    orderable = true;
    lowerDisabled = false;
    raiseDisabled = false;
    queryBadge = false;
    selectionMode;
    changeDetection;
    get opacity() {
        return this.layer.opacity * 100;
    }
    set opacity(opacity) {
        this.layer.opacity = opacity / 100;
    }
    get eyeTooltip() {
        if (this.inResolutionRange$.getValue() === false) {
            return 'igo.geo.layer.notInResolution';
        }
        else {
            return this.layer.visible
                ? 'igo.geo.layer.hideLayer'
                : 'igo.geo.layer.showLayer';
        }
    }
    action = new EventEmitter(undefined);
    checkbox = new EventEmitter();
    constructor(networkService, renderer, elRef, cdRef) {
        this.networkService = networkService;
        this.renderer = renderer;
        this.elRef = elRef;
        this.cdRef = cdRef;
    }
    ngOnInit() {
        if (this.layer.visible &&
            this.expandLegendIfVisible &&
            this.layer.firstLoadComponent === true) {
            this.layer.firstLoadComponent = false;
            this.layer.legendCollapsed = false;
        }
        this.toggleLegend(this.layer.legendCollapsed);
        this.updateQueryBadge();
        const resolution$ = this.layer.map.viewController.resolution$;
        this.resolution$$ = resolution$.subscribe(() => {
            this.onResolutionChange();
        });
        this.tooltipText = this.computeTooltip();
        this.network$$ = this.networkService
            .currentState()
            .subscribe((state) => {
            this.state = state;
            this.onResolutionChange();
        });
        this.layers$$ = this.layers$.subscribe(() => {
            if (this.layer && this.layer.options.active) {
                this.layerTool$.next(true);
                this.renderer.addClass(this.elRef.nativeElement, this.focusedCls);
            }
        });
        if (this.changeDetection) {
            this.changeDetection.subscribe(() => this.cdRef.detectChanges());
        }
    }
    ngOnDestroy() {
        this.resolution$$.unsubscribe();
        this.network$$.unsubscribe();
        this.layers$$.unsubscribe();
    }
    toggleLegend(collapsed) {
        this.layer.legendCollapsed = collapsed;
        this.showLegend$.next(!collapsed);
    }
    toggleLegendOnClick() {
        this.toggleLegend(this.showLegend$.value);
    }
    toggleVisibility(event) {
        event.stopPropagation();
        this.layer.visible = !this.layer.visible;
        if (this.toggleLegendOnVisibilityChange) {
            this.toggleLegend(!this.layer.visible);
        }
        this.updateQueryBadge();
    }
    computeTooltip() {
        const layerOptions = this.layer.options;
        if (!layerOptions.tooltip) {
            return this.layer.title;
        }
        const layerTooltip = layerOptions.tooltip;
        const layerMetadata = layerOptions.metadata;
        switch (layerOptions.tooltip.type) {
            case TooltipType.TITLE:
                return this.layer.title;
            case TooltipType.ABSTRACT:
                if (layerMetadata && layerMetadata.abstract) {
                    return layerMetadata.abstract;
                }
                else {
                    return this.layer.title;
                }
            case TooltipType.CUSTOM:
                if (layerTooltip && layerTooltip.text) {
                    return layerTooltip.text;
                }
                else {
                    return this.layer.title;
                }
            default:
                return this.layer.title;
        }
    }
    onResolutionChange() {
        const inResolutionRange = this.layer.isInResolutionsRange;
        if (inResolutionRange === false &&
            this.updateLegendOnResolutionChange === true) {
            this.toggleLegend(true);
        }
        this.inResolutionRange$.next(inResolutionRange);
    }
    updateQueryBadge() {
        const hidden = this.queryBadge === false ||
            this.layer.visible === false ||
            !layerIsQueryable(this.layer);
        this.queryBadgeHidden$.next(hidden);
    }
    toggleLayerTool() {
        this.layerTool$.next(!this.layerTool$.getValue());
        if (this.layerTool$.getValue() === true) {
            this.renderer.addClass(this.elRef.nativeElement, this.focusedCls);
        }
        else {
            this.renderer.removeClass(this.elRef.nativeElement, this.focusedCls);
        }
        this.action.emit(this.layer);
    }
    check() {
        this.layerCheck = !this.layerCheck;
        this.checkbox.emit({ layer: this.layer, check: this.layerCheck });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LayerItemComponent, deps: [{ token: i2.NetworkService }, { token: i0.Renderer2 }, { token: i0.ElementRef }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: LayerItemComponent, selector: "igo-layer-item", inputs: { activeLayer: "activeLayer", selectAll: "selectAll", layerCheck: "layerCheck", layer: "layer", toggleLegendOnVisibilityChange: "toggleLegendOnVisibilityChange", expandLegendIfVisible: "expandLegendIfVisible", updateLegendOnResolutionChange: "updateLegendOnResolutionChange", orderable: "orderable", lowerDisabled: "lowerDisabled", raiseDisabled: "raiseDisabled", queryBadge: "queryBadge", selectionMode: "selectionMode", changeDetection: "changeDetection" }, outputs: { action: "action", checkbox: "checkbox" }, ngImport: i0, template: "<mat-list-item class=\"igo-layer-list-item\">\n  <mat-checkbox\n    *ngIf=\"selectionMode\"\n    class=\"layerCheck\"\n    matListItemIcon\n    (change)=\"check()\"\n    [checked]=\"layerCheck\"\n  >\n  </mat-checkbox>\n  <span\n    matListItemTitle\n    class=\"igo-layer-title\"\n    [matTooltip]=\"tooltipText\"\n    matTooltipShowDelay=\"500\"\n    (click)=\"toggleLegendOnClick()\"\n  >\n    {{ layer.title }}\n  </span>\n\n  <div matListItemMeta>\n    <button\n      *ngIf=\"!selectionMode\"\n      mat-icon-button\n      [color]=\"layer.visible ? 'primary' : 'default'\"\n      collapsibleButton\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"eyeTooltip | translate\"\n      (click)=\"toggleVisibility($event)\"\n    >\n      <mat-icon\n        aria-hidden=\"false\"\n        matBadge=\"?\"\n        matBadgeColor=\"accent\"\n        matBadgeSize=\"small\"\n        matBadgePosition=\"after\"\n        [matBadgeHidden]=\"queryBadgeHidden$ | async\"\n        [ngClass]=\"{ disabled: (inResolutionRange$ | async) === false }\"\n        [svgIcon]=\"(layer.visible$ | async) ? 'eye' : 'eye-off'\"\n      >\n      </mat-icon>\n    </button>\n\n    <button\n      *ngIf=\"selectionMode\"\n      class=\"selection-eye\"\n      mat-icon-button\n      [color]=\"layer.visible ? 'primary' : 'default'\"\n      collapsibleButton\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"\n        layer.visible\n          ? ('igo.geo.layer.hideLayer' | translate)\n          : ('igo.geo.layer.showLayer' | translate)\n      \"\n      (click)=\"toggleVisibility($event)\"\n    >\n      <mat-icon\n        aria-hidden=\"false\"\n        matBadge=\"?\"\n        matBadgeColor=\"accent\"\n        matBadgeSize=\"small\"\n        matBadgePosition=\"after\"\n        [matBadgeHidden]=\"queryBadgeHidden$ | async\"\n        [ngClass]=\"{ disabled: (inResolutionRange$ | async) === false }\"\n        [svgIcon]=\"layer.visible ? 'eye' : 'eye-off'\"\n      >\n      </mat-icon>\n    </button>\n\n    <button\n      *ngIf=\"!selectionMode\"\n      class=\"actions-button\"\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"'igo.geo.layer.moreOptions' | translate\"\n      mat-icon-button\n      color=\"primary\"\n      (click)=\"toggleLayerTool()\"\n    >\n      <mat-icon svgIcon=\"dots-horizontal\"></mat-icon>\n    </button>\n  </div>\n</mat-list-item>\n\n<div #legend class=\"igo-layer-legend-container\">\n  <igo-layer-legend\n    *ngIf=\"showLegend$ | async\"\n    [layer]=\"layer\"\n    [updateLegendOnResolutionChange]=\"updateLegendOnResolutionChange\"\n  >\n  </igo-layer-legend>\n</div>\n", styles: [":host{overflow:hidden}:host ::ng-deep .igo-layer-title{display:block;width:100%;cursor:pointer}:host .igo-layer-legend-container{padding-left:18px;width:calc(100% - 18px)}:host mat-icon[matBadge] ::ng-deep .mat-badge-content{font-size:12px}:host .layerCheck{align-self:baseline;width:16px;padding-right:0}\n"], dependencies: [{ kind: "directive", type: i2$2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "component", type: i5.MatListItem, selector: "mat-list-item, a[mat-list-item], button[mat-list-item]", inputs: ["activated"], exportAs: ["matListItem"] }, { kind: "directive", type: i5.MatListItemIcon, selector: "[matListItemIcon]" }, { kind: "directive", type: i5.MatListItemTitle, selector: "[matListItemTitle]" }, { kind: "directive", type: i5.MatListItemMeta, selector: "[matListItemMeta]" }, { kind: "directive", type: i6.MatBadge, selector: "[matBadge]", inputs: ["matBadgeDisabled", "matBadgeColor", "matBadgeOverlap", "matBadgePosition", "matBadge", "matBadgeDescription", "matBadgeSize", "matBadgeHidden"] }, { kind: "component", type: i11.MatCheckbox, selector: "mat-checkbox", inputs: ["disableRipple", "color", "tabIndex"], exportAs: ["matCheckbox"] }, { kind: "component", type: LayerLegendComponent, selector: "igo-layer-legend", inputs: ["updateLegendOnResolutionChange", "layer"] }, { kind: "pipe", type: i2$2.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LayerItemComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-layer-item', changeDetection: ChangeDetectionStrategy.OnPush, template: "<mat-list-item class=\"igo-layer-list-item\">\n  <mat-checkbox\n    *ngIf=\"selectionMode\"\n    class=\"layerCheck\"\n    matListItemIcon\n    (change)=\"check()\"\n    [checked]=\"layerCheck\"\n  >\n  </mat-checkbox>\n  <span\n    matListItemTitle\n    class=\"igo-layer-title\"\n    [matTooltip]=\"tooltipText\"\n    matTooltipShowDelay=\"500\"\n    (click)=\"toggleLegendOnClick()\"\n  >\n    {{ layer.title }}\n  </span>\n\n  <div matListItemMeta>\n    <button\n      *ngIf=\"!selectionMode\"\n      mat-icon-button\n      [color]=\"layer.visible ? 'primary' : 'default'\"\n      collapsibleButton\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"eyeTooltip | translate\"\n      (click)=\"toggleVisibility($event)\"\n    >\n      <mat-icon\n        aria-hidden=\"false\"\n        matBadge=\"?\"\n        matBadgeColor=\"accent\"\n        matBadgeSize=\"small\"\n        matBadgePosition=\"after\"\n        [matBadgeHidden]=\"queryBadgeHidden$ | async\"\n        [ngClass]=\"{ disabled: (inResolutionRange$ | async) === false }\"\n        [svgIcon]=\"(layer.visible$ | async) ? 'eye' : 'eye-off'\"\n      >\n      </mat-icon>\n    </button>\n\n    <button\n      *ngIf=\"selectionMode\"\n      class=\"selection-eye\"\n      mat-icon-button\n      [color]=\"layer.visible ? 'primary' : 'default'\"\n      collapsibleButton\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"\n        layer.visible\n          ? ('igo.geo.layer.hideLayer' | translate)\n          : ('igo.geo.layer.showLayer' | translate)\n      \"\n      (click)=\"toggleVisibility($event)\"\n    >\n      <mat-icon\n        aria-hidden=\"false\"\n        matBadge=\"?\"\n        matBadgeColor=\"accent\"\n        matBadgeSize=\"small\"\n        matBadgePosition=\"after\"\n        [matBadgeHidden]=\"queryBadgeHidden$ | async\"\n        [ngClass]=\"{ disabled: (inResolutionRange$ | async) === false }\"\n        [svgIcon]=\"layer.visible ? 'eye' : 'eye-off'\"\n      >\n      </mat-icon>\n    </button>\n\n    <button\n      *ngIf=\"!selectionMode\"\n      class=\"actions-button\"\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"'igo.geo.layer.moreOptions' | translate\"\n      mat-icon-button\n      color=\"primary\"\n      (click)=\"toggleLayerTool()\"\n    >\n      <mat-icon svgIcon=\"dots-horizontal\"></mat-icon>\n    </button>\n  </div>\n</mat-list-item>\n\n<div #legend class=\"igo-layer-legend-container\">\n  <igo-layer-legend\n    *ngIf=\"showLegend$ | async\"\n    [layer]=\"layer\"\n    [updateLegendOnResolutionChange]=\"updateLegendOnResolutionChange\"\n  >\n  </igo-layer-legend>\n</div>\n", styles: [":host{overflow:hidden}:host ::ng-deep .igo-layer-title{display:block;width:100%;cursor:pointer}:host .igo-layer-legend-container{padding-left:18px;width:calc(100% - 18px)}:host mat-icon[matBadge] ::ng-deep .mat-badge-content{font-size:12px}:host .layerCheck{align-self:baseline;width:16px;padding-right:0}\n"] }]
        }], ctorParameters: function () { return [{ type: i2.NetworkService }, { type: i0.Renderer2 }, { type: i0.ElementRef }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { activeLayer: [{
                type: Input
            }], selectAll: [{
                type: Input
            }], layerCheck: [{
                type: Input
            }], layer: [{
                type: Input
            }], toggleLegendOnVisibilityChange: [{
                type: Input
            }], expandLegendIfVisible: [{
                type: Input
            }], updateLegendOnResolutionChange: [{
                type: Input
            }], orderable: [{
                type: Input
            }], lowerDisabled: [{
                type: Input
            }], raiseDisabled: [{
                type: Input
            }], queryBadge: [{
                type: Input
            }], selectionMode: [{
                type: Input
            }], changeDetection: [{
                type: Input
            }], action: [{
                type: Output
            }], checkbox: [{
                type: Output
            }] } });

class LayerLegendItemComponent {
    networkService;
    inResolutionRange$ = new BehaviorSubject(true);
    tooltipText;
    state;
    resolution$$;
    network$$;
    layer;
    updateLegendOnResolutionChange = false;
    constructor(networkService) {
        this.networkService = networkService;
    }
    ngOnInit() {
        const resolution$ = this.layer.map.viewController.resolution$;
        this.resolution$$ = resolution$.subscribe(() => {
            this.onResolutionChange();
        });
        this.tooltipText = this.computeTooltip();
        this.network$$ = this.networkService
            .currentState()
            .subscribe((state) => {
            this.state = state;
            this.onResolutionChange();
        });
    }
    ngOnDestroy() {
        this.resolution$$.unsubscribe();
        this.network$$.unsubscribe();
    }
    computeTooltip() {
        const layerOptions = this.layer.options;
        if (!layerOptions.tooltip) {
            return this.layer.title;
        }
        const layerTooltip = layerOptions.tooltip;
        const layerMetadata = layerOptions.metadata;
        switch (layerOptions.tooltip.type) {
            case TooltipType.TITLE:
                return this.layer.title;
            case TooltipType.ABSTRACT:
                if (layerMetadata && layerMetadata.abstract) {
                    return layerMetadata.abstract;
                }
                else {
                    return this.layer.title;
                }
            case TooltipType.CUSTOM:
                if (layerTooltip && layerTooltip.text) {
                    return layerTooltip.text;
                }
                else {
                    return this.layer.title;
                }
            default:
                return this.layer.title;
        }
    }
    onResolutionChange() {
        const inResolutionRange = this.layer.isInResolutionsRange;
        this.inResolutionRange$.next(inResolutionRange);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LayerLegendItemComponent, deps: [{ token: i2.NetworkService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: LayerLegendItemComponent, selector: "igo-layer-legend-item", inputs: { layer: "layer", updateLegendOnResolutionChange: "updateLegendOnResolutionChange" }, ngImport: i0, template: "<mat-list-item class=\"igo-layer-list-item\">\n  <span\n    matListItemTitle\n    class=\"igo-layer-title\"\n    [matTooltip]=\"tooltipText\"\n    matTooltipShowDelay=\"500\"\n    >{{ layer.title }}</span\n  >\n</mat-list-item>\n\n<div #legend class=\"igo-layer-legend-container\">\n  <igo-layer-legend\n    [layer]=\"layer\"\n    [updateLegendOnResolutionChange]=\"updateLegendOnResolutionChange\"\n  >\n  </igo-layer-legend>\n</div>\n", styles: [":host{overflow:hidden}:host .igo-layer-list-item{height:48px;clear:both}:host .igo-layer-legend-container{padding-left:18px;width:calc(100% - 18px)}\n"], dependencies: [{ kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "component", type: i5.MatListItem, selector: "mat-list-item, a[mat-list-item], button[mat-list-item]", inputs: ["activated"], exportAs: ["matListItem"] }, { kind: "directive", type: i5.MatListItemTitle, selector: "[matListItemTitle]" }, { kind: "component", type: LayerLegendComponent, selector: "igo-layer-legend", inputs: ["updateLegendOnResolutionChange", "layer"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LayerLegendItemComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-layer-legend-item', changeDetection: ChangeDetectionStrategy.OnPush, template: "<mat-list-item class=\"igo-layer-list-item\">\n  <span\n    matListItemTitle\n    class=\"igo-layer-title\"\n    [matTooltip]=\"tooltipText\"\n    matTooltipShowDelay=\"500\"\n    >{{ layer.title }}</span\n  >\n</mat-list-item>\n\n<div #legend class=\"igo-layer-legend-container\">\n  <igo-layer-legend\n    [layer]=\"layer\"\n    [updateLegendOnResolutionChange]=\"updateLegendOnResolutionChange\"\n  >\n  </igo-layer-legend>\n</div>\n", styles: [":host{overflow:hidden}:host .igo-layer-list-item{height:48px;clear:both}:host .igo-layer-legend-container{padding-left:18px;width:calc(100% - 18px)}\n"] }]
        }], ctorParameters: function () { return [{ type: i2.NetworkService }]; }, propDecorators: { layer: [{
                type: Input
            }], updateLegendOnResolutionChange: [{
                type: Input
            }] } });

class LayerLegendListComponent {
    orderable = true;
    hasVisibleOrInRangeLayers$ = new BehaviorSubject(true);
    hasVisibleAndNotInRangeLayers$ = new BehaviorSubject(true);
    layersInUi$ = new BehaviorSubject([]);
    layers$ = new BehaviorSubject([]);
    showAllLegend = false;
    change$ = new ReplaySubject(1);
    change$$;
    set layers(value) {
        this._layers = value;
        this.next();
    }
    get layers() {
        return this._layers;
    }
    _layers;
    excludeBaseLayers = false;
    updateLegendOnResolutionChange = false;
    allowShowAllLegends = false;
    showAllLegendsValue = false;
    allLegendsShown = new EventEmitter(false);
    constructor() { }
    ngOnInit() {
        this.change$$ = this.change$
            .pipe(debounce(() => {
            return this.layers.length === 0 ? EMPTY : timer(50);
        }))
            .subscribe(() => {
            const layers = this.computeShownLayers(this.layers.slice(0));
            this.layers$.next(layers);
            this.hasVisibleOrInRangeLayers$.next(this.layers
                .slice(0)
                .filter((layer) => layer.baseLayer !== true)
                .filter((layer) => layer.visible$.value && layer.isInResolutionsRange$.value).length > 0);
            this.hasVisibleAndNotInRangeLayers$.next(this.layers
                .slice(0)
                .filter((layer) => layer.baseLayer !== true)
                .filter((layer) => layer.visible$.value && !layer.isInResolutionsRange$.value).length > 0);
            this.layersInUi$.next(this.layers
                .slice(0)
                .filter((layer) => layer.showInLayerList !== false &&
                (!this.excludeBaseLayers || !layer.baseLayer)));
        });
    }
    ngOnDestroy() {
        this.change$$.unsubscribe();
    }
    next() {
        this.change$.next();
    }
    computeShownLayers(layers) {
        let shownLayers = layers.filter((layer) => layer.visible && layer.isInResolutionsRange);
        if (this.showAllLegendsValue) {
            shownLayers = layers;
        }
        return this.sortLayersByZindex(shownLayers);
    }
    sortLayersByZindex(layers) {
        return layers.sort((layer1, layer2) => layer2.zIndex - layer1.zIndex);
    }
    toggleShowAllLegends(toggle) {
        this.showAllLegendsValue = toggle;
        this.next();
        this.allLegendsShown.emit(toggle);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LayerLegendListComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: LayerLegendListComponent, selector: "igo-layer-legend-list", inputs: { layers: "layers", excludeBaseLayers: "excludeBaseLayers", updateLegendOnResolutionChange: "updateLegendOnResolutionChange", allowShowAllLegends: "allowShowAllLegends", showAllLegendsValue: "showAllLegendsValue" }, outputs: { allLegendsShown: "allLegendsShown" }, ngImport: i0, template: "<div class=\"layer-legend-list-container\">\n  <mat-slide-toggle\n    tooltip-position=\"above\"\n    matTooltipShowDelay=\"500\"\n    [matTooltip]=\"'igo.geo.layer.legend.showAll' | translate\"\n    [checked]=\"showAllLegendsValue\"\n    class=\"mat-typography\"\n    *ngIf=\"(layersInUi$ | async).length && allowShowAllLegends\"\n    [labelPosition]=\"'before'\"\n    (change)=\"toggleShowAllLegends($event.checked)\"\n  >\n    {{ 'igo.geo.layer.legend.showAll' | translate }}\n  </mat-slide-toggle>\n  <mat-divider\n    *ngIf=\"(layersInUi$ | async).length && allowShowAllLegends\"\n  ></mat-divider>\n  <igo-list [navigation]=\"false\" [selection]=\"false\">\n    <ng-template ngFor let-layer let-i=\"index\" [ngForOf]=\"layers$ | async\">\n      <igo-layer-legend-item\n        *ngIf=\"!(excludeBaseLayers && layer.baseLayer)\"\n        igoListItem\n        [layer]=\"layer\"\n        [updateLegendOnResolutionChange]=\"updateLegendOnResolutionChange\"\n      >\n      </igo-layer-legend-item>\n    </ng-template>\n  </igo-list>\n  <p\n    class=\"layers-empty mat-typography\"\n    *ngIf=\"\n      !showAllLegendsValue &&\n      (layersInUi$ | async).length &&\n      (hasVisibleOrInRangeLayers$ | async) === false &&\n      (hasVisibleAndNotInRangeLayers$ | async) === false &&\n      allowShowAllLegends\n    \"\n  >\n    {{ 'igo.geo.layer.legend.noLayersVisibleWithShowAllButton' | translate }}\n  </p>\n  <p\n    class=\"layers-empty mat-typography\"\n    *ngIf=\"\n      !showAllLegendsValue &&\n      (layersInUi$ | async).length &&\n      (hasVisibleOrInRangeLayers$ | async) === false &&\n      (hasVisibleAndNotInRangeLayers$ | async) &&\n      allowShowAllLegends\n    \"\n  >\n    {{\n      'igo.geo.layer.legend.noLayersVisibleWithShowAllButtonButZoom' | translate\n    }}\n  </p>\n  <p\n    class=\"layers-empty mat-typography\"\n    *ngIf=\"\n      (layersInUi$ | async).length &&\n      (hasVisibleOrInRangeLayers$ | async) === false &&\n      (hasVisibleAndNotInRangeLayers$ | async) === false &&\n      !allowShowAllLegends\n    \"\n  >\n    {{ 'igo.geo.layer.legend.noLayersVisible' | translate }}\n  </p>\n  <p\n    class=\"layers-empty mat-typography\"\n    *ngIf=\"\n      (layersInUi$ | async).length &&\n      (hasVisibleOrInRangeLayers$ | async) === false &&\n      (hasVisibleAndNotInRangeLayers$ | async) &&\n      !allowShowAllLegends\n    \"\n  >\n    {{ 'igo.geo.layer.legend.noLayersVisibleButZoom' | translate }}\n  </p>\n</div>\n", styles: [":host mat-slide-toggle{width:100%;padding:10px}:host mat-slide-toggle ::ng-deep .mdc-form-field{width:100%}:host mat-slide-toggle ::ng-deep .mdc-label{margin-left:0;width:calc(100% - 60px)}:host igo-list{display:contents}:host .layers-empty{text-align:justify;margin:10px}:host .layer-legend-list-container{max-height:100%;overflow:auto}\n"], dependencies: [{ kind: "directive", type: i2$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i9$2.MatDivider, selector: "mat-divider", inputs: ["vertical", "inset"] }, { kind: "component", type: i7.MatSlideToggle, selector: "mat-slide-toggle", inputs: ["disabled", "disableRipple", "color", "tabIndex"], exportAs: ["matSlideToggle"] }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "directive", type: i9$1.ListItemDirective, selector: "[igoListItem]", inputs: ["color", "focused", "selected", "disabled"], outputs: ["beforeSelect", "beforeFocus", "beforeUnselect", "beforeUnfocus", "beforeDisable", "beforeEnable", "focus", "unfocus", "select", "unselect", "disable", "enable"] }, { kind: "component", type: i9$1.ListComponent, selector: "igo-list", inputs: ["navigation", "selection"] }, { kind: "component", type: LayerLegendItemComponent, selector: "igo-layer-legend-item", inputs: ["layer", "updateLegendOnResolutionChange"] }, { kind: "pipe", type: i2$2.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LayerLegendListComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-layer-legend-list', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div class=\"layer-legend-list-container\">\n  <mat-slide-toggle\n    tooltip-position=\"above\"\n    matTooltipShowDelay=\"500\"\n    [matTooltip]=\"'igo.geo.layer.legend.showAll' | translate\"\n    [checked]=\"showAllLegendsValue\"\n    class=\"mat-typography\"\n    *ngIf=\"(layersInUi$ | async).length && allowShowAllLegends\"\n    [labelPosition]=\"'before'\"\n    (change)=\"toggleShowAllLegends($event.checked)\"\n  >\n    {{ 'igo.geo.layer.legend.showAll' | translate }}\n  </mat-slide-toggle>\n  <mat-divider\n    *ngIf=\"(layersInUi$ | async).length && allowShowAllLegends\"\n  ></mat-divider>\n  <igo-list [navigation]=\"false\" [selection]=\"false\">\n    <ng-template ngFor let-layer let-i=\"index\" [ngForOf]=\"layers$ | async\">\n      <igo-layer-legend-item\n        *ngIf=\"!(excludeBaseLayers && layer.baseLayer)\"\n        igoListItem\n        [layer]=\"layer\"\n        [updateLegendOnResolutionChange]=\"updateLegendOnResolutionChange\"\n      >\n      </igo-layer-legend-item>\n    </ng-template>\n  </igo-list>\n  <p\n    class=\"layers-empty mat-typography\"\n    *ngIf=\"\n      !showAllLegendsValue &&\n      (layersInUi$ | async).length &&\n      (hasVisibleOrInRangeLayers$ | async) === false &&\n      (hasVisibleAndNotInRangeLayers$ | async) === false &&\n      allowShowAllLegends\n    \"\n  >\n    {{ 'igo.geo.layer.legend.noLayersVisibleWithShowAllButton' | translate }}\n  </p>\n  <p\n    class=\"layers-empty mat-typography\"\n    *ngIf=\"\n      !showAllLegendsValue &&\n      (layersInUi$ | async).length &&\n      (hasVisibleOrInRangeLayers$ | async) === false &&\n      (hasVisibleAndNotInRangeLayers$ | async) &&\n      allowShowAllLegends\n    \"\n  >\n    {{\n      'igo.geo.layer.legend.noLayersVisibleWithShowAllButtonButZoom' | translate\n    }}\n  </p>\n  <p\n    class=\"layers-empty mat-typography\"\n    *ngIf=\"\n      (layersInUi$ | async).length &&\n      (hasVisibleOrInRangeLayers$ | async) === false &&\n      (hasVisibleAndNotInRangeLayers$ | async) === false &&\n      !allowShowAllLegends\n    \"\n  >\n    {{ 'igo.geo.layer.legend.noLayersVisible' | translate }}\n  </p>\n  <p\n    class=\"layers-empty mat-typography\"\n    *ngIf=\"\n      (layersInUi$ | async).length &&\n      (hasVisibleOrInRangeLayers$ | async) === false &&\n      (hasVisibleAndNotInRangeLayers$ | async) &&\n      !allowShowAllLegends\n    \"\n  >\n    {{ 'igo.geo.layer.legend.noLayersVisibleButZoom' | translate }}\n  </p>\n</div>\n", styles: [":host mat-slide-toggle{width:100%;padding:10px}:host mat-slide-toggle ::ng-deep .mdc-form-field{width:100%}:host mat-slide-toggle ::ng-deep .mdc-label{margin-left:0;width:calc(100% - 60px)}:host igo-list{display:contents}:host .layers-empty{text-align:justify;margin:10px}:host .layer-legend-list-container{max-height:100%;overflow:auto}\n"] }]
        }], ctorParameters: function () { return []; }, propDecorators: { layers: [{
                type: Input
            }], excludeBaseLayers: [{
                type: Input
            }], updateLegendOnResolutionChange: [{
                type: Input
            }], allowShowAllLegends: [{
                type: Input
            }], showAllLegendsValue: [{
                type: Input
            }], allLegendsShown: [{
                type: Output
            }] } });

class LayerLegendListBindingDirective {
    mapService;
    component;
    layersOrResolutionChange$$;
    layersVisibility$$;
    constructor(component, mapService) {
        this.mapService = mapService;
        this.component = component;
    }
    ngOnInit() {
        // Override input layers
        this.component.layers = [];
        this.layersOrResolutionChange$$ = combineLatest([
            this.mapService.getMap().layers$,
            this.mapService.getMap().viewController.resolution$
        ])
            .pipe(debounceTime(10))
            .subscribe((bunch) => {
            const shownLayers = bunch[0].filter((layer) => {
                return layer.showInLayerList === true;
            });
            this.component.layers = shownLayers;
            this.layersVisibility$$ = combineLatest(shownLayers.map((layer) => layer.visible$)).subscribe((r) => {
                this.component.change$.next();
            });
        });
    }
    ngOnDestroy() {
        this.layersOrResolutionChange$$.unsubscribe();
        if (this.layersVisibility$$ !== undefined) {
            this.layersVisibility$$.unsubscribe();
            this.layersVisibility$$ = undefined;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LayerLegendListBindingDirective, deps: [{ token: LayerLegendListComponent, self: true }, { token: MapService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: LayerLegendListBindingDirective, selector: "[igoLayerLegendListBinding]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LayerLegendListBindingDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igoLayerLegendListBinding]'
                }]
        }], ctorParameters: function () { return [{ type: LayerLegendListComponent, decorators: [{
                    type: Self
                }] }, { type: MapService }]; } });

class LayerListToolComponent {
    onlyVisible$ = new BehaviorSubject(false);
    sortAlpha$ = new BehaviorSubject(false);
    term$ = new BehaviorSubject(undefined);
    onlyVisible$$;
    sortAlpha$$;
    term$$;
    layersAreAllVisible = true;
    floatLabel = 'auto';
    set onlyVisible(value) {
        this.onlyVisible$.next(value);
    }
    get onlyVisible() {
        return this.onlyVisible$.value;
    }
    set sortAlpha(value) {
        this.sortAlpha$.next(value);
    }
    get sortAlpha() {
        return this.sortAlpha$.value;
    }
    set term(value) {
        this.term$.next(value);
    }
    get term() {
        return this.term$.value;
    }
    selectionMode = false;
    appliedFilterAndSort = new EventEmitter();
    selection = new EventEmitter();
    ngOnInit() {
        this.term$$ = this.term$.subscribe((keyword) => {
            this.appliedFilterAndSort.emit({
                keyword,
                onlyVisible: this.onlyVisible,
                sortAlpha: this.sortAlpha
            });
        });
        this.onlyVisible$$ = this.onlyVisible$.subscribe((onlyVisible) => {
            this.appliedFilterAndSort.emit({
                keyword: this.term,
                onlyVisible,
                sortAlpha: this.sortAlpha
            });
        });
        this.sortAlpha$$ = this.sortAlpha$.subscribe((sortAlpha) => {
            this.appliedFilterAndSort.emit({
                keyword: this.term,
                onlyVisible: this.onlyVisible,
                sortAlpha
            });
        });
    }
    ngOnDestroy() {
        this.onlyVisible$$.unsubscribe();
        this.sortAlpha$$.unsubscribe();
        this.term$$.unsubscribe();
    }
    clearTerm() {
        this.term = undefined;
    }
    toggleSortAlpha() {
        this.sortAlpha = !this.sortAlpha;
    }
    toggleOnlyVisible() {
        this.onlyVisible = !this.onlyVisible;
    }
    toggleSelectionMode() {
        this.selectionMode = !this.selectionMode;
        this.selection.emit(this.selectionMode);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LayerListToolComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: LayerListToolComponent, selector: "igo-layer-list-tool", inputs: { layersAreAllVisible: "layersAreAllVisible", floatLabel: "floatLabel", onlyVisible: "onlyVisible", sortAlpha: "sortAlpha", term: "term" }, outputs: { appliedFilterAndSort: "appliedFilterAndSort", selection: "selection" }, ngImport: i0, template: "<mat-form-field class=\"inputFilter\" [floatLabel]=\"floatLabel\">\n  <input\n    matInput\n    [placeholder]=\"'igo.geo.layer.filterPlaceholder' | translate\"\n    [matTooltip]=\"'igo.geo.layer.subsetLayersListKeyword' | translate\"\n    matTooltipShowDelay=\"500\"\n    type=\"text\"\n    [(ngModel)]=\"term\"\n  />\n  <button\n    *ngIf=\"term\"\n    matSuffix\n    mat-icon-button\n    aria-label=\"Clear\"\n    color=\"warn\"\n    (click)=\"clearTerm()\"\n  >\n    <mat-icon svgIcon=\"close\"></mat-icon>\n  </button>\n</mat-form-field>\n\n<div class=\"actions-container\">\n  <button\n    class=\"sort-alpha\"\n    [color]=\"sortAlpha ? 'warn' : 'primary'\"\n    mat-icon-button\n    [matTooltip]=\"\n      sortAlpha\n        ? ('igo.geo.layer.sortMapOrder' | translate)\n        : ('igo.geo.layer.sortAlphabetically' | translate)\n    \"\n    matTooltipShowDelay=\"500\"\n    (click)=\"toggleSortAlpha()\"\n  >\n    <mat-icon\n      [svgIcon]=\"sortAlpha ? 'sort-ascending' : 'sort-alphabetical-ascending'\"\n    ></mat-icon>\n  </button>\n\n  <button\n    class=\"only-visible\"\n    mat-icon-button\n    [disabled]=\"layersAreAllVisible && !onlyVisible\"\n    [color]=\"onlyVisible ? 'warn' : 'primary'\"\n    [matTooltip]=\"\n      onlyVisible\n        ? ('igo.geo.layer.resetLayersList' | translate)\n        : ('igo.geo.layer.subsetLayersListOnlyVisible' | translate)\n    \"\n    matTooltipShowDelay=\"500\"\n    (click)=\"toggleOnlyVisible()\"\n  >\n    <mat-icon\n      aria-hidden=\"false\"\n      matBadge=\"icon\"\n      igoMatBadgeIcon=\"eye\"\n      igoMatBadgeInverseColor=\"true\"\n      igoMatBadgeInheritColor=\"true\"\n      [svgIcon]=\"onlyVisible ? 'filter-remove' : 'filter'\"\n    >\n    </mat-icon>\n  </button>\n\n  <button\n    class=\"selection-mode\"\n    mat-icon-button\n    color=\"primary\"\n    [matTooltip]=\"\n      selectionMode\n        ? ('igo.geo.layer.deactivateSelectionMode' | translate)\n        : ('igo.geo.layer.activateSelectionMode' | translate)\n    \"\n    matTooltipShowDelay=\"500\"\n    (click)=\"toggleSelectionMode()\"\n  >\n    <mat-icon\n      [svgIcon]=\"\n        selectionMode\n          ? 'checkbox-multiple-marked-outline'\n          : 'checkbox-multiple-blank-outline'\n      \"\n    ></mat-icon>\n  </button>\n</div>\n", styles: [":host{display:flex;align-items:center;justify-content:space-between;padding:8px 12px}:host .inputFilter{width:calc(100% - 100px);max-width:200px}@media only screen and (orientation:portrait) and (max-width: 599px),only screen and (orientation:landscape) and (max-width: 959px){:host .inputFilter{width:50%}}:host ::ng-deep mat-form-field .mat-mdc-form-field-subscript-wrapper{display:none}\n"], dependencies: [{ kind: "directive", type: i9$3.MatInput, selector: "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", inputs: ["disabled", "id", "placeholder", "name", "required", "type", "errorStateMatcher", "aria-describedby", "value", "readonly"], exportAs: ["matInput"] }, { kind: "component", type: i8.MatFormField, selector: "mat-form-field", inputs: ["hideRequiredMarker", "color", "floatLabel", "appearance", "subscriptSizing", "hintLabel"], exportAs: ["matFormField"] }, { kind: "directive", type: i8.MatSuffix, selector: "[matSuffix], [matIconSuffix], [matTextSuffix]", inputs: ["matTextSuffix"] }, { kind: "directive", type: i2$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2$1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "directive", type: i6.MatBadge, selector: "[matBadge]", inputs: ["matBadgeDisabled", "matBadgeColor", "matBadgeOverlap", "matBadgePosition", "matBadge", "matBadgeDescription", "matBadgeSize", "matBadgeHidden"] }, { kind: "directive", type: i9$1.IgoBadgeIconDirective, selector: "[igoMatBadgeIcon]", inputs: ["igoMatBadgeIcon", "matBadgeHidden", "matBadgeDisabled", "igoMatBadgeInverseColor", "igoMatBadgeInheritColor", "igoMatBadgeColor", "igoMatBadgeBackgroundColor"] }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LayerListToolComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-layer-list-tool', changeDetection: ChangeDetectionStrategy.OnPush, template: "<mat-form-field class=\"inputFilter\" [floatLabel]=\"floatLabel\">\n  <input\n    matInput\n    [placeholder]=\"'igo.geo.layer.filterPlaceholder' | translate\"\n    [matTooltip]=\"'igo.geo.layer.subsetLayersListKeyword' | translate\"\n    matTooltipShowDelay=\"500\"\n    type=\"text\"\n    [(ngModel)]=\"term\"\n  />\n  <button\n    *ngIf=\"term\"\n    matSuffix\n    mat-icon-button\n    aria-label=\"Clear\"\n    color=\"warn\"\n    (click)=\"clearTerm()\"\n  >\n    <mat-icon svgIcon=\"close\"></mat-icon>\n  </button>\n</mat-form-field>\n\n<div class=\"actions-container\">\n  <button\n    class=\"sort-alpha\"\n    [color]=\"sortAlpha ? 'warn' : 'primary'\"\n    mat-icon-button\n    [matTooltip]=\"\n      sortAlpha\n        ? ('igo.geo.layer.sortMapOrder' | translate)\n        : ('igo.geo.layer.sortAlphabetically' | translate)\n    \"\n    matTooltipShowDelay=\"500\"\n    (click)=\"toggleSortAlpha()\"\n  >\n    <mat-icon\n      [svgIcon]=\"sortAlpha ? 'sort-ascending' : 'sort-alphabetical-ascending'\"\n    ></mat-icon>\n  </button>\n\n  <button\n    class=\"only-visible\"\n    mat-icon-button\n    [disabled]=\"layersAreAllVisible && !onlyVisible\"\n    [color]=\"onlyVisible ? 'warn' : 'primary'\"\n    [matTooltip]=\"\n      onlyVisible\n        ? ('igo.geo.layer.resetLayersList' | translate)\n        : ('igo.geo.layer.subsetLayersListOnlyVisible' | translate)\n    \"\n    matTooltipShowDelay=\"500\"\n    (click)=\"toggleOnlyVisible()\"\n  >\n    <mat-icon\n      aria-hidden=\"false\"\n      matBadge=\"icon\"\n      igoMatBadgeIcon=\"eye\"\n      igoMatBadgeInverseColor=\"true\"\n      igoMatBadgeInheritColor=\"true\"\n      [svgIcon]=\"onlyVisible ? 'filter-remove' : 'filter'\"\n    >\n    </mat-icon>\n  </button>\n\n  <button\n    class=\"selection-mode\"\n    mat-icon-button\n    color=\"primary\"\n    [matTooltip]=\"\n      selectionMode\n        ? ('igo.geo.layer.deactivateSelectionMode' | translate)\n        : ('igo.geo.layer.activateSelectionMode' | translate)\n    \"\n    matTooltipShowDelay=\"500\"\n    (click)=\"toggleSelectionMode()\"\n  >\n    <mat-icon\n      [svgIcon]=\"\n        selectionMode\n          ? 'checkbox-multiple-marked-outline'\n          : 'checkbox-multiple-blank-outline'\n      \"\n    ></mat-icon>\n  </button>\n</div>\n", styles: [":host{display:flex;align-items:center;justify-content:space-between;padding:8px 12px}:host .inputFilter{width:calc(100% - 100px);max-width:200px}@media only screen and (orientation:portrait) and (max-width: 599px),only screen and (orientation:landscape) and (max-width: 959px){:host .inputFilter{width:50%}}:host ::ng-deep mat-form-field .mat-mdc-form-field-subscript-wrapper{display:none}\n"] }]
        }], propDecorators: { layersAreAllVisible: [{
                type: Input
            }], floatLabel: [{
                type: Input
            }], onlyVisible: [{
                type: Input
            }], sortAlpha: [{
                type: Input
            }], term: [{
                type: Input
            }], appliedFilterAndSort: [{
                type: Output
            }], selection: [{
                type: Output
            }] } });

class LayerListToolService {
    keyword;
    sortAlpha = false;
    onlyVisible = false;
    onlyInRange = false;
    keywordInitialized = false;
    sortedAlphaInitialized = false;
    onlyVisibleInitialized = false;
    onlyInRangeInitialized = false;
    constructor() { }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LayerListToolService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LayerListToolService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LayerListToolService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return []; } });

class ImageWatcher extends Watcher {
    id;
    loaded = 0;
    loading = 0;
    source;
    messageService;
    constructor(layer, messageService) {
        super();
        this.source = layer.options.source.ol;
        this.id = uuid();
        this.messageService = messageService;
    }
    watch() {
        this.source.on(`imageloadstart`, (e) => this.handleLoadStart(e));
        this.source.on(`imageloadend`, (e) => this.handleLoadEnd(e));
        this.source.on(`imageloaderror`, (e) => this.handleLoadEnd(e));
        this.source.on(`imageloaderror`, (e) => this.handleLoadError(e));
    }
    unwatch() {
        this.source.un(`imageloadstart`, (e) => this.handleLoadStart(e));
        this.source.un(`imageloadend`, (e) => this.handleLoadEnd(e));
        this.source.un(`imageloaderror`, (e) => this.handleLoadEnd(e));
        this.source.un(`imageloaderror`, (e) => this.handleLoadError(e));
    }
    handleLoadStart(event) {
        if (!event.image.__watchers__) {
            event.image.__watchers__ = [];
        }
        event.image.__watchers__.push(this.id);
        this.loading += 1;
        this.status = SubjectStatus.Working;
    }
    handleLoadEnd(event) {
        if (!event.image.__watchers__) {
            return;
        }
        const watcherIndex = event.image.__watchers__.indexOf(this.id);
        if (watcherIndex < 0) {
            return;
        }
        event.image.__watchers__.splice(watcherIndex, 1);
        this.loaded += 1;
        const loading = this.loading;
        if (this.loaded >= loading) {
            if (loading === this.loading) {
                this.status = SubjectStatus.Done;
                this.loaded = this.loading = 0;
            }
        }
    }
    handleLoadError(event) {
        if (!event.image.__watchers__) {
            return;
        }
        this.messageService.error('igo.geo.dataSource.unavailable', 'igo.geo.dataSource.unavailableTitle', undefined, { value: event.target.params_.LAYERS });
        this.loaded = -1;
        this.loading = 0;
        this.status = SubjectStatus.Error;
    }
}

class ImageLayer extends Layer {
    messageService;
    authInterceptor;
    watcher;
    constructor(options, messageService, authInterceptor) {
        super(options, messageService, authInterceptor);
        this.messageService = messageService;
        this.authInterceptor = authInterceptor;
        this.watcher = new ImageWatcher(this, this.messageService);
        this.status$ = this.watcher.status$;
        this.status$.subscribe((valStatus) => {
            if (valStatus === 0) {
                this.olLoadingProblem = true;
            }
        });
    }
    createOlLayer() {
        const olOptions = Object.assign({}, this.options, {
            source: this.options.source.ol
        });
        const image = new olLayerImage(olOptions);
        if (this.authInterceptor) {
            image.getSource().setImageLoadFunction((tile, src) => {
                this.customLoader(tile, src, this.authInterceptor, this.messageService);
            });
        }
        return image;
    }
    setMap(map) {
        if (map === undefined) {
            this.watcher.unsubscribe();
        }
        else {
            this.watcher.subscribe(() => { });
        }
        super.setMap(map);
    }
    customLoader(tile, src, interceptor, messageService) {
        const xhr = new XMLHttpRequest();
        const alteredUrlWithKeyAuth = interceptor.alterUrlWithKeyAuth(src);
        let url = src;
        if (alteredUrlWithKeyAuth) {
            url = alteredUrlWithKeyAuth;
        }
        xhr.open('GET', url);
        const intercepted = interceptor.interceptXhr(xhr, url);
        if (!intercepted) {
            xhr.abort();
            tile.getImage().src = url;
            return;
        }
        xhr.responseType = 'arraybuffer';
        xhr.onload = function () {
            const arrayBufferView = new Uint8Array(this.response);
            const responseString = new TextDecoder().decode(arrayBufferView);
            if (responseString.includes('ServiceExceptionReport')) {
                messageService.error('igo.geo.dataSource.optionsApiUnavailable', 'igo.geo.dataSource.unavailableTitle');
            }
            const blob = new Blob([arrayBufferView], { type: 'image/png' });
            const urlCreator = window.URL;
            const imageUrl = urlCreator.createObjectURL(blob);
            tile.getImage().src = imageUrl;
        };
        xhr.send();
    }
}

class TileWatcher extends Watcher {
    id;
    loaded = 0;
    loading = 0;
    source;
    constructor(layer) {
        super();
        this.source = layer.options.source.ol;
        this.id = uuid();
    }
    watch() {
        this.source.on(`tileloadstart`, (e) => this.handleLoadStart(e));
        this.source.on(`tileloadend`, (e) => this.handleLoadEnd(e));
        this.source.on(`tileloaderror`, (e) => this.handleLoadEnd(e));
    }
    unwatch() {
        this.source.un(`tileloadstart`, (e) => this.handleLoadStart(e));
        this.source.un(`tileloadend`, (e) => this.handleLoadEnd(e));
        this.source.un(`tileloaderror`, (e) => this.handleLoadEnd(e));
    }
    handleLoadStart(event) {
        // This is to avoid increasing
        // the number of loaded tiles if a tile was loading
        // before subscribing to this watcher
        if (!event.tile.__watchers__) {
            event.tile.__watchers__ = [];
        }
        event.tile.__watchers__.push(this.id);
        this.loading += 1;
        this.status = SubjectStatus.Working;
    }
    handleLoadEnd(event) {
        if (!event.tile.__watchers__) {
            return;
        }
        const watcherIndex = event.tile.__watchers__.indexOf(this.id);
        if (watcherIndex < 0) {
            return;
        }
        event.tile.__watchers__.splice(watcherIndex, 1);
        this.loaded += 1;
        const loading = this.loading;
        if (this.loaded >= loading) {
            if (loading === this.loading) {
                this.status = SubjectStatus.Done;
                this.loaded = this.loading = 0;
            }
        }
    }
}

class TileLayer extends Layer {
    messageService;
    authInterceptor;
    watcher;
    constructor(options, messageService, authInterceptor) {
        super(options, messageService);
        this.messageService = messageService;
        this.authInterceptor = authInterceptor;
        this.watcher = new TileWatcher(this);
        this.status$ = this.watcher.status$;
    }
    createOlLayer() {
        const olOptions = Object.assign({}, this.options, {
            source: this.options.source.ol
        });
        const tileLayer = new olLayerTile(olOptions);
        const tileSource = tileLayer.getSource();
        tileSource.setTileLoadFunction((tile, url) => {
            this.customLoader(tile, url, this.authInterceptor);
        });
        return tileLayer;
    }
    /**
     * Custom loader for tile layer.
     * @internal
     * @param tile the current tile
     * @param url the url string or function to retrieve the data
     */
    customLoader(tile, url, interceptor) {
        const alteredUrlWithKeyAuth = interceptor.alterUrlWithKeyAuth(url);
        let modifiedUrl = url;
        if (alteredUrlWithKeyAuth) {
            modifiedUrl = alteredUrlWithKeyAuth;
        }
        tile.getImage().src = modifiedUrl;
    }
    setMap(map) {
        if (map === undefined) {
            this.watcher.unsubscribe();
        }
        else {
            this.watcher.subscribe(() => { });
        }
        super.setMap(map);
    }
}

class FeatureDataSource extends DataSource {
    createOlSource() {
        const sourceOptions = {
            format: this.getSourceFormatFromOptions(this.options)
        };
        return new OlVectorSource(Object.assign(sourceOptions, this.options));
    }
    getSourceFormatFromOptions(options) {
        if (options.format) {
            return options.format;
        }
        let olFormatCls;
        const formatType = options.formatType;
        if (!formatType) {
            olFormatCls = olformat.GeoJSON;
        }
        else {
            olFormatCls = olformat[formatType];
            if (olFormatCls === undefined) {
                throw new Error('Invalid vector source format ${formatType}.');
            }
        }
        const formatOptions = options.formatOptions;
        let format;
        if (formatOptions) {
            format = new olFormatCls(formatOptions);
        }
        else {
            format = new olFormatCls();
        }
        return format;
    }
    onUnwatch() { }
    get queryTitle() {
        return this.options.queryTitle
            ? this.options.queryTitle
            : 'title';
    }
}

const FEATURE = 'Feature';
var FeatureMotion;
(function (FeatureMotion) {
    FeatureMotion[FeatureMotion["None"] = 0] = "None";
    FeatureMotion[FeatureMotion["Move"] = 1] = "Move";
    FeatureMotion[FeatureMotion["Zoom"] = 2] = "Zoom";
    FeatureMotion[FeatureMotion["Default"] = 3] = "Default";
})(FeatureMotion || (FeatureMotion = {}));

/**
 * Create an Openlayers feature object out of a feature definition.
 * The output object has a reference to the feature id.
 * @param feature Feature definition
 * @param projectionOut Feature object projection
 * @returns OpenLayers feature object
 */
function featureToOl(feature, projectionOut, getId) {
    getId = getId ? getId : getEntityId;
    const olFormat = new OlGeoJSON();
    const olFeature = olFormat.readFeature(feature, {
        dataProjection: feature.projection,
        featureProjection: projectionOut
    });
    olFeature.setId(getId(feature));
    const title = getEntityTitle(feature);
    if (title !== undefined) {
        olFeature.set('_title', title, true);
    }
    if (feature.extent !== undefined) {
        olFeature.set('_extent', feature.extent, true);
    }
    if (feature.projection !== undefined) {
        olFeature.set('_projection', feature.projection, true);
    }
    const mapTitle = getEntityProperty(feature, 'meta.mapTitle');
    if (mapTitle !== undefined) {
        olFeature.set('_mapTitle', mapTitle, true);
    }
    olFeature.set('_entityRevision', getEntityRevision(feature), true);
    const icon = getEntityIcon(feature);
    if (icon !== undefined) {
        olFeature.set('_icon', icon, true);
    }
    if (feature.meta && feature.meta.style) {
        olFeature.set('_style', feature.meta.style, true);
    }
    if (feature.sourceId) {
        olFeature.set('_sourceId', feature.sourceId, true);
    }
    return olFeature;
}
function renderFeatureFromOl(olRenderFeature, projectionIn, olLayer, projectionOut = 'EPSG:4326') {
    let geom;
    let title;
    let exclude;
    let excludeOffline;
    if (olLayer) {
        title = olLayer.get('title');
        if (olLayer.get('sourceOptions')) {
            exclude = olLayer.get('sourceOptions').excludeAttribute;
            excludeOffline = olLayer.get('sourceOptions').excludeAttributeOffline;
        }
    }
    else {
        title = olRenderFeature.get('_title');
    }
    const olFormat = new OlGeoJSON();
    const properties = olRenderFeature.getProperties();
    const geometryType = olRenderFeature.getType();
    if (geometryType === 'Polygon') {
        const ends = olRenderFeature.getEnds();
        geom = new OlPolygon(olRenderFeature.getFlatCoordinates(), 'XY', ends);
    }
    else if (geometryType === 'Point') {
        geom = new OlPoint(olRenderFeature.getFlatCoordinates(), 'XY');
    }
    else if (geometryType === 'LineString') {
        geom = new OlLineString(olRenderFeature.getFlatCoordinates(), 'XY');
    }
    const geometry = olFormat.writeGeometryObject(geom, {
        dataProjection: projectionOut,
        featureProjection: projectionIn
    });
    const id = olRenderFeature.getId() ? olRenderFeature.getId() : uuid();
    const mapTitle = olRenderFeature.get('_mapTitle');
    const extent = olproj.transformExtent(olRenderFeature.getExtent(), projectionIn, projectionOut);
    return {
        type: FEATURE,
        projection: projectionOut,
        extent,
        meta: {
            id,
            title: title ? title : mapTitle ? mapTitle : id,
            mapTitle,
            excludeAttribute: exclude,
            excludeAttributeOffline: excludeOffline
        },
        properties,
        geometry,
        ol: olRenderFeature
    };
}
/**
 * Create a feature object out of an OL feature
 * The output object has a reference to the feature id.
 * @param olFeature OL Feature
 * @param projectionIn OL feature projection
 * @param olLayer OL Layer
 * @param projectionOut Feature projection
 * @returns Feature
 */
function featureFromOl(olFeature, projectionIn, olLayer, projectionOut = 'EPSG:4326') {
    let title;
    let exclude;
    let excludeOffline;
    let idColumn; // for arcgisrest and tilearcgisrest source
    const olFormat = new OlGeoJSON();
    const keys = olFeature.getKeys().filter((key) => {
        return !key.startsWith('_') && key !== 'geometry';
    });
    const properties = keys.reduce((acc, key) => {
        acc[key] = olFeature.get(key);
        return acc;
    }, {});
    const geometry = olFormat.writeGeometryObject(olFeature.getGeometry(), {
        dataProjection: projectionOut,
        featureProjection: projectionIn
    });
    if (olLayer) {
        title = olLayer.get('title');
        const sourceOptions = olLayer.get('sourceOptions');
        if (sourceOptions) {
            exclude = sourceOptions.excludeAttribute;
            excludeOffline = sourceOptions.excludeAttributeOffline;
            idColumn =
                sourceOptions.idColumn ||
                    (sourceOptions.type === 'arcgisrest' ||
                        sourceOptions.type === 'tilearcgisrest'
                        ? 'OBJECTID'
                        : undefined);
        }
    }
    else {
        title = olFeature.get('_title');
    }
    const mapTitle = olFeature.get('_mapTitle');
    const id = olFeature.getId()
        ? olFeature.getId()
        : olFeature.get(idColumn)
            ? olFeature.get(idColumn)
            : uuid();
    const newFeature = olFeature.get('_newFeature');
    return {
        type: FEATURE,
        projection: projectionOut,
        extent: olFeature.get('_extent'),
        meta: {
            id,
            title: title ? title : mapTitle ? mapTitle : id,
            mapTitle,
            revision: olFeature.getRevision(),
            style: olFeature.get('_style'),
            excludeAttribute: exclude,
            excludeAttributeOffline: excludeOffline
        },
        properties,
        geometry,
        ol: olFeature
    };
}
/**
 * Compute an OL feature extent in it's map projection
 * @param map Map
 * @param olFeature OL feature
 * @returns Extent in the map projection
 */
function computeOlFeatureExtent(olFeature, projection) {
    let olExtent = olextent.createEmpty();
    const olFeatureExtent = olFeature.get('_extent');
    const olFeatureProjection = olFeature.get('_projection');
    if (olFeatureExtent !== undefined && olFeatureProjection !== undefined) {
        olExtent = olproj.transformExtent(olFeatureExtent, olFeatureProjection, projection);
    }
    else {
        const olGeometry = olFeature.getGeometry();
        if (olGeometry !== null) {
            olExtent = olGeometry.getExtent();
        }
    }
    return olExtent;
}
/**
 * Compute a multiple OL features extent in their map projection
 * @param map Map
 * @param olFeatures OL features
 * @returns Extent in the map projection
 */
function computeOlFeaturesExtent(olFeatures, projection) {
    const extent = olextent.createEmpty();
    olFeatures.forEach((olFeature) => {
        const featureExtent = computeOlFeatureExtent(olFeature, projection);
        olextent.extend(extent, featureExtent);
    });
    return extent;
}
/**
 * Scale an extent.
 * @param extent Extent
 * @param Scaling factors for top, right, bottom and left directions, in that order
 * @returns Scaled extent
 */
function scaleExtent(extent, scale) {
    const [width, height] = olextent.getSize(extent);
    return [
        scale[3] ? extent[0] - width * scale[3] : extent[0],
        scale[2] ? extent[1] - height * scale[2] : extent[1],
        scale[1] ? extent[2] + width * scale[1] : extent[2],
        scale[0] ? extent[3] + height * scale[0] : extent[3]
    ];
}
/**
 * Return true if features are out of view.
 * If features are too close to the edge, they are considered out of view.
 * By default, we define the edge as 5% (0.05) of the extent size.
 * @param map Map
 * @param featuresExtent The features's extent
 * @param edgeRatio Number or Number[] Single value OR an array =>
 *  [top,right,bottom,left] directions, in that order
 * @returns Return true if features are out of view
 */
function featuresAreOutOfView(extent, featuresExtent, edgeRatio = 0.05) {
    const edgesRatio = Array.isArray(edgeRatio)
        ? edgeRatio
        : [edgeRatio, edgeRatio, edgeRatio, edgeRatio];
    const scale = [-1, -1, -1, -1].map((x, i) => x * edgesRatio[i]);
    const viewExtent = scaleExtent(extent, scale);
    return !olextent.containsExtent(viewExtent, featuresExtent);
}
/**
 * Return true if features are too deep into the view. This results
 * in features being too small.
 * Features are considered too small if their extent occupies less than
 * 1% of the map extent.
 * @param map Map
 * @param featuresExtent The features's extent
 * @param areaRatio The features extent to view extent acceptable ratio
 * @returns Return true if features are too deep in the view
 */
function featuresAreTooDeepInView(viewController, featuresExtent, areaRatio) {
    // An area ratio of 0.004 means that the feature extent's width and height
    // should be about 1/16 of the map extent's width and height
    areaRatio = areaRatio ? areaRatio : 0.004;
    const mapExtent = viewController.getExtent();
    const mapExtentArea = olextent.getArea(mapExtent);
    const featuresExtentArea = olextent.getArea(featuresExtent);
    if (featuresExtentArea === 0 && viewController.getZoom() > 13) {
        // In case it's a point
        return false;
    }
    return featuresExtentArea / mapExtentArea < areaRatio;
}
/**
 * Fit view to include the features extent.
 * By default, this method will let the features occupy about 50% of the viewport.
 * @param map Map
 * @param olFeatures OL features
 * @param motion To motion to the new map view
 * @param scale If this is defined, the original view will be scaled
 *  by that factor before any logic is applied.
 */
function moveToOlFeatures(viewController, olFeatures, motion = FeatureMotion.Default, scale, areaRatio) {
    const extent = viewController.getExtent();
    const projection = viewController.getOlProjection();
    const featuresExtent = computeOlFeaturesExtent(olFeatures, projection);
    let viewExtent = featuresExtent;
    if (scale !== undefined) {
        viewExtent = scaleExtent(viewExtent, scale);
    }
    if (motion === FeatureMotion.Zoom) {
        viewController.zoomToExtent(viewExtent);
    }
    else if (motion === FeatureMotion.Move) {
        viewController.moveToExtent(viewExtent);
    }
    else if (motion === FeatureMotion.Default) {
        if (featuresAreOutOfView(extent, featuresExtent) ||
            featuresAreTooDeepInView(viewController, featuresExtent, areaRatio)) {
            viewController.zoomToExtent(viewExtent);
        }
    }
}
/**
 * Hide an OL feature
 * @param olFeature OL feature
 */
function hideOlFeature(olFeature) {
    olFeature.setStyle(new olStyle.Style({}));
}
/**
 * Compute a diff between a source array of Ol features and a target array
 * @param source Source array of OL features
 * @param starget Target array of OL features
 * @returns Features to add and remove
 */
function computeOlFeaturesDiff(source, target) {
    const olFeaturesMap = new Map();
    target.forEach((olFeature) => {
        olFeaturesMap.set(olFeature.getId(), olFeature);
    });
    const olFeaturesToRemove = [];
    source.forEach((olFeature) => {
        const newOlFeature = olFeaturesMap.get(olFeature.getId());
        if (newOlFeature === undefined) {
            olFeaturesToRemove.push(olFeature);
        }
        else if (newOlFeature.get('_entityRevision') !== olFeature.get('_entityRevision')) {
            olFeaturesToRemove.push(olFeature);
        }
        else {
            olFeaturesMap.delete(newOlFeature.getId());
        }
    });
    const olFeaturesToAddIds = Array.from(olFeaturesMap.keys());
    const olFeaturesToAdd = target.filter((olFeature) => {
        return olFeaturesToAddIds.indexOf(olFeature.getId()) >= 0;
    });
    return {
        add: olFeaturesToAdd,
        remove: olFeaturesToRemove
    };
}

class DataService {
}

class OSMDataSource extends DataSource {
    createOlSource() {
        if (!this.options.url) {
            this.options.url = 'https://tile.openstreetmap.org/{z}/{x}/{y}.png';
        }
        return new olSourceOSM(this.options);
    }
    onUnwatch() { }
}

class XYZDataSource extends DataSource {
    createOlSource() {
        return new olSourceXYZ(this.options);
    }
    onUnwatch() { }
}

class WFSDataSource extends DataSource {
    options;
    wfsService;
    authInterceptor;
    set ogcFilters(value) {
        this.options.ogcFilters = value;
    }
    get ogcFilters() {
        return this.options.ogcFilters;
    }
    constructor(options, wfsService, authInterceptor) {
        super(checkWfsParams(options, 'wfs'));
        this.options = options;
        this.wfsService = wfsService;
        this.authInterceptor = authInterceptor;
        const ogcFilters = this.options
            .ogcFilters;
        const fieldNameGeometry = this.options.paramsWFS.fieldNameGeometry || defaultFieldNameGeometry;
        const ogcFilterWriter = new OgcFilterWriter();
        this.options.ogcFilters =
            ogcFilterWriter.defineOgcFiltersDefaultOptions(ogcFilters, fieldNameGeometry);
        if (this.options.ogcFilters.enabled &&
            this.options.ogcFilters.editable &&
            (options.sourceFields || []).filter((sf) => !sf.values).length > 0) {
            this.wfsService.getSourceFieldsFromWFS(this.options);
        }
        if (ogcFilters?.pushButtons) {
            ogcFilters.pushButtons.selectorType = 'pushButton';
        }
        if (ogcFilters?.checkboxes) {
            ogcFilters.checkboxes.selectorType = 'checkbox';
        }
        if (ogcFilters?.radioButtons) {
            ogcFilters.radioButtons.selectorType = 'radioButton';
        }
        if (ogcFilters?.select) {
            ogcFilters.select.selectorType = 'select';
        }
        if (ogcFilters?.autocomplete) {
            ogcFilters.autocomplete.selectorType = 'autocomplete';
        }
        this.setOgcFilters(this.options.ogcFilters, true);
    }
    createOlSource() {
        const vectorSource = new OlVectorSource({
            format: getFormatFromOptions(this.options),
            strategy: OlLoadingStrategy.bbox
        });
        return vectorSource;
    }
    setOgcFilters(ogcFilters, triggerEvent = false) {
        this.ogcFilters = ogcFilters;
        if (triggerEvent) {
            this.ol.notify('ogcFilters', this.ogcFilters);
        }
    }
    onUnwatch() { }
}

class WFSService extends DataService {
    http;
    constructor(http) {
        super();
        this.http = http;
    }
    getData() {
        console.log('This is defining a data service.');
        return 'This is defining a data service.';
    }
    getSourceFieldsFromWFS(dataSourceOptions) {
        if (!dataSourceOptions.sourceFields ||
            dataSourceOptions.sourceFields.length === 0) {
            dataSourceOptions.sourceFields = [];
            this.defineFieldAndValuefromWFS(dataSourceOptions).subscribe((getfeatureSourceField) => {
                dataSourceOptions.sourceFields = getfeatureSourceField;
            });
        }
        else {
            this.defineFieldAndValuefromWFS(dataSourceOptions).subscribe((getfeatureSourceField) => {
                dataSourceOptions.sourceFields.forEach((sourcefield) => {
                    if (sourcefield.alias === undefined) {
                        sourcefield.alias = sourcefield.name; // to allow only a list of sourcefield with names
                    }
                    if (sourcefield.values === undefined ||
                        sourcefield.values.length === 0) {
                        sourcefield.values = getfeatureSourceField.find((sf) => sf.name === sourcefield.name).values;
                    }
                });
            });
        }
    }
    wfsGetFeature(dataSourceOptions, nb = defaultMaxFeatures, epsgCode = defaultEpsg, propertyName, startIndex = 0, forceDefaultOutputFormat = false) {
        const queryStringValues = formatWFSQueryString(dataSourceOptions, nb, epsgCode, propertyName, startIndex, forceDefaultOutputFormat);
        const baseUrl = queryStringValues.find((f) => f.name === 'getfeature').value;
        const outputFormat = dataSourceOptions.paramsWFS.outputFormat;
        if (forceDefaultOutputFormat ||
            gmlRegex.test(outputFormat) ||
            !outputFormat) {
            return this.http.get(baseUrl, { responseType: 'text' });
        }
        else {
            return this.http.get(baseUrl);
        }
    }
    defineFieldAndValuefromWFS(dataSourceOptions) {
        return new Observable((d) => {
            const sourceFields = [];
            let fieldList;
            let fieldListWoGeom;
            let fieldListWoGeomStr;
            let olFormats;
            let effectiveOlFormats;
            olFormats = getFormatFromOptions(dataSourceOptions);
            const gmlDataSourceOptions = JSON.parse(JSON.stringify(dataSourceOptions));
            delete gmlDataSourceOptions.paramsWFS.outputFormat;
            delete gmlDataSourceOptions.formatOptions;
            effectiveOlFormats = getFormatFromOptions(gmlDataSourceOptions);
            let sourceFieldsToRetrieveValues = dataSourceOptions.sourceFields
                ?.filter((f) => !f.values)
                .map((f) => f.name);
            // Validate if the service manage no outputformat (wfs 1.0.0 and GML is the default return)
            this.wfsGetFeature(dataSourceOptions, 1, undefined, undefined, 0, true)
                .pipe(concatMap((res) => String(res).toLowerCase().includes('exception')
                ? of(false)
                : of(true)), concatMap((allowGml) => {
                // If the service return GML (return no exception)
                return this.wfsGetFeature(dataSourceOptions, 1).pipe(concatMap((firstFeature) => {
                    const features = olFormats.readFeatures(firstFeature);
                    fieldList = features[0].getKeys();
                    if (dataSourceOptions.sourceFields ||
                        dataSourceOptions.sourceFields.length === 0) {
                        sourceFieldsToRetrieveValues = fieldList;
                    }
                    fieldListWoGeom = fieldList.filter((field) => sourceFieldsToRetrieveValues.includes(field) &&
                        field !== features[0].getGeometryName() &&
                        !field.match(/boundedby/gi));
                    fieldListWoGeomStr = fieldListWoGeom.join(',');
                    const processingArray = [];
                    let startIndex = 0;
                    // If the service do not allow gml return, dice the call in multiple
                    // calls by increment of chunkSize with the original outputFormat
                    if (!allowGml &&
                        dataSourceOptions.paramsWFS.version === '2.0.0' &&
                        dataSourceOptions.paramsWFS.maxFeatures > defaultMaxFeatures) {
                        const chunkSize = 1000;
                        while (startIndex < dataSourceOptions.paramsWFS.maxFeatures) {
                            processingArray.push(this.wfsGetFeature(dataSourceOptions, chunkSize, dataSourceOptions.paramsWFS.srsName, fieldListWoGeomStr, startIndex));
                            startIndex += chunkSize;
                        }
                        effectiveOlFormats = olFormats;
                    }
                    else {
                        processingArray.push(this.wfsGetFeature(dataSourceOptions, dataSourceOptions.paramsWFS.maxFeatures ||
                            defaultMaxFeatures, dataSourceOptions.paramsWFS.srsName, fieldListWoGeomStr, 0, true));
                    }
                    return combineLatest(processingArray);
                }));
            }))
                .subscribe((results) => {
                let mfeatures = [];
                results.map((result) => {
                    const loopFeatures = effectiveOlFormats.readFeatures(result);
                    mfeatures = mfeatures.concat(loopFeatures);
                });
                this.built_properties_value(mfeatures).forEach((element) => {
                    sourceFields.push(element);
                });
                d.next(sourceFields);
                d.complete();
            });
        });
    }
    built_properties_value(features) {
        if (features.length === 0) {
            return [];
        }
        const kv = Object.assign({}, features[0].getProperties());
        delete kv[features[0].getGeometryName()];
        delete kv.boundedBy;
        const sourceFields = [];
        for (const property in kv) {
            if (kv.hasOwnProperty(property)) {
                const fieldType = typeof features[0].get(property) === 'object'
                    ? undefined
                    : typeof features[0].get(property);
                sourceFields.push({
                    name: property,
                    alias: property,
                    type: fieldType,
                    values: [kv[property]]
                });
            }
        }
        features.every((element) => {
            const featureProperties = element.getProperties();
            for (const key in featureProperties) {
                if (featureProperties.hasOwnProperty(key) && key in kv) {
                    sourceFields
                        .filter((f) => f.name === key)
                        .forEach((v) => {
                        if (v.values.indexOf(featureProperties[key]) === -1) {
                            v.values.push(featureProperties[key]);
                        }
                    });
                }
            }
            return true;
        });
        return sourceFields;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: WFSService, deps: [{ token: i1.HttpClient }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: WFSService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: WFSService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i1.HttpClient }]; } });

function createDefaultTileGrid(epsg) {
    const projection = epsg ? olproj.get(epsg) : olproj.get('EPSG:3857');
    const projectionExtent = projection.getExtent();
    const size = getWidth(projectionExtent) / 256;
    const resolutions = new Array(20);
    const matrixIds = new Array(20);
    for (let z = 0; z < 20; ++z) {
        resolutions[z] = size / Math.pow(2, z);
        matrixIds[z] = z;
    }
    return new olTileGridWMTS({
        origin: getTopLeft(projectionExtent),
        resolutions,
        matrixIds
    });
}

class WMTSDataSource extends DataSource {
    constructor(options) {
        super(options);
    }
    createOlSource() {
        const sourceOptions = Object.assign({
            tileGrid: createDefaultTileGrid(this.options.projection)
        }, this.options);
        return new olSourceWMTS(sourceOptions);
    }
    onUnwatch() { }
}

class CartoDataSource extends DataSource {
    get params() {
        return this.options.params;
    }
    get queryTitle() {
        return this.options.queryTitle
            ? this.options.queryTitle
            : 'title';
    }
    get mapLabel() {
        return this.options.mapLabel;
    }
    get queryHtmlTarget() {
        return this.options.queryHtmlTarget
            ? this.options.queryHtmlTarget
            : QueryHtmlTarget.BLANK;
    }
    createOlSource() {
        const crossOrigin = this.options.crossOrigin
            ? this.options.crossOrigin
            : 'anonymous';
        const sourceOptions = Object.assign({
            crossOrigin
        }, this.options);
        return new olSourceCarto(sourceOptions);
    }
    getLegend() {
        const legend = super.getLegend();
        if (legend.length > 0) {
            return legend;
        }
        let htmlString = '<table>';
        if (this.options.config.layers[0].legend !== null) {
            this.options.config.layers[0].legend.items.forEach((f) => {
                if (f.visible === true) {
                    htmlString +=
                        '<tr><td>' +
                            '<p><font size="5" color="' +
                            f.value +
                            '"> &#9679</font></p></td>' +
                            '<td>' +
                            f.name +
                            '</td></tr>';
                }
            });
            htmlString += '</table>';
            return [{ html: htmlString }];
        }
        else {
            // Try to build the legend from the cartocss options
            const layerOptions = this.options.config.layers[0].options;
            // All available cartocss style options
            const types = [
                'polygon-fill:',
                'marker-fill:',
                'shield-fill:',
                'building-fill:',
                'line-color:'
            ];
            for (const oneType of types) {
                if (layerOptions.cartocss.includes(oneType)) {
                    const type = layerOptions.cartocss.split(oneType).pop();
                    const color = type.substr(0, type.indexOf(';'));
                    if (color.includes('ramp')) {
                        const colors = color.split(', (')[1].split(',');
                        const data = color.split(', (')[2].split(',');
                        for (let j = 0; j < colors.length; j++) {
                            colors[j] = colors[j].replace(/("|\))/g, '');
                            data[j] = data[j].replace(/("|\))/g, '');
                            if (data[j].replace(/\s+/g, '') === '=') {
                                data[j] = 'Autres';
                            }
                            htmlString +=
                                '<tr><td>' +
                                    '<p><font size="5" color="' +
                                    colors[j] +
                                    '"> &#9679</font></p></td>' +
                                    '<td>' +
                                    data[j] +
                                    '</td></tr>';
                        }
                        break;
                    }
                    else {
                        const title = layerOptions.layer_name
                            ? layerOptions.layer_name
                            : '';
                        htmlString +=
                            '<tr><td>' +
                                '<p><font size="5" color="' +
                                color +
                                '"> &#9679</font></p>' +
                                '</td><td>' +
                                title +
                                '</td></tr>';
                        break;
                    }
                }
            }
            htmlString += '</table>';
            return [{ html: htmlString }];
        }
    }
    onUnwatch() { }
}

class ArcGISRestDataSource extends DataSource {
    createOlSource() {
        const esrijsonFormat = new olFormatEsriJSON();
        return new OlVectorSource({
            attributions: this.options.params.attributions,
            overlaps: false,
            format: esrijsonFormat,
            url: function (extent, resolution, proj) {
                const baseUrl = this.options.url + '/' + this.options.layer + '/query/';
                const geometry = encodeURIComponent('{"xmin":' +
                    extent[0] +
                    ',"ymin":' +
                    extent[1] +
                    ',"xmax":' +
                    extent[2] +
                    ',"ymax":' +
                    extent[3] +
                    ',"spatialReference":{"wkid":102100}}');
                const params = [
                    'f=json',
                    `geometry=${geometry}`,
                    'geometryType=esriGeometryEnvelope',
                    'inSR=102100',
                    'spatialRel=esriSpatialRelIntersects',
                    'outFields=*',
                    'returnGeometry=true',
                    'outSR=102100'
                ];
                if (this.options.params.time) {
                    const time = `time=${this.options.params.time}`;
                    params.push(time);
                }
                if (this.options.params.customParams) {
                    this.options.params.customParams.forEach((element) => {
                        params.push(element);
                    });
                }
                return `${baseUrl}?${params.join('&')}`;
            }.bind(this),
            strategy: OlLoadingStrategy.bbox
        });
    }
    getLegend() {
        const legendInfo = this.options.legendInfo;
        const legend = super.getLegend();
        if (legendInfo === undefined || legend.length > 0) {
            return legend;
        }
        if (!legendInfo) {
            return;
        }
        let htmlString = '<table>';
        let src;
        let label;
        let svg;
        if (legendInfo.legend) {
            for (const legendElement of legendInfo.legend) {
                src = this.htmlImgSrc(legendElement.contentType, legendElement.imageData);
                label = legendElement.label
                    ? legendElement.label.replace('<Null>', 'Null')
                    : '';
                htmlString +=
                    `<tr><td align='left'><img src="` +
                        src +
                        `" alt ='' /></td><td class="mat-typography">` +
                        label +
                        '</td></tr>';
            }
        }
        else if (legendInfo.type === 'uniqueValue') {
            for (const legendElement of legendInfo.uniqueValueInfos) {
                label = legendElement.label.replace('<Null>', 'Null');
                if (legendElement.symbol.type === 'esriPMS') {
                    src = this.htmlImgSrc(legendElement.symbol.contentType, legendElement.symbol.imageData);
                    htmlString +=
                        `<tr><td align='left'><img src="` +
                            src +
                            `" alt ='' /></td><td class="mat-typography">` +
                            label +
                            '</td></tr>';
                }
                else if (legendElement.symbol.type !== 'esriPMS') {
                    svg = this.createSVG(legendElement.symbol);
                    htmlString +=
                        `<tr><td align='left'>` +
                            svg +
                            `</td><td class="mat-typography">` +
                            label +
                            '</td></tr>';
                }
            }
        }
        else if (legendInfo.type === 'simple') {
            label = legendInfo.label
                ? legendInfo.label.replace('<Null>', 'Null')
                : '';
            if (legendInfo.symbol.type === 'esriPMS') {
                src = this.htmlImgSrc(legendInfo.symbol.contentType, legendInfo.symbol.imageData);
                htmlString +=
                    `<tr><td align='left'><img src="` +
                        src +
                        `" alt ='' /></td><td class="mat-typography">` +
                        label +
                        '</td></tr>';
            }
            else if (legendInfo.symbol.type !== 'esriPMS') {
                svg = this.createSVG(legendInfo.symbol);
                htmlString +=
                    `<tr><td align='left'>` +
                        svg +
                        `</td><td class="mat-typography">` +
                        label +
                        '</td></tr>';
            }
        }
        htmlString += '</table>';
        return [{ html: htmlString }];
    }
    htmlImgSrc(contentType, imageData) {
        return `data:${contentType};base64,${imageData}`;
    }
    createSVG(symbol) {
        let svg = '';
        const color = symbol.color ? symbol.color : [0, 0, 0, 0];
        if (symbol.type === 'esriSLS') {
            const width = symbol.width ? symbol.width : 0;
            const stroke = `stroke:rgba(` +
                color[0] +
                ',' +
                color[1] +
                ',' +
                color[2] +
                ',' +
                color[3] +
                ')';
            const strokeWidth = `stroke-width:` + width;
            if (symbol.style === 'esriSLSSolid') {
                svg =
                    `<svg height="30" width="30"><line x1="0" y1="15" x2="30" y2="15" style="` +
                        stroke +
                        ';' +
                        strokeWidth +
                        `"/></svg>`;
            }
            else if (symbol.style === 'esriSLSDash') {
                const strokeDashArray = `stroke-dasharray="5,5"`;
                svg =
                    `<svg height="30" width="30"><line x1="0" y1="15" x2="30" y2="15" style="` +
                        stroke +
                        ';' +
                        strokeWidth +
                        `" ` +
                        strokeDashArray +
                        `/></svg>`;
            }
        }
        else if (symbol.style === 'esriSMSCircle' ||
            symbol.style === 'esriSFSSolid') {
            const outlineColor = symbol.outline.color;
            const outlineWidth = symbol.outline.width;
            const size = symbol.size;
            const stroke = `stroke:rgba(` +
                outlineColor[0] +
                ',' +
                outlineColor[1] +
                ',' +
                outlineColor[2] +
                ',' +
                outlineColor[3] +
                ')';
            const strokeWidth = `stroke-width:` + outlineWidth;
            const fill = `fill:rgba(` +
                color[0] +
                ',' +
                color[1] +
                ',' +
                color[2] +
                ',' +
                color[3] +
                ')';
            if (symbol.style === 'esriSMSCircle') {
                svg =
                    `<svg height="30" width="30"><circle cx="15" cy="15" r="` +
                        size / 2 +
                        `" style="` +
                        stroke +
                        ';' +
                        strokeWidth +
                        ';' +
                        fill +
                        `"/></svg>`;
            }
            else {
                svg =
                    `<svg height="30" width="30"><rect x="5" y="5" width="20" height="20" style ="` +
                        stroke +
                        ';' +
                        strokeWidth +
                        ';' +
                        fill +
                        `"/></svg>`;
            }
        }
        return svg;
    }
    onUnwatch() { }
}

class ImageArcGISRestDataSource extends DataSource {
    get params() {
        return this.options.params;
    }
    get queryTitle() {
        return this.options.queryTitle
            ? this.options.queryTitle
            : 'title';
    }
    get mapLabel() {
        return this.options.mapLabel;
    }
    get queryHtmlTarget() {
        return this.options.queryHtmlTarget
            ? this.options.queryHtmlTarget
            : QueryHtmlTarget.BLANK;
    }
    createOlSource() {
        const params = this.options.layer === undefined
            ? this.options.params
            : Object.assign({ LAYERS: `show:${this.options.layer}` }, this.options.params);
        if (typeof params.renderingRule === 'object') {
            params.renderingRule = JSON.stringify(params.renderingRule);
        }
        return new ImageArcGISRest({
            ratio: 1,
            params,
            url: this.options.url
        });
    }
    getLegend() {
        const legendInfo = this.options.legendInfo;
        const legend = super.getLegend();
        if (legendInfo === undefined ||
            this.options.layer === undefined ||
            legend.length > 0) {
            return legend;
        }
        if (!legendInfo) {
            return;
        }
        let htmlString = '<table>';
        for (const legendElement of legendInfo.legend) {
            const src = `${this.options.url}/${legendInfo.layerId}/images/${legendElement.url}`;
            const label = legendElement.label.replace('<Null>', 'Null');
            htmlString +=
                `<tr><td align='left'><img src="` +
                    src +
                    `" alt ='' /></td><td class="mat-typography">` +
                    label +
                    '</td></tr>';
        }
        htmlString += '</table>';
        return [{ html: htmlString }];
    }
    onUnwatch() { }
}

class TileArcGISRestDataSource extends DataSource {
    get params() {
        return this.options.params;
    }
    get queryTitle() {
        return this.options.queryTitle
            ? this.options.queryTitle
            : 'title';
    }
    get mapLabel() {
        return this.options.mapLabel;
    }
    get queryHtmlTarget() {
        return this.options.queryHtmlTarget
            ? this.options.queryHtmlTarget
            : QueryHtmlTarget.BLANK;
    }
    createOlSource() {
        return new olSourceTileArcGISRest(this.options);
    }
    getLegend() {
        const legendInfo = this.options.legendInfo;
        const legend = super.getLegend();
        if (legendInfo === undefined ||
            this.options.layer === undefined ||
            legend.length > 0) {
            return legend;
        }
        if (!legendInfo) {
            return;
        }
        let htmlString = '<table>';
        for (const legendElement of legendInfo.legend) {
            const src = `${this.options.url}/${legendInfo.layerId}/images/${legendElement.url}`;
            const label = legendElement.label.replace('<Null>', 'Null');
            htmlString +=
                `<tr><td align='left'><img src="` +
                    src +
                    `" alt ='' /></td><td class="mat-typography">` +
                    label +
                    '</td></tr>';
        }
        htmlString += '</table>';
        return [{ html: htmlString }];
    }
    onUnwatch() { }
}

class TileDebugDataSource extends DataSource {
    createOlSource() {
        const baseOptions = JSON.parse(JSON.stringify(this.options)); // to avoid to alter the original options
        if (this.options.tileGrid) {
            delete baseOptions.tileGrid;
            baseOptions.tileGrid = new TileGrid(this.options.tileGrid);
        }
        return new TileDebug(baseOptions);
    }
    onUnwatch() { }
}

class WebSocketDataSource extends FeatureDataSource {
    ws;
    createOlSource() {
        this.createWebSocket();
        this.options.format = this.getSourceFormatFromOptions(this.options);
        return super.createOlSource();
    }
    createWebSocket() {
        this.ws = new WebSocket(this.options.url);
        this.ws.onmessage = this.onMessage.bind(this);
        if (this.options.onclose) {
            this.ws.onclose = this.onClose.bind(this);
        }
        if (this.options.onerror) {
            this.ws.onerror = this.onError.bind(this);
        }
        if (this.options.onopen) {
            this.ws.onopen = this.onOpen.bind(this);
        }
    }
    onMessage(event) {
        const featureAdded = this.options.format.readFeature(event.data);
        switch (this.options.onmessage) {
            case 'update':
                // ol don't add if same ID
                const featureToRemove = this.ol.getFeatureById(featureAdded.getId());
                if (featureToRemove) {
                    this.ol.removeFeature(featureToRemove);
                }
                this.ol.addFeature(featureAdded);
                break;
            case 'delete':
                this.ol.clear(true);
                this.ol.addFeature(featureAdded);
                break;
            case 'add':
            default:
                this.ol.addFeature(featureAdded);
        }
    }
    onClose(event) {
        // thrown message to user
    }
    onError(event) {
        // thrown message to user
    }
    onOpen(event) {
        // thrown message to user ?
    }
    onUnwatch() {
        this.ws.close();
    }
}

class MVTDataSource extends DataSource {
    createOlSource() {
        let mvtFormat;
        if (this.options.featureClass === 'feature') {
            mvtFormat = new olFormatMVT({ featureClass: OlFeature });
        }
        else {
            mvtFormat = new olFormatMVT();
        }
        this.options.format = mvtFormat;
        return new olSourceVectorTile(this.options);
    }
    generateId() {
        if (!this.options.url) {
            return uuid();
        }
        const chain = 'mvt' + this.options.url;
        return Md5.hashStr(chain);
    }
    onUnwatch() { }
}

class ClusterDataSource extends FeatureDataSource {
    createOlSource() {
        this.options.format = this.getSourceFormatFromOptions(this.options);
        this.options.source = super.createOlSource();
        return new olSourceCluster(this.options);
    }
    generateId() {
        return uuid();
    }
    onUnwatch() { }
}

/**
 * Try to bind a layer to a store if none is bound already.
 * The layer will also be added to the store's map.
 * If no layer is given to that function, a basic one will be created.
 * @param store The store to bind the layer
 * @param layer An optional VectorLayer
 */
function tryBindStoreLayer(store, layer) {
    if (store.layer !== undefined) {
        if (store.layer.map === undefined) {
            store.map.addLayer(store.layer);
        }
        return;
    }
    layer = layer
        ? layer
        : new VectorLayer({
            source: new FeatureDataSource()
        });
    store.bindLayer(layer);
    if (store.layer.map === undefined) {
        store.map.addLayer(store.layer);
    }
}

/**
 * The class is a specialized version of an EntityStore that stores
 * features and the map layer to display them on. Synchronization
 * between the store and the layer is handled by strategies.
 */
class FeatureStore extends EntityStore {
    /**
     * Vector layer to display the features on
     */
    layer;
    /**
     * The map the layer is bound to
     */
    map;
    /**
     * The layer's data source
     */
    get source() {
        return this.layer
            ? this.layer.dataSource
            : undefined;
    }
    /**
     * The searchable index of loaded feature. Computed if strategy is provided
     */
    set searchDocument(v) {
        this._searchDocument = v;
    }
    get searchDocument() {
        return this._searchDocument;
    }
    _searchDocument;
    constructor(entities, options) {
        super(entities, options);
        this.map = options.map;
    }
    /**
     * Bind this store to a vector layer
     * @param layer Vector layer
     * @returns Feature store
     */
    bindLayer(layer) {
        this.layer = layer;
        return this;
    }
    /**
     * Set the layer's features and perform a motion to make them visible. Strategies
     * make extensive use of that method.
     * @param features Features
     * @param motion Optional: The type of motion to perform
     */
    setLayerFeatures(features, motion = FeatureMotion.Default, viewScale, areaRatio, getId) {
        getId = getId ? getId : getEntityId;
        this.checkLayer();
        const olFeatures = features.map((feature) => featureToOl(feature, this.map.projection, getId));
        this.setLayerOlFeatures(olFeatures, motion, viewScale, areaRatio);
    }
    /**
     * Set the store's features from an array of OL features.
     * @param olFeatures Ol features
     */
    setStoreOlFeatures(olFeatures) {
        this.checkLayer();
        const features = olFeatures.map((olFeature) => {
            olFeature.set('_featureStore', this, true);
            return featureFromOl(olFeature, this.layer.map.projection);
        });
        this.load(features);
    }
    /**
     * Remove all features from the layer
     */
    clearLayer() {
        this.checkLayer();
        this.source.ol.clear();
    }
    /**
     * Check wether a layer is bound or not and throw an error if not.
     */
    checkLayer() {
        if (this.layer === undefined) {
            throw new Error('This FeatureStore is not bound to a layer.');
        }
    }
    /**
     * Set the layer's features and perform a motion to make them visible.
     * @param features Openlayers feature objects
     * @param motion Optional: The type of motion to perform
     */
    setLayerOlFeatures(olFeatures, motion = FeatureMotion.Default, viewScale, areaRatio) {
        const olSource = this.layer.ol.getSource();
        const diff = computeOlFeaturesDiff(olSource.getFeatures(), olFeatures);
        if (diff.remove.length > 0) {
            this.removeOlFeaturesFromLayer(diff.remove);
        }
        if (diff.add.length > 0) {
            this.addOlFeaturesToLayer(diff.add);
        }
        if (diff.add.length > 0) {
            // If features are added, do a motion toward the newly added features
            moveToOlFeatures(this.map.viewController, diff.add, motion, viewScale, areaRatio);
        }
        else if (diff.remove.length > 0) {
            // Else, do a motion toward all the features
            moveToOlFeatures(this.map.viewController, olFeatures, motion, viewScale, areaRatio);
        }
    }
    setLayerExtent() {
        let features = this.entities$.getValue();
        let extent = olextent.createEmpty();
        let olFeatures = [];
        features.forEach((feature) => {
            olFeatures.push(featureToOl(feature, this.map.projection));
        });
        const featuresExtent = computeOlFeaturesExtent(olFeatures, this.map.viewProjection);
        olextent.extend(extent, featuresExtent);
        this.layer.setExtent(extent);
    }
    /**
     * Add features to the the layer
     * @param features Openlayers feature objects
     */
    addOlFeaturesToLayer(olFeatures) {
        olFeatures.forEach((olFeature) => {
            olFeature.set('_featureStore', this, true);
        });
        this.source.ol.addFeatures(olFeatures);
    }
    /**
     * Remove features from the the layer
     * @param features Openlayers feature objects
     */
    removeOlFeaturesFromLayer(olFeatures) {
        olFeatures.forEach((olFeature) => {
            this.source.ol.removeFeature(olFeature);
        });
    }
}

/**
 * This strategy maintain the store features updated while the map is moved.
 * The features's state inside the map are tagged inMapExtent = true;
 */
class FeatureStoreInMapExtentStrategy extends EntityStoreStrategy {
    options;
    /**
     * Subscription to the store's OL source changes
     */
    stores$$ = new Map();
    states$$ = [];
    empty$$;
    constructor(options) {
        super(options);
        this.options = options;
    }
    /**
     * Bind this strategy to a store and start watching for Ol source changes
     * @param store Feature store
     */
    bindStore(store) {
        super.bindStore(store);
        if (this.active === true) {
            this.watchStore(store);
        }
        this.empty$$ = store.empty$
            .pipe(skipWhile((empty) => !empty))
            .subscribe(() => this.updateEntitiesInExtent(store));
    }
    /**
     * Unbind this strategy from a store and stop watching for Ol source changes
     * @param store Feature store
     */
    unbindStore(store) {
        super.unbindStore(store);
        if (this.active === true) {
            this.unwatchStore(store);
        }
    }
    /**
     * Start watching all stores already bound to that strategy at once.
     * @internal
     */
    doActivate() {
        this.stores.forEach((store) => this.watchStore(store));
    }
    /**
     * Stop watching all stores bound to that strategy
     * @internal
     */
    doDeactivate() {
        this.unwatchAll();
    }
    /**
     * Watch for a store's  OL source changes
     * @param store Feature store
     */
    watchStore(store) {
        if (this.stores$$.has(store)) {
            return;
        }
        this.updateEntitiesInExtent(store);
        this.states$$.push(store.layer.map.viewController.state$
            .pipe(debounceTime(250))
            .subscribe(() => this.updateEntitiesInExtent(store)));
    }
    updateEntitiesInExtent(store) {
        if (store?.layer?.map?.viewController) {
            store.state.updateAll({ inMapExtent: false });
            const mapExtent = store.layer.map.viewController.getExtent();
            const features = store.entities$.value;
            const entitiesInMapExtent = this.getFeaturesInExtent(features, mapExtent);
            store.state.updateMany(entitiesInMapExtent, { inMapExtent: true }, false);
        }
    }
    getFeaturesInExtent(features, extent) {
        return features.reduce((acc, feature) => {
            const geom = feature.ol?.getGeometry();
            if (geom) {
                const featureExtent = geom.getExtent();
                if (olextent.intersects(featureExtent, extent)) {
                    acc.push(feature);
                }
            }
            else {
                // By default, keep entity with no geometry
                acc.push(feature);
            }
            return acc;
        }, []);
    }
    /**
     * Stop watching for a store's OL source changes
     * @param store Feature store
     */
    unwatchStore(store) {
        const key = this.stores$$.get(store);
        if (key !== undefined) {
            this.stores$$.delete(store);
        }
    }
    /**
     * Stop watching for OL source changes in all stores.
     */
    unwatchAll() {
        this.stores$$.clear();
        this.states$$.map((state) => state.unsubscribe());
        if (this.empty$$) {
            this.empty$$.unsubscribe();
        }
    }
}

/**
 * This strategy maintain the store features updated while the map is scrolled.
 * The features's state inside the map's resolution are tagged inMapResolution = true;
 */
class FeatureStoreInMapResolutionStrategy extends EntityStoreStrategy {
    options;
    /**
     * Subscription to the store's OL source changes
     */
    stores$$ = new Map();
    resolution$$ = [];
    empty$$;
    constructor(options) {
        super(options);
        this.options = options;
    }
    /**
     * Bind this strategy to a store and start watching for Ol source changes
     * @param store Feature store
     */
    bindStore(store) {
        super.bindStore(store);
        if (this.active === true) {
            this.watchStore(store);
        }
        this.empty$$ = store.empty$.subscribe(() => this.updateEntitiesInResolution(store, store.layer.map.viewController.getResolution()));
    }
    /**
     * Unbind this strategy from a store and stop watching for Ol source changes
     * @param store Feature store
     */
    unbindStore(store) {
        super.unbindStore(store);
        if (this.active === true) {
            this.unwatchStore(store);
        }
    }
    /**
     * Start watching all stores already bound to that strategy at once.
     * @internal
     */
    doActivate() {
        this.stores.forEach((store) => this.watchStore(store));
    }
    /**
     * Stop watching all stores bound to that strategy
     * @internal
     */
    doDeactivate() {
        this.unwatchAll();
    }
    /**
     * Watch for a store's  OL source changes
     * @param store Feature store
     */
    watchStore(store) {
        if (this.stores$$.has(store)) {
            return;
        }
        this.updateEntitiesInResolution(store, store.layer.map.viewController.getResolution());
        this.resolution$$.push(store.layer.map.viewController.resolution$
            .pipe(debounceTime$1(250))
            .subscribe((res) => {
            this.updateEntitiesInResolution(store, res);
        }));
    }
    updateEntitiesInResolution(store, mapResolution) {
        if (mapResolution > store.layer.minResolution &&
            mapResolution < store.layer.maxResolution) {
            store.state.updateAll({ inMapResolution: true });
        }
        else {
            store.state.updateAll({ inMapResolution: false });
        }
    }
    /**
     * Stop watching for a store's OL source changes
     * @param store Feature store
     */
    unwatchStore(store) {
        const key = this.stores$$.get(store);
        if (key !== undefined) {
            this.stores$$.delete(store);
        }
    }
    /**
     * Stop watching for OL source changes in all stores.
     */
    unwatchAll() {
        this.stores$$.clear();
        this.resolution$$.map((state) => state.unsubscribe());
        if (this.empty$$) {
            this.empty$$.unsubscribe();
        }
    }
}

/**
 * This strategy maintain the store features updated to detect geoproperties
 * (wms/arcgis... layer and url).
 * The features's state inside the map are tagged haveGeoServiceProperties = true;
 */
class GeoPropertiesStrategy extends EntityStoreStrategy {
    options;
    propertyTypeDetectorService;
    capabilitiesService;
    /**
     * Subscription to the store's OL source changes
     */
    stores$$ = new Map();
    states$$ = [];
    empty$$;
    /**
     * The map the layer is bound to
     */
    map;
    constructor(options, propertyTypeDetectorService, capabilitiesService) {
        super(options);
        this.options = options;
        this.propertyTypeDetectorService = propertyTypeDetectorService;
        this.capabilitiesService = capabilitiesService;
        this.map = options.map;
    }
    /**
     * Bind this strategy to a store and start watching for Ol source changes
     * @param store Feature store
     */
    bindStore(store) {
        super.bindStore(store);
        if (this.active === true) {
            this.watchStore(store);
        }
    }
    /**
     * Unbind this strategy from a store and stop watching for Ol source changes
     * @param store Feature store
     */
    unbindStore(store) {
        super.unbindStore(store);
        if (this.active === true) {
            this.unwatchStore(store);
        }
    }
    /**
     * Start watching all stores already bound to that strategy at once.
     * @internal
     */
    doActivate() {
        this.stores.forEach((store) => this.watchStore(store));
    }
    /**
     * Stop watching all stores bound to that strategy
     * @internal
     */
    doDeactivate() {
        this.unwatchAll();
    }
    /**
     * Watch for a store's  OL source changes
     * @param store Feature store
     */
    watchStore(store) {
        if (this.stores$$.has(store)) {
            return;
        }
        this.updateEntitiesPropertiesState(store);
        this.states$$.push(this.map.layers$
            .pipe(debounceTime$1(250), pairwise())
            .subscribe(([prevLayers, currentLayers]) => {
            let prevLayersId;
            if (prevLayers) {
                prevLayersId = prevLayers.map((l) => l.id);
            }
            const layers = currentLayers.filter((l) => !prevLayersId.includes(l.id));
            this.updateEntitiesPropertiesState(store, layers);
        }));
        this.states$$.push(store.entities$.pipe(debounceTime$1(250)).subscribe((a) => {
            this.updateEntitiesPropertiesState(store);
        }));
    }
    updateEntitiesPropertiesState(store, layers) {
        const layersId = this.map.layers.map((l) => l.id);
        let entities = [];
        if (layers) {
            entities = store.entities$.value;
        }
        else {
            const allSV = store.stateView.all();
            entities = allSV.length
                ? store.stateView
                    .all()
                    .filter((s) => !s.state.geoService)
                    .map((e) => e.entity)
                : store.entities$.value;
        }
        const sampling = entities.length >= 250 ? 250 : entities.length;
        const firstN = entities.slice(0, sampling);
        let allKeys = [];
        firstN.map((e) => {
            allKeys = allKeys.concat(Object.keys(e.properties || {}));
        });
        allKeys = [...new Set(allKeys)];
        const distinctValues = {};
        allKeys.map((k) => {
            distinctValues[k] = [
                ...new Set(entities.map((item) => item.properties[k]))
            ];
        });
        const containGeoServices = {};
        Object.entries(distinctValues).forEach((entry) => {
            const [key, values] = entry;
            const valuedAreGeoservices = values.filter((value) => this.propertyTypeDetectorService.isGeoService(value));
            if (valuedAreGeoservices?.length) {
                containGeoServices[key] = valuedAreGeoservices;
            }
        });
        const geoServiceAssociations = [];
        Object.entries(containGeoServices).forEach((entry) => {
            const [key, values] = entry;
            values.map((value) => {
                const geoService = this.propertyTypeDetectorService.getGeoService(value, allKeys);
                if (geoService) {
                    const propertiesForLayerName = allKeys.filter((p) => geoService.propertiesForLayerName.includes(p));
                    // providing the the first matching regex;
                    const propertyForLayerName = propertiesForLayerName.length
                        ? propertiesForLayerName[0]
                        : undefined;
                    if (propertyForLayerName) {
                        geoServiceAssociations.push({
                            url: value,
                            urlProperty: key,
                            layerNameProperty: propertyForLayerName,
                            geoService
                        });
                    }
                }
            });
        });
        const geoServiceStates = [];
        geoServiceAssociations.map((geoServiceAssociation) => {
            const url = geoServiceAssociation.url;
            const type = geoServiceAssociation.geoService.type || 'wms';
            distinctValues[geoServiceAssociation.layerNameProperty].map((layerName) => {
                let appliedLayerName = layerName;
                let arcgisLayerName = undefined;
                if (['arcgisrest', 'imagearcgisrest', 'tilearcgisrest'].includes(type)) {
                    appliedLayerName = undefined;
                    arcgisLayerName = layerName;
                }
                const so = ObjectUtils.removeUndefined({
                    sourceOptions: {
                        type: type || 'wms',
                        url,
                        optionsFromCapabilities: true,
                        optionsFromApi: true,
                        params: {
                            LAYERS: appliedLayerName,
                            LAYER: arcgisLayerName
                        }
                    }
                });
                const potentialLayerId = generateIdFromSourceOptions(so.sourceOptions);
                geoServiceStates.push({
                    geoServiceAssociation,
                    state: {
                        added: layersId.find((l) => l === potentialLayerId) !== undefined,
                        haveGeoServiceProperties: true,
                        type,
                        url,
                        layerName
                    }
                });
            });
        });
        geoServiceStates.map((geoServiceState) => {
            const urlProperty = geoServiceState.geoServiceAssociation.urlProperty;
            const layerNameProperty = geoServiceState.geoServiceAssociation.layerNameProperty;
            const urlValue = geoServiceState.state.url;
            const layerNameValue = geoServiceState.state.layerName;
            const entitiesToProcess = entities.filter((e) => e.properties[urlProperty] === urlValue &&
                e.properties[layerNameProperty] === layerNameValue);
            const ns = {
                geoService: geoServiceState.state
            };
            store.state.updateMany(entitiesToProcess, ns, true);
        });
    }
    /**
     * Stop watching for a store's OL source changes
     * @param store Feature store
     */
    unwatchStore(store) {
        const key = this.stores$$.get(store);
        if (key !== undefined) {
            this.stores$$.delete(store);
        }
    }
    /**
     * Stop watching for OL source changes in all stores.
     */
    unwatchAll() {
        this.stores$$.clear();
        this.states$$.map((state) => state.unsubscribe());
        if (this.empty$$) {
            this.empty$$.unsubscribe();
        }
    }
}

/**
 * This strategy loads a store's features into it's layer counterpart.
 * The store -> layer binding is a one-way binding. That means any entity
 * added to the store will be added to the layer but the opposite is false.
 *
 * Important: This strategy observes filtered entities, not raw entities. This
 * is not configurable yet.
 */
class FeatureStoreLoadingStrategy extends EntityStoreStrategy {
    options;
    /**
     * Subscription to the store's features
     */
    stores$$ = new Map();
    motion;
    constructor(options) {
        super(options);
        this.options = options;
        this.setMotion(options.motion);
    }
    /**
     * Bind this strategy to a store and start watching for entities changes
     * @param store Feature store
     */
    bindStore(store) {
        super.bindStore(store);
        if (this.active === true) {
            this.watchStore(store);
        }
    }
    /**
     * Unbind this strategy from a store and stop watching for entities changes
     * @param store Feature store
     */
    unbindStore(store) {
        super.unbindStore(store);
        if (this.active === true) {
            this.unwatchStore(store);
        }
    }
    /**
     * Define the motion to apply on load
     * @param motion Feature motion
     */
    setMotion(motion) {
        this.motion = motion;
    }
    /**
     * Start watching all stores already bound to that strategy at once.
     * @internal
     */
    doActivate() {
        this.stores.forEach((store) => this.watchStore(store));
    }
    /**
     * Stop watching all stores bound to that strategy
     * @internal
     */
    doDeactivate() {
        this.unwatchAll();
    }
    /**
     * Watch for entities changes in a store.
     * Important: Never observe a store's sorted entities. It makes no sense
     * to display sorted entities (instead of unsorted) on a layer and it
     * would potentially result in a lot of useless computation.
     * @param store Feature store
     */
    watchStore(store) {
        if (this.stores$$.has(store)) {
            return;
        }
        const subscription = store.view
            .all$()
            .subscribe((features) => this.onFeaturesChange(features, store));
        this.stores$$.set(store, subscription);
    }
    /**
     * Stop watching for entities changes in a store.
     * @param store Feature store
     */
    unwatchStore(store) {
        const subscription = this.stores$$.get(store);
        if (subscription !== undefined) {
            subscription.unsubscribe();
            this.stores$$.delete(store);
        }
    }
    /**
     * Stop watching for entities changes in all stores.
     */
    unwatchAll() {
        Array.from(this.stores$$.entries()).forEach((entries) => {
            entries[1].unsubscribe();
        });
        this.stores$$.clear();
    }
    /**
     * Load features into a layer or clear the layer if the array of features is empty.
     * @param features Store filtered features
     * @param store Feature store
     */
    onFeaturesChange(features, store) {
        if (features.length === 0) {
            store.clearLayer();
        }
        else {
            store.setLayerFeatures(features, this.selectMotion(store), this.options.viewScale, this.options.areaRatio, this.options.getFeatureId);
        }
    }
    /**
     * Selects the best motion
     * @param store A FeatureStore to apply the motion
     * @returns The motion selected
     */
    selectMotion(store) {
        if (this.motion !== undefined) {
            return this.motion;
        }
        if (store.pristine === true) {
            // If features have just been loaded into the store, move/zoom on them
            return FeatureMotion.Default;
        }
        else if (store.count > store.view.count) {
            // If features have been filtered, move/zoom on the remaining ones
            return FeatureMotion.Default;
        }
        else {
            // On insert, update or delete, do nothing
            return FeatureMotion.None;
        }
    }
}

/**
 * This strategy loads a layer's features into it's store counterpart.
 * The layer -> store binding is a one-way binding. That means any OL feature
 * added to the layer will be added to the store but the opposite is false.
 *
 * Important: In it's current state, this strategy is to meant to be combined
 * with a standard Loading strategy and it would probably cause recursion issues.
 */
class FeatureStoreLoadingLayerStrategy extends EntityStoreStrategy {
    options;
    /**
     * Subscription to the store's OL source changes
     */
    stores$$ = new Map();
    constructor(options) {
        super(options);
        this.options = options;
    }
    /**
     * Bind this strategy to a store and start watching for Ol source changes
     * @param store Feature store
     */
    bindStore(store) {
        super.bindStore(store);
        if (this.active === true) {
            this.watchStore(store);
        }
    }
    /**
     * Unbind this strategy from a store and stop watching for Ol source changes
     * @param store Feature store
     */
    unbindStore(store) {
        super.unbindStore(store);
        if (this.active === true) {
            this.unwatchStore(store);
        }
    }
    /**
     * Start watching all stores already bound to that strategy at once.
     * @internal
     */
    doActivate() {
        this.stores.forEach((store) => this.watchStore(store));
    }
    /**
     * Stop watching all stores bound to that strategy
     * @internal
     */
    doDeactivate() {
        this.unwatchAll();
    }
    /**
     * Watch for a store's  OL source changes
     * @param store Feature store
     */
    watchStore(store) {
        if (this.stores$$.has(store)) {
            return;
        }
        this.onSourceChanges(store);
        const olSource = store.layer.ol.getSource();
        olSource.on('change', (event) => {
            this.onSourceChanges(store);
        });
    }
    /**
     * Stop watching for a store's OL source changes
     * @param store Feature store
     */
    unwatchStore(store) {
        const key = this.stores$$.get(store);
        if (key !== undefined) {
            this.stores$$.delete(store);
        }
    }
    /**
     * Stop watching for OL source changes in all stores.
     */
    unwatchAll() {
        Array.from(this.stores$$.entries()).forEach((entries) => { });
        this.stores$$.clear();
    }
    /**
     * Load features from an OL source into a  store or clear the store if the source is empty
     * @param features Store filtered features
     * @param store Feature store
     */
    onSourceChanges(store) {
        let olFeatures = store.layer.ol.getSource().getFeatures();
        if (store.layer.dataSource instanceof ClusterDataSource) {
            olFeatures = olFeatures.flatMap((cluster) => cluster.get('features'));
        }
        if (olFeatures.length === 0) {
            store.clear();
        }
        else {
            store.setStoreOlFeatures(olFeatures);
        }
    }
}

class OlDragSelectInteraction extends OlDragBoxInteraction {
    constructor(options) {
        super(options);
    }
}
/**
 * This strategy synchronizes a store and a layer selected entities.
 * The store <-> layer binding is a two-way binding.
 *
 * In many cases, a single strategy bound to multiple stores
 * will yield better results that multiple strategies with each their
 * own store. In the latter scenario, a click on overlapping features
 * would trigger the strategy of each layer and they would cancel
 * each other as well as move the map view around needlessly.
 */
class FeatureStoreSelectionStrategy extends EntityStoreStrategy {
    options;
    /**
     * Listener to the map click event that allows selecting a feature
     * by clicking on the map
     */
    mapClickListener;
    olDragSelectInteraction;
    olDragSelectInteractionEndKey;
    /**
     * Subscription to all stores selected entities
     */
    stores$$;
    motion;
    /**
     * The map the layers belong to
     */
    get map() {
        return this.options.map;
    }
    /**
     * A feature store that'll contain the selected features. It has it's own
     * layer, shared by all the stores this staretgy is bound to.
     */
    get overlayStore() {
        return this._overlayStore;
    }
    _overlayStore;
    constructor(options) {
        super(options);
        this.options = options;
        this.setMotion(options.motion);
        this._overlayStore = this.createOverlayStore();
    }
    /**
     * Bind this strategy to a store and force this strategy's
     * reactivation to properly setup watchers.
     * @param store Feature store
     */
    bindStore(store) {
        super.bindStore(store);
        if (this.active === true) {
            // Force reactivation
            this.activate();
        }
    }
    /**
     * Unbind this strategy from a store and force this strategy's
     * reactivation to properly setup watchers.
     * @param store Feature store
     */
    unbindStore(store) {
        super.unbindStore(store);
        if (this.active === true) {
            // Force reactivation
            this.activate();
        }
    }
    /**
     * Define the motion to apply on select
     * @param motion Feature motion
     */
    setMotion(motion) {
        this.motion = motion;
    }
    /**
     * Unselect all entities, from all stores
     */
    unselectAll() {
        this.stores.forEach((store) => {
            store.state.updateAll({ selected: false });
        });
    }
    /**
     * Clear the overlay
     */
    clear() {
        this.overlayStore.source.ol.clear();
        this.overlayStore.clear();
    }
    /**
     * Deactivate the selection without removing the selection
     * overlay.
     */
    deactivateSelection() {
        this.unlistenToMapClick();
        this.removeDragBoxInteraction();
        this.unwatchAll();
    }
    /**
     * Add the overlay layer, setup the map click lsitener and
     * start watching for stores selection
     * @internal
     */
    doActivate() {
        this.addOverlayLayer();
        this.listenToMapClick();
        if (this.options.dragBox === true) {
            this.addDragBoxInteraction();
        }
        this.watchAll();
    }
    /**
     * Remove the overlay layer, remove the map click lsitener and
     * stop watching for stores selection
     * @internal
     */
    doDeactivate() {
        this.deactivateSelection();
        this.removeOverlayLayer();
    }
    /**
     * Create a single observable of all the stores. With a single observable,
     * features can be added all at once to the overlay layer and a single
     * motion can be performed. Multiple observable would have
     * a cancelling effect on each other.
     */
    watchAll() {
        this.unwatchAll();
        const stores$ = this.stores.map((store) => {
            return store.stateView
                .manyBy$((record) => {
                return record.state.selected === true;
            })
                .pipe(map((records) => records.map((record) => record.entity)));
        });
        this.stores$$ = combineLatest(stores$)
            .pipe(debounceTime(5), skip(1), // Skip intial selection
        map((features) => features.reduce((a, b) => a.concat(b))))
            .subscribe((features) => this.onSelectFromStore(features));
    }
    /**
     * Stop watching for selection in all stores.
     */
    unwatchAll() {
        if (this.stores$$ !== undefined) {
            this.stores$$.unsubscribe();
        }
    }
    /**
     * Add a 'singleclick' listener to the map that'll allow selecting
     * features by clicking on the map. The selection will be performed
     * only on the layers bound to this strategy.
     */
    listenToMapClick() {
        this.mapClickListener = this.map.ol.on('singleclick', (event) => {
            this.onMapClick(event);
        });
    }
    /**
     * Remove the map click listener
     */
    unlistenToMapClick() {
        unByKey(this.mapClickListener);
    }
    /**
     * On map click, select feature at pixel
     * @param event OL MapBrowserPointerEvent
     */
    onMapClick(event) {
        const exclusive = !ctrlKeyDown(event);
        const reverse = !exclusive;
        const olFeatures = event.map.getFeaturesAtPixel(event.pixel, {
            hitTolerance: this.options.hitTolerance || 0,
            layerFilter: (olLayer) => {
                const storeOlLayer = this.stores.find((store) => {
                    return store.layer?.ol === olLayer;
                });
                return storeOlLayer !== undefined;
            }
        });
        this.onSelectFromMap(olFeatures, exclusive, reverse);
    }
    /**
     * Add a drag box interaction and, on drag box end, select features
     */
    addDragBoxInteraction() {
        let olDragSelectInteraction;
        const olInteractions = this.map.ol.getInteractions().getArray();
        // There can only be one dragbox interaction, so find the current one, if any
        // Don't keep a reference to the current dragbox because we don't want
        // to remove it when this startegy is deactivated
        for (const olInteraction of olInteractions) {
            if (olInteraction instanceof OlDragSelectInteraction) {
                olDragSelectInteraction = olInteraction;
                break;
            }
        }
        // If no drag box interaction is found, create a new one and add it to the map
        if (olDragSelectInteraction === undefined) {
            olDragSelectInteraction = new OlDragSelectInteraction({
                condition: ctrlKeyDown
            });
            this.map.ol.addInteraction(olDragSelectInteraction);
            this.olDragSelectInteraction = olDragSelectInteraction;
        }
        this.olDragSelectInteractionEndKey = olDragSelectInteraction.on('boxend', (event) => this.onDragBoxEnd(event));
    }
    /**
     * Remove drag box interaction
     */
    removeDragBoxInteraction() {
        if (this.olDragSelectInteractionEndKey !== undefined) {
            unByKey(this.olDragSelectInteractionEndKey);
        }
        if (this.olDragSelectInteraction !== undefined) {
            this.map.ol.removeInteraction(this.olDragSelectInteraction);
        }
        this.olDragSelectInteraction = undefined;
    }
    /**
     * On dragbox end, select features in drag box
     * @param event OL MapBrowserPointerEvent
     */
    onDragBoxEnd(event) {
        const exclusive = !ctrlKeyDown(event.mapBrowserEvent);
        const target = event.target;
        const extent = target.getGeometry().getExtent();
        const olFeatures = this.stores.reduce((acc, store) => {
            const olSource = store.layer.ol.getSource();
            acc.push(...olSource.getFeaturesInExtent(extent));
            return acc;
        }, []);
        this.onSelectFromMap(olFeatures, exclusive, false);
    }
    /**
     * When features are selected from the store, add
     * them to this startegy's overlay layer (select on map)
     * @param features Store features
     */
    onSelectFromStore(features) {
        const motion = this.motion;
        const olOverlayFeatures = this.overlayStore.layer.ol
            .getSource()
            .getFeatures();
        const overlayFeaturesKeys = olOverlayFeatures.map((olFeature) => olFeature.getId());
        const featuresKeys = features.map(this.overlayStore.getKey);
        let doMotion;
        if (features.length === 0) {
            doMotion = false;
        }
        else {
            doMotion =
                overlayFeaturesKeys.length !== featuresKeys.length ||
                    !overlayFeaturesKeys.every((key) => featuresKeys.indexOf(key) >= 0);
        }
        this.overlayStore.setLayerFeatures(features, doMotion ? motion : FeatureMotion.None, this.options.viewScale, this.options.areaRatio, this.options.getFeatureId);
    }
    /**
     * When features are selected from the map, also select them
     * in their store.
     * @param olFeatures OL feature objects
     */
    onSelectFromMap(olFeatures, exclusive, reverse) {
        const groupedFeatures = this.groupFeaturesByStore(olFeatures);
        this.stores.forEach((store) => {
            const features = groupedFeatures.get(store);
            if (features === undefined && exclusive === true) {
                this.unselectAllFeaturesFromStore(store);
            }
            else if (features === undefined && exclusive === false) {
                // Do nothing
            }
            else {
                this.selectFeaturesFromStore(store, features, exclusive, reverse);
            }
        });
    }
    /**
     * Select features in store
     * @param store: Feature store
     * @param features Features
     */
    selectFeaturesFromStore(store, features, exclusive, reverse) {
        if (reverse === true) {
            store.state.reverseMany(features, ['selected']);
        }
        else {
            store.state.updateMany(features, { selected: true }, exclusive);
        }
    }
    /**
     * Unselect all features from store
     * @param store: Feature store
     */
    unselectAllFeaturesFromStore(store) {
        store.state.updateAll({ selected: false });
    }
    /**
     * This method returns a store -> features mapping from a list
     * of OL selected features. OL features keep a reference to the store
     * they are from.
     * @param olFeatures: OL feature objects
     * @returns Store -> features mapping
     */
    groupFeaturesByStore(olFeatures) {
        const groupedFeatures = new Map();
        if (olFeatures === null || olFeatures === undefined) {
            return groupedFeatures;
        }
        olFeatures.forEach((olFeature) => {
            const store = olFeature.get('_featureStore');
            if (store === undefined) {
                return;
            }
            let features = groupedFeatures.get(store);
            if (features === undefined) {
                features = [];
                groupedFeatures.set(store, features);
            }
            const feature = store.get(olFeature.getId());
            if (feature !== undefined) {
                features.push(feature);
            }
        });
        return groupedFeatures;
    }
    /**
     * Create an overlay store that'll contain the selected features.
     * @returns Overlay store
     */
    createOverlayStore() {
        const overlayLayer = this.options.layer
            ? this.options.layer
            : this.createOverlayLayer();
        return new FeatureStore([], { map: this.map }).bindLayer(overlayLayer);
    }
    /**
     * Create an overlay store that'll contain the selected features.
     * @returns Overlay layer
     */
    createOverlayLayer() {
        return new VectorLayer({
            zIndex: 300,
            source: new FeatureDataSource(),
            style: undefined,
            showInLayerList: false,
            exportable: false,
            browsable: false
        });
    }
    /**
     * Add the overlay store's layer to the map to display the selected
     * features.
     */
    addOverlayLayer() {
        if (this.overlayStore.layer.map === undefined) {
            this.map.addLayer(this.overlayStore.layer);
        }
    }
    /**
     * Remove the overlay layer from the map
     */
    removeOverlayLayer() {
        this.overlayStore.source.ol.clear();
        this.map.removeLayer(this.overlayStore.layer);
    }
}

/**
 *
 * This strategy loads a layer's features's properties into a searchable index.
 */
class FeatureStoreSearchIndexStrategy extends EntityStoreStrategy {
    options;
    /**
     * Subscription to the store's OL source changes
     */
    stores$$ = new Map();
    constructor(options) {
        super(options);
        this.options = options;
    }
    /**
     * Bind this strategy to a store and start watching for entities changes
     * @param store Feature store
     */
    bindStore(store) {
        super.bindStore(store);
        if (this.active === true) {
            this.watchStore(store);
        }
    }
    /**
     * Unbind this strategy from a store and stop watching for entities changes
     * @param store Feature store
     */
    unbindStore(store) {
        super.unbindStore(store);
        if (this.active === true) {
            this.unwatchStore(store);
        }
    }
    /**
     * Start watching all stores already bound to that strategy at once.
     * @internal
     */
    doActivate() {
        this.stores.forEach((store) => this.watchStore(store));
    }
    /**
     * Stop watching all stores bound to that strategy
     * @internal
     */
    doDeactivate() {
        this.unwatchAll();
    }
    initStoreSearchIndex(store) {
        store.searchDocument = new Document$1({ tokenize: 'full' });
    }
    /**
     * Watch for a store's entities changes
     * @param store Feature store
     */
    watchStore(store) {
        if (this.stores$$.has(store)) {
            return;
        }
        this.initStoreSearchIndex(store);
        store.entities$
            .pipe(skipWhile((e) => !e.length))
            .subscribe(() => this.onEntitiesChanges(store));
    }
    /**
     * Stop watching for a store's entities changes
     * @param store Feature store
     */
    unwatchStore(store) {
        const key = this.stores$$.get(store);
        if (key !== undefined) {
            store.searchDocument = undefined;
            this.stores$$.delete(store);
        }
    }
    /**
     * Stop watching for OL source changes in all stores.
     */
    unwatchAll() {
        Array.from(this.stores$$.entries()).forEach((entries) => { });
        this.stores$$.clear();
    }
    /**
     * Maintain searcahble index for every loaded entities
     * @param store Feature store
     */
    onEntitiesChanges(store) {
        const ratio = this.options.percentDistinctValueRatio || 2;
        const featuresProperties = [];
        store.index.forEach((value, key) => {
            const fp = value.properties;
            fp.igoSearchID = key;
            featuresProperties.push(fp);
        });
        const toIndex = [];
        let columnsToNotIndex = [];
        let contentToIndex = [];
        if (this.options.sourceFields) {
            columnsToNotIndex = this.options.sourceFields.filter((sf) => !sf.searchIndex?.enabled);
            contentToIndex = this.options.sourceFields
                .filter((sf) => sf.searchIndex?.enabled)
                .map((sf2) => {
                return Object.assign({}, { field: sf2.name, tokenize: 'full' }, sf2.searchIndex);
            });
        }
        else {
            if (featuresProperties.length) {
                // THIS METHOD COMPUTE COLUMN DISTINCT VALUE TO FILTER WHICH COLUMN TO INDEX BASED ON A RATIO or discard float columns
                const columns = Object.keys(featuresProperties[0]);
                const columnsToIndex = [];
                columnsToNotIndex = columns
                    .map((column) => {
                    const distinctValues = [
                        ...new Set(featuresProperties.map((item) => item[column]))
                    ];
                    // identify column to not index based on a ratio distinctValues/nb of features OR discart exclusive float column (ex: lat, long)
                    if ((distinctValues.length / featuresProperties.length) * 100 <=
                        ratio ||
                        distinctValues.every((n) => Number(n) === n && n % 1 !== 0)) {
                        columnsToNotIndex.push(column);
                    }
                    else {
                        columnsToIndex.push(column);
                    }
                })
                    .filter((f) => f);
                const keysToIndex = columnsToIndex.filter((f) => f !== 'igoSearchID');
                contentToIndex = keysToIndex.map((key) => {
                    return { field: key, tokenize: 'full' };
                });
            }
        }
        store.index.forEach((value, key) => {
            const propertiesToIndex = JSON.parse(JSON.stringify(value.properties));
            columnsToNotIndex.map((c) => delete propertiesToIndex[c]);
            if (Object.keys(propertiesToIndex).length) {
                toIndex.push(propertiesToIndex);
            }
        });
        if (toIndex.length === 0) {
            this.initStoreSearchIndex(store);
        }
        else {
            store.searchDocument = new Document$1({
                document: {
                    id: 'igoSearchID',
                    index: contentToIndex
                }
            });
            toIndex.map((i) => {
                store.searchDocument.add(i.igoSearchID, i);
            });
        }
    }
}

/**
 * Try to add a loading strategy to a store and activate it.
 * If no strategy is given to that function, a basic one will be created.
 * @param store The store to bind the loading strategy
 * @param strategy An optional loading strategy
 */
function tryAddLoadingStrategy(store, strategy) {
    if (store.getStrategyOfType(FeatureStoreLoadingStrategy) !== undefined) {
        store.activateStrategyOfType(FeatureStoreLoadingStrategy);
        return;
    }
    strategy = strategy ? strategy : new FeatureStoreLoadingStrategy({});
    store.addStrategy(strategy);
    strategy.activate();
}
/**
 * Try to add a selection strategy to a store and activate it.
 * If no strategy is given to that function, a basic one will be created.
 * @param store The store to bind the selection strategy
 * @param [strategy] An optional selection strategy
 */
function tryAddSelectionStrategy(store, strategy) {
    if (store.getStrategyOfType(FeatureStoreSelectionStrategy) !== undefined) {
        store.activateStrategyOfType(FeatureStoreSelectionStrategy);
        return;
    }
    strategy = strategy
        ? strategy
        : new FeatureStoreSelectionStrategy({
            map: store.map
        });
    store.addStrategy(strategy);
    strategy.activate();
}

/**
 * Create an overlay style with markers for points and a basic stroke/fill
 * combination for lines and polygons
 * @returns Style function
 */
function createOverlayLayerStyle() {
    const defaultStyle = createOverlayDefaultStyle();
    const markerStyle = createOverlayMarkerStyle();
    let style;
    return (olFeature, resolution) => {
        if (olFeature.getId() === 'bufferFeature') {
            style = createBufferStyle(olFeature.get('bufferStroke'), 2, olFeature.get('bufferFill'), olFeature.get('bufferText'));
            return style;
        }
        else {
            const customStyle = olFeature.get('_style');
            if (customStyle) {
                const styleService = new StyleService();
                return styleService.createStyle(customStyle, olFeature, resolution);
            }
            const geometryType = olFeature.getGeometry().getType();
            style = geometryType === 'Point' ? markerStyle : defaultStyle;
            style.getText().setText(olFeature.get('_mapTitle'));
            return style;
        }
    };
}
/**
 * Create a basic style for lines and polygons
 * @returns Style
 */
function createOverlayDefaultStyle({ text, strokeWidth = 2, fillColor = [0, 161, 222, 0.3], strokeColor = [0, 161, 222, 0.9] } = {}) {
    const fillWithOpacity = asArray(fillColor).slice(0);
    const strokeWithOpacity = asArray(strokeColor).slice(0);
    const stroke = new olStyle.Stroke({
        width: strokeWidth,
        color: strokeWithOpacity
    });
    const fill = new olStyle.Fill({
        color: fillWithOpacity
    });
    return new olStyle.Style({
        stroke,
        fill,
        image: new olStyle.Circle({
            radius: 5,
            stroke,
            fill
        }),
        text: new olStyle.Text({
            text,
            font: '12px Calibri,sans-serif',
            fill: new olStyle.Fill({ color: '#000' }),
            stroke: new olStyle.Stroke({ color: '#fff', width: 3 }),
            overflow: true
        })
    });
}
function createBufferStyle(strokeRGBA = [0, 161, 222, 1], strokeWidth = 2, fillRGBA = [0, 161, 222, 0.15], bufferRadius) {
    const stroke = new olStyle.Stroke({
        width: strokeWidth,
        color: strokeRGBA
    });
    const fill = new olStyle.Fill({
        color: fillRGBA
    });
    return new olStyle.Style({
        stroke,
        fill,
        image: new olStyle.Circle({
            radius: 5,
            stroke,
            fill
        }),
        text: new olStyle.Text({
            font: '12px Calibri,sans-serif',
            text: bufferRadius,
            fill: new olStyle.Fill({ color: '#000' }),
            stroke: new olStyle.Stroke({ color: '#fff', width: 3 }),
            overflow: true
        })
    });
}

/**
 * Create an overlay layer and it's source
 * @returns Overlay layer
 */
function createOverlayLayer() {
    const overlayDataSource = new FeatureDataSource();
    return new VectorLayer({
        title: 'Overlay',
        zIndex: 300,
        source: overlayDataSource,
        style: createOverlayLayerStyle()
    });
}

/**
 * This class is simply a shortcut for adding features to a map.
 * It does nothing more than a standard layer but it's shipped with
 * a defautl style based on the geometry type of the features it contains.
 * @todo Enhance that by using a FeatureStore and strategies.
 */
class Overlay {
    /**
     * The map to add the layer to
     */
    map;
    /**
     * Overlay layer
     */
    layer;
    /**
     * Overlay layer's data source
     */
    get dataSource() {
        return this.layer.dataSource;
    }
    constructor(map) {
        this.layer = createOverlayLayer();
        this.setMap(map);
    }
    /**
     * Bind this to a map and add the overlay layer to that map
     * @param map Map
     */
    setMap(map) {
        if (map === undefined) {
            if (this.map !== undefined) {
                this.map.ol.removeLayer(this.layer.ol);
            }
        }
        else {
            map.ol.addLayer(this.layer.ol);
        }
        this.map = map;
    }
    /**
     * Set the overlay features and, optionally, move to them
     * @param features Features
     * @param motion Optional: Apply this motion to the map view
     * @param sourceId Optional: Remove features of certain sourceId (ex: 'Map' for query features)
     */
    setFeatures(features, motion = FeatureMotion.Default, sourceId) {
        if (sourceId) {
            for (const olFeature of this.dataSource.ol.getFeatures()) {
                if (olFeature.get('_sourceId') === sourceId) {
                    this.removeOlFeature(olFeature);
                }
            }
        }
        else {
            this.clear();
        }
        this.addFeatures(features, motion);
    }
    /**
     * Add a feature to the  overlay and, optionally, move to it
     * @param feature Feature
     * @param motion Optional: Apply this motion to the map view
     */
    addFeature(feature, motion = FeatureMotion.Default) {
        this.addFeatures([feature], motion);
    }
    /**
     * Add features to the  overlay and, optionally, move to them
     * @param features Features
     * @param motion Optional: Apply this motion to the map view
     */
    addFeatures(features, motion = FeatureMotion.Default) {
        const olFeatures = [];
        features.forEach((feature) => {
            const olFeature = featureToOl(feature, this.map.projection);
            const olGeometry = olFeature.getGeometry();
            if (olGeometry === null) {
                return;
            }
            olFeatures.push(olFeature);
        });
        this.addOlFeatures(olFeatures, motion);
    }
    /**
     * Add a OpenLayers feature to the  overlay and, optionally, move to it
     * @param olFeature OpenLayers Feature
     * @param motion Optional: Apply this motion to the map view
     */
    addOlFeature(olFeature, motion = FeatureMotion.Default) {
        this.addOlFeatures([olFeature], motion);
    }
    /**
     * Add OpenLayers features to the overlay and, optionally, move to them
     * @param olFeatures OpenLayers Features
     * @param motion Optional: Apply this motion to the map view
     */
    addOlFeatures(olFeatures, motion = FeatureMotion.Default) {
        this.dataSource.ol.addFeatures(olFeatures);
        moveToOlFeatures(this.map.viewController, olFeatures, motion);
    }
    /**
     * Remove a feature from the overlay
     * @param feature Feature
     */
    removeFeature(feature) {
        this.removeFeatures([feature]);
    }
    /**
     * Remove features from the overlay
     * @param features Features
     */
    removeFeatures(features) {
        features.forEach((feature) => {
            if (feature.meta) {
                if (this.dataSource.ol.getFeatureById(feature.meta.id)) {
                    this.removeOlFeature(this.dataSource.ol.getFeatureById(feature.meta.id));
                }
            }
        });
    }
    /**
     * Remove an OpenLayers feature from the overlay
     * @param olFeature OpenLayers Feature
     */
    removeOlFeature(olFeature) {
        this.dataSource.ol.removeFeature(olFeature);
    }
    /**
     * Clear the overlay
     */
    clear() {
        this.dataSource.ol.clear();
    }
}

class LayerWatcher extends Watcher {
    propertyChange$ = new BehaviorSubject(undefined);
    loaded = 0;
    loading = 0;
    layers = [];
    subscriptions = [];
    constructor() {
        super();
    }
    watch() { }
    unwatch() {
        this.layers.forEach((layer) => this.unwatchLayer(layer), this);
    }
    setPropertyChange(change, layer) {
        if (![
            LinkedProperties.TIMEFILTER,
            LinkedProperties.OGCFILTERS,
            LinkedProperties.VISIBLE,
            LinkedProperties.OPACITY,
            LinkedProperties.MINRESOLUTION,
            LinkedProperties.MAXRESOLUTION
        ].includes(change.key)) {
            return;
        }
        this.propertyChange$.next({ event: change, layer });
    }
    watchLayer(layer) {
        if (layer.status$ === undefined) {
            return;
        }
        layer.ol.on('propertychange', (evt) => this.setPropertyChange(evt, layer));
        layer.dataSource.ol.on('propertychange', (evt) => this.setPropertyChange(evt, layer));
        this.layers.push(layer);
        const layer$$ = layer.status$
            .pipe(distinctUntilChanged())
            .subscribe((status) => {
            if (status === SubjectStatus.Error) {
                this.loading = 0;
                this.loaded = -1;
            }
            if (status === SubjectStatus.Working) {
                this.loading += 1;
            }
            else if (status === SubjectStatus.Done) {
                this.loaded += 1;
            }
            if (this.loaded >= this.loading) {
                this.loading = this.loaded = 0;
                this.status = SubjectStatus.Done;
            }
            else if (this.loading > 0) {
                this.status = SubjectStatus.Working;
            }
        });
        this.subscriptions.push(layer$$);
    }
    unwatchLayer(layer) {
        layer.ol.un('propertychange', (evt) => this.setPropertyChange(evt, layer));
        layer.dataSource.ol.un('propertychange', (evt) => this.setPropertyChange(evt, layer));
        layer.status$.next(SubjectStatus.Done);
        const index = this.layers.indexOf(layer);
        if (index >= 0) {
            const status = layer.watcher.status;
            if ([SubjectStatus.Working, SubjectStatus.Waiting].indexOf(status) !== -1) {
                this.loaded += 1;
            }
            this.subscriptions[index].unsubscribe();
            this.subscriptions.splice(index, 1);
            this.layers.splice(index, 1);
            layer.watcher.unwatch();
        }
    }
}

/**
 * Base map controller
 */
class MapController {
    /**
     * OL Map
     */
    olMap;
    /**
     * Array of observer keys
     */
    observerKeys = [];
    /**
     * Return the OL map this controller is bound to
     * @returns OL Map
     */
    getOlMap() {
        return this.olMap;
    }
    /**
     * Add or remove this controller to/from a map.
     * @param map OL Map
     */
    setOlMap(olMap) {
        if (olMap !== undefined && this.getOlMap() !== undefined) {
            throw new Error('This controller is already bound to a map.');
        }
        if (olMap === undefined) {
            this.teardownObservers();
            this.olMap = olMap;
            return;
        }
        this.olMap = olMap;
    }
    /**
     * Teardown any observers
     */
    teardownObservers() {
        this.observerKeys.forEach((key) => unByKey(key));
        this.observerKeys = [];
    }
}

var GeolocationOverlayType;
(function (GeolocationOverlayType) {
    GeolocationOverlayType["Position"] = "position";
    GeolocationOverlayType["PositionDirection"] = "positionDirection";
    GeolocationOverlayType["Accuracy"] = "accuracy";
    GeolocationOverlayType["Buffer"] = "buffer";
})(GeolocationOverlayType || (GeolocationOverlayType = {}));

/**
 * Controller to handle map view interactions
 */
class MapGeolocationController extends MapController {
    map;
    options;
    storageService;
    configService;
    arrowRotation;
    subscriptions$$ = [];
    geolocationOverlay;
    positionFeatureStyle = new olStyle.Style({
        image: new olStyle.Circle({
            radius: 6,
            fill: new olStyle.Fill({
                color: '#3399CC'
            }),
            stroke: new olStyle.Stroke({
                color: '#fff',
                width: 2
            })
        })
    });
    accuracyFeatureStyle = new olStyle.Style({
        stroke: new olStyle.Stroke({
            color: 'rgba(120, 120, 120, 0.4)',
            width: 1
        }),
        fill: new olStyle.Fill({
            color: 'rgba(120, 120, 120, 0.4)'
        })
    });
    get bufferStyle() {
        return new olStyle.Style({
            stroke: new olStyle.Stroke({ width: 2, color: this.buffer.bufferStroke }),
            fill: new olStyle.Fill({ color: this.buffer.bufferFill }),
            text: new olStyle.Text({
                textAlign: 'left',
                offsetX: 10,
                offsetY: -10,
                font: '12px Calibri,sans-serif',
                text: this.buffer.showBufferRadius
                    ? `${this.buffer.bufferRadius}m`
                    : '',
                fill: new olStyle.Fill({ color: '#000' }),
                stroke: new olStyle.Stroke({ color: '#fff', width: 3 })
            })
        });
    }
    get arrowStyle() {
        return new olStyle.Style({
            image: new olStyle.RegularShape({
                radius: 5.5,
                fill: new olStyle.Fill({
                    color: 'rgba(0, 132, 202)'
                }),
                stroke: new olStyle.Stroke({
                    color: '#fff',
                    width: 1.5
                }),
                points: 3,
                displacement: [0, 9],
                rotation: this.arrowRotation,
                rotateWithView: true
            })
        });
    }
    geolocation;
    /**
     * Observable of the current emission interval of the position. In seconds
     */
    emissionIntervalSeconds$ = new BehaviorSubject(5);
    /**
     * Observable of the current position
     */
    position$ = new BehaviorSubject(undefined);
    /**
     * Observable of the tracking state
     */
    tracking$ = new BehaviorSubject(undefined);
    /**
     * Observable of the follow position state
     */
    followPosition$ = new BehaviorSubject(undefined);
    lastPosition;
    /**
     * Whether the geolocate should show a buffer around the current position
     */
    set buffer(value) {
        this._buffer = value;
        this.handleFeatureCreation(this.position$.value);
    }
    get buffer() {
        return this._buffer;
    }
    _buffer;
    /**
     * Whether the geolocate controller accuracy threshold to store/show the position.
     */
    set accuracyThreshold(value) {
        this._accuracyThreshold = value;
        this.handleFeatureCreation(this.position$.value);
    }
    get accuracyThreshold() {
        return this._accuracyThreshold;
    }
    _accuracyThreshold;
    get olGeolocation() {
        return this.geolocation;
    }
    /**
     * Whether the activate the geolocation.
     */
    get tracking() {
        return this.geolocation.getTracking();
    }
    set tracking(value) {
        this.geolocation.setTracking(value || false);
        this.tracking$.next(value);
        if (this.storageService && value !== undefined) {
            this.storageService.set('geolocation.tracking', value);
        }
        if (!value) {
            this.position$.next(undefined);
        }
    }
    /**
     * Whether the activate the view tracking of the current position
     */
    set followPosition(value) {
        this._followPosition = value;
        this.followPosition$.next(value);
        if (this.configService?.getConfig('geolocate.followPosition') === false) {
            this._followPosition = false;
            this.followPosition$.next(false);
        }
        this.handleFeatureCreation(this.position$.value);
        if (this.storageService && value !== undefined) {
            this.storageService.set('geolocation.followPosition', value);
        }
    }
    get followPosition() {
        return this._followPosition;
    }
    _followPosition;
    constructor(map, options, storageService, configService) {
        super();
        this.map = map;
        this.options = options;
        this.storageService = storageService;
        this.configService = configService;
        this.geolocationOverlay = new Overlay(this.map);
        this._followPosition =
            this.options && this.options.followPosition
                ? this.options.followPosition
                : false;
        this._buffer =
            this.options && this.options.buffer ? this.options.buffer : undefined;
        this._accuracyThreshold =
            this.options && this.options.accuracyThreshold
                ? this.options.accuracyThreshold
                : 5000;
    }
    /**
     * Add or remove this controller to/from a map.
     * @param map OL Map
     */
    setOlMap(olMap) {
        super.setOlMap(olMap);
        this.setupObservers();
    }
    deleteGeolocationFeatures() {
        this.deleteFeatureByType(GeolocationOverlayType.Position);
        this.deleteFeatureByType(GeolocationOverlayType.PositionDirection);
        this.deleteFeatureByType(GeolocationOverlayType.Accuracy);
        this.deleteFeatureByType(GeolocationOverlayType.Buffer);
    }
    setupObservers() {
        this.tracking$.subscribe((tracking) => {
            if (tracking) {
                this.onPositionChange(true, true);
            }
            else {
                this.deleteGeolocationFeatures();
            }
        });
        this.geolocation = new olGeolocation({
            // enableHighAccuracy must be set to true to have the heading value.
            trackingOptions: {
                enableHighAccuracy: true,
                maximumAge: 10000,
                timeout: 600000
            },
            projection: this.options.projection
        });
        let tracking = false;
        this.subscriptions$$.push(this.emissionIntervalSeconds$
            .pipe(switchMap((value) => interval(value * 1000)))
            .subscribe(() => {
            if (tracking === this.tracking) {
                this.onPositionChange(true);
            }
            else {
                tracking = this.tracking;
                this.onPositionChange(true, true);
            }
        }));
        this.geolocation.on('change', (evt) => {
            this.onPositionChange(false, false);
        });
    }
    updateArrowFeatureOrientation(position) {
        const position4326 = olproj.transform(position.position, position.projection, 'EPSG:4326');
        if (!this.lastPosition) {
            this.lastPosition = { coordinates: position4326, dateTime: new Date() };
            return;
        }
        const arrowFeature = this.getFeatureByType(GeolocationOverlayType.PositionDirection);
        const isMoving = position?.speed > 1.25 &&
            this.distanceBetweenPoints(this.lastPosition.coordinates, position4326) >
                0.003;
        if (position.accuracy <= this.accuracyThreshold && isMoving) {
            // Calculate the heading using current position and last recorded
            // because ol heading not returning right value
            var dx = position4326[1] - this.lastPosition.coordinates[1];
            var dy = position4326[0] - this.lastPosition.coordinates[0];
            var theta = Math.atan2(dy, dx);
            if (theta < 0)
                theta = 2 * Math.PI + theta;
            this.arrowRotation = theta;
            if (arrowFeature) {
                arrowFeature.setStyle(this.arrowStyle);
            }
            this.lastPosition = { coordinates: position4326, dateTime: new Date() };
        }
        else {
            if (arrowFeature &&
                new Date().getTime() - this.lastPosition.dateTime.getTime() > 3000)
                hideOlFeature(arrowFeature);
        }
    }
    /**
     * @returns distance in km between coord1 and coord2
     */
    distanceBetweenPoints(coord1, coord2) {
        return olSphere.getDistance(coord1, coord2) / 1000;
    }
    addOnChangedListener(event) {
        let listener = () => {
            event(this.geolocation);
        };
        this.geolocation.on('change', listener);
        return listener;
    }
    deleteChangedListener(event) {
        this.geolocation.un('change', event);
    }
    updateGeolocationOptions(options) {
        if (!options) {
            return;
        }
        // todo maybe a dedicated interface for geolocation should be defined instead of putting these inside the mapviewoptions?
        let tracking = options.geolocate;
        let followPosition = options.alwaysTracking;
        if (this.storageService) {
            const storedTracking = this.storageService.get('geolocation.tracking');
            if (storedTracking !== null && storedTracking !== undefined) {
                tracking = storedTracking;
            }
            const storedFollowPosition = this.storageService.get('geolocation.followPosition');
            if (storedFollowPosition !== null && storedFollowPosition !== undefined) {
                followPosition = storedFollowPosition;
            }
        }
        this.tracking = tracking;
        this.followPosition = followPosition;
        this.buffer = options.buffer;
    }
    /**
     * Teardown any observers
     */
    teardownObservers() {
        if (this.subscriptions$$.length) {
            this.subscriptions$$.map((s) => s.unsubscribe());
        }
        super.teardownObservers();
    }
    /**
     * On position change, get the position, show it on the map and record it.
     * @param emitEvent Map event
     */
    onPositionChange(emitEvent = false, zoomTo = false) {
        if (!this.tracking) {
            return;
        }
        const geolocateProperties = this.geolocation.getProperties();
        if (geolocateProperties.accuracy > this.accuracyThreshold) {
            console.warn('Poor geolocation accuracy. No position are stored/shown');
            this.position$.next(undefined);
            return;
        }
        const position = {
            position: geolocateProperties.position,
            projection: this.geolocation.getProjection().getCode(),
            accuracy: geolocateProperties.accuracy,
            altitude: geolocateProperties.altitude,
            altitudeAccuracy: geolocateProperties.altitudeAccuracy,
            heading: geolocateProperties.heading,
            speed: geolocateProperties.speed,
            enableHighAccuracy: geolocateProperties.trackingOptions
                ?.enableHighAccuracy
                ? true
                : false,
            timestamp: new Date()
        };
        this.handleFeatureCreation(position);
        this.handleViewFromFeatures(position, zoomTo);
        if (emitEvent) {
            this.position$.next(position);
        }
    }
    getFeatureByType(type) {
        return this.geolocationOverlay.dataSource.ol.getFeatureById(type);
    }
    deleteFeatureByType(type) {
        const featureById = this.geolocationOverlay?.dataSource.ol.getFeatureById(type);
        if (featureById) {
            this.geolocationOverlay.dataSource.ol.removeFeature(featureById);
        }
    }
    handleFeatureCreation(position) {
        if (!position || !position.position) {
            return;
        }
        const positionGeometry = new Point(position.position);
        const accuracyGeometry = fromCircle(new OlCircle(position.position, position.accuracy || 0));
        let positionFeature = this.getFeatureByType(GeolocationOverlayType.Position);
        let positionFeatureArrow = this.getFeatureByType(GeolocationOverlayType.PositionDirection);
        let accuracyFeature = this.getFeatureByType(GeolocationOverlayType.Accuracy);
        const positionFeatureExists = positionFeature ? true : false;
        const positionFeatureArrowExists = positionFeatureArrow ? true : false;
        const accuracyFeatureExists = accuracyFeature ? true : false;
        if (!positionFeatureArrowExists) {
            positionFeatureArrow = new OlFeature({
                geometry: positionGeometry
            });
            positionFeatureArrow.setId(GeolocationOverlayType.PositionDirection);
            hideOlFeature(positionFeatureArrow);
        }
        if (!positionFeatureExists) {
            positionFeature = new OlFeature({ geometry: positionGeometry });
            positionFeature.setId(GeolocationOverlayType.Position);
            positionFeature.setStyle(this.positionFeatureStyle);
        }
        if (!accuracyFeatureExists) {
            accuracyFeature = new OlFeature({ geometry: accuracyGeometry });
            accuracyFeature.setId(GeolocationOverlayType.Accuracy);
            accuracyFeature.setStyle(this.accuracyFeatureStyle);
        }
        if (positionGeometry) {
            positionFeatureExists
                ? positionFeature.setGeometry(positionGeometry)
                : this.geolocationOverlay.addOlFeature(positionFeature, FeatureMotion.None);
            positionFeatureArrowExists
                ? positionFeatureArrow.setGeometry(positionGeometry)
                : this.geolocationOverlay.addOlFeature(positionFeatureArrow, FeatureMotion.None);
            this.updateArrowFeatureOrientation(position);
            accuracyFeatureExists
                ? accuracyFeature.setGeometry(accuracyGeometry)
                : this.geolocationOverlay.addOlFeature(accuracyFeature, FeatureMotion.None);
            if (this.buffer) {
                let bufferFeature = this.getFeatureByType(GeolocationOverlayType.Buffer);
                const bufferFeatureExists = bufferFeature ? true : false;
                const bufferGeometry = new OlCircle(position.position, this.buffer.bufferRadius);
                if (!bufferFeatureExists) {
                    bufferFeature = new OlFeature(bufferGeometry);
                    bufferFeature.setId(GeolocationOverlayType.Buffer);
                    bufferFeature.setStyle(this.positionFeatureStyle);
                }
                bufferFeature.setStyle(this.bufferStyle);
                bufferFeatureExists
                    ? bufferFeature.setGeometry(bufferGeometry)
                    : this.geolocationOverlay.addOlFeature(bufferFeature, FeatureMotion.None);
            }
        }
    }
    handleViewFromFeatures(position, zoomTo = false) {
        let positionFeature = this.getFeatureByType(GeolocationOverlayType.Position);
        let positionFeatureArrow = this.getFeatureByType(GeolocationOverlayType.PositionDirection);
        let accuracyFeature = this.getFeatureByType(GeolocationOverlayType.Accuracy);
        let bufferFeature = this.getFeatureByType(GeolocationOverlayType.Buffer);
        const features = [
            positionFeature,
            positionFeatureArrow,
            accuracyFeature,
            bufferFeature
        ].filter((f) => f);
        if (features.length > 0) {
            const featuresExtent = computeOlFeaturesExtent(features, this.map.viewProjection);
            const edgeRatios = position?.speed > 12.5
                ? [0.25, 0.25, 0.25, 0.25]
                : [0.15, 0.1, 0.1, 0.1];
            const areOutOfView = featuresAreOutOfView(this.map.getExtent(), featuresExtent, edgeRatios);
            let motion = this.followPosition && areOutOfView
                ? FeatureMotion.Move
                : FeatureMotion.None;
            if (zoomTo) {
                motion = FeatureMotion.Zoom;
            }
            motion !== FeatureMotion.None
                ? moveToOlFeatures(this.map.viewController, features, motion)
                : undefined;
        }
    }
}

var MapViewAction;
(function (MapViewAction) {
    MapViewAction[MapViewAction["Move"] = 0] = "Move";
    MapViewAction[MapViewAction["Zoom"] = 1] = "Zoom";
})(MapViewAction || (MapViewAction = {}));

/**
 * Controller to handle map view interactions
 */
class MapViewController extends MapController {
    options;
    /**
     * Observable of the current rotation in radians
     */
    rotation$ = new BehaviorSubject(0);
    /**
     * Observable of the current resolution
     */
    resolution$ = new BehaviorSubject(undefined);
    /**
     * Observable of the current state
     */
    state$ = new BehaviorSubject(undefined);
    /**
     * View Padding
     * Values in the array are top, right, bottom and left padding.
     */
    padding = [0, 0, 0, 0];
    /**
     * Max zoom after set extent
     */
    maxZoomOnExtent = 19;
    /**
     * Max extent possible when zooming
     */
    maxLayerZoomExtent;
    /**
     * Extent stream
     */
    extent$ = new Subject();
    /**
     * Subscription to the movement stream
     */
    extent$$;
    /**
     * History of states
     */
    states = [];
    /**
     * Current state index
     */
    stateIndex = 0;
    /**
     * Whether the view controller should keep the view's state history
     */
    get stateHistory() {
        return this.options ? this.options.stateHistory === true : false;
    }
    /**
     * OL View
     */
    get olView() {
        return this.olMap.getView();
    }
    constructor(options) {
        super();
        this.options = options;
    }
    setPadding(padding) {
        // Values in the array are top, right, bottom and left padding.
        if (padding.top || padding.top === 0) {
            this.padding[0] = padding.top;
        }
        if (padding.right || padding.right === 0) {
            this.padding[1] = padding.right;
        }
        if (padding.bottom || padding.bottom === 0) {
            this.padding[2] = padding.bottom;
        }
        if (padding.left || padding.left === 0) {
            this.padding[3] = padding.left;
        }
    }
    /**
     * Add or remove this controller to/from a map.
     * @param map OL Map
     */
    setOlMap(olMap) {
        super.setOlMap(olMap);
        this.setupObservers();
    }
    /**
     * Observe move moveend and subscribe to the extent stream
     */
    setupObservers() {
        if (this.stateHistory === true) {
            this.observerKeys.push(this.olMap.on('moveend', (event) => this.onMoveEnd(event)));
        }
        this.extent$$ = this.extent$
            .pipe(debounceTime(25))
            .subscribe((value) => {
            this.setExtent(value.extent, value.action);
        });
    }
    monitorRotation() {
        this.observerKeys.push(this.olMap.getView().on('change:rotation', (evt) => {
            this.rotation$.next(evt.target.getRotation());
        }));
        this.rotation$.next(this.getRotation());
    }
    /**
     * Teardown any observers
     */
    teardownObservers() {
        super.teardownObservers();
        if (this.extent$$ !== undefined) {
            this.extent$$.unsubscribe();
            this.extent$$ = undefined;
        }
    }
    /**
     * Get the view's OL projection
     * @returns OL projection
     */
    getOlProjection() {
        return this.olView.getProjection();
    }
    /**
     * Get the current map view center
     * @param projection Output projection
     * @returns Center
     */
    getCenter(projection) {
        let center = this.olView.getCenter();
        if (projection && center) {
            center = olproj.transform(center, this.getOlProjection(), projection);
        }
        return center;
    }
    /**
     * Get the current view extent
     * @param projection Output projection
     * @returns Extent
     */
    getExtent(projection) {
        let extent = this.olView.calculateExtent(this.olMap.getSize());
        if (projection && extent) {
            extent = olproj.transformExtent(extent, this.getOlProjection(), projection);
        }
        return extent;
    }
    /**
     * Get the current scale
     * @param dpi Dot per inches
     * @returns View scale
     */
    getScale(dpi = 96) {
        return getScaleFromResolution(this.getResolution(), this.getOlProjection().getUnits(), dpi);
    }
    /**
     * Get the current resolution
     * @returns Projection denominator
     */
    getResolution() {
        return this.olView.getResolution();
    }
    /**
     * Get the current zoom level
     * @returns Zoom level
     */
    getZoom() {
        return Math.round(this.olView.getZoom());
    }
    /**
     * Zoom in
     */
    zoomIn() {
        this.zoomTo(this.olView.getZoom() + 1);
    }
    /**
     * Zoom out
     */
    zoomOut() {
        this.zoomTo(this.olView.getZoom() - 1);
    }
    /**
     * Zoom to specific zoom level
     * @param zoom Zoom level
     */
    zoomTo(zoom) {
        this.olView.cancelAnimations();
        this.olView.animate({
            zoom,
            duration: 250,
            easing: oleasing.easeOut
        });
    }
    /**
     * Move to extent after a short delay (100ms) unless
     * a new movement gets registered in the meantime.
     * @param extent Extent to move to
     */
    moveToExtent(extent) {
        this.extent$.next({ extent, action: MapViewAction.Move });
    }
    /**
     * Zoom to extent after a short delay (100ms) unless
     * a new movement gets registered in the meantime.
     * @param extent Extent to zoom to
     */
    zoomToExtent(extent) {
        this.extent$.next({ extent, action: MapViewAction.Zoom });
    }
    /**
     * Return the current view rotation
     * @returns Rotation angle in radians
     */
    getRotation() {
        return this.olView.getRotation();
    }
    /**
     * Reset the view rotation to 0
     */
    resetRotation() {
        this.olView.animate({ rotation: 0 });
    }
    /**
     * Whether the view has a previous state
     * @returns True if the view has a previous state
     */
    hasPreviousState() {
        return this.states.length > 1 && this.stateIndex > 0;
    }
    /**
     * Whether the view has a next state
     * @returns True if the view has a next state
     */
    hasNextState() {
        return this.states.length > 1 && this.stateIndex < this.states.length - 1;
    }
    /**
     * Restore the previous view state
     */
    previousState() {
        if (this.hasPreviousState()) {
            this.setStateIndex(this.stateIndex - 1);
        }
    }
    /**
     * Restore the next view state
     */
    nextState() {
        if (this.hasNextState()) {
            this.setStateIndex(this.stateIndex + 1);
        }
    }
    /**
     * Clear the state history
     */
    clearStateHistory() {
        this.states = [];
        this.stateIndex = 0;
    }
    /**
     * Update the the view to it's intial state
     */
    setInitialState() {
        if (this.states.length > 0) {
            this.setStateIndex(0);
        }
    }
    /**
     * Move to the extent retrieved from the stream
     * @param extent Extent
     * @param action Either zoom or move
     * @param animation With or without animation to the target extent.
     */
    setExtent(extent, action, animation = true) {
        const olView = this.olView;
        olView.cancelAnimations();
        const duration = animation ? 500 : 0;
        const zoom = olView.getZoom();
        const fromCenter = olView.getCenter();
        const toCenter = [
            extent[0] + (extent[2] - extent[0]) / 2,
            extent[1] + (extent[3] - extent[1]) / 2
        ];
        const distCenter = Math.sqrt(Math.pow(fromCenter[0] - toCenter[0], 2) +
            Math.pow(fromCenter[1] - toCenter[1], 2));
        const fromExtent = olView.calculateExtent();
        const fromSize = Math.sqrt(Math.pow(fromExtent[2] - fromExtent[0], 2) +
            Math.pow(fromExtent[3] - fromExtent[1], 2));
        const toSize = Math.sqrt(Math.pow(extent[2] - extent[0], 2) + Math.pow(extent[3] - extent[1], 2));
        const moySize = (toSize + fromSize) / 2;
        const xSize = distCenter / moySize;
        const maxZoom = action === MapViewAction.Move || zoom > this.maxZoomOnExtent
            ? zoom
            : this.maxZoomOnExtent;
        olView.fit(extent, {
            size: this.olMap.getSize(),
            maxZoom,
            padding: this.padding,
            duration: xSize > 4 ? 0 : duration,
            callback: (isFinished) => {
                if (!isFinished) {
                    olView.fit(extent, {
                        size: this.olMap.getSize(),
                        maxZoom,
                        padding: this.padding,
                        duration: xSize > 4 ? 0 : duration
                    });
                }
            }
        });
    }
    /**
     * Set the view state index
     * @param index State index
     */
    setStateIndex(index) {
        this.stateIndex = index;
        this.setState(this.states[index]);
    }
    /**
     * Set the view state
     * @param state View state
     */
    setState(state) {
        this.olView.animate({
            resolution: state.resolution,
            center: state.center,
            duration: 0
        });
    }
    /**
     * On move end, get the view state and record it.
     * @param event Map event
     */
    onMoveEnd(event) {
        const resolution = this.getResolution();
        if (this.resolution$.value !== resolution) {
            this.resolution$.next(resolution);
        }
        const state = {
            resolution,
            center: this.getCenter(),
            zoom: this.getZoom()
        };
        if (this.stateHistory === true) {
            const stateIndex = this.stateIndex;
            const stateAtIndex = this.states.length === 0 ? undefined : this.states[stateIndex];
            if (!viewStatesAreEqual(state, stateAtIndex)) {
                this.states = this.states.slice(0, stateIndex + 1).concat([state]);
                this.stateIndex = this.states.length - 1;
            }
        }
        this.state$.next(state);
    }
}

// TODO: This class is messy. Clearly define it's scope and the map browser's.
// Move some stuff into controllers.
class IgoMap {
    storageService;
    configService;
    ol;
    forcedOffline$ = new BehaviorSubject(false);
    layers$ = new BehaviorSubject([]);
    layersAddedByClick$ = new BehaviorSubject(undefined);
    status$;
    propertyChange$;
    overlay;
    queryResultsOverlay;
    searchResultsOverlay;
    viewController;
    geolocationController;
    swipeEnabled$ = new BehaviorSubject(false);
    mapCenter$ = new BehaviorSubject(false);
    selectedFeatures$ = new BehaviorSubject(null);
    bufferDataSource;
    layerWatcher;
    options;
    mapViewOptions;
    defaultOptions = {
        controls: { attribution: false }
    };
    get layers() {
        return this.layers$.value;
    }
    /** @deprecated use projectionCode */
    get projection() {
        return this.projectionCode;
    }
    get viewProjection() {
        return this.viewController.getOlProjection();
    }
    get projectionCode() {
        return this.viewProjection.getCode();
    }
    constructor(options, storageService, configService) {
        this.storageService = storageService;
        this.configService = configService;
        this.options = Object.assign({}, this.defaultOptions, options);
        this.layerWatcher = new LayerWatcher();
        this.status$ = this.layerWatcher.status$;
        this.propertyChange$ = this.layerWatcher.propertyChange$;
        olproj4.register(proj4);
        this.init();
    }
    init() {
        const controls = [];
        if (this.options.controls) {
            if (this.options.controls.attribution) {
                const attributionOpt = (this.options.controls.attribution === true
                    ? {}
                    : this.options.controls.attribution);
                controls.push(new olAttribution(attributionOpt));
            }
            if (this.options.controls.scaleLine) {
                const scaleLineOpt = (this.options.controls.scaleLine === true
                    ? {}
                    : this.options.controls.scaleLine);
                controls.push(new olControlScaleLine(scaleLineOpt));
            }
        }
        let interactions = {};
        if (this.options.interactions === false) {
            interactions = {
                altShiftDragRotate: false,
                doubleClickZoom: false,
                keyboard: false,
                mouseWheelZoom: false,
                shiftDragZoom: false,
                dragPan: false,
                pinchRotate: false,
                pinchZoom: false
            };
        }
        this.ol = new olMap({
            interactions: olInteraction.defaults(interactions),
            controls
        });
        this.setView(this.options.view || {});
        this.viewController = new MapViewController({
            stateHistory: true
        });
        this.viewController.setOlMap(this.ol);
        this.overlay = new Overlay(this);
        this.queryResultsOverlay = new Overlay(this);
        this.searchResultsOverlay = new Overlay(this);
        this.ol.once('rendercomplete', () => {
            this.geolocationController = new MapGeolocationController(this, {
                projection: this.viewController.getOlProjection()
            }, this.storageService, this.configService);
            this.geolocationController.setOlMap(this.ol);
            if (this.geolocationController) {
                this.geolocationController.updateGeolocationOptions(this.mapViewOptions);
            }
            this.layers$.pipe(pairwise()).subscribe(([prevLayers, currentLayers]) => {
                let prevLayersId;
                if (prevLayers) {
                    prevLayersId = prevLayers.map((l) => l.id);
                }
                const layers = currentLayers.filter((l) => !prevLayersId.includes(l.id));
                for (const layer of layers) {
                    if (layer.options.linkedLayers) {
                        layer.ol.once('postrender', () => {
                            initLayerSyncFromRootParentLayers(this, layers);
                        });
                    }
                }
            });
            this.viewController.monitorRotation();
        });
        this.propertyChange$
            .pipe(skipWhile$1((pc) => !pc))
            .subscribe((p) => handleLayerPropertyChange(this, p.event, p.layer));
    }
    setTarget(id) {
        this.ol.setTarget(id);
        if (id !== undefined) {
            this.layerWatcher.subscribe(() => { }, null);
        }
        else {
            this.layerWatcher.unsubscribe();
        }
    }
    updateView(options) {
        const currentView = this.ol.getView();
        const viewOptions = {
            ...currentView.getProperties(),
            ...options
        };
        if (options.zoom && options.resolution == null) {
            viewOptions.resolution = undefined;
        }
        this.setView(viewOptions);
        if (options.maxZoomOnExtent) {
            this.viewController.maxZoomOnExtent = options.maxZoomOnExtent;
        }
        this.mapViewOptions = options;
    }
    /**
     * Set the map view
     * @param options Map view options
     */
    setView(options) {
        if (this.viewController !== undefined) {
            this.viewController.clearStateHistory();
        }
        const viewOptions = { constrainResolution: true, ...options };
        if (options.center) {
            viewOptions.center = olproj.fromLonLat(options.center, options.projection);
        }
        this.ol.setView(new olView(viewOptions));
        if (options.maxLayerZoomExtent) {
            this.viewController.maxLayerZoomExtent = options.maxLayerZoomExtent;
        }
    }
    updateControls(value) {
        if (value === undefined) {
            return;
        }
        const controls = [];
        if (value.attribution) {
            const attributionOpt = (value.attribution === true ? {} : value.attribution);
            controls.push(new olAttribution(attributionOpt));
        }
        if (value.scaleLine) {
            const scaleLineOpt = (value.scaleLine === true ? {} : value.scaleLine);
            controls.push(new olControlScaleLine(scaleLineOpt));
        }
        const currentControls = Object.assign([], this.ol.getControls().getArray());
        currentControls.forEach((control) => {
            this.ol.removeControl(control);
        });
        controls.forEach((control) => {
            this.ol.addControl(control);
        });
    }
    /**
     * @deprecated
     * TODO: Move to ViewController and update every place it's used
     */
    getCenter(projection) {
        return this.viewController.getCenter(projection);
    }
    /**
     * @deprecated
     * TODO: Move to ViewController and update every place it's used
     */
    getExtent(projection) {
        return this.viewController.getExtent(projection);
    }
    /**
     * @deprecated
     * TODO: Move to ViewController and update every place it's used
     */
    getZoom() {
        return this.viewController.getZoom();
    }
    changeBaseLayer(baseLayer) {
        if (!baseLayer) {
            return;
        }
        for (const bl of this.getBaseLayers()) {
            bl.visible = false;
        }
        baseLayer.visible = true;
        this.viewController.olView.setMinZoom(baseLayer.dataSource.options.minZoom || (this.options.view || {}).minZoom);
        this.viewController.olView.setMaxZoom(baseLayer.dataSource.options.maxZoom || (this.options.view || {}).maxZoom);
    }
    getBaseLayers() {
        return this.layers.filter((layer) => layer.baseLayer === true);
    }
    getLayerById(id) {
        return this.layers.find((layer) => layer.id && layer.id === id);
    }
    getLayerByAlias(alias) {
        return this.layers.find((layer) => layer.alias && layer.alias === alias);
    }
    getLayerByOlUId(olUId) {
        return this.layers.find((layer) => getUid(layer.ol) && getUid(layer.ol) === olUId);
    }
    getLayerByOlLayer(olLayer) {
        const olUId = getUid(olLayer);
        return this.getLayerByOlUId(olUId);
    }
    /**
     * Add a single layer
     * @param layer Layer to add
     * @param push DEPRECATED
     */
    addLayer(layer, push = true) {
        this.addLayers([layer]);
    }
    /**
     * Add many layers
     * @param layers Layers to add
     * @param push DEPRECATED
     */
    addLayers(layers, push = true) {
        let offsetZIndex = 0;
        let offsetBaseLayerZIndex = 0;
        const addedLayers = layers
            .map((layer) => {
            if (!layer) {
                return;
            }
            const offset = layer.zIndex
                ? 0
                : layer.baseLayer
                    ? offsetBaseLayerZIndex++
                    : offsetZIndex++;
            return this.doAddLayer(layer, offset);
        })
            .filter((layer) => layer !== undefined);
        this.setLayers([].concat(this.layers, addedLayers));
    }
    /**
     * Remove a single layer
     * @param layer Layer to remove
     */
    removeLayer(layer) {
        this.removeLayers([layer]);
    }
    /**
     * Remove many layers
     * @param layers Layers to remove
     */
    removeLayers(layers) {
        const newLayers = this.layers$.value.slice(0);
        const layersToRemove = [];
        layers.forEach((layer) => {
            if (layer instanceof VectorLayer) {
                layer.removeLayerFromIDB();
            }
            const index = newLayers.indexOf(layer);
            if (index >= 0) {
                layersToRemove.push(layer);
                newLayers.splice(index, 1);
                this.handleLinkedLayersDeletion(layer, layersToRemove);
                layersToRemove.map((linkedLayer) => {
                    const linkedIndex = newLayers.indexOf(linkedLayer);
                    if (linkedIndex >= 0) {
                        newLayers.splice(linkedIndex, 1);
                    }
                });
            }
        });
        layersToRemove.forEach((layer) => this.doRemoveLayer(layer));
        this.setLayers(newLayers);
    }
    /**
     * Build a list of linked layers to delete
     * @param srcLayer Layer that has triggered the deletion
     * @param layersToRemove list to append the layer to delete into
     */
    handleLinkedLayersDeletion(srcLayer, layersToRemove) {
        let rootParentByDeletion = getRootParentByDeletion(this, srcLayer);
        if (!rootParentByDeletion) {
            rootParentByDeletion = srcLayer;
        }
        const clbd = getAllChildLayersByDeletion(this, rootParentByDeletion, [
            rootParentByDeletion
        ]);
        for (const layer of clbd) {
            layersToRemove.push(layer);
        }
    }
    /**
     * Remove all layers
     */
    removeAllLayers() {
        this.layers.forEach((layer) => this.doRemoveLayer(layer));
        this.layers$.next([]);
    }
    raiseLayer(layer) {
        const index = this.getLayerIndex(layer);
        if (index > 1) {
            this.moveLayer(layer, index, index - 1);
        }
    }
    raiseLayers(layers) {
        for (const layer of layers) {
            this.raiseLayer(layer);
        }
    }
    lowerLayer(layer) {
        const index = this.getLayerIndex(layer);
        if (index < this.layers.length - 1) {
            this.moveLayer(layer, index, index + 1);
        }
    }
    lowerLayers(layers) {
        const reverseLayers = layers.reverse();
        for (const layer of reverseLayers) {
            this.lowerLayer(layer);
        }
    }
    moveLayer(layer, from, to) {
        const layerTo = this.layers[to];
        const zIndexTo = layerTo.zIndex;
        const zIndexFrom = layer.zIndex;
        if (layerTo.baseLayer || layer.baseLayer) {
            return;
        }
        layer.zIndex = zIndexTo;
        layerTo.zIndex = zIndexFrom;
        this.layers[to] = layer;
        this.layers[from] = layerTo;
        this.layers$.next(this.layers.slice(0));
    }
    /**
     * Add a layer to the OL map and start watching. If the layer is already
     * added to this map, make it visible but don't add it one again.
     * @param layer Layer
     * @returns The layer added, if any
     */
    doAddLayer(layer, offsetZIndex) {
        if (layer.baseLayer && layer.visible) {
            this.changeBaseLayer(layer);
        }
        const existingLayer = this.getLayerById(layer.id);
        if (existingLayer !== undefined) {
            existingLayer.visible = true;
            return;
        }
        if (!layer.baseLayer && layer.zIndex) {
            layer.zIndex += 10;
        }
        if (layer.zIndex === undefined || layer.zIndex === 0) {
            const maxZIndex = Math.max(layer.baseLayer ? 0 : 10, ...this.layers
                .filter((l) => l.baseLayer === layer.baseLayer && l.zIndex < 200 // zIndex > 200 = system layer
            )
                .map((l) => l.zIndex));
            layer.zIndex = maxZIndex + 1 + offsetZIndex;
        }
        if (layer.baseLayer && layer.zIndex > 9) {
            layer.zIndex = 10; // baselayer must have zIndex < 10
        }
        layer.setMap(this);
        this.layerWatcher.watchLayer(layer);
        this.ol.addLayer(layer.ol);
        return layer;
    }
    /**
     * Remove a layer from the OL map and stop watching
     * @param layer Layer
     */
    doRemoveLayer(layer) {
        this.layerWatcher.unwatchLayer(layer);
        this.ol.removeLayer(layer.ol);
        layer.setMap(undefined);
    }
    /**
     * Update the layers observable
     * @param layers Layers
     */
    setLayers(layers) {
        this.layers$.next(this.sortLayersByZIndex(layers).slice(0));
    }
    /**
     * Sort layers by descending zIndex
     * @param layers Array of layers
     * @returns The original array, sorted by zIndex
     */
    sortLayersByZIndex(layers) {
        // Sort by descending zIndex
        return layers.sort((layer1, layer2) => layer2.zIndex - layer1.zIndex);
    }
    /**
     * Get layer index in the map's inenr array of layers
     * @param layer Layer
     * @returns The layer index
     */
    getLayerIndex(layer) {
        return this.layers.findIndex((_layer) => _layer === layer);
    }
}

class MapBase {
    ol;
    forcedOffline$;
    layers$;
    layersAddedByClick$;
    status$;
    propertyChange$;
    overlay;
    queryResultsOverlay;
    searchResultsOverlay;
    viewController;
    geolocationController;
    swipeEnabled$;
    mapCenter$;
    selectedFeatures$;
    bufferDataSource;
    // Getter
    layers;
    projection;
    viewProjection;
    projectionCode;
}

class MapBrowserComponent {
    activityService;
    activityId;
    status$$;
    map;
    get view() {
        return this._view;
    }
    set view(value) {
        this._view = value;
        if (this.map !== undefined) {
            this.map.updateView(value);
        }
    }
    _view;
    get controls() {
        return this._controls;
    }
    set controls(value) {
        this._controls = value;
        if (this.map !== undefined) {
            this.map.updateControls(value);
        }
    }
    _controls;
    id = `igo-map-target-${uuid()}`;
    constructor(activityService) {
        this.activityService = activityService;
    }
    ngOnInit() {
        this.status$$ = this.map.status$.subscribe((status) => this.handleStatusChange(status));
    }
    ngAfterViewInit() {
        this.map.setTarget(this.id);
    }
    ngOnDestroy() {
        this.map.setTarget(undefined);
        this.activityService.unregister(this.activityId);
        this.status$$.unsubscribe();
    }
    handleStatusChange(status) {
        if (status === SubjectStatus.Working && this.activityId === undefined) {
            this.activityId = this.activityService.register();
        }
        else if (status === SubjectStatus.Done && this.activityId !== undefined) {
            this.activityService.unregister(this.activityId);
            this.activityId = undefined;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: MapBrowserComponent, deps: [{ token: i2.ActivityService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: MapBrowserComponent, selector: "igo-map-browser", inputs: { map: "map", view: "view" }, ngImport: i0, template: "<div [id]=\"id\" class=\"igo-map-browser-target\"></div>\n<ng-content></ng-content>\n", styles: [":host{position:relative;display:block}:host,.igo-map-browser-target{width:100%;height:100%}:host ::ng-deep .ol-attribution{flex-flow:row;left:50px;bottom:5px;text-align:left;padding:0;margin-right:90px;background-color:#fff0;width:calc(100% - 100px)}:host ::ng-deep .ol-attribution.ol-logo-only{height:inherit}:host ::ng-deep .ol-attribution.ol-collapsed{background:none}:host ::ng-deep .ol-attribution.ol-collapsed button{transform:none}:host ::ng-deep .ol-attribution button{transform:rotate(180deg);background-color:#fff;cursor:pointer;outline:none}:host ::ng-deep .ol-scale-line-inner{color:#000;border-color:#000;text-shadow:rgb(255,255,255) -1px -1px 3px,rgb(255,255,255) 1px -1px 3px,rgb(255,255,255) -1px 1px 3px,rgb(255,255,255) 1px 1px 4px;box-shadow:0 1px 0 1px #fff9}:host ::ng-deep .ol-scale-line{background-color:#fff0;bottom:4px;transform:translate(-50%);left:50%}:host ::ng-deep .ol-scale-bar{background-color:#fff0;bottom:4px;transform:translate(-50%);left:50%}:host ::ng-deep .ol-scale-text{text-shadow:rgb(255,255,255) -1px -1px 3px,rgb(255,255,255) 1px -1px 3px,rgb(255,255,255) -1px 1px 3px,rgb(255,255,255) 1px 1px 4px}:host ::ng-deep .ol-scale-step-text{text-shadow:rgb(255,255,255) -1px -1px 3px,rgb(255,255,255) 1px -1px 3px,rgb(255,255,255) -1px 1px 3px,rgb(255,255,255) 1px 1px 4px}:host ::ng-deep canvas{display:block}\n"] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: MapBrowserComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-map-browser', template: "<div [id]=\"id\" class=\"igo-map-browser-target\"></div>\n<ng-content></ng-content>\n", styles: [":host{position:relative;display:block}:host,.igo-map-browser-target{width:100%;height:100%}:host ::ng-deep .ol-attribution{flex-flow:row;left:50px;bottom:5px;text-align:left;padding:0;margin-right:90px;background-color:#fff0;width:calc(100% - 100px)}:host ::ng-deep .ol-attribution.ol-logo-only{height:inherit}:host ::ng-deep .ol-attribution.ol-collapsed{background:none}:host ::ng-deep .ol-attribution.ol-collapsed button{transform:none}:host ::ng-deep .ol-attribution button{transform:rotate(180deg);background-color:#fff;cursor:pointer;outline:none}:host ::ng-deep .ol-scale-line-inner{color:#000;border-color:#000;text-shadow:rgb(255,255,255) -1px -1px 3px,rgb(255,255,255) 1px -1px 3px,rgb(255,255,255) -1px 1px 3px,rgb(255,255,255) 1px 1px 4px;box-shadow:0 1px 0 1px #fff9}:host ::ng-deep .ol-scale-line{background-color:#fff0;bottom:4px;transform:translate(-50%);left:50%}:host ::ng-deep .ol-scale-bar{background-color:#fff0;bottom:4px;transform:translate(-50%);left:50%}:host ::ng-deep .ol-scale-text{text-shadow:rgb(255,255,255) -1px -1px 3px,rgb(255,255,255) 1px -1px 3px,rgb(255,255,255) -1px 1px 3px,rgb(255,255,255) 1px 1px 4px}:host ::ng-deep .ol-scale-step-text{text-shadow:rgb(255,255,255) -1px -1px 3px,rgb(255,255,255) 1px -1px 3px,rgb(255,255,255) -1px 1px 3px,rgb(255,255,255) 1px 1px 4px}:host ::ng-deep canvas{display:block}\n"] }]
        }], ctorParameters: function () { return [{ type: i2.ActivityService }]; }, propDecorators: { map: [{
                type: Input
            }], view: [{
                type: Input
            }] } });

class MapOfflineDirective {
    networkService;
    messageService;
    component;
    get map() {
        return this.component.map;
    }
    previousMessageId;
    constructor(component, networkService, messageService) {
        this.networkService = networkService;
        this.messageService = messageService;
        this.component = component;
    }
    ngAfterViewInit() {
        const initialOnline = window.navigator.onLine;
        this.map.forcedOffline$.subscribe((forcedOffline) => {
            const online = window.navigator.onLine;
            // prevent first online message if no state change.
            if (initialOnline && initialOnline === online && !forcedOffline) {
                return;
            }
            if (this.previousMessageId) {
                this.messageService.remove(this.previousMessageId);
            }
            if (!forcedOffline && online) {
                const messageObj = this.messageService.info('igo.geo.network.online.message', 'igo.geo.network.online.title');
                this.previousMessageId = messageObj.toastId;
            }
            else if (forcedOffline) {
                const messageObj = this.messageService.info('igo.geo.network.offline.message', 'igo.geo.network.offline.title');
                this.previousMessageId = messageObj.toastId;
            }
        });
        combineLatest([
            this.networkService.currentState(),
            this.map.forcedOffline$,
            this.map.layers$
        ]).subscribe((bunch) => {
            const online = bunch[0].connection;
            const forcedOffline = bunch[1];
            const layers = bunch[2];
            this.handleLayersOnlineState(online, forcedOffline, layers);
        });
    }
    handleNonOfflinableLayerResolution(online, forcedOffline, layer) {
        if (!online || forcedOffline) {
            layer.maxResolution = 0;
        }
        else if (online || !forcedOffline) {
            layer.maxResolution = layer.options.maxResolution || Infinity;
        }
    }
    handleLayersOnlineState(online, forcedOffline, layers) {
        layers.forEach((layer) => {
            let offlinableByUrlSourceOptions;
            if (layer.isIgoInternalLayer) {
                return;
            }
            // detect if layer/source are offlinable by url/pathOffline properties
            if (layer.options.sourceOptions?.pathOffline) {
                offlinableByUrlSourceOptions = layer.options.sourceOptions;
            }
            if (offlinableByUrlSourceOptions) {
                const type = offlinableByUrlSourceOptions.type;
                if (type === 'mvt') {
                    layer.ol.getSource().refresh();
                }
                if (!online || forcedOffline) {
                    if (['vector', 'cluster'].includes(type)) {
                        return;
                    }
                    layer.ol.getSource().setUrl(offlinableByUrlSourceOptions.pathOffline);
                }
                else if (!online || !forcedOffline) {
                    if (['vector', 'cluster'].includes(type)) {
                        return;
                    }
                    layer.ol.getSource().setUrl(offlinableByUrlSourceOptions.url);
                }
                else {
                    this.handleNonOfflinableLayerResolution(online, forcedOffline, layer);
                }
            }
            else {
                // FOR ALL NON OFFLINABLE SOURCE (i.e. EXCEPT PREVIOUS);
                this.handleNonOfflinableLayerResolution(online, forcedOffline, layer);
                return;
            }
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: MapOfflineDirective, deps: [{ token: MapBrowserComponent }, { token: i2.NetworkService }, { token: i2.MessageService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: MapOfflineDirective, selector: "[igoMapOffline]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: MapOfflineDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igoMapOffline]'
                }]
        }], ctorParameters: function () { return [{ type: MapBrowserComponent }, { type: i2.NetworkService }, { type: i2.MessageService }]; } });

/**
 * This directive return the pointer coordinate (on click or pointermove)
 * in [longitude, latitude], delayed by in input (pointerMoveDelay)
 * to avoid too many emitted values.
 */
class PointerPositionDirective {
    component;
    mediaService;
    lastTimeoutRequest;
    /**
     * Listener to the pointer move event
     */
    pointerMoveListener;
    /**
     * Listener to the map click event
     */
    mapClickListener;
    /**
     * Delay before emitting an event
     */
    pointerPositionDelay = 1000;
    /**
     * Event emitted when the pointer move, delayed by pointerMoveDelay
     */
    pointerPositionCoord = new EventEmitter();
    /**
     * IGO map
     * @internal
     */
    get map() {
        return this.component.map;
    }
    get mapProjection() {
        return this.component.map.projection;
    }
    constructor(component, mediaService) {
        this.component = component;
        this.mediaService = mediaService;
    }
    /**
     * Start listening to pointermove
     * @internal
     */
    ngOnInit() {
        this.listenToMapPointerMove();
        this.listenToMapClick();
    }
    /**
     * Stop listening to pointermove
     * @internal
     */
    ngOnDestroy() {
        this.unlistenToMapPointerMove();
        this.unlistenToMapClick();
    }
    /**
     * On map pointermove
     */
    listenToMapPointerMove() {
        this.pointerMoveListener = this.map.ol.on('pointermove', (event) => this.onPointerEvent(event, this.pointerPositionDelay));
    }
    /**
     * On map click
     */
    listenToMapClick() {
        this.mapClickListener = this.map.ol.on('singleclick', (event) => this.onPointerEvent(event, 0));
    }
    /**
     * Stop listening for map pointermove
     */
    unlistenToMapPointerMove() {
        unByKey(this.pointerMoveListener);
        this.pointerMoveListener = undefined;
    }
    /**
     * Stop listening for map clicks
     */
    unlistenToMapClick() {
        this.mapClickListener = undefined;
    }
    /**
     * emit delayed coordinate (longitude, latitude array) based on pointerMoveDelay or on click
     * @param event OL map browser pointer event
     */
    onPointerEvent(event, delay) {
        if (event.dragging || this.mediaService.isTouchScreen()) {
            return;
        }
        if (typeof this.lastTimeoutRequest !== 'undefined') {
            // cancel timeout when the mouse moves
            clearTimeout(this.lastTimeoutRequest);
        }
        const lonlat = transform(event.coordinate, this.mapProjection, 'EPSG:4326');
        this.lastTimeoutRequest = setTimeout(() => {
            this.pointerPositionCoord.emit(lonlat);
        }, delay);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PointerPositionDirective, deps: [{ token: MapBrowserComponent, self: true }, { token: i2.MediaService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: PointerPositionDirective, selector: "[igoPointerPosition]", inputs: { pointerPositionDelay: "pointerPositionDelay" }, outputs: { pointerPositionCoord: "pointerPositionCoord" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PointerPositionDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igoPointerPosition]'
                }]
        }], ctorParameters: function () { return [{ type: MapBrowserComponent, decorators: [{
                    type: Self
                }] }, { type: i2.MediaService }]; }, propDecorators: { pointerPositionDelay: [{
                type: Input
            }], pointerPositionCoord: [{
                type: Output
            }] } });

function featureRandomStyleFunction() {
    const r = Math.floor(Math.random() * 255);
    const g = Math.floor(Math.random() * 255);
    const b = Math.floor(Math.random() * 255);
    const stroke = new olStyle.Stroke({
        color: [r, g, b, 1],
        width: 2
    });
    const fill = new olStyle.Fill({
        color: [r, g, b, 0.4]
    });
    return (olFeature, resolution) => {
        const customStyle = olFeature.get('_style');
        if (customStyle) {
            if (customStyle.circle &&
                olFeature.get('rad') &&
                olFeature.get('longitude') &&
                olFeature.get('latitude')) {
                const lonLat = [
                    olFeature.get('longitude'),
                    olFeature.get('latitude')
                ];
                const radius = olFeature.get('rad') /
                    Math.cos((Math.PI / 180) * lonLat[1]) /
                    resolution;
                customStyle.circle.radius = radius;
            }
            const styleService = new StyleService();
            return styleService.createStyle(customStyle, undefined, resolution);
        }
        const style = new olStyle.Style({
            stroke,
            fill,
            image: new olStyle.Circle({
                radius: 5,
                stroke,
                fill
            }),
            text: olFeature.get('_mapTitle')
                ? new olStyle.Text({
                    text: olFeature.get('_mapTitle').toString(),
                    offsetX: 5,
                    offsetY: -5,
                    font: '12px Calibri,sans-serif',
                    fill: new olStyle.Fill({ color: '#000' }),
                    stroke: new olStyle.Stroke({ color: '#fff', width: 3 }),
                    overflow: true
                })
                : undefined
        });
        return style;
    };
}
function featureRandomStyle() {
    const r = Math.floor(Math.random() * 255);
    const g = Math.floor(Math.random() * 255);
    const b = Math.floor(Math.random() * 255);
    const stroke = new olStyle.Stroke({
        color: [r, g, b, 1],
        width: 2
    });
    const fill = new olStyle.Fill({
        color: [r, g, b, 0.4]
    });
    const style = new olStyle.Style({
        stroke,
        fill,
        image: new olStyle.Circle({
            radius: 5,
            stroke,
            fill
        })
    });
    return style;
}
/**
 * Create a default style for the pointer position and it's label summary.
 * @param feature olFeature
 * @returns OL style function
 */
function hoverFeatureMarkerStyle(feature, resolution) {
    const olStyleText = new olStyle.Style({
        text: new olStyle.Text({
            text: feature.get('hoverSummary'),
            textAlign: 'left',
            textBaseline: 'top',
            font: '12px Calibri,sans-serif',
            fill: new olStyle.Fill({ color: '#000' }),
            backgroundFill: new olStyle.Fill({ color: 'rgba(255, 255, 255, 0.5)' }),
            backgroundStroke: new olStyle.Stroke({
                color: 'rgba(200, 200, 200, 0.75)',
                width: 2
            }),
            stroke: new olStyle.Stroke({ color: '#fff', width: 3 }),
            overflow: true,
            offsetX: 10,
            offsetY: 20,
            padding: [2.5, 2.5, 2.5, 2.5]
        })
    });
    const olStyles = [olStyleText];
    switch (feature.getGeometry().getType()) {
        case 'Point':
            olStyles.push(new olStyle.Style({
                image: new olStyle.Circle({
                    radius: 10,
                    stroke: new olStyle.Stroke({
                        color: 'blue',
                        width: 3
                    })
                })
            }));
            break;
        default:
            olStyles.push(new olStyle.Style({
                stroke: new olStyle.Stroke({
                    color: 'white',
                    width: 5
                })
            }));
            olStyles.push(new olStyle.Style({
                stroke: new olStyle.Stroke({
                    color: 'blue',
                    width: 3
                })
            }));
    }
    return olStyles;
}
/**
 * Create a default style for the pointer position and it's label summary.
 * @param feature olFeature
 * @returns OL style function
 */
function pointerPositionSummaryMarkerStyle(feature, resolution) {
    return new olStyle.Style({
        image: new olStyle.Icon({
            src: './assets/igo2/geo/icons/cross_black_18px.svg'
        }),
        text: new olStyle.Text({
            text: feature.get('pointerSummary'),
            textAlign: 'left',
            textBaseline: 'bottom',
            font: '12px Calibri,sans-serif',
            fill: new olStyle.Fill({ color: '#000' }),
            backgroundFill: new olStyle.Fill({ color: 'rgba(255, 255, 255, 0.5)' }),
            backgroundStroke: new olStyle.Stroke({
                color: 'rgba(200, 200, 200, 0.75)',
                width: 2
            }),
            stroke: new olStyle.Stroke({ color: '#fff', width: 3 }),
            overflow: true,
            offsetX: 10,
            offsetY: -10,
            padding: [2.5, 2.5, 2.5, 2.5]
        })
    });
}

/**
 * This directive makes the mouse coordinate trigger a reverse search on available search sources.
 * The search results are placed into a label, on a cross icon, representing the mouse coordinate.
 * By default, no search sources. Config in config file must be defined.
 * the layer level.
 */
class HoverFeatureDirective {
    component;
    mediaService;
    styleService;
    store;
    pointerHoverFeatureStore = new EntityStore([]);
    lastTimeoutRequest;
    store$$;
    layers$$;
    selectionLayer;
    selectionMVT = {};
    mvtStyleOptions;
    /**
     * Listener to the pointer move event
     */
    pointerMoveListener;
    singleClickMapListener;
    hoverFeatureId = 'hoverFeatureId';
    /**
     * The delay where the mouse must be motionless before trigger the reverse search
     */
    igoHoverFeatureDelay = 1000;
    /**
     * If the user has enabled or not the directive
     */
    igoHoverFeatureEnabled = false;
    mouseout() {
        clearTimeout(this.lastTimeoutRequest);
        this.clearLayer();
    }
    /**
     * IGO map
     * @internal
     */
    get map() {
        return this.component.map;
    }
    get mapProjection() {
        return this.component.map.projection;
    }
    constructor(component, mediaService, styleService) {
        this.component = component;
        this.mediaService = mediaService;
        this.styleService = styleService;
    }
    /**
     * Start listening to pointermove and reverse search results.
     * @internal
     */
    ngOnInit() {
        this.map.status$
            .pipe(first((status) => status === SubjectStatus.Done))
            .subscribe(() => {
            this.store = new FeatureStore([], { map: this.map });
            this.initStore();
            this.listenToMapPointerMove();
            this.subscribeToPointerStore();
            this.listenToMapClick();
        });
        // To handle context change without using the contextService.
        this.layers$$ = this.map.layers$.subscribe((layers) => {
            if (this.store && !layers.find((l) => l.id === 'hoverFeatureId')) {
                this.initStore();
            }
        });
    }
    /**
     * Initialize the pointer position store
     * @internal
     */
    initStore() {
        const store = this.store;
        const layer = new VectorLayer({
            isIgoInternalLayer: true,
            id: 'hoverFeatureId',
            title: 'hoverFeature',
            zIndex: 900,
            source: new FeatureDataSource(),
            showInLayerList: false,
            exportable: false,
            browsable: false,
            style: hoverFeatureMarkerStyle
        });
        tryBindStoreLayer(store, layer);
        this.selectionLayer = new olLayerVectorTile({
            map: this.map.ol,
            zIndex: 901,
            renderMode: 'vector',
            declutter: true,
            source: new olSourceVectorTile({ projection: this.map.projection }),
            style: (feature, resolution) => {
                if (this.mvtStyleOptions && feature.getId() in this.selectionMVT) {
                    return this.createHoverStyle(feature, this.mvtStyleOptions, resolution);
                }
            }
        });
    }
    createHoverStyle(feature, hoverStyle, resolution) {
        const localHoverStyle = { ...hoverStyle };
        let label = hoverStyle.label ? hoverStyle.label.attribute : undefined;
        let hasLabelStyle = hoverStyle.label?.style ? true : false;
        if (!feature.get('_isLabel')) {
            localHoverStyle.label = undefined;
            hasLabelStyle = false;
            label = undefined;
        }
        else {
            // clear the style for label....
            const size = localHoverStyle.data ? localHoverStyle.data.length : 0;
            const radius = [];
            const stroke = [];
            const width = [];
            const fill = [];
            for (let i = 0; i < size; i++) {
                radius.push(0);
                stroke.push('rgba(255, 255, 255, 0)');
                width.push(0);
                fill.push('rgba(255, 255, 255, 0)');
            }
            localHoverStyle.radius = radius;
            localHoverStyle.stroke = stroke;
            localHoverStyle.width = width;
            localHoverStyle.fill = fill;
        }
        if (!hasLabelStyle && label) {
            localHoverStyle.label.style = {
                textAlign: 'left',
                textBaseline: 'top',
                font: '12px Calibri,sans-serif',
                fill: { color: '#000' },
                backgroundFill: { color: 'rgba(255, 255, 255, 0.5)' },
                backgroundStroke: { color: 'rgba(200, 200, 200, 0.75)', width: 2 },
                stroke: { color: '#fff', width: 3 },
                overflow: true,
                offsetX: 10,
                offsetY: 20,
                padding: [2.5, 2.5, 2.5, 2.5]
            };
        }
        return this.styleService.createStyleByAttribute(feature, localHoverStyle, resolution);
    }
    /**
     * Stop listening to pointermove and reverse search results.
     * @internal
     */
    ngOnDestroy() {
        this.unlistenToMapPointerMove();
        this.unsubscribeToPointerStore();
        this.unlistenToMapSingleClick();
        this.layers$$.unsubscribe();
    }
    /**
     * Subscribe to pointermove result store
     * @internal
     */
    subscribeToPointerStore() {
        this.store$$ = this.pointerHoverFeatureStore.entities$.subscribe((resultsUnderPointerPosition) => {
            this.addFeatureOverlay(resultsUnderPointerPosition);
        });
    }
    /**
     * On map pointermove
     */
    listenToMapPointerMove() {
        this.pointerMoveListener = this.map.ol.on('pointermove', (event) => this.onMapEvent(event));
    }
    /**
     * On map singleclick
     */
    listenToMapClick() {
        this.singleClickMapListener = this.map.ol.on('singleclick', (event) => this.onMapSingleClickEvent(event));
    }
    /**
     * Unsubscribe to pointer store.
     * @internal
     */
    unsubscribeToPointerStore() {
        this.store$$.unsubscribe();
    }
    /**
     * Stop listening for map pointermove
     * @internal
     */
    unlistenToMapPointerMove() {
        unByKey(this.pointerMoveListener);
        this.pointerMoveListener = undefined;
    }
    /**
     * Stop listening for map singleclick
     * @internal
     */
    unlistenToMapSingleClick() {
        unByKey(this.singleClickMapListener);
        this.singleClickMapListener = undefined;
    }
    /**
     * Trigger clear layer on singleclick.
     * @param event OL map browser singleclick event
     */
    onMapSingleClickEvent(event) {
        this.clearLayer();
    }
    /**
     * Trigger hover when the mouse is motionless during the defined delay (pointerMoveDelay).
     * @param event OL map browser pointer event
     */
    onMapEvent(event) {
        if (event.dragging ||
            !this.igoHoverFeatureEnabled ||
            this.mediaService.isTouchScreen()) {
            this.clearLayer();
            return;
        }
        if (typeof this.lastTimeoutRequest !== 'undefined') {
            // cancel timeout when the mouse moves
            clearTimeout(this.lastTimeoutRequest);
        }
        let maximumZindex = -Infinity;
        let topMostOlLayer;
        const pixel = this.map.ol.getPixelFromCoordinate(event.coordinate);
        this.lastTimeoutRequest = setTimeout(() => {
            // retrieve the topmost layer with feature to only apply the hover on this layer.
            this.map.ol.forEachFeatureAtPixel(pixel, (mapFeature, layerOL) => {
                if (!layerOL) {
                    return;
                }
                const igoLayer = this.map.getLayerByOlUId(layerOL.ol_uid);
                if (!this.canProcessHover(igoLayer)) {
                    return;
                }
                if (igoLayer.zIndex <= maximumZindex) {
                    return;
                }
                maximumZindex = igoLayer.zIndex;
                topMostOlLayer = layerOL;
            }, {
                hitTolerance: 10,
                layerFilter: (olLayer) => olLayer instanceof OlVectorLayer ||
                    olLayer instanceof olLayerVectorTile
            });
            if (!topMostOlLayer) {
                // To clear label
                this.clearLayer();
                this.pointerHoverFeatureStore.clear();
                return;
            }
            this.map.ol.forEachFeatureAtPixel(pixel, (mapFeature, layerOL) => {
                // To avoid flashing feature
                if (mapFeature.get('hoverSummary') === undefined &&
                    mapFeature.getProperties() !==
                        this.pointerHoverFeatureStore.all()[0]?.getProperties()) {
                    this.clearLayer();
                    let igoLayer;
                    if (layerOL instanceof OlVectorLayer) {
                        const myLayerVector = this.map.getLayerByOlUId(layerOL.ol_uid);
                        if (!this.canProcessHover(myLayerVector)) {
                            return;
                        }
                        let localOlFeature = this.handleRenderFeature(mapFeature);
                        this.setLayerStyleFromOptions(myLayerVector, localOlFeature);
                        const featuresToLoad = [localOlFeature];
                        localOlFeature.set('_isLabel', false);
                        const myLabelOlFeature = new OlFeature();
                        myLabelOlFeature.setProperties(localOlFeature.getProperties());
                        const labelGeom = localOlFeature.getGeometry().getType() === 'Point'
                            ? localOlFeature.getGeometry()
                            : new olgeom.Point(event.coordinate);
                        myLabelOlFeature.setGeometry(labelGeom);
                        myLabelOlFeature.setId(localOlFeature.getId());
                        myLabelOlFeature.set('_isLabel', true);
                        this.setLayerStyleFromOptions(myLayerVector, myLabelOlFeature);
                        featuresToLoad.push(myLabelOlFeature);
                        this.pointerHoverFeatureStore.load(featuresToLoad);
                        igoLayer = myLayerVector;
                        return true;
                    }
                    if (layerOL instanceof olLayerVectorTile) {
                        const myLayerVectorTile = this.map.getLayerByOlUId(layerOL.ol_uid);
                        if (!this.canProcessHover(myLayerVectorTile)) {
                            return;
                        }
                        if (myLayerVectorTile?.options?.igoStyle?.styleByAttribute
                            ?.hoverStyle) {
                            this.mvtStyleOptions =
                                myLayerVectorTile.options.igoStyle.styleByAttribute.hoverStyle;
                        }
                        else if (myLayerVectorTile?.options?.igoStyle?.hoverStyle) {
                            this.mvtStyleOptions =
                                myLayerVectorTile.options.igoStyle.hoverStyle;
                        }
                        this.selectionLayer.setSource(layerOL.getSource());
                        layerOL
                            .getFeatures(event.pixel)
                            .then((mvtFeatures) => {
                            if (!mvtFeatures.length) {
                                this.selectionMVT = {};
                                this.selectionLayer.changed();
                                this.clearLayer();
                                return;
                            }
                            const feature = mvtFeatures[0];
                            if (!feature) {
                                this.clearLayer();
                                return;
                            }
                            let localOlFeature = this.handleRenderFeature(feature);
                            localOlFeature.set('_isLabel', false);
                            const myLabelOlFeature = new OlFeature();
                            myLabelOlFeature.setProperties(localOlFeature.getProperties());
                            const labelGeom = localOlFeature.getGeometry().getType() === 'Point'
                                ? localOlFeature.getGeometry()
                                : new olgeom.Point(event.coordinate);
                            myLabelOlFeature.setGeometry(labelGeom);
                            myLabelOlFeature.setId(localOlFeature.getId());
                            myLabelOlFeature.set('_isLabel', true);
                            this.setLayerStyleFromOptions(myLayerVectorTile, myLabelOlFeature);
                            this.pointerHoverFeatureStore.load([myLabelOlFeature]);
                            this.selectionMVT[feature.getId()] = localOlFeature;
                            this.selectionLayer.changed();
                        });
                        igoLayer = myLayerVectorTile;
                    }
                }
            }, {
                hitTolerance: 10,
                layerFilter: (olLayer) => olLayer === topMostOlLayer
            });
        }, this.igoHoverFeatureDelay);
    }
    canProcessHover(igoLayer) {
        if (!igoLayer) {
            return false;
        }
        if (!igoLayer.visible) {
            return false;
        }
        if (!igoLayer.options) {
            return false;
        }
        if (!igoLayer.options.igoStyle?.styleByAttribute &&
            !igoLayer.options.igoStyle?.hoverStyle) {
            return false;
        }
        if (igoLayer.options.igoStyle?.styleByAttribute &&
            !igoLayer.options.igoStyle?.styleByAttribute.hoverStyle &&
            !igoLayer.options.igoStyle?.hoverStyle) {
            return false;
        }
        return true;
    }
    handleRenderFeature(feature) {
        let localFeature;
        if (feature instanceof RenderFeature) {
            localFeature = new OlFeature({
                geometry: this.getGeometry(feature)
            });
            localFeature.setId(feature.getId());
        }
        else if (feature instanceof OlFeature) {
            localFeature = feature;
        }
        localFeature.setProperties(feature.getProperties());
        return localFeature;
    }
    /**
     * Add a feature to the pointer store
     * @param text string
     */
    addFeatureOverlay(hoverEntity) {
        if (hoverEntity.length > 0) {
            const result = hoverEntity[0];
            this.clearLayer();
            const feature = new OlFeature({
                geometry: result.getGeometry(),
                meta: { id: this.hoverFeatureId },
                hoverSummary: this.getHoverSummary(result.getProperties())
            });
            this.store.setLayerOlFeatures([feature], FeatureMotion.None);
        }
    }
    setLayerStyleFromOptions(igoLayer, feature) {
        const resolution = this.store.layer.map.viewController.getResolution();
        if (igoLayer?.options?.igoStyle?.styleByAttribute?.hoverStyle) {
            this.store.layer.ol.setStyle(this.createHoverStyle(feature, igoLayer.options.igoStyle.styleByAttribute.hoverStyle, resolution));
            return;
        }
        if (igoLayer?.options?.igoStyle?.hoverStyle) {
            this.store.layer.ol.setStyle(this.createHoverStyle(feature, igoLayer.options.igoStyle.hoverStyle, resolution));
        }
    }
    getHoverSummary(properties) {
        let summary = '';
        for (const [key, value] of Object.entries(properties)) {
            if (!key.startsWith('_') && key !== 'geometry') {
                summary += `${key}: ${value}` + '\n';
            }
        }
        return summary.length >= 2 ? summary.slice(0, -2) : summary;
    }
    getGeometry(feature) {
        let geom;
        if (!feature.getOrientedFlatCoordinates) {
            geom = feature.getGeometry();
        }
        else {
            const coords = feature.getOrientedFlatCoordinates();
            const flatCoords = [];
            coords.forEach((c, idx) => {
                if (idx % 2 === 0) {
                    flatCoords.push([
                        parseFloat(coords[idx]),
                        parseFloat(coords[idx + 1])
                    ]);
                }
            });
            // TODO: test MultiX
            switch (feature.getType()) {
                case 'Point':
                    geom = new olgeom.Point(flatCoords);
                    break;
                case 'Polygon':
                    geom = new olgeom.Polygon([flatCoords]);
                    break;
                case 'LineString':
                    geom = new olgeom.LineString([flatCoords]);
                    break;
            }
        }
        return geom;
    }
    /**
     * Clear the pointer store features
     */
    clearLayer() {
        this.selectionMVT = {};
        if (this.selectionLayer) {
            this.selectionLayer.changed();
        }
        if (this.store) {
            this.store.clearLayer();
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: HoverFeatureDirective, deps: [{ token: MapBrowserComponent, self: true }, { token: i2.MediaService }, { token: StyleService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: HoverFeatureDirective, selector: "[igoHoverFeature]", inputs: { igoHoverFeatureDelay: "igoHoverFeatureDelay", igoHoverFeatureEnabled: "igoHoverFeatureEnabled" }, host: { listeners: { "mouseout": "mouseout()" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: HoverFeatureDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igoHoverFeature]'
                }]
        }], ctorParameters: function () { return [{ type: MapBrowserComponent, decorators: [{
                    type: Self
                }] }, { type: i2.MediaService }, { type: StyleService }]; }, propDecorators: { igoHoverFeatureDelay: [{
                type: Input
            }], igoHoverFeatureEnabled: [{
                type: Input
            }], mouseout: [{
                type: HostListener,
                args: ['mouseout']
            }] } });

/**
 * When injected, this service automatically registers and
 * projection defined in the application config. A custom projection
 * needs to be registered to be usable by OL.
 */
class ProjectionService {
    config;
    constructor(config) {
        this.config = config;
        const projections = this.config.getConfig('projections') || [];
        projections.forEach((projection) => {
            projection.alias = projection.alias ? projection.alias : projection.code;
            this.registerProjection(projection);
        });
        // register all utm zones
        for (let utmZone = 1; utmZone < 61; utmZone++) {
            const code = utmZone < 10 ? `EPSG:3260${utmZone}` : `EPSG:326${utmZone}`;
            const def = `+proj=utm +zone=${utmZone} +datum=WGS84 +units=m +no_defs`;
            const proj = { code, def, extent: undefined };
            this.registerProjection(proj);
        }
        // register all mtm zones
        for (let mtmZone = 1; mtmZone < 11; mtmZone++) {
            const code = mtmZone < 10 ? `EPSG:3218${mtmZone}` : `EPSG:321${80 + mtmZone}`;
            let lon0;
            if (Number(mtmZone) <= 2) {
                lon0 = -50 - Number(mtmZone) * 3;
            }
            else if (Number(mtmZone) >= 12) {
                lon0 = -81 - (Number(mtmZone) - 12) * 3;
            }
            else {
                lon0 = -49.5 - Number(mtmZone) * 3;
            }
            const def = `+proj=tmerc +lat_0=0 +lon_0=${lon0} +k=0.9999 +x_0=304800 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"`;
            const proj = { code, def, extent: undefined };
            this.registerProjection(proj);
        }
    }
    /**
     * Define a proj4 projection and register it in OL
     * @param projection Projection
     */
    registerProjection(projection) {
        proj4.defs(projection.code, projection.def);
        olproj4.register(proj4);
        if (projection.extent) {
            olproj.get(projection.code).setExtent(projection.extent);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ProjectionService, deps: [{ token: i2.ConfigService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ProjectionService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ProjectionService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i2.ConfigService }]; } });

/**
 * Return a number of zone MTM for a longitude for province of Quebec only
 * @param lon number
 * @returns zone
 */
function zoneMtm(lon) {
    let lonMin = -54;
    const lonMax = -81;
    if (lon < lonMax || lon > lonMin) {
        return 0;
    }
    else {
        const deltaLon = 3;
        let zone = 2;
        while (Math.abs(lon - lonMin) > deltaLon) {
            lonMin = lonMin - deltaLon;
            zone++;
        }
        return zone;
    }
}
/**
 * Return a number of zone UTM for a longitude
 * @param lon number
 * @returns zone
 */
function zoneUtm(lon) {
    let lonMin = -180;
    const lonMax = 180;
    const deltaLon = 6;
    let zone = 1;
    while (Math.abs(lon - lonMin) > deltaLon) {
        lonMin = lonMin + deltaLon;
        zone++;
    }
    return zone;
}
/**
 * Compute the contraints of projections
 * @param projectionsLimitations: ProjectionsLimitationsOptions
 * @returns projectionsContraints: ProjectionsLimitationsOptions
 */
function computeProjectionsConstraints(projectionsLimitations) {
    const mtmZone = projectionsLimitations.mtmZone;
    const utmZone = projectionsLimitations.utmZone;
    const projectionsConstraints = {
        projFromConfig: projectionsLimitations.projFromConfig === false ? false : true,
        nad83: projectionsLimitations.nad83 === false ? false : true,
        wgs84: projectionsLimitations.wgs84 === false ? false : true,
        webMercator: projectionsLimitations.webMercator === false ? false : true,
        utm: projectionsLimitations.utm === false ? false : true,
        mtm: projectionsLimitations.mtm === false ? false : true,
        utmZone: {
            minZone: utmZone && utmZone.minZone ? utmZone.minZone : 17,
            maxZone: utmZone && utmZone.maxZone ? utmZone.maxZone : 21
        },
        mtmZone: {
            minZone: mtmZone && mtmZone.minZone ? mtmZone.minZone : 2,
            maxZone: mtmZone && mtmZone.maxZone ? mtmZone.maxZone : 10
        }
    };
    return projectionsConstraints;
}

var InsertSourceInsertDBEnum;
(function (InsertSourceInsertDBEnum) {
    InsertSourceInsertDBEnum["System"] = "system";
    InsertSourceInsertDBEnum["User"] = "user";
})(InsertSourceInsertDBEnum || (InsertSourceInsertDBEnum = {}));

function olStyleToBasicIgoStyle(layer) {
    const layerOlStyle = layer.getStyle();
    if (typeof layerOlStyle === 'function' || layerOlStyle instanceof Array) {
        return;
    }
    const rStyle = {
        fill: {
            color: layerOlStyle.getFill().getColor()
        },
        stroke: {
            color: layerOlStyle.getStroke().getColor(),
            width: 2
        },
        circle: {
            fill: {
                color: layerOlStyle.getImage().getFill().getColor()
            },
            stroke: {
                color: layerOlStyle.getImage().getStroke().getColor(),
                width: 2
            },
            radius: 5
        }
    };
    return rStyle;
}

class VectorWatcher extends Watcher {
    id;
    loaded = 0;
    loading = 0;
    layer;
    constructor(layer) {
        super();
        this.layer = layer;
        this.id = uuid();
    }
    watch() {
        let olSource = this.layer.options.source.ol;
        if (this.layer.dataSource instanceof ClusterDataSource) {
            olSource = this.layer.options.source.options.source;
        }
        if (olSource.getUrl()) {
            olSource.on(`featuresloadstart`, (e) => this.handleLoadStart(e));
            olSource.on(`featuresloadend`, (e) => this.handleLoadEnd(e));
            olSource.on(`featuresloaderror`, (e) => this.handleLoadEnd(e));
        }
    }
    unwatch() {
        let olSource = this.layer.options.source.ol;
        if (this.layer.dataSource instanceof ClusterDataSource) {
            olSource = this.layer.options.source.options.source;
        }
        if (olSource.getUrl()) {
            olSource.un(`featuresloadstart`, (e) => this.handleLoadStart(e));
            olSource.un(`featuresloadend`, (e) => this.handleLoadEnd(e));
            olSource.un(`featuresloaderror`, (e) => this.handleLoadEnd(e));
        }
    }
    handleLoadStart(event) {
        this.loading += 1;
        this.status = SubjectStatus.Working;
    }
    handleLoadEnd(event) {
        this.loaded += 1;
        const loading = this.loading;
        if (this.loaded >= loading) {
            if (loading === this.loading) {
                this.status = SubjectStatus.Done;
                this.loaded = this.loading = 0;
            }
        }
    }
}

class VectorLayer extends Layer {
    messageService;
    authInterceptor;
    geoNetworkService;
    geoDBService;
    layerDBService;
    previousLoadExtent;
    previousLoadResolution;
    previousOgcFilters;
    xhrAccumulator = [];
    watcher;
    trackFeatureListenerId;
    get browsable() {
        return this.options.browsable !== false;
    }
    get exportable() {
        return this.options.exportable !== false;
    }
    constructor(options, messageService, authInterceptor, geoNetworkService, geoDBService, layerDBService) {
        super(options, messageService, authInterceptor, geoDBService, layerDBService);
        this.messageService = messageService;
        this.authInterceptor = authInterceptor;
        this.geoNetworkService = geoNetworkService;
        this.geoDBService = geoDBService;
        this.layerDBService = layerDBService;
        this.watcher = new VectorWatcher(this);
        this.status$ = this.watcher.status$;
    }
    createOlLayer() {
        const initialOpacityValue = this.options.opacity || 1;
        const initialVisibleValue = this.options.visible !== false;
        const initialMinResValue = this.options.minResolution ||
            getResolutionFromScale(Number(this.options.minScaleDenom));
        const initialMaxResValue = this.options.maxResolution ||
            getResolutionFromScale(Number(this.options.maxScaleDenom));
        const so = this.options.sourceOptions;
        if (this.dataSource instanceof FeatureDataSource) {
            if (so?.preload?.bypassResolution || so?.preload?.bypassVisible) {
                this.options.opacity = 0;
                if (so.preload.bypassResolution &&
                    (this.options.minResolution || this.options.maxResolution)) {
                    this.options.minResolution = 0;
                    this.options.maxResolution = Infinity;
                }
                if (so.preload.bypassVisible && !initialVisibleValue) {
                    this.options.visible = true;
                }
            }
        }
        const olOptions = Object.assign({}, this.options, {
            source: this.options.source.ol,
            sourceOptions: this.options.sourceOptions || this.options.source.options
        });
        if (this.options.animation) {
            this.dataSource.ol.on('addfeature', function (e) {
                this.flash(e.feature);
            }.bind(this));
        }
        if (this.options.idbInfo?.storeToIdb && this.geoDBService) {
            if (this.options.idbInfo.firstLoad) {
                this.maintainFeaturesInIdb();
            }
            this.dataSource.ol.once('featuresloadend', () => {
                this.dataSource.ol.on('addfeature', () => this.maintainFeaturesInIdb());
                this.dataSource.ol.on('changefeature', () => this.maintainFeaturesInIdb());
                this.dataSource.ol.on('clear', () => this.maintainFeaturesInIdb());
                this.dataSource.ol.on('removefeature', () => this.maintainFeaturesInIdb());
            });
        }
        if (this.dataSource instanceof FeatureDataSource &&
            (so?.preload?.bypassResolution || so?.preload?.bypassVisible)) {
            this.dataSource.ol.once('featuresloadend', () => {
                if (initialOpacityValue) {
                    this.opacity = initialOpacityValue;
                }
                if (so.preload.bypassResolution) {
                    this.minResolution = initialMinResValue;
                    this.maxResolution = initialMaxResValue;
                }
                if (so.preload.bypassVisible) {
                    this.visible = initialVisibleValue;
                }
            });
        }
        if (this.options.trackFeature) {
            this.enableTrackFeature(this.options.trackFeature);
        }
        const vector = new OlVectorLayer(olOptions);
        const vectorSource = vector.getSource();
        const url = vectorSource.getUrl();
        if (typeof url === 'function') {
            return vector;
        }
        if (url || olOptions.sourceOptions?.type === 'wfs') {
            let loader;
            const wfsOptions = olOptions.sourceOptions;
            if (wfsOptions?.type === 'wfs' &&
                (wfsOptions.params || wfsOptions.paramsWFS)) {
                loader = (extent, resolution, proj, success, failure) => {
                    this.customWFSLoader(vectorSource, wfsOptions, this.authInterceptor, extent, resolution, proj, success, failure);
                };
            }
            else {
                loader = (extent, resolution, proj, success, failure) => {
                    this.customLoader(vectorSource, url, this.authInterceptor, extent, resolution, proj, success, failure);
                };
            }
            if (loader) {
                vectorSource.setLoader(loader);
            }
        }
        else if (this.options.idbInfo?.storeToIdb && this.geoDBService) {
            const idbLoader = (extent, resolution, proj, success, failure) => {
                this.customIDBLoader(vectorSource, olOptions.id, extent, proj, success, failure);
            };
            if (idbLoader) {
                vectorSource.setLoader(idbLoader);
            }
        }
        if (this.options.idbInfo?.storeToIdb && this.geoDBService) {
            vector.once('sourceready', () => {
                if (this.options.idbInfo.firstLoad) {
                    this.maintainOptionsInIdb();
                }
                fromEvent(vector, 'change')
                    .pipe(debounceTime(750))
                    .subscribe(() => this.maintainOptionsInIdb());
                vector.on('change:zIndex', () => this.maintainOptionsInIdb());
            });
        }
        return vector;
    }
    removeLayerFromIDB() {
        if (this.geoDBService && this.layerDBService) {
            zip(this.geoDBService.deleteByKey(this.id), this.layerDBService.deleteByKey(this.id)).subscribe();
        }
    }
    maintainOptionsInIdb() {
        this.options.igoStyle.igoStyleObject = olStyleToBasicIgoStyle(this.ol);
        const layerData = ObjectUtils.removeUndefined({
            layerId: this.id,
            detailedContextUri: this.options.idbInfo.contextUri,
            sourceOptions: {
                id: this.id,
                type: 'vector',
                queryable: true
            },
            layerOptions: {
                workspace: this.options.workspace,
                zIndex: this.ol ? this.zIndex : 1000000,
                id: this.id,
                isIgoInternalLayer: this.isIgoInternalLayer,
                title: this.title,
                igoStyle: this.options.igoStyle,
                idbInfo: Object.assign({}, this.options.idbInfo, { firstLoad: false })
            },
            insertEvent: `${this.title}-${this.id}-${new Date()}`
        });
        this.layerDBService.update(layerData);
    }
    maintainFeaturesInIdb() {
        const dsFeatures = this.dataSource.ol.getFeatures();
        const geojsonObject = JSON.parse(new olformat.GeoJSON().writeFeatures(dsFeatures, {
            dataProjection: 'EPSG:4326',
            featureProjection: this.dataSource.ol.getProjection() || 'EPSG:3857'
        }));
        this.geoDBService.update(this.id, this.id, geojsonObject, InsertSourceInsertDBEnum.User, `${this.title}-${this.id}-${new Date()}`);
    }
    flash(feature) {
        const start = new Date().getTime();
        const listenerKey = this.ol.on('postrender', animate.bind(this));
        function animate(event) {
            const vectorContext = getVectorContext(event);
            const frameState = event.frameState;
            const flashGeom = feature.getGeometry().clone();
            const elapsed = frameState.time - start;
            const elapsedRatio = elapsed / this.options.animation.duration;
            const opacity = easeOut(1 - elapsedRatio);
            const newColor = asArray(this.options.animation.color || 'red');
            newColor[3] = opacity;
            let style = this.ol
                .getStyleFunction()
                .call(this, feature)
                .find((style2) => {
                return style2.getImage();
            });
            if (!style) {
                style = this.ol.getStyleFunction().call(this, feature)[0];
            }
            const styleClone = style.clone();
            switch (feature.getGeometry().getType()) {
                case 'Point':
                    if (styleClone.getImage() !== null &&
                        typeof styleClone.getImage().getRadius === 'function') {
                        const radius = easeOut(elapsedRatio) * (styleClone.getImage().getRadius() * 3);
                        styleClone.getImage().setRadius(radius);
                        styleClone.getImage().setOpacity(opacity);
                    }
                    break;
                case 'LineString':
                    // TODO
                    if (styleClone.getImage()) {
                        styleClone.getImage().getStroke().setColor(newColor);
                        styleClone
                            .getImage()
                            .getStroke()
                            .setWidth(easeOut(elapsedRatio) *
                            (styleClone.getImage().getStroke().getWidth() * 3));
                    }
                    if (styleClone.getStroke()) {
                        styleClone.getStroke().setColor(newColor);
                        styleClone
                            .getStroke()
                            .setWidth(easeOut(elapsedRatio) * (styleClone.getStroke().getWidth() * 3));
                    }
                    break;
                case 'Polygon':
                    // TODO
                    if (styleClone.getImage()) {
                        styleClone.getImage().getFill().setColor(newColor);
                    }
                    if (styleClone.getFill()) {
                        styleClone.getFill().setColor(newColor);
                    }
                    break;
            }
            styleClone.setText('');
            vectorContext.setStyle(styleClone);
            vectorContext.drawGeometry(flashGeom);
            if (elapsed > this.options.animation.duration) {
                unByKey(listenerKey);
                // remove last geometry
                // there is a little flash before feature disappear, better solution ?
                this.map.ol.render();
                return;
            }
            // tell OpenLayers to continue postcompose animation
            this.map.ol.render();
        }
    }
    setMap(map) {
        if (map === undefined) {
            this.watcher.unsubscribe();
        }
        else {
            this.watcher.subscribe(() => { });
        }
        super.setMap(map);
    }
    setExtent(extent) {
        this.options.extent = extent;
    }
    onUnwatch() {
        this.dataSource.onUnwatch();
        this.stopAnimation();
    }
    stopAnimation() {
        this.dataSource.ol.un('addfeature', function (e) {
            if (this.visible) {
                this.flash(e.feature);
            }
        }.bind(this));
    }
    enableTrackFeature(id) {
        this.trackFeatureListenerId = this.dataSource.ol.on('addfeature', this.trackFeature.bind(this, id));
    }
    centerMapOnFeature(id) {
        const feat = this.dataSource.ol.getFeatureById(id);
        if (feat) {
            this.map.ol
                .getView()
                .setCenter(feat.getGeometry().getCoordinates());
        }
    }
    trackFeature(id, feat) {
        if (feat.feature.getId() === id && this.visible) {
            this.centerMapOnFeature(id);
        }
    }
    disableTrackFeature(id) {
        unByKey(this.trackFeatureListenerId);
    }
    /**
     * Custom loader for a WFS datasource
     * @internal
     * @param vectorSource the vector source to be created
     * @param options olOptions from source
     * @param interceptor the interceptor of the data
     * @param extent the extent of the requested data
     * @param resolution the current resolution
     * @param proj the projection to retrieve the data
     * @param success success callback
     * @param failure failure callback
     * @param randomParam random parameter to ensure cache is not causing problems in retrieving new data
     */
    customWFSLoader(vectorSource, options, interceptor, extent, resolution, proj, success, failure, randomParam) {
        {
            const paramsWFS = options.paramsWFS;
            const wfsProj = paramsWFS.srsName
                ? new olProjection({ code: paramsWFS.srsName })
                : proj;
            const currentExtent = olproj.transformExtent(extent, proj, wfsProj);
            const ogcFilters = options.ogcFilters;
            if ((this.previousLoadExtent &&
                this.previousLoadExtent !== currentExtent) ||
                (this.previousLoadResolution &&
                    this.previousLoadResolution !== resolution) ||
                (this.previousOgcFilters && this.previousOgcFilters !== ogcFilters)) {
                vectorSource.removeLoadedExtent(this.previousLoadExtent);
                for (let xhr of this.xhrAccumulator) {
                    xhr.abort();
                }
            }
            this.previousLoadExtent = currentExtent;
            this.previousLoadResolution = resolution;
            this.previousOgcFilters = ogcFilters;
            paramsWFS.srsName = paramsWFS.srsName || proj.getCode();
            const url = buildUrl(options, currentExtent, wfsProj, ogcFilters, randomParam);
            let startIndex = 0;
            if (paramsWFS.version === '2.0.0' &&
                paramsWFS.maxFeatures > defaultMaxFeatures) {
                const nbOfFeature = 1000;
                while (startIndex < paramsWFS.maxFeatures) {
                    let alteredUrl = url.replace('count=' + paramsWFS.maxFeatures, 'count=' + nbOfFeature);
                    alteredUrl = alteredUrl.replace('startIndex=0', '0');
                    alteredUrl += '&startIndex=' + startIndex;
                    alteredUrl.replace(/&&/g, '&');
                    this.getFeatures(vectorSource, interceptor, currentExtent, wfsProj, proj, alteredUrl, success, failure);
                    startIndex += nbOfFeature;
                }
            }
            else {
                this.getFeatures(vectorSource, interceptor, currentExtent, wfsProj, proj, url, success, failure);
            }
        }
    }
    /**
     * Custom loader to get feature from a WFS datasource
     * @internal
     * @param vectorSource the vector source to be created
     * @param interceptor the interceptor of the data
     * @param extent the extent of the requested data
     * @param dataProjection the projection of the retrieved data
     * @param featureProjection the projection of the created features
     * @param url the url string to retrieve the data
     * @param success success callback
     * @param failure failure callback
     */
    getFeatures(vectorSource, interceptor, extent, dataProjection, featureProjection, url, success, failure) {
        const xhr = new XMLHttpRequest();
        const alteredUrlWithKeyAuth = interceptor.alterUrlWithKeyAuth(url);
        let modifiedUrl = url;
        if (alteredUrlWithKeyAuth) {
            modifiedUrl = alteredUrlWithKeyAuth;
        }
        xhr.open('GET', modifiedUrl);
        if (interceptor) {
            interceptor.interceptXhr(xhr, modifiedUrl);
        }
        const onError = () => {
            vectorSource.removeLoadedExtent(extent);
            failure();
        };
        xhr.onerror = onError;
        xhr.onload = () => {
            if (xhr.status === 200 && xhr.responseText.length > 0) {
                const features = vectorSource
                    .getFormat()
                    .readFeatures(xhr.responseText, {
                    dataProjection,
                    featureProjection
                });
                if (features) {
                    vectorSource.addFeatures(features);
                    success(features);
                }
                else {
                    success([]);
                }
            }
            else {
                onError();
            }
        };
        this.xhrAccumulator.push(xhr);
        xhr.send();
    }
    /**
     * Custom loader for vector layer.
     * @internal
     * @param vectorSource the vector source to be created
     * @param url the url string or function to retrieve the data
     * @param interceptor the interceptor of the data
     * @param extent the extent of the requested data
     * @param resolution the current resolution
     * @param projection the projection to retrieve the data
     */
    customLoader(vectorSource, url, interceptor, extent, resolution, projection, success, failure) {
        const xhr = new XMLHttpRequest();
        let modifiedUrl = url;
        if (typeof url !== 'function') {
            const alteredUrlWithKeyAuth = interceptor.alterUrlWithKeyAuth(url);
            if (alteredUrlWithKeyAuth) {
                modifiedUrl = alteredUrlWithKeyAuth;
            }
        }
        if (this.geoNetworkService && typeof url !== 'function') {
            const format = vectorSource.getFormat();
            const type = format.getType();
            let responseType = type;
            const onError = () => {
                vectorSource.removeLoadedExtent(extent);
                failure();
            };
            const options = { responseType };
            this.geoNetworkService.geoDBService
                .get(url)
                .pipe(delay(750))
                .pipe(concatMap((r) => r
                ? of(r)
                : this.geoNetworkService.get(modifiedUrl, options).pipe(first(), catchError((res) => {
                    onError();
                    throw res;
                }))))
                .subscribe((content) => {
                if (content) {
                    const format = vectorSource.getFormat();
                    const type = format.getType();
                    let source;
                    if (type === 'json' || type === 'text') {
                        source = content;
                    }
                    else if (type === 'xml') {
                        source = content;
                        if (!source) {
                            source = new DOMParser().parseFromString(content, 'application/xml');
                        }
                    }
                    else if (type === 'arraybuffer') {
                        source = content;
                    }
                    if (source) {
                        const features = format.readFeatures(source, {
                            extent,
                            featureProjection: projection
                        });
                        vectorSource.addFeatures(features);
                        success(features);
                    }
                    else {
                        onError();
                    }
                }
            });
        }
        else {
            xhr.open('GET', modifiedUrl);
            const format = vectorSource.getFormat();
            if (format.getType() === 'arraybuffer') {
                xhr.responseType = 'arraybuffer';
            }
            if (interceptor) {
                interceptor.interceptXhr(xhr, modifiedUrl);
            }
            const onError = () => {
                vectorSource.removeLoadedExtent(extent);
                failure();
            };
            xhr.onerror = onError;
            xhr.onload = () => {
                // status will be 0 for file:// urls
                if (!xhr.status || (xhr.status >= 200 && xhr.status < 300)) {
                    const type = format.getType();
                    let source;
                    if (type === 'json' || type === 'text') {
                        source = xhr.responseText;
                    }
                    else if (type === 'xml') {
                        source = xhr.responseXML;
                        if (!source) {
                            source = new DOMParser().parseFromString(xhr.responseText, 'application/xml');
                        }
                    }
                    else if (type === 'arraybuffer') {
                        source = xhr.response;
                    }
                    if (source) {
                        const features = format.readFeatures(source, {
                            extent,
                            featureProjection: projection
                        });
                        vectorSource.addFeatures(features);
                        success(features);
                    }
                    else {
                        onError();
                    }
                }
                else {
                    onError();
                }
            };
            xhr.send();
        }
    }
    /**
     * Custom loader for vector layer.
     * @internal
     * @param vectorSource the vector source to be created
     * @param layerID the url string or function to retrieve the data
     * @param interceptor the interceptor of the data
     * @param extent the extent of the requested data
     * @param resolution the current resolution
     * @param projection the projection to retrieve the data
     */
    customIDBLoader(vectorSource, layerID, extent, projection, success, failure) {
        if (this.geoNetworkService) {
            const onError = () => {
                vectorSource.removeLoadedExtent(extent);
                failure();
            };
            this.geoNetworkService.geoDBService.get(layerID).subscribe((content) => {
                if (content) {
                    const format = vectorSource.getFormat();
                    const type = format.getType();
                    let source;
                    if (type === 'json' || type === 'text') {
                        source = content;
                    }
                    else if (type === 'xml') {
                        source = content;
                        if (!source) {
                            source = new DOMParser().parseFromString(content, 'application/xml');
                        }
                    }
                    else if (type === 'arraybuffer') {
                        source = content;
                    }
                    if (source) {
                        const features = format.readFeatures(source, {
                            extent,
                            featureProjection: projection
                        });
                        vectorSource.addFeatures(features, format.readProjection(source));
                        success(features);
                    }
                    else {
                        onError();
                    }
                }
            });
        }
    }
}

class VectorTileLayer extends Layer {
    messageService;
    authInterceptor;
    watcher;
    constructor(options, messageService, authInterceptor) {
        super(options, messageService, authInterceptor);
        this.messageService = messageService;
        this.authInterceptor = authInterceptor;
        this.watcher = new TileWatcher(this);
        this.status$ = this.watcher.status$;
    }
    createOlLayer() {
        const olOptions = Object.assign({}, this.options, {
            source: this.options.source.ol
        });
        const vectorTile = new olLayerVectorTile(olOptions);
        const vectorTileSource = vectorTile.getSource();
        vectorTileSource.setTileLoadFunction((tile, url) => {
            const loader = this.customLoader(url, tile.getFormat(), this.authInterceptor, tile.onLoad.bind(tile));
            if (loader) {
                tile.setLoader(loader);
            }
        });
        return vectorTile;
    }
    /**
     * Custom loader for vector tile layer. Modified from the loadFeaturesXhr function in ol\featureloader.js
     * @internal
     * @param url the url string or function to retrieve the data
     * @param format the format of the tile
     * @param interceptor the interceptor of the data
     * @param success On success event action to trigger
     * @param failure On failure event action to trigger TODO
     */
    customLoader(url, format, interceptor, success, failure) {
        return (extent, resolution, projection) => {
            const xhr = new XMLHttpRequest();
            let modifiedUrl = url;
            if (typeof url !== 'function') {
                const alteredUrlWithKeyAuth = interceptor.alterUrlWithKeyAuth(url);
                if (alteredUrlWithKeyAuth) {
                    modifiedUrl = alteredUrlWithKeyAuth;
                }
            }
            else {
                modifiedUrl = url(extent, resolution, projection);
            }
            xhr.open('GET', modifiedUrl);
            if (interceptor) {
                interceptor.interceptXhr(xhr, modifiedUrl);
            }
            if (format.getType() === 'arraybuffer') {
                xhr.responseType = 'arraybuffer';
            }
            xhr.onload = (event) => {
                if (!xhr.status || (xhr.status >= 200 && xhr.status < 300)) {
                    const type = format.getType();
                    let source;
                    if (type === 'json' || type === 'text') {
                        source = xhr.responseText;
                    }
                    else if (type === 'xml') {
                        source = xhr.responseXML;
                        if (!source) {
                            source = new DOMParser().parseFromString(xhr.responseText, 'application/xml');
                        }
                    }
                    else if (type === 'arraybuffer') {
                        source = xhr.response;
                    }
                    if (source) {
                        success.call(this, format.readFeatures(source, {
                            extent,
                            featureProjection: projection
                        }), format.readProjection(source));
                    }
                    else {
                        // TODO
                        failure.call(this);
                    }
                }
                else {
                    // TODO
                    failure.call(this);
                }
            };
            xhr.onerror = () => {
                // TODO
                failure.call(this);
            };
            xhr.send();
        };
    }
    setMap(map) {
        if (map === undefined) {
            this.watcher.unsubscribe();
        }
        else {
            this.watcher.subscribe(() => { });
        }
        super.setMap(map);
    }
}

function getLinkedLayersOptions(layer) {
    return layer.options.linkedLayers;
}
function getIgoLayerByLinkId(map, id) {
    return map.layers.find((l) => l.options.linkedLayers?.linkId === id);
}
function layerHasLinkWithProperty(layer, property) {
    let hasLinkWithProperty = false;
    const layerLLOptions = getLinkedLayersOptions(layer);
    if (layerLLOptions?.links) {
        const link = layerLLOptions.links.find((l) => l.properties.includes(property));
        hasLinkWithProperty = link ? true : false;
    }
    return hasLinkWithProperty;
}
function layerHasLinkDeletion(layer) {
    let hasLinkWithSyncedDelete = false;
    const layerLLOptions = getLinkedLayersOptions(layer);
    if (layerLLOptions?.links) {
        const link = layerLLOptions.links.find((l) => l.syncedDelete);
        hasLinkWithSyncedDelete = link ? true : false;
    }
    return hasLinkWithSyncedDelete;
}
function getRootParentByProperty(map, layer, property) {
    let layerToUse = layer;
    let parentLayer = layerToUse;
    let hasParentLayer = true;
    while (hasParentLayer) {
        layerToUse = parentLayer;
        parentLayer = getDirectParentLayerByProperty(map, layerToUse, property);
        hasParentLayer = parentLayer ? true : false;
    }
    if (!hasParentLayer) {
        if (!layerHasLinkWithProperty(layerToUse, property)) {
            layerToUse = undefined;
        }
    }
    return hasParentLayer ? parentLayer : layerToUse;
}
function getDirectParentLayerByProperty(map, layer, property) {
    if (layer?.options.linkedLayers?.linkId) {
        const currentLinkId = layer.options.linkedLayers.linkId;
        let parents = map.layers.filter((pl) => {
            const linkedLayers = pl.options.linkedLayers;
            if (linkedLayers && linkedLayers.links) {
                const a = linkedLayers.links.find((l) => l.linkedIds.includes(currentLinkId) &&
                    l.properties.includes(property));
                return a;
            }
        });
        if (parents.length > 1) {
            console.warn(`Your layer ${layer.title || layer.id} must only have 1 parent (${parents.map((p) => p.title || p.id)})
            , The first parent (${parents[0].title || parents[0].id}) will be use to sync properties`);
        }
        return parents[0];
    }
}
function getDirectChildLayersByProperty(map, layer, property) {
    let linkedIds = [];
    if (layer?.options.linkedLayers?.links) {
        layer.options.linkedLayers.links
            .filter((l) => l.properties.includes(property))
            .map((link) => {
            linkedIds = linkedIds.concat(link.linkedIds);
        });
    }
    return linkedIds.map((lid) => getIgoLayerByLinkId(map, lid));
}
function getAllChildLayersByProperty(map, layer, knownChildLayers, property) {
    let childLayers = getDirectChildLayersByProperty(map, layer, property);
    childLayers.map((cl) => {
        knownChildLayers.push(cl);
        const directChildLayers = getDirectChildLayersByProperty(map, cl, property);
        if (directChildLayers) {
            getAllChildLayersByProperty(map, cl, knownChildLayers, property);
        }
    });
    return knownChildLayers;
}
function getRootParentByDeletion(map, layer) {
    let layerToUse = layer;
    let parentLayer = layerToUse;
    let hasParentLayer = true;
    while (hasParentLayer) {
        layerToUse = parentLayer;
        parentLayer = getDirectParentLayerByDeletion(map, layerToUse);
        hasParentLayer = parentLayer ? true : false;
    }
    if (!hasParentLayer) {
        if (!layerHasLinkDeletion(layerToUse)) {
            layerToUse = undefined;
        }
    }
    return hasParentLayer ? parentLayer : layerToUse;
}
function getDirectParentLayerByDeletion(map, layer) {
    if (layer.options.linkedLayers?.linkId) {
        const currentLinkId = layer.options.linkedLayers.linkId;
        let parents = map.layers.filter((pl) => {
            const linkedLayers = pl.options.linkedLayers;
            if (linkedLayers && linkedLayers.links) {
                const a = linkedLayers.links.find((l) => l.linkedIds.includes(currentLinkId) && l.syncedDelete);
                return a;
            }
        });
        if (parents.length > 1) {
            console.warn(`Your layer ${layer.title || layer.id} must only have 1 parent (${parents.map((p) => p.title || p.id)})
          , The first parent (${parents[0].title || parents[0].id}) will be use to sync properties`);
        }
        return parents[0];
    }
}
function getDirectChildLayersByDeletion(map, layer) {
    let linkedIds = [];
    if (layer?.options.linkedLayers?.links) {
        layer.options.linkedLayers.links
            .filter((l) => l.syncedDelete)
            .map((link) => {
            linkedIds = linkedIds.concat(link.linkedIds);
        });
    }
    return linkedIds.map((lid) => getIgoLayerByLinkId(map, lid));
}
function getAllChildLayersByDeletion(map, layer, knownChildLayers) {
    let childLayers = getDirectChildLayersByDeletion(map, layer);
    childLayers.map((cl) => {
        knownChildLayers.push(cl);
        const directChildLayers = getDirectChildLayersByDeletion(map, cl);
        if (directChildLayers) {
            getAllChildLayersByDeletion(map, cl, knownChildLayers);
        }
    });
    return knownChildLayers;
}
function initLayerSyncFromRootParentLayers(map, layers) {
    const rootLayersByProperty = {};
    const keys = Object.keys(LinkedProperties);
    keys.map((k) => {
        rootLayersByProperty[LinkedProperties[k]] = [];
    });
    layers
        .filter((l) => getLinkedLayersOptions(l))
        .map((l) => {
        keys.map((key) => {
            const k = LinkedProperties[key];
            const plbp = getRootParentByProperty(map, l, k);
            const layers = rootLayersByProperty[k];
            const layersId = layers.map((l) => l.id);
            if (plbp && !layersId.includes(plbp.id)) {
                rootLayersByProperty[k].push(plbp);
            }
        });
    });
    Object.keys(rootLayersByProperty).map((k) => {
        const layers = rootLayersByProperty[k];
        layers.map((l) => l.ol.notify(k, undefined));
    });
}
function handleLayerPropertyChange(map, propertyChange, initiatorIgoLayer) {
    if (!propertyChange) {
        return;
    }
    const ogcFilterWriter = new OgcFilterWriter();
    let isLayerProperty = true;
    let isDatasourceProperty = true;
    const key = propertyChange.key;
    let newValue;
    if (key === 'ogcFilters') {
        isLayerProperty = false;
        isDatasourceProperty = true;
        newValue = initiatorIgoLayer.dataSource.options.ogcFilters;
    }
    else if (key === 'timeFilter') {
        isLayerProperty = false;
        isDatasourceProperty = true;
        newValue = initiatorIgoLayer.dataSource.options.timeFilter;
    }
    else {
        isLayerProperty = true;
        isDatasourceProperty = false;
        newValue = initiatorIgoLayer.ol.get(key);
    }
    const initiatorLinkedLayersOptions = getLinkedLayersOptions(initiatorIgoLayer);
    if (initiatorLinkedLayersOptions) {
        let rootParentByProperty = getRootParentByProperty(map, initiatorIgoLayer, key);
        if (!rootParentByProperty) {
            rootParentByProperty = initiatorIgoLayer;
        }
        const clbp = [rootParentByProperty];
        getAllChildLayersByProperty(map, rootParentByProperty, clbp, key);
        let resolutionPropertyHasChanged = false;
        const initiatorIgoLayerSourceType = initiatorIgoLayer.options.source.options.type;
        const initiatorIgoLayerOgcFilterableDataSourceOptions = initiatorIgoLayer
            .dataSource.options;
        clbp.map((l) => {
            if (initiatorIgoLayer &&
                l &&
                getUid(initiatorIgoLayer.ol) !== getUid(l?.ol)) {
                const lLayerType = l.options.source.options.type;
                if (isLayerProperty) {
                    l.ol.set(key, newValue, true);
                    if (key === 'visible') {
                        l.visible$.next(newValue);
                    }
                    if (key === 'minResolution' || key === 'maxResolution') {
                        resolutionPropertyHasChanged = true;
                    }
                }
                else if (isDatasourceProperty) {
                    if (key === 'ogcFilters') {
                        l.dataSource.setOgcFilters(newValue, false);
                        if (lLayerType === 'wfs') {
                            l.ol.getSource().refresh();
                        }
                        if (lLayerType === 'wms') {
                            let appliedOgcFilter;
                            if (initiatorIgoLayerSourceType === 'wfs') {
                                appliedOgcFilter = ogcFilterWriter.handleOgcFiltersAppliedValue(initiatorIgoLayerOgcFilterableDataSourceOptions, initiatorIgoLayer.dataSource.options
                                    .fieldNameGeometry, undefined, map.viewController.getOlProjection());
                            }
                            else if (initiatorIgoLayerSourceType === 'wms') {
                                appliedOgcFilter = initiatorIgoLayer.dataSource.ol.getParams().FILTER;
                            }
                            l.dataSource.ol.updateParams({
                                FILTER: appliedOgcFilter
                            });
                        }
                    }
                    else if (l.dataSource instanceof WMSDataSource &&
                        key === 'timeFilter') {
                        l.dataSource.setTimeFilter(newValue, false);
                        const appliedTimeFilter = initiatorIgoLayer.ol.getSource().getParams().TIME;
                        l.dataSource.ol.updateParams({ TIME: appliedTimeFilter });
                    }
                }
            }
        });
        if (resolutionPropertyHasChanged) {
            map.viewController.resolution$.next(map.viewController.resolution$.value);
        }
    }
}

var LayerListControlsEnum;
(function (LayerListControlsEnum) {
    LayerListControlsEnum["always"] = "always";
    LayerListControlsEnum["never"] = "never";
    LayerListControlsEnum["default"] = "default";
})(LayerListControlsEnum || (LayerListControlsEnum = {}));
var LayerListSelectVisibleEnum;
(function (LayerListSelectVisibleEnum) {
    LayerListSelectVisibleEnum["ALL_VISIBLE"] = "ALL_VISIBLE";
    LayerListSelectVisibleEnum["ALL_HIDDEN"] = "ALL_HIDDEN";
    LayerListSelectVisibleEnum["MIXED"] = "MIXED";
    LayerListSelectVisibleEnum["NULL"] = "NULL";
})(LayerListSelectVisibleEnum || (LayerListSelectVisibleEnum = {}));
var LayerListDisplacement;
(function (LayerListDisplacement) {
    LayerListDisplacement["Raise"] = "raise";
    LayerListDisplacement["Lower"] = "lower";
})(LayerListDisplacement || (LayerListDisplacement = {}));

// TODO: This class could use a clean up. Also, some methods could be moved ealsewhere
class LayerListComponent {
    elRef;
    orderable = true;
    thresholdToFilterAndSort = 5;
    layers$ = new BehaviorSubject([]);
    change$ = new ReplaySubject(1);
    showToolbar$ = new BehaviorSubject(false);
    layerTool;
    hideSelectedLayers = true;
    activeLayer$ = new BehaviorSubject(undefined);
    layersChecked = [];
    selection;
    change$$;
    layers$$;
    layerItemChangeDetection$ = new BehaviorSubject(undefined);
    templateLayerToolbar;
    layersAreAllVisible = true;
    ogcButton = true;
    timeButton = true;
    get map() {
        return this._map;
    }
    set map(value) {
        this._map = value;
    }
    _map;
    set layers(value) {
        this._layers = this.removeProblemLayerInList(value);
        this.next();
    }
    get layers() {
        return this._layers;
    }
    _layers;
    set activeLayer(value) {
        this._activeLayer = value;
        this.activeLayer$.next(value);
    }
    get activeLayer() {
        return this._activeLayer;
    }
    _activeLayer;
    floatLabel = 'auto';
    layerFilterAndSortOptions = {};
    excludeBaseLayers = false;
    toggleLegendOnVisibilityChange = false;
    expandLegendOfVisibleLayers = false;
    updateLegendOnResolutionChange = false;
    queryBadge = false;
    appliedFilterAndSort = new EventEmitter();
    get keyword() {
        return this._keyword;
    }
    set keyword(value) {
        this._keyword = value;
        this.next();
    }
    _keyword = undefined;
    get onlyVisible() {
        return this._onlyVisible;
    }
    set onlyVisible(value) {
        this._onlyVisible = value;
        this.next();
    }
    _onlyVisible = false;
    get sortAlpha() {
        return this._sortedAlpha;
    }
    set sortAlpha(value) {
        this._sortedAlpha = value;
        this.next();
    }
    _sortedAlpha = false;
    get opacity() {
        return Math.round(this.activeLayer$.getValue().opacity * 100);
    }
    set opacity(opacity) {
        this.activeLayer$.getValue().opacity = opacity / 100;
    }
    get badgeOpacity() {
        if (this.opacity === 100) {
            return;
        }
        return this.opacity;
    }
    get raiseDisabled() {
        if (!this.orderable ||
            this.activeLayer.baseLayer ||
            this.getUpperLayer().id === this.activeLayer.id ||
            this.isUpperBaselayer(this.activeLayer)) {
            return true;
        }
        return false;
    }
    get lowerDisabled() {
        if (!this.orderable ||
            this.activeLayer.baseLayer ||
            this.getLowerLayer().id === this.activeLayer.id ||
            this.isLowerBaselayer(this.activeLayer)) {
            return true;
        }
        return false;
    }
    get raiseDisabledSelection() {
        if (this.layersChecked.length === 0 ||
            !this.orderable ||
            !this.raisableLayers(this.layersChecked) ||
            this.selectAllCheck === true) {
            return true;
        }
        return false;
    }
    get lowerDisabledSelection() {
        if (this.layersChecked.length === 0 ||
            !this.orderable ||
            !this.lowerableLayers(this.layersChecked) ||
            this.selectAllCheck === true) {
            return true;
        }
        return false;
    }
    get checkOpacity() {
        return this.layersCheckedOpacity() * 100;
    }
    set checkOpacity(opacity) {
        for (const layer of this.layersChecked) {
            layer.opacity = opacity / 100;
        }
    }
    get layerListDisplacement() {
        return LayerListDisplacement;
    }
    toggleOpacity = false;
    selectAllCheck;
    selectAllCheck$ = new BehaviorSubject(undefined);
    selectAllCheck$$;
    constructor(elRef) {
        this.elRef = elRef;
    }
    /**
     * Subscribe to the search term stream and trigger researches
     * @internal
     */
    ngOnInit() {
        this.change$$ = this.change$
            .pipe(debounce(() => {
            return this.layers.length === 0 ? EMPTY : timer(50);
        }))
            .subscribe(() => {
            this.showToolbar$.next(this.computeShowToolbar());
            this.layers$.next(this.computeLayers(this.layers.slice(0)));
            this.appliedFilterAndSort.emit({
                keyword: this.keyword,
                sortAlpha: this.sortAlpha,
                onlyVisible: this.onlyVisible
            });
        });
        this.selectAllCheck$$ = this.selectAllCheck$.subscribe((value) => {
            this.selectAllCheck = value;
        });
        this.layers$$ = this.layers$.subscribe(() => {
            if (this.layers) {
                let checks = 0;
                for (const layer of this.layers) {
                    layer.status$.subscribe((valStatus) => {
                        if (valStatus === 0) {
                            this.map.removeLayer(layer);
                        }
                    });
                    if (layer.options.active) {
                        this.activeLayer = layer;
                        this.layerTool = true;
                    }
                    if (layer.options.check) {
                        checks += 1;
                    }
                }
                if (this.excludeBaseLayers) {
                    this.selectAllCheck =
                        checks ===
                            this.layers.filter((lay) => lay.baseLayer !== true && lay.showInLayerList).length
                            ? true
                            : false;
                }
                else {
                    this.selectAllCheck =
                        checks === this.layers.filter((lay) => lay.showInLayerList).length
                            ? true
                            : false;
                }
            }
        });
    }
    ngOnDestroy() {
        this.change$$.unsubscribe();
        this.selectAllCheck$$.unsubscribe();
        this.layers$$.unsubscribe();
    }
    activeLayerExtentIsValid(layer) {
        let valid = false;
        if (layer.options.showButtonZoomToExtent === false) {
            return false;
        }
        const layerExtent = layer.options.extent;
        const maxLayerZoomExtent = this.map.viewController.maxLayerZoomExtent;
        if (layerExtent) {
            if (maxLayerZoomExtent) {
                valid = olextent.containsExtent(maxLayerZoomExtent, layerExtent);
            }
            else {
                valid = true;
            }
        }
        return valid;
    }
    activeLayersExtentAreValid(layers) {
        let valid = false;
        const layersExtent = olextent.createEmpty();
        const maxLayerZoomExtent = this.map.viewController.maxLayerZoomExtent;
        for (const layer of layers) {
            const layerExtent = layer.options.extent;
            if (layerExtent && !layerExtent.includes(Infinity)) {
                olextent.extend(layersExtent, layerExtent);
            }
        }
        if (!olextent.isEmpty(layersExtent)) {
            if (maxLayerZoomExtent) {
                valid = olextent.containsExtent(maxLayerZoomExtent, layersExtent);
            }
            else {
                valid = true;
            }
        }
        return valid;
    }
    zoomLayerExtents(layer) {
        this.map.viewController.zoomToExtent(layer.options.extent);
    }
    zoomLayersExtents(layers) {
        const layersExtent = olextent.createEmpty();
        for (const layer of layers) {
            const layerExtent = layer.options.extent;
            if (layerExtent) {
                olextent.extend(layersExtent, layerExtent);
            }
        }
        this.map.viewController.zoomToExtent(layersExtent);
    }
    changeOpacity(event) {
        this.opacity = event.value;
    }
    clearKeyword() {
        this.keyword = undefined;
    }
    getLowerLayer() {
        return this.layers
            .filter((l) => !l.baseLayer)
            .reduce((prev, current) => {
            return prev.zIndex < current.zIndex ? prev : current;
        }, { zIndex: undefined, id: undefined });
    }
    isLowerBaselayer(layer) {
        const index = this.layers.findIndex((lay) => layer.id === lay.id);
        if (this.layers &&
            this.layers[index + 1] &&
            this.layers[index + 1].baseLayer === true) {
            return true;
        }
        return false;
    }
    getUpperLayer() {
        return this.layers
            .filter((l) => !l.baseLayer)
            .reduce((prev, current) => {
            return prev.zIndex > current.zIndex ? prev : current;
        }, { zIndex: undefined, id: undefined });
    }
    isUpperBaselayer(layer) {
        const index = this.layers.findIndex((lay) => layer.id === lay.id);
        if (this.layers &&
            this.layers[index - 1] &&
            this.layers[index - 1].baseLayer === true) {
            return true;
        }
        return false;
    }
    moveActiveLayer(activeLayer, actiontype, fromUi = false) {
        const sortedLayersToMove = [];
        getRootParentByProperty(this.map, activeLayer, LinkedProperties.ZINDEX);
        let rootParentByProperty = getRootParentByProperty(this.map, activeLayer, LinkedProperties.ZINDEX);
        if (!rootParentByProperty) {
            rootParentByProperty = activeLayer;
        }
        const layersToMove = [rootParentByProperty];
        getAllChildLayersByProperty(this.map, rootParentByProperty, layersToMove, LinkedProperties.ZINDEX);
        this.layers.map((layer) => {
            if (layersToMove.indexOf(layer) !== -1) {
                sortedLayersToMove.push(layer);
            }
        });
        if (actiontype === LayerListDisplacement.Raise) {
            this.raiseLayers(sortedLayersToMove, fromUi);
        }
        else if (actiontype === LayerListDisplacement.Lower) {
            this.lowerLayers(sortedLayersToMove, fromUi);
        }
    }
    /*
     * For selection mode disabled attribute
     */
    raisableLayers(layers) {
        let response = false;
        let base = 0;
        for (const layer of layers) {
            const mapIndex = this.layers.findIndex((lay) => layer.id === lay.id);
            const currentLayer = this.layers[mapIndex];
            if (currentLayer.baseLayer) {
                base += 1;
            }
            const previousLayer = this.layers[mapIndex - 1];
            if (previousLayer &&
                previousLayer.baseLayer !== true &&
                !layers.find((lay) => previousLayer.id === lay.id) &&
                currentLayer.baseLayer !== true) {
                response = true;
            }
        }
        if ((this.layersChecked.length === 1 && this.layersChecked[0].baseLayer) ||
            base === this.layersChecked.length) {
            response = false;
        }
        return response;
    }
    /*
     * When multiple layers is selected but some may be allow to move
     */
    raisableLayer(index) {
        if (index < 1) {
            return false;
        }
        if (this.layers[index - 1].options.check) {
            return this.raisableLayer(index - 1);
        }
        return true;
    }
    raiseLayers(layers, fromUi = true) {
        const layersToRaise = [];
        for (const layer of layers) {
            const index = this.layers.findIndex((lay) => lay.id === layer.id);
            if (this.raisableLayer(index)) {
                layersToRaise.push(layer);
            }
        }
        this.map.raiseLayers(layersToRaise);
        if (fromUi) {
            setTimeout(() => {
                const checkItems = this.elRef.nativeElement.getElementsByClassName('mat-checkbox-checked');
                const itemFocused = this.elRef.nativeElement.getElementsByClassName('igo-layer-item-focused');
                let targetToScroll;
                if (checkItems.length) {
                    targetToScroll = checkItems[0];
                }
                if (itemFocused.length) {
                    targetToScroll = itemFocused[0];
                }
                if (targetToScroll) {
                    scrollIntoView(targetToScroll, {
                        scrollMode: 'if-needed',
                        behavior: 'smooth',
                        block: 'end',
                        inline: 'nearest'
                    });
                }
            }, 100);
        }
    }
    /*
     * For selection mode disabled attribute
     */
    lowerableLayers(layers) {
        let response = false;
        let base = 0;
        for (const layer of layers) {
            const mapIndex = this.layers.findIndex((lay) => layer.id === lay.id);
            const currentLayer = this.layers[mapIndex];
            if (currentLayer.baseLayer) {
                base += 1;
            }
            const nextLayer = this.layers[mapIndex + 1];
            if (nextLayer &&
                nextLayer.baseLayer !== true &&
                !layers.find((lay) => nextLayer.id === lay.id)) {
                response = true;
            }
        }
        if ((this.layersChecked.length === 1 && this.layersChecked[0].baseLayer) ||
            base === this.layersChecked.length) {
            response = false;
        }
        return response;
    }
    /*
     * When multiple layers is selected but some may be allow to move
     */
    lowerableLayer(index) {
        if (index >
            this.layers.filter((lay) => lay.baseLayer !== true).length - 2) {
            return false;
        }
        if (this.layers[index + 1].options.check) {
            return this.lowerableLayer(index + 1);
        }
        return true;
    }
    lowerLayers(layers, fromUi = true) {
        const layersToLower = [];
        for (const layer of layers) {
            const index = this.layers.findIndex((lay) => lay.id === layer.id);
            if (this.lowerableLayer(index)) {
                layersToLower.push(layer);
            }
        }
        this.map.lowerLayers(layersToLower);
        if (fromUi) {
            setTimeout(() => {
                const checkItems = this.elRef.nativeElement.getElementsByClassName('mat-checkbox-checked');
                const itemFocused = this.elRef.nativeElement.getElementsByClassName('igo-layer-item-focused');
                let targetToScroll;
                if (checkItems.length) {
                    targetToScroll = checkItems[checkItems.length - 1];
                }
                if (itemFocused.length) {
                    targetToScroll = itemFocused[0];
                }
                if (targetToScroll) {
                    scrollIntoView(targetToScroll, {
                        scrollMode: 'if-needed',
                        behavior: 'smooth',
                        block: 'end',
                        inline: 'nearest'
                    });
                }
            }, 100);
        }
    }
    next() {
        this.change$.next();
    }
    computeLayers(layers) {
        let layersOut = this.filterLayers(layers);
        if (this.sortAlpha) {
            layersOut = this.sortLayersByTitle(layersOut);
        }
        else {
            layersOut = this.sortLayersByZindex(layersOut);
        }
        return layersOut;
    }
    onKeywordChange(term) {
        this.keyword = term;
    }
    onAppliedFilterAndSortChange(appliedFilter) {
        this.keyword = appliedFilter.keyword;
        this.onlyVisible = appliedFilter.onlyVisible;
        this.sortAlpha = appliedFilter.sortAlpha;
    }
    filterLayers(layers) {
        if (this.layerFilterAndSortOptions.showToolbar === LayerListControlsEnum.never) {
            return layers;
        }
        if (!this.keyword && !this.onlyVisible) {
            return layers;
        }
        const keepLayerIds = layers.map((layer) => layer.id);
        layers.forEach((layer) => {
            const layerOptions = layer.options || {};
            const dataSourceOptions = layer.dataSource.options || {};
            const metadata = layerOptions.metadata || {};
            const keywords = metadata.keywordList || [];
            const layerKeywords = keywords.map((kw) => {
                return kw.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
            });
            if (this.keyword && layer.title) {
                const localKeyword = this.keyword
                    .normalize('NFD')
                    .replace(/[\u0300-\u036f]/g, '');
                const layerTitle = layer.title
                    .normalize('NFD')
                    .replace(/[\u0300-\u036f]/g, '');
                const dataSourceType = dataSourceOptions.type || '';
                const keywordRegex = new RegExp(localKeyword, 'gi');
                const keywordInList = layerKeywords.find((kw) => keywordRegex.test(kw)) !==
                    undefined;
                if (!keywordRegex.test(layerTitle) &&
                    !(this.keyword.toLowerCase() === dataSourceType.toLowerCase()) &&
                    !keywordInList) {
                    const index = keepLayerIds.indexOf(layer.id);
                    if (index > -1) {
                        keepLayerIds.splice(index, 1);
                    }
                }
            }
            if (this.onlyVisible && layer.visible === false) {
                const index = keepLayerIds.indexOf(layer.id);
                if (index > -1) {
                    keepLayerIds.splice(index, 1);
                }
            }
        });
        return layers.filter((layer) => keepLayerIds.indexOf(layer.id) !== -1);
    }
    sortLayersByZindex(layers) {
        return layers.sort((layer1, layer2) => layer2.zIndex - layer1.zIndex);
    }
    sortLayersByTitle(layers) {
        return layers.sort((a, b) => {
            if (this.normalize(a.title) < this.normalize(b.title)) {
                return -1;
            }
            if (this.normalize(a.title) > this.normalize(b.title)) {
                return 1;
            }
            return 0;
        });
    }
    normalize(str) {
        return str
            .normalize('NFD')
            .replace(/[\u0300-\u036f]/g, '')
            .toLowerCase();
    }
    computeShowToolbar() {
        switch (this.layerFilterAndSortOptions.showToolbar) {
            case LayerListControlsEnum.always:
                return true;
            case LayerListControlsEnum.never:
                return false;
            default:
                if (this.layers.length >= this.thresholdToFilterAndSort ||
                    this.keyword ||
                    this.onlyVisible) {
                    return true;
                }
                return false;
        }
    }
    toggleLayerTool(layer) {
        this.toggleOpacity = false;
        if (this.layerTool && layer === this.activeLayer) {
            this.layerTool = false;
        }
        else {
            this.layerTool = true;
        }
        for (const lay of this.layers) {
            lay.options.active = false;
        }
        layer.options.active = true;
        this.activeLayer = layer;
    }
    removeLayers(layers) {
        if (layers && layers.length > 0) {
            this.layersChecked = [];
            for (const layer of layers) {
                if (layer.options.removable !== false) {
                    layer.map.removeLayer(layer);
                }
                else {
                    this.layersChecked.push(layer);
                }
            }
        }
        else if (!layers && this.activeLayer.options.removable !== false) {
            this.activeLayer.map.removeLayer(this.activeLayer);
            this.layerTool = false;
        }
    }
    toggleVisibility(layers) {
        if (layers && layers.length > 0) {
            for (const layer of layers) {
                layer.visible = this.hideSelectedLayers;
            }
        }
        this.layerItemChangeDetection$.next(true);
    }
    isLayerRemovable(layer) {
        return layer.options.removable !== false;
    }
    isAllLayersRemovable(layers) {
        return layers.every((l) => this.isLayerRemovable(l));
    }
    get statusSelectedLayersCheck() {
        let statusSelectedLayers = LayerListSelectVisibleEnum.NULL;
        let findTrue = false;
        let findFalse = false;
        if (this.layersChecked.length === 0) {
            statusSelectedLayers = LayerListSelectVisibleEnum.NULL;
        }
        else {
            statusSelectedLayers = LayerListSelectVisibleEnum.MIXED;
            this.hideSelectedLayers = false;
            for (const layer2 of this.layersChecked) {
                if (layer2.visible === true) {
                    findTrue = true;
                }
                if (layer2.visible === false) {
                    findFalse = true;
                }
            }
            if (findTrue === true && findFalse === false) {
                statusSelectedLayers = LayerListSelectVisibleEnum.ALL_VISIBLE;
            }
            if (findTrue === false && findFalse === true) {
                statusSelectedLayers = LayerListSelectVisibleEnum.ALL_HIDDEN;
                this.hideSelectedLayers = true;
            }
        }
        return statusSelectedLayers;
    }
    layersCheck(event) {
        event.layer.options.check = event.check;
        if (event.check === true) {
            const eventMapIndex = this.layers.findIndex((layer) => event.layer.id === layer.id);
            for (const layer of this.layersChecked) {
                const mapIndex = this.layers.findIndex((lay) => layer.id === lay.id);
                if (eventMapIndex < mapIndex) {
                    this.layersChecked.splice(this.layersChecked.findIndex((lay) => layer.id === lay.id), 0, event.layer);
                    if (this.excludeBaseLayers) {
                        if (this.layersChecked.length ===
                            this.layers.filter((lay) => lay.baseLayer !== true && lay.showInLayerList).length) {
                            this.selectAllCheck = true;
                        }
                        else {
                            this.selectAllCheck = false;
                        }
                    }
                    else if (!this.excludeBaseLayers) {
                        if (this.layersChecked.length ===
                            this.layers.filter((lay) => lay.showInLayerList).length) {
                            this.selectAllCheck = true;
                        }
                        else {
                            this.selectAllCheck = false;
                        }
                    }
                    return;
                }
            }
            this.layersChecked.push(event.layer);
        }
        else {
            const index = this.layersChecked.findIndex((layer) => event.layer.id === layer.id);
            this.layersChecked.splice(index, 1);
        }
        if (this.excludeBaseLayers) {
            if (this.layersChecked.length ===
                this.layers.filter((lay) => lay.baseLayer !== true && lay.showInLayerList).length) {
                this.selectAllCheck = true;
            }
            else {
                this.selectAllCheck = false;
            }
        }
        else if (!this.excludeBaseLayers) {
            if (this.layersChecked.length ===
                this.layers.filter((lay) => lay.showInLayerList).length) {
                this.selectAllCheck = true;
            }
            else {
                this.selectAllCheck = false;
            }
        }
    }
    toggleSelectionMode(value) {
        this.selection = value;
        this.activeLayer = undefined;
        if (value === true) {
            this.layerTool = false;
            for (const layer of this.layers) {
                if (layer.options.check) {
                    this.layersChecked.push(layer);
                }
            }
        }
    }
    layersCheckedOpacity() {
        if (this.layersChecked.length > 1) {
            return 1;
        }
        else {
            const opacity = [];
            for (const layer of this.layersChecked) {
                opacity.push(layer.opacity);
            }
            return opacity;
        }
    }
    selectAll() {
        if (!this.selectAllCheck) {
            for (const layer of this.layers) {
                if (this.excludeBaseLayers &&
                    layer.baseLayer !== true &&
                    layer.showInLayerList) {
                    layer.options.check = true;
                    this.layersChecked.push(layer);
                }
                else if (!this.excludeBaseLayers && layer.showInLayerList) {
                    layer.options.check = true;
                    this.layersChecked.push(layer);
                }
            }
            this.selectAllCheck$.next(true);
        }
        else {
            for (const layer of this.layers) {
                layer.options.check = false;
            }
            this.layersChecked = [];
            this.selectAllCheck$.next(false);
        }
    }
    isScrolledIntoView(elemSource, elem) {
        const docViewTop = elemSource.scrollTop;
        const docViewBottom = docViewTop + elemSource.clientHeight;
        const elemTop = elem.offsetTop;
        const elemBottom = elemTop + elem.clientHeight;
        return elemBottom <= docViewBottom && elemTop >= docViewTop;
    }
    removeProblemLayerInList(layersList) {
        for (const layer of layersList) {
            if (layer.olLoadingProblem === true) {
                this.map.removeLayer(layer);
            }
        }
        return layersList;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LayerListComponent, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: LayerListComponent, selector: "igo-layer-list", inputs: { layersAreAllVisible: "layersAreAllVisible", ogcButton: "ogcButton", timeButton: "timeButton", map: "map", layers: "layers", floatLabel: "floatLabel", layerFilterAndSortOptions: "layerFilterAndSortOptions", excludeBaseLayers: "excludeBaseLayers", toggleLegendOnVisibilityChange: "toggleLegendOnVisibilityChange", expandLegendOfVisibleLayers: "expandLegendOfVisibleLayers", updateLegendOnResolutionChange: "updateLegendOnResolutionChange", queryBadge: "queryBadge" }, outputs: { appliedFilterAndSort: "appliedFilterAndSort" }, queries: [{ propertyName: "templateLayerToolbar", first: true, predicate: ["igoLayerItemToolbar"], descendants: true }], ngImport: i0, template: "<igo-layer-list-tool\n  *ngIf=\"showToolbar$ | async\"\n  floatLabel=\"auto\"\n  [layersAreAllVisible]=\"layersAreAllVisible\"\n  [term]=\"layerFilterAndSortOptions.keyword\"\n  [onlyVisible]=\"layerFilterAndSortOptions.onlyVisible\"\n  [sortAlpha]=\"layerFilterAndSortOptions.sortAlpha\"\n  (appliedFilterAndSort)=\"onAppliedFilterAndSortChange($event)\"\n  (selection)=\"toggleSelectionMode($event)\"\n>\n</igo-layer-list-tool>\n\n<div *ngIf=\"selection\" class=\"select-all\">\n  <mat-checkbox\n    class=\"select-all-checkbox\"\n    [color]=\"!selectAllCheck && layersChecked.length > 0 ? 'accent' : 'primary'\"\n    (change)=\"selectAll()\"\n    [checked]=\"selectAllCheck\"\n    [indeterminate]=\"!selectAllCheck && layersChecked.length > 0\"\n  >\n    {{\n      selectAllCheck\n        ? ('igo.geo.layer.deselectAll' | translate)\n        : ('igo.geo.layer.selectAll' | translate)\n    }}\n  </mat-checkbox>\n</div>\n<mat-divider></mat-divider>\n\n<igo-list #igoList [navigation]=\"false\" [selection]=\"false\">\n  <ng-template ngFor let-layer let-i=\"index\" [ngForOf]=\"layers$ | async\">\n    <igo-layer-item\n      *ngIf=\"!(excludeBaseLayers && layer.baseLayer)\"\n      igoListItem\n      [layer]=\"layer\"\n      [activeLayer]=\"activeLayer\"\n      [orderable]=\"orderable && !layer.baseLayer\"\n      [lowerDisabled]=\"getLowerLayer().id === layer.id\"\n      [raiseDisabled]=\"getUpperLayer().id === layer.id\"\n      [queryBadge]=\"queryBadge\"\n      [expandLegendIfVisible]=\"expandLegendOfVisibleLayers\"\n      [updateLegendOnResolutionChange]=\"updateLegendOnResolutionChange\"\n      [toggleLegendOnVisibilityChange]=\"toggleLegendOnVisibilityChange\"\n      [selectionMode]=\"selection\"\n      [selectAll]=\"selectAllCheck\"\n      [layerCheck]=\"layer.options.check\"\n      [changeDetection]=\"layerItemChangeDetection$\"\n      (action)=\"toggleLayerTool($event)\"\n      (checkbox)=\"layersCheck($event)\"\n    >\n    </igo-layer-item>\n  </ng-template>\n</igo-list>\n\n<igo-panel\n  *ngIf=\"!selection && layerTool && activeLayer\"\n  class=\"igo-layer-actions-container\"\n  [title]=\"activeLayer.title\"\n>\n  <div class=\"igo-layer-button-group\">\n    <button\n      *ngIf=\"isLayerRemovable(activeLayer)\"\n      class=\"delete-button\"\n      mat-icon-button\n      color=\"warn\"\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"'igo.geo.layer.removeLayer' | translate\"\n      (click)=\"removeLayers()\"\n    >\n      <mat-icon svgIcon=\"delete\"></mat-icon>\n    </button>\n\n    <button\n      class=\"down-button\"\n      mat-icon-button\n      color=\"primary\"\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"\n        sortAlpha || onlyVisible || keyword\n          ? ('igo.geo.layer.filterLowerLayer' | translate)\n          : ('igo.geo.layer.lowerLayer' | translate)\n      \"\n      [disabled]=\"lowerDisabled\"\n      (click)=\"moveActiveLayer(activeLayer, layerListDisplacement.Lower, true)\"\n    >\n      <mat-icon\n        aria-hidden=\"false\"\n        [matBadge]=\"sortAlpha || onlyVisible || keyword ? '!' : ''\"\n        matBadgeColor=\"warn\"\n        matBadgeSize=\"medium\"\n        [matBadgeHidden]=\"lowerDisabled\"\n        svgIcon=\"arrow-down\"\n      ></mat-icon>\n    </button>\n\n    <button\n      class=\"up-button\"\n      color=\"primary\"\n      mat-icon-button\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"\n        sortAlpha || onlyVisible || keyword\n          ? ('igo.geo.layer.filterRaiseLayer' | translate)\n          : ('igo.geo.layer.raiseLayer' | translate)\n      \"\n      [disabled]=\"raiseDisabled\"\n      (click)=\"moveActiveLayer(activeLayer, layerListDisplacement.Raise, true)\"\n    >\n      <mat-icon\n        aria-hidden=\"false\"\n        [matBadge]=\"sortAlpha || onlyVisible || keyword ? '!' : ''\"\n        matBadgeColor=\"warn\"\n        matBadgeSize=\"medium\"\n        [matBadgeHidden]=\"raiseDisabled\"\n        svgIcon=\"arrow-up\"\n      ></mat-icon>\n    </button>\n\n    <!-- <label>{{ 'igo.geo.layer.opacity' | translate }} </label> -->\n    <button\n      class=\"opacity-button\"\n      color=\"primary\"\n      mat-icon-button\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matMenuTriggerFor]=\"opacityMenu\"\n      [matTooltip]=\"'igo.geo.layer.opacity' | translate\"\n    >\n      <mat-icon\n        aria-hidden=\"false\"\n        [matBadge]=\"badgeOpacity\"\n        matBadgeColor=\"primary\"\n        matBadgeSize=\"medium\"\n        svgIcon=\"opacity\"\n      ></mat-icon>\n    </button>\n\n    <mat-menu #opacityMenu=\"matMenu\" class=\"panel-opacity-menu\">\n      <mat-slider\n        id=\"opacity-slider\"\n        color=\"primary\"\n        discrete\n        step=\"5\"\n        [min]=\"0\"\n        [max]=\"100\"\n        [matTooltip]=\"'igo.geo.layer.opacity' | translate\"\n        (click)=\"$event.stopPropagation()\"\n        matTooltipShowDelay=\"500\"\n        tooltip-position=\"below\"\n        #ngSlider\n        ><input\n          matSliderThumb\n          [value]=\"opacity\"\n          (input)=\"\n            changeOpacity({\n              source: ngSliderThumb,\n              parent: ngSlider,\n              value: ngSliderThumb.value\n            })\n          \"\n          #ngSliderThumb=\"matSliderThumb\"\n        />\n      </mat-slider>\n    </mat-menu>\n\n    <button\n      *ngIf=\"activeLayerExtentIsValid(activeLayer)\"\n      class=\"zoomLayer-button\"\n      color=\"primary\"\n      mat-icon-button\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"'igo.geo.layer.zoomLayer' | translate\"\n      (click)=\"zoomLayerExtents(activeLayer)\"\n    >\n      <mat-icon\n        matBadgeColor=\"primary\"\n        matBadgeSize=\"medium\"\n        svgIcon=\"magnify-scan\"\n      ></mat-icon>\n    </button>\n\n    <ng-container\n      igoLayerItemToolbar\n      [ngTemplateOutlet]=\"templateLayerToolbar\"\n      [ngTemplateOutletContext]=\"{ layer: activeLayer }\"\n    >\n    </ng-container>\n\n    <ng-content select=\"[igoLayerItemToolbar]\"></ng-content>\n  </div>\n</igo-panel>\n\n<igo-panel\n  *ngIf=\"selection && layers.length > 0\"\n  class=\"igo-layer-actions-container\"\n  [title]=\"'igo.geo.layer.tools' | translate\"\n>\n  <div class=\"actions-buttons-multi\">\n    <button\n      class=\"delete-button\"\n      mat-icon-button\n      color=\"warn\"\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [disabled]=\"layersChecked.length === 0\"\n      [matTooltip]=\"\n        isAllLayersRemovable(layersChecked)\n          ? ('igo.geo.layer.removeSelectedLayers' | translate)\n          : ('igo.geo.layer.removeSelectedLayersRestriction' | translate)\n      \"\n      (click)=\"removeLayers(layersChecked)\"\n    >\n      <mat-icon\n        aria-hidden=\"false\"\n        [matBadge]=\"'!'\"\n        matBadgeColor=\"warn\"\n        matBadgeSize=\"medium\"\n        [matBadgeHidden]=\"isAllLayersRemovable(layersChecked)\"\n        svgIcon=\"delete\"\n      ></mat-icon>\n    </button>\n\n    <button\n      class=\"eye-button\"\n      mat-icon-button\n      color=\"primary\"\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [disabled]=\"layersChecked.length === 0\"\n      [matTooltip]=\"\n        statusSelectedLayersCheck === 'ALL_HIDDEN'\n          ? ('igo.geo.layer.showSelectedLayers' | translate)\n          : ('igo.geo.layer.hideSelectedLayers' | translate)\n      \"\n      (click)=\"toggleVisibility(layersChecked)\"\n    >\n      <mat-icon\n        [svgIcon]=\"\n          statusSelectedLayersCheck === 'ALL_HIDDEN' ? 'eye-off' : 'eye'\n        \"\n      ></mat-icon>\n    </button>\n\n    <button\n      class=\"down-button\"\n      mat-icon-button\n      color=\"primary\"\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"\n        sortAlpha || onlyVisible || keyword\n          ? ('igo.geo.layer.filterLowerLayer' | translate)\n          : ('igo.geo.layer.lowerLayer' | translate)\n      \"\n      [disabled]=\"lowerDisabledSelection\"\n      (click)=\"lowerLayers(layersChecked)\"\n    >\n      <mat-icon\n        aria-hidden=\"false\"\n        [matBadge]=\"sortAlpha || onlyVisible || keyword ? '!' : ''\"\n        matBadgeColor=\"warn\"\n        matBadgeSize=\"medium\"\n        [matBadgeHidden]=\"lowerDisabledSelection\"\n        svgIcon=\"arrow-down\"\n      ></mat-icon>\n    </button>\n\n    <button\n      class=\"up-button\"\n      color=\"primary\"\n      mat-icon-button\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"\n        sortAlpha || onlyVisible || keyword\n          ? ('igo.geo.layer.filterRaiseLayer' | translate)\n          : ('igo.geo.layer.raiseLayer' | translate)\n      \"\n      [disabled]=\"raiseDisabledSelection\"\n      (click)=\"raiseLayers(layersChecked)\"\n    >\n      <mat-icon\n        aria-hidden=\"false\"\n        [matBadge]=\"sortAlpha || onlyVisible || keyword ? '!' : ''\"\n        matBadgeColor=\"warn\"\n        matBadgeSize=\"medium\"\n        [matBadgeHidden]=\"raiseDisabledSelection\"\n        svgIcon=\"arrow-up\"\n      ></mat-icon>\n    </button>\n\n    <button\n      class=\"opacity-button\"\n      color=\"primary\"\n      mat-icon-button\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [disabled]=\"layersChecked.length === 0\"\n      [matMenuTriggerFor]=\"opacityMenu\"\n      [matTooltip]=\"'igo.geo.layer.opacity' | translate\"\n    >\n      <mat-icon svgIcon=\"opacity\"></mat-icon>\n    </button>\n\n    <mat-menu #opacityMenu=\"matMenu\" class=\"mat-menu-opacity-slider\">\n      <div id=\"opacity-menu\">\n        <!-- TODO: The 'tickInterval' property no longer exists -->\n        <mat-slider\n          *ngIf=\"layersChecked.length\"\n          id=\"opacity-slider\"\n          color=\"primary\"\n          thumbLabel\n          showTickMarks\n          step=\"5\"\n          [min]=\"0\"\n          [max]=\"100\"\n          [(ngModel)]=\"checkOpacity\"\n          [matTooltip]=\"'igo.geo.layer.opacity' | translate\"\n          matTooltipShowDelay=\"500\"\n          tooltip-position=\"below\"\n          (click)=\"$event.stopPropagation()\"\n          ><input matSliderThumb />\n        </mat-slider>\n      </div>\n    </mat-menu>\n\n    <button\n      *ngIf=\"\n        layersChecked.length !== 0 && activeLayersExtentAreValid(layersChecked)\n      \"\n      class=\"zoomLayer-button\"\n      color=\"primary\"\n      mat-icon-button\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"'igo.geo.layer.zoomLayers' | translate\"\n      (click)=\"zoomLayersExtents(layersChecked)\"\n    >\n      <mat-icon svgIcon=\"magnify-scan\"></mat-icon>\n    </button>\n  </div>\n</igo-panel>\n", styles: [":host{display:flex;flex-direction:column;height:100%}:host igo-list{flex:1;padding-top:8px}:host mat-form-field.inputFilter{width:calc(100% - 100px);max-width:200px}:host .igo-layer-actions-container{padding:0 6px 0 4px}:host .igo-layer-actions-container>div{text-align:center}:host mat-list-item ::ng-deep .mdc-list-item__content{margin-bottom:10px}:host .igo-layer-button-group,:host .actions-buttons-multi{display:flex;align-items:center;flex-direction:row-reverse;overflow-x:auto;overflow-y:hidden}:host .igo-layer-button-group::-webkit-scrollbar,:host .actions-buttons-multi::-webkit-scrollbar{height:4px}:host .igo-layer-button-group::-webkit-scrollbar-track,:host .actions-buttons-multi::-webkit-scrollbar-track{background:#f1f1f1}:host .igo-layer-button-group::-webkit-scrollbar-thumb,:host .actions-buttons-multi::-webkit-scrollbar-thumb{background:#888}:host .igo-layer-button-group::-webkit-scrollbar-thumb:hover,:host .actions-buttons-multi::-webkit-scrollbar-thumb:hover{background:#555}:host .igo-layer-button-group{padding-top:5px}:host igo-panel{height:unset}:host .select-all{display:flex;align-items:center;height:48px;padding:0 16px}::ng-deep .panel-opacity-menu{overflow:visible!important}::ng-deep .panel-opacity-menu #opacity-slider{margin:0 16px}\n"], dependencies: [{ kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2$2.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: i2$1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "component", type: i9$2.MatDivider, selector: "mat-divider", inputs: ["vertical", "inset"] }, { kind: "component", type: i7$1.MatMenu, selector: "mat-menu", exportAs: ["matMenu"] }, { kind: "directive", type: i7$1.MatMenuTrigger, selector: "[mat-menu-trigger-for], [matMenuTriggerFor]", exportAs: ["matMenuTrigger"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "component", type: i8$1.MatSlider, selector: "mat-slider", inputs: ["color", "disableRipple", "disabled", "discrete", "showTickMarks", "min", "max", "step", "displayWith"], exportAs: ["matSlider"] }, { kind: "directive", type: i8$1.MatSliderThumb, selector: "input[matSliderThumb]", inputs: ["value"], outputs: ["valueChange", "dragStart", "dragEnd"], exportAs: ["matSliderThumb"] }, { kind: "directive", type: i6.MatBadge, selector: "[matBadge]", inputs: ["matBadgeDisabled", "matBadgeColor", "matBadgeOverlap", "matBadgePosition", "matBadge", "matBadgeDescription", "matBadgeSize", "matBadgeHidden"] }, { kind: "component", type: i11.MatCheckbox, selector: "mat-checkbox", inputs: ["disableRipple", "color", "tabIndex"], exportAs: ["matCheckbox"] }, { kind: "directive", type: i9$1.ListItemDirective, selector: "[igoListItem]", inputs: ["color", "focused", "selected", "disabled"], outputs: ["beforeSelect", "beforeFocus", "beforeUnselect", "beforeUnfocus", "beforeDisable", "beforeEnable", "focus", "unfocus", "select", "unselect", "disable", "enable"] }, { kind: "component", type: i9$1.ListComponent, selector: "igo-list", inputs: ["navigation", "selection"] }, { kind: "component", type: i9$1.PanelComponent, selector: "igo-panel", inputs: ["title", "withHeader", "cursorPointer"] }, { kind: "component", type: LayerItemComponent, selector: "igo-layer-item", inputs: ["activeLayer", "selectAll", "layerCheck", "layer", "toggleLegendOnVisibilityChange", "expandLegendIfVisible", "updateLegendOnResolutionChange", "orderable", "lowerDisabled", "raiseDisabled", "queryBadge", "selectionMode", "changeDetection"], outputs: ["action", "checkbox"] }, { kind: "component", type: LayerListToolComponent, selector: "igo-layer-list-tool", inputs: ["layersAreAllVisible", "floatLabel", "onlyVisible", "sortAlpha", "term"], outputs: ["appliedFilterAndSort", "selection"] }, { kind: "pipe", type: i2$2.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LayerListComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-layer-list', changeDetection: ChangeDetectionStrategy.OnPush, template: "<igo-layer-list-tool\n  *ngIf=\"showToolbar$ | async\"\n  floatLabel=\"auto\"\n  [layersAreAllVisible]=\"layersAreAllVisible\"\n  [term]=\"layerFilterAndSortOptions.keyword\"\n  [onlyVisible]=\"layerFilterAndSortOptions.onlyVisible\"\n  [sortAlpha]=\"layerFilterAndSortOptions.sortAlpha\"\n  (appliedFilterAndSort)=\"onAppliedFilterAndSortChange($event)\"\n  (selection)=\"toggleSelectionMode($event)\"\n>\n</igo-layer-list-tool>\n\n<div *ngIf=\"selection\" class=\"select-all\">\n  <mat-checkbox\n    class=\"select-all-checkbox\"\n    [color]=\"!selectAllCheck && layersChecked.length > 0 ? 'accent' : 'primary'\"\n    (change)=\"selectAll()\"\n    [checked]=\"selectAllCheck\"\n    [indeterminate]=\"!selectAllCheck && layersChecked.length > 0\"\n  >\n    {{\n      selectAllCheck\n        ? ('igo.geo.layer.deselectAll' | translate)\n        : ('igo.geo.layer.selectAll' | translate)\n    }}\n  </mat-checkbox>\n</div>\n<mat-divider></mat-divider>\n\n<igo-list #igoList [navigation]=\"false\" [selection]=\"false\">\n  <ng-template ngFor let-layer let-i=\"index\" [ngForOf]=\"layers$ | async\">\n    <igo-layer-item\n      *ngIf=\"!(excludeBaseLayers && layer.baseLayer)\"\n      igoListItem\n      [layer]=\"layer\"\n      [activeLayer]=\"activeLayer\"\n      [orderable]=\"orderable && !layer.baseLayer\"\n      [lowerDisabled]=\"getLowerLayer().id === layer.id\"\n      [raiseDisabled]=\"getUpperLayer().id === layer.id\"\n      [queryBadge]=\"queryBadge\"\n      [expandLegendIfVisible]=\"expandLegendOfVisibleLayers\"\n      [updateLegendOnResolutionChange]=\"updateLegendOnResolutionChange\"\n      [toggleLegendOnVisibilityChange]=\"toggleLegendOnVisibilityChange\"\n      [selectionMode]=\"selection\"\n      [selectAll]=\"selectAllCheck\"\n      [layerCheck]=\"layer.options.check\"\n      [changeDetection]=\"layerItemChangeDetection$\"\n      (action)=\"toggleLayerTool($event)\"\n      (checkbox)=\"layersCheck($event)\"\n    >\n    </igo-layer-item>\n  </ng-template>\n</igo-list>\n\n<igo-panel\n  *ngIf=\"!selection && layerTool && activeLayer\"\n  class=\"igo-layer-actions-container\"\n  [title]=\"activeLayer.title\"\n>\n  <div class=\"igo-layer-button-group\">\n    <button\n      *ngIf=\"isLayerRemovable(activeLayer)\"\n      class=\"delete-button\"\n      mat-icon-button\n      color=\"warn\"\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"'igo.geo.layer.removeLayer' | translate\"\n      (click)=\"removeLayers()\"\n    >\n      <mat-icon svgIcon=\"delete\"></mat-icon>\n    </button>\n\n    <button\n      class=\"down-button\"\n      mat-icon-button\n      color=\"primary\"\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"\n        sortAlpha || onlyVisible || keyword\n          ? ('igo.geo.layer.filterLowerLayer' | translate)\n          : ('igo.geo.layer.lowerLayer' | translate)\n      \"\n      [disabled]=\"lowerDisabled\"\n      (click)=\"moveActiveLayer(activeLayer, layerListDisplacement.Lower, true)\"\n    >\n      <mat-icon\n        aria-hidden=\"false\"\n        [matBadge]=\"sortAlpha || onlyVisible || keyword ? '!' : ''\"\n        matBadgeColor=\"warn\"\n        matBadgeSize=\"medium\"\n        [matBadgeHidden]=\"lowerDisabled\"\n        svgIcon=\"arrow-down\"\n      ></mat-icon>\n    </button>\n\n    <button\n      class=\"up-button\"\n      color=\"primary\"\n      mat-icon-button\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"\n        sortAlpha || onlyVisible || keyword\n          ? ('igo.geo.layer.filterRaiseLayer' | translate)\n          : ('igo.geo.layer.raiseLayer' | translate)\n      \"\n      [disabled]=\"raiseDisabled\"\n      (click)=\"moveActiveLayer(activeLayer, layerListDisplacement.Raise, true)\"\n    >\n      <mat-icon\n        aria-hidden=\"false\"\n        [matBadge]=\"sortAlpha || onlyVisible || keyword ? '!' : ''\"\n        matBadgeColor=\"warn\"\n        matBadgeSize=\"medium\"\n        [matBadgeHidden]=\"raiseDisabled\"\n        svgIcon=\"arrow-up\"\n      ></mat-icon>\n    </button>\n\n    <!-- <label>{{ 'igo.geo.layer.opacity' | translate }} </label> -->\n    <button\n      class=\"opacity-button\"\n      color=\"primary\"\n      mat-icon-button\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matMenuTriggerFor]=\"opacityMenu\"\n      [matTooltip]=\"'igo.geo.layer.opacity' | translate\"\n    >\n      <mat-icon\n        aria-hidden=\"false\"\n        [matBadge]=\"badgeOpacity\"\n        matBadgeColor=\"primary\"\n        matBadgeSize=\"medium\"\n        svgIcon=\"opacity\"\n      ></mat-icon>\n    </button>\n\n    <mat-menu #opacityMenu=\"matMenu\" class=\"panel-opacity-menu\">\n      <mat-slider\n        id=\"opacity-slider\"\n        color=\"primary\"\n        discrete\n        step=\"5\"\n        [min]=\"0\"\n        [max]=\"100\"\n        [matTooltip]=\"'igo.geo.layer.opacity' | translate\"\n        (click)=\"$event.stopPropagation()\"\n        matTooltipShowDelay=\"500\"\n        tooltip-position=\"below\"\n        #ngSlider\n        ><input\n          matSliderThumb\n          [value]=\"opacity\"\n          (input)=\"\n            changeOpacity({\n              source: ngSliderThumb,\n              parent: ngSlider,\n              value: ngSliderThumb.value\n            })\n          \"\n          #ngSliderThumb=\"matSliderThumb\"\n        />\n      </mat-slider>\n    </mat-menu>\n\n    <button\n      *ngIf=\"activeLayerExtentIsValid(activeLayer)\"\n      class=\"zoomLayer-button\"\n      color=\"primary\"\n      mat-icon-button\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"'igo.geo.layer.zoomLayer' | translate\"\n      (click)=\"zoomLayerExtents(activeLayer)\"\n    >\n      <mat-icon\n        matBadgeColor=\"primary\"\n        matBadgeSize=\"medium\"\n        svgIcon=\"magnify-scan\"\n      ></mat-icon>\n    </button>\n\n    <ng-container\n      igoLayerItemToolbar\n      [ngTemplateOutlet]=\"templateLayerToolbar\"\n      [ngTemplateOutletContext]=\"{ layer: activeLayer }\"\n    >\n    </ng-container>\n\n    <ng-content select=\"[igoLayerItemToolbar]\"></ng-content>\n  </div>\n</igo-panel>\n\n<igo-panel\n  *ngIf=\"selection && layers.length > 0\"\n  class=\"igo-layer-actions-container\"\n  [title]=\"'igo.geo.layer.tools' | translate\"\n>\n  <div class=\"actions-buttons-multi\">\n    <button\n      class=\"delete-button\"\n      mat-icon-button\n      color=\"warn\"\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [disabled]=\"layersChecked.length === 0\"\n      [matTooltip]=\"\n        isAllLayersRemovable(layersChecked)\n          ? ('igo.geo.layer.removeSelectedLayers' | translate)\n          : ('igo.geo.layer.removeSelectedLayersRestriction' | translate)\n      \"\n      (click)=\"removeLayers(layersChecked)\"\n    >\n      <mat-icon\n        aria-hidden=\"false\"\n        [matBadge]=\"'!'\"\n        matBadgeColor=\"warn\"\n        matBadgeSize=\"medium\"\n        [matBadgeHidden]=\"isAllLayersRemovable(layersChecked)\"\n        svgIcon=\"delete\"\n      ></mat-icon>\n    </button>\n\n    <button\n      class=\"eye-button\"\n      mat-icon-button\n      color=\"primary\"\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [disabled]=\"layersChecked.length === 0\"\n      [matTooltip]=\"\n        statusSelectedLayersCheck === 'ALL_HIDDEN'\n          ? ('igo.geo.layer.showSelectedLayers' | translate)\n          : ('igo.geo.layer.hideSelectedLayers' | translate)\n      \"\n      (click)=\"toggleVisibility(layersChecked)\"\n    >\n      <mat-icon\n        [svgIcon]=\"\n          statusSelectedLayersCheck === 'ALL_HIDDEN' ? 'eye-off' : 'eye'\n        \"\n      ></mat-icon>\n    </button>\n\n    <button\n      class=\"down-button\"\n      mat-icon-button\n      color=\"primary\"\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"\n        sortAlpha || onlyVisible || keyword\n          ? ('igo.geo.layer.filterLowerLayer' | translate)\n          : ('igo.geo.layer.lowerLayer' | translate)\n      \"\n      [disabled]=\"lowerDisabledSelection\"\n      (click)=\"lowerLayers(layersChecked)\"\n    >\n      <mat-icon\n        aria-hidden=\"false\"\n        [matBadge]=\"sortAlpha || onlyVisible || keyword ? '!' : ''\"\n        matBadgeColor=\"warn\"\n        matBadgeSize=\"medium\"\n        [matBadgeHidden]=\"lowerDisabledSelection\"\n        svgIcon=\"arrow-down\"\n      ></mat-icon>\n    </button>\n\n    <button\n      class=\"up-button\"\n      color=\"primary\"\n      mat-icon-button\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"\n        sortAlpha || onlyVisible || keyword\n          ? ('igo.geo.layer.filterRaiseLayer' | translate)\n          : ('igo.geo.layer.raiseLayer' | translate)\n      \"\n      [disabled]=\"raiseDisabledSelection\"\n      (click)=\"raiseLayers(layersChecked)\"\n    >\n      <mat-icon\n        aria-hidden=\"false\"\n        [matBadge]=\"sortAlpha || onlyVisible || keyword ? '!' : ''\"\n        matBadgeColor=\"warn\"\n        matBadgeSize=\"medium\"\n        [matBadgeHidden]=\"raiseDisabledSelection\"\n        svgIcon=\"arrow-up\"\n      ></mat-icon>\n    </button>\n\n    <button\n      class=\"opacity-button\"\n      color=\"primary\"\n      mat-icon-button\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [disabled]=\"layersChecked.length === 0\"\n      [matMenuTriggerFor]=\"opacityMenu\"\n      [matTooltip]=\"'igo.geo.layer.opacity' | translate\"\n    >\n      <mat-icon svgIcon=\"opacity\"></mat-icon>\n    </button>\n\n    <mat-menu #opacityMenu=\"matMenu\" class=\"mat-menu-opacity-slider\">\n      <div id=\"opacity-menu\">\n        <!-- TODO: The 'tickInterval' property no longer exists -->\n        <mat-slider\n          *ngIf=\"layersChecked.length\"\n          id=\"opacity-slider\"\n          color=\"primary\"\n          thumbLabel\n          showTickMarks\n          step=\"5\"\n          [min]=\"0\"\n          [max]=\"100\"\n          [(ngModel)]=\"checkOpacity\"\n          [matTooltip]=\"'igo.geo.layer.opacity' | translate\"\n          matTooltipShowDelay=\"500\"\n          tooltip-position=\"below\"\n          (click)=\"$event.stopPropagation()\"\n          ><input matSliderThumb />\n        </mat-slider>\n      </div>\n    </mat-menu>\n\n    <button\n      *ngIf=\"\n        layersChecked.length !== 0 && activeLayersExtentAreValid(layersChecked)\n      \"\n      class=\"zoomLayer-button\"\n      color=\"primary\"\n      mat-icon-button\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"'igo.geo.layer.zoomLayers' | translate\"\n      (click)=\"zoomLayersExtents(layersChecked)\"\n    >\n      <mat-icon svgIcon=\"magnify-scan\"></mat-icon>\n    </button>\n  </div>\n</igo-panel>\n", styles: [":host{display:flex;flex-direction:column;height:100%}:host igo-list{flex:1;padding-top:8px}:host mat-form-field.inputFilter{width:calc(100% - 100px);max-width:200px}:host .igo-layer-actions-container{padding:0 6px 0 4px}:host .igo-layer-actions-container>div{text-align:center}:host mat-list-item ::ng-deep .mdc-list-item__content{margin-bottom:10px}:host .igo-layer-button-group,:host .actions-buttons-multi{display:flex;align-items:center;flex-direction:row-reverse;overflow-x:auto;overflow-y:hidden}:host .igo-layer-button-group::-webkit-scrollbar,:host .actions-buttons-multi::-webkit-scrollbar{height:4px}:host .igo-layer-button-group::-webkit-scrollbar-track,:host .actions-buttons-multi::-webkit-scrollbar-track{background:#f1f1f1}:host .igo-layer-button-group::-webkit-scrollbar-thumb,:host .actions-buttons-multi::-webkit-scrollbar-thumb{background:#888}:host .igo-layer-button-group::-webkit-scrollbar-thumb:hover,:host .actions-buttons-multi::-webkit-scrollbar-thumb:hover{background:#555}:host .igo-layer-button-group{padding-top:5px}:host igo-panel{height:unset}:host .select-all{display:flex;align-items:center;height:48px;padding:0 16px}::ng-deep .panel-opacity-menu{overflow:visible!important}::ng-deep .panel-opacity-menu #opacity-slider{margin:0 16px}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { templateLayerToolbar: [{
                type: ContentChild,
                args: ['igoLayerItemToolbar', /* TODO: add static flag */ {}]
            }], layersAreAllVisible: [{
                type: Input
            }], ogcButton: [{
                type: Input
            }], timeButton: [{
                type: Input
            }], map: [{
                type: Input
            }], layers: [{
                type: Input
            }], floatLabel: [{
                type: Input
            }], layerFilterAndSortOptions: [{
                type: Input
            }], excludeBaseLayers: [{
                type: Input
            }], toggleLegendOnVisibilityChange: [{
                type: Input
            }], expandLegendOfVisibleLayers: [{
                type: Input
            }], updateLegendOnResolutionChange: [{
                type: Input
            }], queryBadge: [{
                type: Input
            }], appliedFilterAndSort: [{
                type: Output
            }] } });

class LayerListBindingDirective {
    mapService;
    route;
    component;
    layersOrResolutionChange$$;
    layersVisibility$$;
    constructor(component, mapService, route) {
        this.mapService = mapService;
        this.route = route;
        this.component = component;
    }
    ngOnInit() {
        // Override input layers
        // this.component.layers = [];
        this.layersOrResolutionChange$$ = combineLatest([
            this.mapService.getMap().layers$,
            this.mapService.getMap().viewController.resolution$
        ])
            .pipe(debounceTime(10))
            .subscribe((bunch) => {
            const shownLayers = bunch[0].filter((layer) => {
                return layer.showInLayerList === true;
            });
            this.component.layers = shownLayers;
            this.setLayersVisibilityStatus(shownLayers, this.component.excludeBaseLayers);
        });
    }
    setLayersVisibilityStatus(layers, excludeBaseLayers) {
        if (this.layersVisibility$$ !== undefined) {
            this.layersVisibility$$.unsubscribe();
            this.layersVisibility$$ = undefined;
        }
        this.layersVisibility$$ = combineLatest(layers
            .filter((layer) => layer.baseLayer !== excludeBaseLayers)
            .map((layer) => layer.visible$))
            .pipe(map((visibles) => visibles.every(Boolean)))
            .subscribe((allLayersAreVisible) => (this.component.layersAreAllVisible = allLayersAreVisible));
    }
    ngOnDestroy() {
        this.layersOrResolutionChange$$.unsubscribe();
        if (this.layersVisibility$$ !== undefined) {
            this.layersVisibility$$.unsubscribe();
            this.layersVisibility$$ = undefined;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LayerListBindingDirective, deps: [{ token: LayerListComponent, self: true }, { token: MapService }, { token: i2.RouteService, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: LayerListBindingDirective, selector: "[igoLayerListBinding]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LayerListBindingDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igoLayerListBinding]'
                }]
        }], ctorParameters: function () { return [{ type: LayerListComponent, decorators: [{
                    type: Self
                }] }, { type: MapService }, { type: i2.RouteService, decorators: [{
                    type: Optional
                }] }]; } });

class OptionsService {
}

class DataSourceService {
    capabilitiesService;
    optionsService;
    wfsDataSourceService;
    languageService;
    messageService;
    projectionService;
    authInterceptor;
    datasources$ = new BehaviorSubject([]);
    constructor(capabilitiesService, optionsService, wfsDataSourceService, languageService, messageService, projectionService, authInterceptor) {
        this.capabilitiesService = capabilitiesService;
        this.optionsService = optionsService;
        this.wfsDataSourceService = wfsDataSourceService;
        this.languageService = languageService;
        this.messageService = messageService;
        this.projectionService = projectionService;
        this.authInterceptor = authInterceptor;
    }
    createAsyncDataSource(context, detailedContextUri) {
        if (!context.type) {
            console.error(context);
            throw new Error('Datasource needs a type');
        }
        let dataSource;
        switch (context.type.toLowerCase()) {
            case 'osm':
                dataSource = this.createOSMDataSource(context);
                break;
            case 'vector':
                dataSource = this.createFeatureDataSource(context);
                break;
            case 'wfs':
                dataSource = this.createWFSDataSource(context);
                break;
            case 'wms':
                const wmsContext = context;
                ObjectUtils.removeDuplicateCaseInsensitive(wmsContext.params);
                dataSource = this.createWMSDataSource(wmsContext, detailedContextUri);
                break;
            case 'wmts':
                dataSource = this.createWMTSDataSource(context);
                break;
            case 'xyz':
                dataSource = this.createXYZDataSource(context);
                break;
            case 'tiledebug':
                dataSource = this.createTileDebugDataSource(context);
                break;
            case 'carto':
                dataSource = this.createCartoDataSource(context);
                break;
            case 'arcgisrest':
                dataSource = this.createArcGISRestDataSource(context, detailedContextUri);
                break;
            case 'imagearcgisrest':
                dataSource = this.createArcGISRestImageDataSource(context, detailedContextUri);
                break;
            case 'websocket':
                dataSource = this.createWebSocketDataSource(context);
                break;
            case 'mvt':
                dataSource = this.createMVTDataSource(context);
                break;
            case 'tilearcgisrest':
                dataSource = this.createTileArcGISRestDataSource(context, detailedContextUri);
                break;
            case 'cluster':
                dataSource = this.createClusterDataSource(context);
                break;
            default:
                console.error(context);
                throw new Error('Invalid datasource type');
        }
        this.datasources$.next(this.datasources$.value.concat([dataSource]));
        return dataSource;
    }
    createOSMDataSource(context) {
        return new Observable((d) => d.next(new OSMDataSource(context)));
    }
    createFeatureDataSource(context) {
        return new Observable((d) => d.next(new FeatureDataSource(context)));
    }
    createWebSocketDataSource(context) {
        return new Observable((d) => d.next(new WebSocketDataSource(context)));
    }
    createWFSDataSource(context) {
        return new Observable((d) => d.next(new WFSDataSource(context, this.wfsDataSourceService, this.authInterceptor)));
    }
    createWMSDataSource(context, detailedContextUri) {
        const observables = [];
        if (context.optionsFromCapabilities && window.navigator.onLine) {
            observables.push(this.capabilitiesService.getWMSOptions(context).pipe(catchError((e) => {
                this.messageService.error('igo.geo.dataSource.unavailable', 'igo.geo.dataSource.unavailableTitle', undefined, { value: context.params.LAYERS });
                throw e;
            })));
        }
        if (this.optionsService &&
            context.optionsFromApi &&
            window.navigator.onLine) {
            observables.push(this.optionsService.getWMSOptions(context, detailedContextUri).pipe(catchError((e) => {
                e.error.toDisplay = true;
                e.error.title = this.languageService.translate.instant('igo.geo.dataSource.unavailableTitle');
                e.error.message = this.languageService.translate.instant('igo.geo.dataSource.optionsApiUnavailable');
                return of({});
            })));
        }
        observables.push(of(context));
        return forkJoin(observables).pipe(map((options) => {
            const optionsMerged = options.reduce((a, b) => ObjectUtils.mergeDeep(a, b));
            return new WMSDataSource(optionsMerged, this.wfsDataSourceService);
        }), catchError(() => {
            return of(undefined);
        }));
    }
    createWMTSDataSource(context) {
        if (context.optionsFromCapabilities && window.navigator.onLine) {
            return this.capabilitiesService.getWMTSOptions(context).pipe(map((options) => {
                return options ? new WMTSDataSource(options) : undefined;
            }), catchError(() => {
                this.messageService.error('igo.geo.dataSource.unavailable', 'igo.geo.dataSource.unavailableTitle', undefined, { value: context.layer });
                return of(undefined);
            }));
        }
        return new Observable((d) => d.next(new WMTSDataSource(context)));
    }
    createXYZDataSource(context) {
        return new Observable((d) => d.next(new XYZDataSource(context)));
    }
    createTileDebugDataSource(context) {
        return new Observable((d) => d.next(new TileDebugDataSource(context)));
    }
    createCartoDataSource(context) {
        if (context.mapId) {
            return this.capabilitiesService
                .getCartoOptions(context)
                .pipe(map((options) => new CartoDataSource(options)));
        }
        return new Observable((d) => d.next(new CartoDataSource(context)));
    }
    createArcGISRestDataSource(context, detailedContextUri) {
        const observables = [];
        if (window.navigator.onLine) {
            observables.push(this.capabilitiesService.getArcgisOptions(context).pipe(catchError((e) => {
                this.messageService.error('igo.geo.dataSource.unavailable', 'igo.geo.dataSource.unavailableTitle', undefined, { value: context.layer });
                throw e;
            })));
        }
        if (this.optionsService &&
            context.optionsFromApi &&
            window.navigator.onLine) {
            observables.push(this.optionsService
                .getArcgisRestOptions(context, detailedContextUri)
                .pipe(catchError((e) => {
                e.error.toDisplay = true;
                e.error.title = this.languageService.translate.instant('igo.geo.dataSource.unavailableTitle');
                e.error.message = this.languageService.translate.instant('igo.geo.dataSource.optionsApiUnavailable');
                return of({});
            })));
        }
        observables.push(of(context));
        return forkJoin(observables).pipe(map((options) => {
            const optionsMerged = options.reduce((a, b) => ObjectUtils.mergeDeep(a, b));
            return new ArcGISRestDataSource(optionsMerged);
        }), catchError(() => {
            return of(undefined);
        }));
    }
    createArcGISRestImageDataSource(context, detailedContextUri) {
        const observables = [];
        if (window.navigator.onLine) {
            observables.push(this.capabilitiesService.getImageArcgisOptions(context).pipe(catchError((e) => {
                this.messageService.error('igo.geo.dataSource.unavailable', 'igo.geo.dataSource.unavailableTitle', undefined, { value: context.params.LAYERS });
                throw e;
            })));
        }
        if (this.optionsService &&
            context.optionsFromApi &&
            window.navigator.onLine) {
            observables.push(this.optionsService
                .getArcgisRestOptions(context, detailedContextUri)
                .pipe(catchError((e) => {
                e.error.toDisplay = true;
                e.error.title = this.languageService.translate.instant('igo.geo.dataSource.unavailableTitle');
                e.error.message = this.languageService.translate.instant('igo.geo.dataSource.optionsApiUnavailable');
                return of({});
            })));
        }
        observables.push(of(context));
        return forkJoin(observables).pipe(map((options) => {
            const optionsMerged = options.reduce((a, b) => ObjectUtils.mergeDeep(a, b));
            return new ImageArcGISRestDataSource(optionsMerged);
        }), catchError(() => {
            return of(undefined);
        }));
    }
    createTileArcGISRestDataSource(context, detailedContextUri) {
        const observables = [];
        if (window.navigator.onLine) {
            observables.push(this.capabilitiesService.getImageArcgisOptions(context).pipe(catchError((e) => {
                this.messageService.error('igo.geo.dataSource.unavailable', 'igo.geo.dataSource.unavailableTitle', undefined, { value: context.params.LAYERS });
                throw e;
            })));
        }
        if (this.optionsService &&
            context.optionsFromApi &&
            window.navigator.onLine) {
            observables.push(this.optionsService
                .getArcgisRestOptions(context, detailedContextUri)
                .pipe(catchError((e) => {
                e.error.toDisplay = true;
                e.error.title = this.languageService.translate.instant('igo.geo.dataSource.unavailableTitle');
                e.error.message = this.languageService.translate.instant('igo.geo.dataSource.optionsApiUnavailable');
                return of({});
            })));
        }
        observables.push(of(context));
        return forkJoin(observables).pipe(map((options) => {
            const optionsMerged = options.reduce((a, b) => ObjectUtils.mergeDeep(a, b));
            return new TileArcGISRestDataSource(optionsMerged);
        }), catchError(() => {
            return of(undefined);
        }));
    }
    createMVTDataSource(context) {
        return new Observable((d) => d.next(new MVTDataSource(context)));
    }
    createClusterDataSource(context) {
        return new Observable((d) => d.next(new ClusterDataSource(context)));
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DataSourceService, deps: [{ token: CapabilitiesService }, { token: OptionsService, optional: true }, { token: WFSService }, { token: i2.LanguageService }, { token: i2.MessageService }, { token: ProjectionService }, { token: i6$1.AuthInterceptor }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DataSourceService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DataSourceService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: CapabilitiesService }, { type: OptionsService, decorators: [{
                    type: Optional
                }] }, { type: WFSService }, { type: i2.LanguageService }, { type: i2.MessageService }, { type: ProjectionService }, { type: i6$1.AuthInterceptor }]; } });

class LayerDBService {
    ngxIndexedDBService;
    dbName = 'layerData';
    constructor(ngxIndexedDBService) {
        this.ngxIndexedDBService = ngxIndexedDBService;
    }
    /**
     * This method allow to update the stored layer into the indexeddb (layerData)
     * @param layerDBData
     * @returns
     */
    update(layerDBData) {
        const subject = new Subject();
        this.ngxIndexedDBService
            .getByID(this.dbName, layerDBData.layerId)
            .pipe(first(), concatMap((dbObject) => {
            if (!dbObject) {
                return this.ngxIndexedDBService.add(this.dbName, layerDBData);
            }
            else {
                return this.customUpdate(layerDBData);
            }
        }))
            .subscribe((response) => {
            subject.next(response);
            subject.complete();
        });
        return subject;
    }
    customUpdate(layerDBData) {
        const subject = new Subject();
        const deleteRequest = this.ngxIndexedDBService.deleteByKey(this.dbName, layerDBData.layerId);
        deleteRequest
            .pipe(concatMap((isDeleted) => isDeleted
            ? this.ngxIndexedDBService.add(this.dbName, layerDBData)
            : of(undefined)))
            .subscribe((object) => {
            if (object) {
                subject.next(object);
            }
            subject.complete();
        });
        return subject;
    }
    /**
     * This method retrieve an idb layer definition
     * @param layerId
     * @returns
     */
    getByID(layerId) {
        return this.ngxIndexedDBService.getByID(this.dbName, layerId);
    }
    /**
     * This method delete an idb layer definition
     * @param layerId
     * @returns
     */
    deleteByKey(layerId) {
        return this.ngxIndexedDBService.deleteByKey(this.dbName, layerId);
    }
    /**
     * This method retrive all idb layer definition
     * @param layerId
     * @returns
     */
    getAll() {
        return this.ngxIndexedDBService.getAll(this.dbName);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LayerDBService, deps: [{ token: i1$1.NgxIndexedDBService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LayerDBService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LayerDBService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i1$1.NgxIndexedDBService }]; } });

class GeoDBService {
    ngxIndexedDBService;
    compression;
    dbName = 'geoData';
    collisionsMap = new Map();
    _newData = 0;
    constructor(ngxIndexedDBService, compression) {
        this.ngxIndexedDBService = ngxIndexedDBService;
        this.compression = compression;
    }
    /**
     * Only blob can be compressed
     * @param url
     * @param regionID
     * @param object object to handle
     * @param insertSource type of event user or system
     * @param insertEvent Name of the event where the insert has been triggered
     * @returns
     */
    update(url, regionID, object, insertSource, insertEvent) {
        if (!object) {
            return;
        }
        let compress = false;
        const subject = new Subject();
        let object$ = of(object);
        if (object instanceof Blob) {
            object$ = this.compression.compressBlob(object);
            compress = true;
        }
        let geoDBData;
        object$
            .pipe(first(), concatMap((object) => {
            geoDBData = {
                url,
                regionID,
                object: object,
                compressed: compress,
                insertSource,
                insertEvent
            };
            return this.ngxIndexedDBService.getByID(this.dbName, url);
        }), concatMap((dbObject) => {
            if (!dbObject) {
                this._newData++;
                return this.ngxIndexedDBService.add(this.dbName, geoDBData);
            }
            else {
                const currentRegionID = dbObject.regionID;
                if (currentRegionID !== regionID) {
                    const collisions = this.collisionsMap.get(currentRegionID);
                    if (collisions !== undefined) {
                        collisions.push(dbObject.url);
                        this.collisionsMap.set(currentRegionID, collisions);
                    }
                    else {
                        this.collisionsMap.set(currentRegionID, [dbObject.url]);
                    }
                }
                return this.customUpdate(geoDBData);
            }
        }))
            .subscribe((response) => {
            subject.next(response);
            subject.complete();
        });
        return subject;
    }
    customUpdate(geoDBData) {
        const subject = new Subject();
        const deleteRequest = this.ngxIndexedDBService.deleteByKey(this.dbName, geoDBData.url);
        deleteRequest
            .pipe(concatMap((isDeleted) => isDeleted
            ? this.ngxIndexedDBService.add(this.dbName, geoDBData)
            : of(undefined)))
            .subscribe((object) => {
            if (object) {
                subject.next(object);
            }
            subject.complete();
        });
        return subject;
    }
    get(url) {
        return this.ngxIndexedDBService.getByID(this.dbName, url).pipe(map((data) => {
            if (data) {
                const object = data.object;
                if (!data.compressed) {
                    return object;
                }
                return this.compression.decompressBlob(object);
            }
        }));
    }
    getByID(url) {
        return this.ngxIndexedDBService.getByID(this.dbName, url);
    }
    deleteByKey(url) {
        return this.ngxIndexedDBService.deleteByKey(this.dbName, url);
    }
    getRegionCountByID(id) {
        const subject = new Subject();
        const dbRequest = this.getRegionByID(id).subscribe((datas) => {
            subject.next(datas.length);
            subject.complete();
        });
        return subject;
    }
    getRegionByID(id) {
        if (!id) {
            return;
        }
        const IDBKey = IDBKeyRange.only(id);
        const dbRequest = this.ngxIndexedDBService.getAllByIndex(this.dbName, 'regionID', IDBKey);
        return dbRequest;
    }
    deleteByRegionID(id) {
        if (!id) {
            return;
        }
        const IDBKey = IDBKeyRange.only(id);
        const dbRequest = this.ngxIndexedDBService.getAllByIndex(this.dbName, 'regionID', IDBKey);
        dbRequest.subscribe((datas) => {
            datas.forEach((data) => {
                this.ngxIndexedDBService.deleteByKey(this.dbName, data.url);
            });
        });
        return dbRequest;
    }
    openCursor(keyRange = IDBKeyRange.lowerBound(0), mode = DBMode.readonly) {
        const request = this.ngxIndexedDBService.openCursorByIndex(this.dbName, 'regionID', keyRange, mode);
        return request;
    }
    resetCounters() {
        this.resetCollisionsMap();
        this._newData = 0;
    }
    resetCollisionsMap() {
        this.collisionsMap = new Map();
    }
    revertCollisions() {
        for (const [regionID, collisions] of this.collisionsMap) {
            for (const url of collisions) {
                this.ngxIndexedDBService
                    .getByKey(this.dbName, url)
                    .pipe(take(1))
                    .subscribe((dbObject) => {
                    const updatedObject = dbObject;
                    updatedObject.regionID = regionID;
                    this.customUpdate(dbObject);
                });
            }
        }
    }
    get newData() {
        return this._newData;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GeoDBService, deps: [{ token: i1$1.NgxIndexedDBService }, { token: i2.CompressionService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GeoDBService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GeoDBService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i1$1.NgxIndexedDBService }, { type: i2.CompressionService }]; } });

var ResponseType;
(function (ResponseType) {
    ResponseType["Arraybuffer"] = "arraybuffer";
    ResponseType["Blob"] = "blob";
    ResponseType["Text"] = "text";
    ResponseType["Json"] = "json";
})(ResponseType || (ResponseType = {}));
class GeoNetworkService {
    http;
    geoDBService;
    networkService;
    networkOnline = true;
    constructor(http, geoDBService, networkService) {
        this.http = http;
        this.geoDBService = geoDBService;
        this.networkService = networkService;
        this.networkService.currentState().subscribe((state) => {
            this.networkOnline = state.connection;
        });
    }
    get(url, simpleGetOptions) {
        if (window.navigator.onLine && this.networkOnline) {
            return this.getOnline(url, simpleGetOptions);
        }
        return this.getOffline(url);
    }
    getOnline(url, simpleGetOptions) {
        let request;
        switch (simpleGetOptions.responseType) {
            case 'arraybuffer':
                request = this.http.get(url, {
                    responseType: 'arraybuffer',
                    withCredentials: simpleGetOptions.withCredentials
                });
                break;
            case 'text':
                request = this.http.get(url, {
                    responseType: 'text',
                    withCredentials: simpleGetOptions.withCredentials
                });
                break;
            case 'json':
                request = this.http.get(url, {
                    responseType: 'json',
                    withCredentials: simpleGetOptions.withCredentials
                });
                break;
            default:
                request = this.http.get(url, {
                    responseType: 'blob',
                    withCredentials: simpleGetOptions.withCredentials
                });
                break;
        }
        return request;
    }
    getOffline(url) {
        return this.geoDBService.get(url);
    }
    isOnline() {
        return this.networkOnline && window.navigator.onLine;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GeoNetworkService, deps: [{ token: i1.HttpClient }, { token: GeoDBService }, { token: i2.NetworkService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GeoNetworkService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GeoNetworkService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: GeoDBService }, { type: i2.NetworkService }]; } });

function computeMVTOptionsOnHover(layerOptions) {
    const vectorTileLayerOptions = layerOptions;
    if (vectorTileLayerOptions.sourceOptions?.type === 'mvt' &&
        (vectorTileLayerOptions.igoStyle?.styleByAttribute?.hoverStyle ||
            vectorTileLayerOptions.igoStyle?.hoverStyle)) {
        const fc = vectorTileLayerOptions.sourceOptions.featureClass;
        vectorTileLayerOptions.sourceOptions.featureClass = fc ? fc : 'feature';
    }
    return layerOptions;
}

class LayerService {
    http;
    styleService;
    dataSourceService;
    geoNetworkService;
    messageService;
    layerDBService;
    authInterceptor;
    constructor(http, styleService, dataSourceService, geoNetworkService, messageService, layerDBService, authInterceptor) {
        this.http = http;
        this.styleService = styleService;
        this.dataSourceService = dataSourceService;
        this.geoNetworkService = geoNetworkService;
        this.messageService = messageService;
        this.layerDBService = layerDBService;
        this.authInterceptor = authInterceptor;
    }
    createLayer(layerOptions) {
        if (!layerOptions.source) {
            return;
        }
        if (layerOptions.source.options &&
            layerOptions.source.options._layerOptionsFromSource) {
            layerOptions = ObjectUtils.mergeDeep(layerOptions.source.options._layerOptionsFromSource, layerOptions || {});
        }
        let layer;
        switch (layerOptions.source.constructor) {
            case OSMDataSource:
            case WMTSDataSource:
            case XYZDataSource:
            case TileDebugDataSource:
            case CartoDataSource:
            case TileArcGISRestDataSource:
                layer = this.createTileLayer(layerOptions);
                break;
            case FeatureDataSource:
            case WFSDataSource:
            case ArcGISRestDataSource:
            case WebSocketDataSource:
            case ClusterDataSource:
                layer = this.createVectorLayer(layerOptions);
                break;
            case ImageArcGISRestDataSource:
            case WMSDataSource:
                layer = this.createImageLayer(layerOptions);
                break;
            case MVTDataSource:
                const _layerOptions = computeMVTOptionsOnHover(layerOptions);
                layer = this.createVectorTileLayer(_layerOptions);
                break;
            default:
                break;
        }
        return layer;
    }
    createAsyncLayer(_layerOptions, detailedContextUri) {
        const layerOptions = computeMVTOptionsOnHover(_layerOptions);
        if (layerOptions.source) {
            return new Observable((d) => d.next(this.createLayer(layerOptions)));
        }
        return this.dataSourceService
            .createAsyncDataSource(layerOptions.sourceOptions, detailedContextUri)
            .pipe(map((source) => {
            if (source === undefined) {
                return undefined;
            }
            return this.createLayer(Object.assign(layerOptions, { source }));
        }));
    }
    createImageLayer(layerOptions) {
        return new ImageLayer(layerOptions, this.messageService, this.authInterceptor);
    }
    createTileLayer(layerOptions) {
        return new TileLayer(layerOptions, this.messageService, this.authInterceptor);
    }
    createVectorLayer(layerOptions) {
        let style = layerOptions.style;
        let igoLayer;
        if (!layerOptions.igoStyle) {
            layerOptions.igoStyle = {};
        }
        const legacyStyleOptions = [
            'styleByAttribute',
            'hoverStyle',
            'mapboxStyle',
            'clusterBaseStyle',
            'style'
        ];
        // handling legacy property.
        this.handleLegacyStyles(layerOptions, legacyStyleOptions);
        if (layerOptions.igoStyle.igoStyleObject &&
            !layerOptions.idbInfo?.storeToIdb) {
            style = (feature, resolution) => this.styleService.createStyle(layerOptions.igoStyle.igoStyleObject, feature, resolution);
        }
        else if (layerOptions.igoStyle.igoStyleObject &&
            layerOptions.idbInfo?.storeToIdb) {
            // temporary fix todo : handle it with geostyler.
            style = this.styleService.parseStyle('style', layerOptions.igoStyle.igoStyleObject);
        }
        if (layerOptions.source instanceof ArcGISRestDataSource) {
            const source = layerOptions.source;
            style = source.options.params.style;
        }
        else if (layerOptions.igoStyle?.styleByAttribute) {
            const serviceStyle = this.styleService;
            layerOptions.style = (feature, resolution) => {
                return serviceStyle.createStyleByAttribute(feature, layerOptions.igoStyle.styleByAttribute, resolution);
            };
            igoLayer = new VectorLayer(layerOptions, this.messageService, this.authInterceptor, this.geoNetworkService, this.geoNetworkService.geoDBService, this.layerDBService);
        }
        if (layerOptions.source instanceof ClusterDataSource) {
            const serviceStyle = this.styleService;
            const baseStyle = layerOptions.igoStyle.clusterBaseStyle;
            layerOptions.style = (feature, resolution) => {
                return serviceStyle.createClusterStyle(feature, resolution, layerOptions.clusterParam, baseStyle);
            };
            igoLayer = new VectorLayer(layerOptions, this.messageService, this.authInterceptor, this.geoNetworkService, this.geoNetworkService.geoDBService, this.layerDBService);
        }
        const layerOptionsOl = Object.assign({}, layerOptions, {
            style
        });
        if (!igoLayer) {
            igoLayer = new VectorLayer(layerOptionsOl, this.messageService, this.authInterceptor, this.geoNetworkService, this.geoNetworkService.geoDBService, this.layerDBService);
        }
        this.applyMapboxStyle(igoLayer, layerOptionsOl);
        return igoLayer;
    }
    handleLegacyStyles(layerOptions, legacyStyleOptions) {
        legacyStyleOptions.map((legacyOption) => {
            if (layerOptions[legacyOption]) {
                let newKey = legacyOption;
                if (legacyOption === 'style') {
                    if (layerOptions[legacyOption] instanceof olStyle.Style) {
                        return;
                    }
                    if (typeof layerOptions[legacyOption] === 'object') {
                        newKey = 'igoStyleObject';
                    }
                    else {
                        return;
                    }
                }
                layerOptions.igoStyle[newKey] = layerOptions[legacyOption];
                delete layerOptions[legacyOption];
                console.warn(`
        The location of this style option (${legacyOption}) is deprecated.
        Please move this property within igoStyle property.
        Ex: ${legacyOption}: {...} must be transfered to igoStyle: { ${newKey}: {...} }
        This legacy conversion will be deleted in 2024.
        `);
            }
        });
    }
    createVectorTileLayer(layerOptions) {
        let style;
        let igoLayer;
        if (!layerOptions.igoStyle) {
            layerOptions.igoStyle = {};
        }
        const legacyStyleOptions = [
            'styleByAttribute',
            'hoverStyle',
            'mapboxStyle',
            'style'
        ];
        // handling legacy property.
        this.handleLegacyStyles(layerOptions, legacyStyleOptions);
        if (layerOptions.igoStyle.igoStyleObject) {
            style = (feature, resolution) => this.styleService.createStyle(layerOptions.igoStyle.igoStyleObject, feature, resolution);
        }
        if (layerOptions.igoStyle.styleByAttribute) {
            const serviceStyle = this.styleService;
            layerOptions.style = (feature, resolution) => {
                return serviceStyle.createStyleByAttribute(feature, layerOptions.igoStyle.styleByAttribute, resolution);
            };
            igoLayer = new VectorTileLayer(layerOptions, this.messageService, this.authInterceptor);
        }
        const layerOptionsOl = Object.assign({}, layerOptions, {
            style
        });
        if (!igoLayer) {
            igoLayer = new VectorTileLayer(layerOptionsOl, this.messageService, this.authInterceptor);
        }
        this.applyMapboxStyle(igoLayer, layerOptionsOl);
        return igoLayer;
    }
    applyMapboxStyle(layer, layerOptions) {
        if (layerOptions.igoStyle?.mapboxStyle) {
            this.getStuff(layerOptions.igoStyle.mapboxStyle.url).subscribe((res) => {
                if (res.sprite) {
                    const url = this.getAbsoluteUrl(layerOptions.igoStyle.mapboxStyle.url, res.sprite);
                    this.getStuff(url + '.json').subscribe((res2) => {
                        stylefunction(layer.ol, res, layerOptions.igoStyle.mapboxStyle.source, undefined, res2, url + '.png');
                    });
                }
                else {
                    stylefunction(layer.ol, res, layerOptions.igoStyle.mapboxStyle.source);
                }
            });
        }
    }
    getStuff(url) {
        return this.http.get(url).pipe(map((res) => res), catchError((err) => {
            console.log('No style was found');
            return of(err);
        }));
    }
    getAbsoluteUrl(source, url) {
        const r = new RegExp('^http|//', 'i');
        if (r.test(url)) {
            return url;
        }
        else {
            if (source.substr(source.length - 1) === '/') {
                return source + url;
            }
            else {
                return source + '/' + url;
            }
        }
    }
    createAsyncIdbLayers(contextUri = '*') {
        return this.layerDBService.getAll().pipe(concatMap((res) => {
            const idbLayers = contextUri !== '*'
                ? res.filter((l) => l.detailedContextUri === contextUri)
                : res;
            const layersOptions = idbLayers.map((idbl) => Object.assign({}, idbl.layerOptions, {
                sourceOptions: idbl.sourceOptions
            }));
            return combineLatest(layersOptions.map((layerOptions) => this.createAsyncLayer(layerOptions)));
        }));
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LayerService, deps: [{ token: i1.HttpClient }, { token: StyleService }, { token: DataSourceService }, { token: GeoNetworkService }, { token: i2.MessageService }, { token: LayerDBService }, { token: i6$1.AuthInterceptor, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LayerService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LayerService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: StyleService }, { type: DataSourceService }, { type: GeoNetworkService }, { type: i2.MessageService }, { type: LayerDBService }, { type: i6$1.AuthInterceptor, decorators: [{
                    type: Optional
                }] }]; } });

class TrackFeatureButtonComponent {
    layer;
    trackFeature = false;
    get options() {
        if (!this.layer) {
            return;
        }
        return this.layer.options;
    }
    color = 'primary';
    constructor() { }
    ngOnInit() {
        this.color = this.trackFeature ? 'primary' : 'basic';
    }
    toggleTrackFeature() {
        if (this.trackFeature) {
            this.layer.disableTrackFeature(this.layer.options.trackFeature);
            this.color = 'basic';
        }
        else {
            this.layer.enableTrackFeature(this.layer.options.trackFeature);
            this.color = 'primary';
        }
        this.trackFeature = !this.trackFeature;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TrackFeatureButtonComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: TrackFeatureButtonComponent, selector: "igo-track-feature-button", inputs: { layer: "layer", trackFeature: "trackFeature" }, ngImport: i0, template: "<button\n  *ngIf=\"options.trackFeature\"\n  mat-icon-button\n  collapsibleButton\n  tooltip-position=\"below\"\n  matTooltipShowDelay=\"500\"\n  [matTooltip]=\"'igo.geo.layer.trackFeature' | translate\"\n  [color]=\"color\"\n  (click)=\"toggleTrackFeature()\"\n>\n  <mat-icon svgIcon=\"crosshairs-gps\"></mat-icon>\n</button>\n", styles: [""], dependencies: [{ kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TrackFeatureButtonComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-track-feature-button', changeDetection: ChangeDetectionStrategy.OnPush, template: "<button\n  *ngIf=\"options.trackFeature\"\n  mat-icon-button\n  collapsibleButton\n  tooltip-position=\"below\"\n  matTooltipShowDelay=\"500\"\n  [matTooltip]=\"'igo.geo.layer.trackFeature' | translate\"\n  [color]=\"color\"\n  (click)=\"toggleTrackFeature()\"\n>\n  <mat-icon svgIcon=\"crosshairs-gps\"></mat-icon>\n</button>\n" }]
        }], ctorParameters: function () { return []; }, propDecorators: { layer: [{
                type: Input
            }], trackFeature: [{
                type: Input
            }] } });

class IgoLayerModule {
    static forRoot() {
        return {
            ngModule: IgoLayerModule,
            providers: [LayerService, StyleService, LayerListToolService]
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoLayerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoLayerModule, declarations: [LayerItemComponent,
            LayerLegendItemComponent,
            LayerLegendComponent,
            LayerListComponent,
            LayerListToolComponent,
            LayerLegendListComponent,
            LayerListBindingDirective,
            LayerLegendListBindingDirective,
            TrackFeatureButtonComponent], imports: [MatInputModule,
            ReactiveFormsModule,
            MatFormFieldModule,
            CommonModule,
            FormsModule,
            MatDividerModule,
            MatMenuModule,
            MatIconModule,
            MatButtonModule,
            MatSlideToggleModule,
            MatSelectModule,
            MatTooltipModule,
            MatListModule,
            MatSliderModule,
            MatBadgeModule,
            MatCheckboxModule,
            IgoLanguageModule,
            IgoListModule,
            IgoCollapsibleModule,
            IgoImageModule,
            IgoPanelModule,
            IgoMatBadgeIconModule,
            IgoCustomHtmlModule], exports: [LayerItemComponent,
            LayerLegendItemComponent,
            LayerLegendComponent,
            LayerListComponent,
            LayerListToolComponent,
            LayerLegendListComponent,
            LayerListBindingDirective,
            LayerLegendListBindingDirective,
            TrackFeatureButtonComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoLayerModule, imports: [MatInputModule,
            ReactiveFormsModule,
            MatFormFieldModule,
            CommonModule,
            FormsModule,
            MatDividerModule,
            MatMenuModule,
            MatIconModule,
            MatButtonModule,
            MatSlideToggleModule,
            MatSelectModule,
            MatTooltipModule,
            MatListModule,
            MatSliderModule,
            MatBadgeModule,
            MatCheckboxModule,
            IgoLanguageModule,
            IgoListModule,
            IgoCollapsibleModule,
            IgoImageModule,
            IgoPanelModule,
            IgoMatBadgeIconModule,
            IgoCustomHtmlModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoLayerModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        MatInputModule,
                        ReactiveFormsModule,
                        MatFormFieldModule,
                        CommonModule,
                        FormsModule,
                        MatDividerModule,
                        MatMenuModule,
                        MatIconModule,
                        MatButtonModule,
                        MatSlideToggleModule,
                        MatSelectModule,
                        MatTooltipModule,
                        MatListModule,
                        MatSliderModule,
                        MatBadgeModule,
                        MatCheckboxModule,
                        IgoLanguageModule,
                        IgoListModule,
                        IgoCollapsibleModule,
                        IgoImageModule,
                        IgoPanelModule,
                        IgoMatBadgeIconModule,
                        IgoCustomHtmlModule
                    ],
                    exports: [
                        LayerItemComponent,
                        LayerLegendItemComponent,
                        LayerLegendComponent,
                        LayerListComponent,
                        LayerListToolComponent,
                        LayerLegendListComponent,
                        LayerListBindingDirective,
                        LayerLegendListBindingDirective,
                        TrackFeatureButtonComponent
                    ],
                    declarations: [
                        LayerItemComponent,
                        LayerLegendItemComponent,
                        LayerLegendComponent,
                        LayerListComponent,
                        LayerListToolComponent,
                        LayerLegendListComponent,
                        LayerListBindingDirective,
                        LayerLegendListBindingDirective,
                        TrackFeatureButtonComponent
                    ]
                }]
        }] });

class MetadataService {
    constructor() { }
    open(metadata) {
        if (metadata.extern) {
            window.open(metadata.url, '_blank');
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: MetadataService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: MetadataService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: MetadataService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return []; } });

class MetadataButtonComponent {
    metadataService;
    dialog;
    get layer() {
        return this._layer;
    }
    set layer(value) {
        this._layer = value;
    }
    _layer;
    get color() {
        return this._color;
    }
    set color(value) {
        this._color = value;
    }
    _color = 'primary';
    constructor(metadataService, dialog) {
        this.metadataService = metadataService;
        this.dialog = dialog;
    }
    openMetadata(metadata) {
        if (metadata.extern) {
            if (!metadata.url && metadata.abstract) {
                this.dialog.open(MetadataAbstractComponent, {
                    data: {
                        layerTitle: this.layer.title,
                        abstract: metadata.abstract,
                        type: metadata.type
                    }
                });
            }
            else if (metadata.url) {
                this.metadataService.open(metadata);
            }
        }
        else if (!metadata.extern && metadata.abstract) {
            this.dialog.open(MetadataAbstractComponent, {
                data: {
                    layerTitle: this.layer.title,
                    abstract: metadata.abstract,
                    type: metadata.type
                }
            });
        }
    }
    get options() {
        if (!this.layer) {
            return;
        }
        return this.layer.options;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: MetadataButtonComponent, deps: [{ token: MetadataService }, { token: i1$2.MatDialog }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: MetadataButtonComponent, selector: "igo-metadata-button", inputs: { layer: "layer", color: "color" }, ngImport: i0, template: "<button\n  *ngIf=\"\n    (options && options.metadata && options.metadata.url) ||\n    (options && options.metadata && options.metadata.abstract)\n  \"\n  mat-icon-button\n  tooltip-position=\"below\"\n  matTooltipShowDelay=\"500\"\n  [matTooltip]=\"'igo.geo.metadata.show' | translate\"\n  [color]=\"color\"\n  (click)=\"openMetadata(options.metadata)\"\n>\n  <mat-icon svgIcon=\"information-outline\"></mat-icon>\n</button>\n", styles: [""], dependencies: [{ kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: MetadataButtonComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-metadata-button', changeDetection: ChangeDetectionStrategy.OnPush, template: "<button\n  *ngIf=\"\n    (options && options.metadata && options.metadata.url) ||\n    (options && options.metadata && options.metadata.abstract)\n  \"\n  mat-icon-button\n  tooltip-position=\"below\"\n  matTooltipShowDelay=\"500\"\n  [matTooltip]=\"'igo.geo.metadata.show' | translate\"\n  [color]=\"color\"\n  (click)=\"openMetadata(options.metadata)\"\n>\n  <mat-icon svgIcon=\"information-outline\"></mat-icon>\n</button>\n" }]
        }], ctorParameters: function () { return [{ type: MetadataService }, { type: i1$2.MatDialog }]; }, propDecorators: { layer: [{
                type: Input
            }], color: [{
                type: Input
            }] } });
class MetadataAbstractComponent {
    data;
    constructor(data) {
        this.data = data;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: MetadataAbstractComponent, deps: [{ token: MAT_DIALOG_DATA }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: MetadataAbstractComponent, selector: "igo-metadata-abstract", ngImport: i0, template: "<h2 mat-dialog-title>{{ data.layerTitle }}</h2>\n<button class=\"close-button\" mat-button mat-dialog-close>X</button>\n<mat-dialog-content *ngIf=\"data.type !== 'arcgisrest'\" class=\"mat-typography\">\n  <h3>{{ data.abstract }}</h3>\n</mat-dialog-content>\n<mat-dialog-content *ngIf=\"data.type === 'arcgisrest'\" class=\"mat-typography\">\n  <h3 [innerHTML]=\"data.abstract\"></h3>\n</mat-dialog-content>\n", styles: [":host{position:relative;display:block}:host .close-button{top:5px;right:5px;padding:7px;line-height:10px;position:absolute!important;min-width:auto}\n"], dependencies: [{ kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i4$1.MatButton, selector: "    button[mat-button], button[mat-raised-button], button[mat-flat-button],    button[mat-stroked-button]  ", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "directive", type: i1$2.MatDialogClose, selector: "[mat-dialog-close], [matDialogClose]", inputs: ["aria-label", "type", "mat-dialog-close", "matDialogClose"], exportAs: ["matDialogClose"] }, { kind: "directive", type: i1$2.MatDialogTitle, selector: "[mat-dialog-title], [matDialogTitle]", inputs: ["id"], exportAs: ["matDialogTitle"] }, { kind: "directive", type: i1$2.MatDialogContent, selector: "[mat-dialog-content], mat-dialog-content, [matDialogContent]" }], encapsulation: i0.ViewEncapsulation.None });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: MetadataAbstractComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-metadata-abstract', encapsulation: ViewEncapsulation.None, template: "<h2 mat-dialog-title>{{ data.layerTitle }}</h2>\n<button class=\"close-button\" mat-button mat-dialog-close>X</button>\n<mat-dialog-content *ngIf=\"data.type !== 'arcgisrest'\" class=\"mat-typography\">\n  <h3>{{ data.abstract }}</h3>\n</mat-dialog-content>\n<mat-dialog-content *ngIf=\"data.type === 'arcgisrest'\" class=\"mat-typography\">\n  <h3 [innerHTML]=\"data.abstract\"></h3>\n</mat-dialog-content>\n", styles: [":host{position:relative;display:block}:host .close-button{top:5px;right:5px;padding:7px;line-height:10px;position:absolute!important;min-width:auto}\n"] }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [MAT_DIALOG_DATA]
                }] }]; } });

class IgoMetadataModule {
    static forRoot() {
        return {
            ngModule: IgoMetadataModule,
            providers: []
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoMetadataModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoMetadataModule, declarations: [MetadataButtonComponent, MetadataAbstractComponent], imports: [CommonModule,
            MatIconModule,
            MatButtonModule,
            MatTooltipModule,
            IgoLanguageModule,
            MatDialogModule], exports: [MetadataButtonComponent, MetadataAbstractComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoMetadataModule, imports: [CommonModule,
            MatIconModule,
            MatButtonModule,
            MatTooltipModule,
            IgoLanguageModule,
            MatDialogModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoMetadataModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        MatIconModule,
                        MatButtonModule,
                        MatTooltipModule,
                        IgoLanguageModule,
                        MatDialogModule
                    ],
                    exports: [MetadataButtonComponent, MetadataAbstractComponent],
                    declarations: [MetadataButtonComponent, MetadataAbstractComponent]
                }]
        }] });

var CatalogItemType;
(function (CatalogItemType) {
    CatalogItemType["Layer"] = "layer";
    CatalogItemType["Group"] = "group";
})(CatalogItemType || (CatalogItemType = {}));
var TypeCatalog;
(function (TypeCatalog) {
    TypeCatalog[TypeCatalog["wms"] = 0] = "wms";
    TypeCatalog[TypeCatalog["wmts"] = 1] = "wmts";
    TypeCatalog[TypeCatalog["baselayers"] = 2] = "baselayers";
    TypeCatalog[TypeCatalog["arcgisrest"] = 3] = "arcgisrest";
    TypeCatalog[TypeCatalog["tilearcgisrest"] = 4] = "tilearcgisrest";
    TypeCatalog[TypeCatalog["imagearcgisrest"] = 5] = "imagearcgisrest";
    TypeCatalog[TypeCatalog["composite"] = 6] = "composite";
})(TypeCatalog || (TypeCatalog = {}));

class Catalog {
    id;
    title;
    url;
    removable;
    externalProvider;
    abstract;
    forcedProperties;
    items;
    type;
    version;
    matrixSet;
    requestEncoding;
    regFilters;
    groupImpose;
    groupSeparator;
    timeFilter;
    queryFormat;
    queryHtmlTarget;
    queryParams;
    sourceOptions;
    count;
    tooltipType;
    sortDirection;
    setCrossOriginAnonymous;
    showLegend;
    profils;
    constructor(options) {
        Object.assign(this, options);
    }
}

class WMSCatalog extends Catalog {
    _collectCatlogItems;
    constructor(options, _collectCatlogItems) {
        super(options);
        this._collectCatlogItems = _collectCatlogItems;
        const sType = TypeCatalog[TypeCatalog.wms];
        this.type = TypeCatalog[sType];
    }
    collectCatalogItems() {
        return this._collectCatlogItems(this);
    }
}
class WMTSCatalog extends Catalog {
    _collectCatlogItems;
    constructor(options, _collectCatlogItems) {
        super(options);
        this._collectCatlogItems = _collectCatlogItems;
        const sType = TypeCatalog[TypeCatalog.wmts];
        this.type = TypeCatalog[sType];
    }
    collectCatalogItems() {
        return this._collectCatlogItems(this);
    }
}
class BaselayersCatalog extends Catalog {
    _collectCatlogItems;
    constructor(options, _collectCatlogItems) {
        super(options);
        this._collectCatlogItems = _collectCatlogItems;
        const sType = TypeCatalog[TypeCatalog.baselayers];
        this.type = TypeCatalog[sType];
    }
    collectCatalogItems() {
        return this._collectCatlogItems(this);
    }
}
class ArcGISRestCatalog extends Catalog {
    _collectCatlogItems;
    constructor(options, _collectCatlogItems) {
        super(options);
        this._collectCatlogItems = _collectCatlogItems;
        const sType = TypeCatalog[TypeCatalog.arcgisrest];
        this.type = TypeCatalog[sType];
    }
    collectCatalogItems() {
        return this._collectCatlogItems(this);
    }
}
class TileOrImageArcGISRestCatalog extends Catalog {
    _collectCatlogItems;
    constructor(options, _collectCatlogItems, typeCatalog) {
        super(options);
        this._collectCatlogItems = _collectCatlogItems;
        this.type = TypeCatalog[TypeCatalog[typeCatalog]];
    }
    collectCatalogItems() {
        return this._collectCatlogItems(this);
    }
}
class CompositeCatalog extends Catalog {
    _collectCatlogItems;
    constructor(options, _collectCatlogItems) {
        super(options);
        this._collectCatlogItems = _collectCatlogItems;
        const sType = TypeCatalog[TypeCatalog.composite];
        this.type = TypeCatalog[sType];
        this.url = null;
    }
    collectCatalogItems() {
        return this._collectCatlogItems(this);
    }
}

class CatalogService {
    http;
    config;
    languageService;
    messageService;
    capabilitiesService;
    constructor(http, config, languageService, messageService, capabilitiesService) {
        this.http = http;
        this.config = config;
        this.languageService = languageService;
        this.messageService = messageService;
        this.capabilitiesService = capabilitiesService;
    }
    loadCatalogs() {
        const contextConfig = this.config.getConfig('context') || {};
        const catalogConfig = this.config.getConfig('catalog') || {};
        const apiUrl = catalogConfig.url || contextConfig.url;
        const catalogsFromConfig = catalogConfig.sources || [];
        const observables$ = [];
        if (apiUrl) {
            if (catalogConfig.baselayers) {
                const translate = this.languageService.translate;
                const title = translate.instant('igo.geo.catalog.baseLayers');
                const baseLayersCatalog = [
                    {
                        id: 'catalog.baselayers',
                        title,
                        url: `${apiUrl}/baselayers`,
                        type: 'baselayers'
                    }
                ];
                observables$.push(of(baseLayersCatalog));
            }
            // Catalogs from API
            const catalogsFromApi$ = this.http
                .get(`${apiUrl}/catalogs`)
                .pipe(map((catalogs) => catalogs.map((c) => Object.assign(c, c.options))), catchError((_response) => EMPTY));
            observables$.push(catalogsFromApi$);
        }
        // Catalogs from config
        if (catalogsFromConfig.length > 0) {
            observables$.push(of(catalogsFromConfig).pipe(map((catalogs) => catalogs.map((c) => {
                if (!c.id) {
                    c.id = uuid();
                }
                return c;
            }))));
        }
        return zip(...observables$).pipe(map((catalogs) => [].concat.apply([], catalogs)));
    }
    loadCatalogItems(catalog) {
        let newCatalog;
        newCatalog = CatalogFactory.createInstanceCatalog(catalog, this);
        return newCatalog.collectCatalogItems();
    }
    loadCatalogBaseLayerItems(catalog) {
        return this.getCatalogBaseLayersOptions(catalog).pipe(map((layersOptions) => {
            const items = layersOptions.map((layerOptions) => {
                return {
                    id: generateIdFromSourceOptions(layerOptions.sourceOptions),
                    title: layerOptions.title,
                    type: CatalogItemType.Layer,
                    externalProvider: catalog.externalProvider,
                    options: layerOptions
                };
            });
            return [
                {
                    id: 'catalog.group.baselayers',
                    type: CatalogItemType.Group,
                    externalProvider: catalog.externalProvider,
                    title: catalog.title,
                    items
                }
            ];
        }));
    }
    getCatalogBaseLayersOptions(catalog) {
        return this.http.get(catalog.url);
    }
    loadCatalogWMSLayerItems(catalog) {
        return this.getCatalogCapabilities(catalog).pipe(map((capabilities) => {
            const items = [];
            if (!capabilities) {
                return items;
            }
            if (capabilities.Service &&
                capabilities.Service.Abstract &&
                capabilities.Service.Abstract.length) {
                catalog.abstract = capabilities.Service.Abstract;
            }
            const finalLayers = [];
            this.flattenWmsCapabilities(capabilities.Capability.Layer, 0, finalLayers, catalog.groupSeparator);
            const capabilitiesCapabilityLayer = Object.assign({}, capabilities.Capability.Layer);
            capabilitiesCapabilityLayer.Layer = finalLayers.filter((f) => f.Layer.length !== 0);
            this.includeRecursiveItems(catalog, capabilitiesCapabilityLayer, items);
            return items;
        }));
    }
    flattenWmsCapabilities(parent, level = 0, finalLayers, separator = ' / ') {
        if (!finalLayers.includes(parent.Title)) {
            const modifiedParent = Object.assign({}, parent);
            modifiedParent.Layer = [];
            finalLayers.push(modifiedParent);
        }
        for (const layer of parent.Layer) {
            const modifiedLayer = Object.assign({}, layer);
            if (level > 0) {
                modifiedLayer.Title = parent.Title + separator + layer.Title;
            }
            if (layer.Layer) {
                this.flattenWmsCapabilities(modifiedLayer, level + 1, finalLayers, separator);
            }
            else {
                finalLayers.find((ff) => ff.Title === parent.Title).Layer.push(layer);
            }
        }
    }
    loadCatalogWMTSLayerItems(catalog) {
        return this.getCatalogCapabilities(catalog).pipe(map((capabilities) => this.getWMTSItems(catalog, capabilities)));
    }
    loadCatalogArcGISRestItems(catalog) {
        return this.getCatalogCapabilities(catalog).pipe(map((capabilities) => {
            return this.getArcGISRESTItems(catalog, capabilities);
        }));
    }
    loadCatalogCompositeLayerItems(catalog) {
        const compositeCatalog = catalog.composite;
        const catalogsFromInstance = [];
        compositeCatalog.map((component) => {
            component.sortDirection = catalog.sortDirection; // propagate sortDirection with parent value
            catalogsFromInstance.push(CatalogFactory.createInstanceCatalog(component, this));
        });
        // get CatalogItems for each original Catalog-----------------------------------------------------
        const request1$ = [];
        catalogsFromInstance.map((component) => request1$.push(component.collectCatalogItems()));
        // integrate imposed group -----------------------------------------------------
        let request2$ = [];
        function flatDeepLayer(arr) {
            return arr.reduce((acc, val) => acc.concat(val.type === CatalogItemType.Group ? flatDeepLayer(val.items) : val), []);
        }
        if (Object.keys(compositeCatalog).find((k) => compositeCatalog[k].groupImpose)) {
            const pushImposeGroup = (item, index) => {
                const c = catalogsFromInstance[index];
                const outGroupImpose = Object.assign({}, c.groupImpose);
                outGroupImpose.address = c.id;
                outGroupImpose.type = CatalogItemType.Group;
                outGroupImpose.externalProvider = c.externalProvider;
                if (outGroupImpose.sortDirection === undefined) {
                    outGroupImpose.sortDirection = c.sortDirection;
                }
                outGroupImpose.items = [];
                const flatLayer = flatDeepLayer(item);
                flatLayer.map((v) => (v.address = `${outGroupImpose.address}.${outGroupImpose.id}`));
                outGroupImpose.items = flatLayer;
                return outGroupImpose;
            };
            request2$ = request1$.map((obs, idx) => obs.pipe(map((items) => compositeCatalog[idx].groupImpose
                ? pushImposeGroup(items, idx)
                : items)));
        }
        else {
            request2$ = request1$;
        }
        // concat Group -----------------------------------------------------
        const request3$ = zip(...request2$).pipe(map((output) => [].concat(...output) // [].concat.apply([], result1
        ));
        // merge Group (first level only) -----------------------------------------------------
        const groupByGroupId = (data, keyFn) => data.reduce((acc, group) => {
            const groupId = keyFn(group);
            const ind = acc.find((x) => x.id === groupId);
            if (!ind) {
                acc[acc.length] = group;
            }
            else {
                const ix = acc.indexOf(ind);
                if (acc[ix].address.split('|').indexOf(group.address) === -1) {
                    acc[ix].address = `${acc[ix].address}|${group.address}`;
                }
                acc[ix].items.push(...group.items);
            }
            return acc;
        }, []);
        // merge Layer for each Level (catalog, group(recursive))
        const recursiveGroupByLayerAddress = (items, keyFn) => items.reduce((acc, item, idx, arr) => {
            const layerTitle = keyFn(item);
            const outItem = Object.assign({}, item);
            if (item.type === CatalogItemType.Layer) {
                // same title, same address => result: only one item is kept
                // same title, address diff
                const indicesMatchTitle = [];
                const indicesMatchNewMetadataUrl = []; // metadata
                const diffAddress = arr.filter((x, i) => {
                    let bInd = false;
                    if (x.title === layerTitle && x.type === CatalogItemType.Layer) {
                        if (i !== idx && x.address !== item.address) {
                            bInd = true;
                        }
                        indicesMatchTitle.push(i);
                    }
                    return bInd;
                }); // $& i !== idx
                if (diffAddress.length > 0) {
                    let nPosition = indicesMatchTitle.findIndex((x) => x === idx) + 1;
                    outItem.title = `${item.title} (${nPosition})`; // source: ${item.address.split('.')[0]}
                    nPosition =
                        indicesMatchNewMetadataUrl.findIndex((x) => x === idx) + 1;
                    outItem.newMetadataUrl = `${item.newMetadataUrl} (${nPosition})`; // source: ${item.address.split('.')[0]}
                }
                const exist = acc.find((x) => x.title === outItem.title && x.type === CatalogItemType.Layer);
                if (!exist) {
                    acc[acc.length] = outItem;
                }
            }
            else if (item.type === CatalogItemType.Group) {
                outItem.items = recursiveGroupByLayerAddress(item.items, (layer) => layer.title);
                acc[acc.length] = outItem;
            }
            return acc;
        }, []);
        const request4$ = request3$.pipe(map((output) => groupByGroupId(output, (group) => group.id)), map((output) => [].concat(...output)), map((data) => recursiveGroupByLayerAddress(data, (layer) => layer.title)));
        return request4$;
    }
    getCatalogCapabilities(catalog) {
        const sType = TypeCatalog[catalog.type];
        return this.capabilitiesService
            .getCapabilities(sType, catalog.url, catalog.version)
            .pipe(catchError((e) => {
            this.messageService.error(catalog.title
                ? 'igo.geo.catalog.unavailable'
                : 'igo.geo.catalog.someUnavailable', 'igo.geo.catalog.unavailableTitle', undefined, catalog.title ? { value: catalog.title } : undefined);
            console.error(e);
            return of(undefined);
        }));
    }
    computeForcedProperties(layerNameFromCatalog, forcedProperties) {
        if (!forcedProperties || forcedProperties.length === 0) {
            return;
        }
        const returnProperty = {
            layerName: layerNameFromCatalog,
            title: undefined,
            metadataUrl: undefined,
            metadataAbstract: undefined,
            metadataAbstractAll: undefined,
            metadataUrlAll: undefined
        };
        //process wildcard before
        // if there is a * wildcard
        const forcedPropertiesForAllLayers = forcedProperties.find((f) => f.layerName === '*');
        if (forcedPropertiesForAllLayers) {
            // metadataAbstractAll
            if (forcedPropertiesForAllLayers.metadataAbstractAll) {
                returnProperty.metadataAbstractAll =
                    forcedPropertiesForAllLayers.metadataAbstractAll;
            }
            // metadataUrlAll
            if (forcedPropertiesForAllLayers.metadataUrlAll) {
                returnProperty.metadataUrlAll =
                    forcedPropertiesForAllLayers.metadataUrlAll;
            }
        }
        forcedProperties.map((forcedProperty) => {
            // if match found
            if (layerNameFromCatalog === forcedProperty.layerName) {
                // title
                if (forcedProperty.title) {
                    returnProperty.title = forcedProperty.title;
                }
                // metadataUrl
                if (forcedProperty.metadataUrl) {
                    returnProperty.metadataUrl = forcedProperty.metadataUrl;
                }
                // metadataAbstract
                if (forcedProperty.metadataAbstract) {
                    returnProperty.metadataAbstract = forcedProperty.metadataAbstract;
                }
            }
        });
        return returnProperty;
    }
    /// WMS
    prepareCatalogItemLayer(layer, idParent, layersQueryFormat, catalog) {
        const configuredQueryFormat = this.retrieveLayerInfoFormat(layer.Name, layersQueryFormat);
        const legendOptions = catalog.showLegend && layer.Style
            ? this.capabilitiesService.getStyle(layer.Style)
            : undefined;
        const params = Object.assign({}, catalog.queryParams, {
            LAYERS: layer.Name,
            VERSION: catalog.version
        });
        const baseSourceOptions = {
            type: 'wms',
            url: catalog.url,
            crossOrigin: catalog.setCrossOriginAnonymous ? 'anonymous' : undefined,
            queryFormat: configuredQueryFormat,
            queryHtmlTarget: configuredQueryFormat === QueryFormat.HTML ||
                configuredQueryFormat === QueryFormat.HTMLGML2
                ? 'iframe'
                : undefined,
            optionsFromCapabilities: true
        };
        const sourceOptions = Object.assign({}, baseSourceOptions, catalog.sourceOptions, { params });
        const propertiesToForce = this.computeForcedProperties(layer.Name, catalog.forcedProperties);
        let baseAbstract;
        let extern = true;
        if (layer.Abstract) {
            baseAbstract = layer.Abstract;
        }
        else if (!layer.Abstract && catalog.abstract) {
            baseAbstract = catalog.abstract;
        }
        const layerOnlineResource = layer?.DataURL && layer?.DataURL.length > 0
            ? layer?.DataURL[0].OnlineResource
            : undefined;
        let metadataUrl = propertiesToForce?.metadataUrl ||
            propertiesToForce?.metadataUrlAll ||
            layerOnlineResource;
        let metadataAbstract = propertiesToForce?.metadataAbstract ||
            propertiesToForce?.metadataAbstractAll ||
            baseAbstract;
        if (!propertiesToForce?.metadataUrl &&
            !propertiesToForce?.metadataUrlAll &&
            (propertiesToForce?.metadataAbstract ||
                propertiesToForce?.metadataAbstractAll)) {
            extern = false;
        }
        if (propertiesToForce?.metadataAbstract &&
            propertiesToForce?.metadataUrlAll) {
            extern = false;
        }
        const layerPrepare = {
            id: generateIdFromSourceOptions(sourceOptions),
            type: CatalogItemType.Layer,
            title: propertiesToForce?.title ? propertiesToForce.title : layer.Title,
            address: idParent,
            externalProvider: catalog.externalProvider || false,
            options: {
                maxResolution: getResolutionFromScale(layer.MaxScaleDenominator),
                minResolution: getResolutionFromScale(layer.MinScaleDenominator),
                metadata: {
                    url: metadataUrl,
                    extern,
                    abstract: metadataAbstract,
                    type: baseSourceOptions.type
                },
                legendOptions,
                tooltip: { type: catalog.tooltipType },
                sourceOptions
            }
        };
        return ObjectUtils.removeUndefined(layerPrepare);
    }
    prepareCatalogItemGroup(itemListIn, regexes, idGroup, layersQueryFormat, catalog) {
        const groupPrepare = {
            id: idGroup,
            type: CatalogItemType.Group,
            title: itemListIn.Title,
            address: catalog.id,
            externalProvider: catalog.externalProvider || false,
            sortDirection: catalog.sortDirection,
            items: itemListIn.Layer.reduce((items, layer) => {
                if (layer.Layer !== undefined) {
                    // recursive, check next level
                    const idGroupItemNextLevel = idGroup + `.group.${layer.Name || layer.Layer[0].Name}`;
                    const groupItem = this.prepareCatalogItemGroup(layer, regexes, idGroupItemNextLevel, layersQueryFormat, catalog);
                    items.push(groupItem);
                }
                else {
                    if (this.testLayerRegexes(layer.Name, regexes) === false) {
                        return items;
                    }
                    const layerItem = this.prepareCatalogItemLayer(layer, idGroup, layersQueryFormat, catalog);
                    items.push(layerItem);
                }
                return items;
            }, [])
        };
        return groupPrepare;
    }
    includeRecursiveItems(catalog, itemListIn, itemsPrepare, loopLevel = 0) {
        // Dig all levels until last level (layer object are not defined on last level)
        const regexes = (catalog.regFilters || []).map((pattern) => new RegExp(pattern));
        if (!itemListIn.Layer) {
            return;
        }
        for (const item of itemListIn.Layer) {
            if (item.Layer !== undefined) {
                // recursive, check next level
                this.includeRecursiveItems(catalog, item, itemsPrepare, loopLevel + 1);
                continue;
            }
            const layersQueryFormat = this.findCatalogInfoFormat(catalog);
            // group(with layers) and layer(without group) level 1
            if (loopLevel !== 0) {
                // TODO: Slice that into multiple methods
                // Define object of group layer
                const idGroupItem = `catalog.group.${itemListIn.Name || item.Name}`;
                const groupItem = this.prepareCatalogItemGroup(itemListIn, regexes, idGroupItem, layersQueryFormat, catalog);
                if (groupItem.items.length !== 0) {
                    itemsPrepare.push(groupItem);
                }
                // Break the group (don't add a group of layer for each of their layer!)
                break;
            }
            else {
                // layer without group
                if (this.testLayerRegexes(item.Name, regexes) !== false) {
                    const layerItem = this.prepareCatalogItemLayer(item, catalog.id, layersQueryFormat, catalog);
                    itemsPrepare.push(layerItem);
                }
            }
        }
    }
    /// WMTS
    getWMTSItems(catalog, capabilities) {
        if (!capabilities) {
            return [];
        }
        const layers = capabilities.Contents.Layer;
        const regexes = (catalog.regFilters || []).map((pattern) => new RegExp(pattern));
        if (capabilities.ServiceIdentification &&
            capabilities.ServiceIdentification.Abstract &&
            capabilities.ServiceIdentification.Abstract.length) {
            catalog.abstract = capabilities.ServiceIdentification.Abstract;
        }
        return layers
            .map((layer) => {
            const propertiesToForce = this.computeForcedProperties(layer.Title, catalog.forcedProperties);
            let extern = true;
            let metadataUrl = propertiesToForce?.metadataUrl || propertiesToForce?.metadataUrlAll;
            let metadataAbstract = propertiesToForce?.metadataAbstract ||
                propertiesToForce?.metadataAbstractAll ||
                catalog.abstract;
            if (!propertiesToForce?.metadataUrl &&
                !propertiesToForce?.metadataUrlAll &&
                (propertiesToForce?.metadataAbstract ||
                    propertiesToForce?.metadataAbstractAll)) {
                extern = false;
            }
            if (propertiesToForce?.metadataAbstract &&
                propertiesToForce?.metadataUrlAll) {
                extern = false;
            }
            if (this.testLayerRegexes(layer.Identifier, regexes) === false) {
                return undefined;
            }
            const params = Object.assign({}, catalog.queryParams, {
                version: '1.0.0'
            });
            const baseSourceOptions = {
                type: 'wmts',
                url: catalog.url,
                crossOrigin: catalog.setCrossOriginAnonymous
                    ? 'anonymous'
                    : undefined,
                layer: layer.Identifier,
                matrixSet: catalog.matrixSet,
                optionsFromCapabilities: true,
                requestEncoding: catalog.requestEncoding || 'KVP',
                style: 'default'
            };
            const sourceOptions = Object.assign({}, baseSourceOptions, catalog.sourceOptions, { params });
            return ObjectUtils.removeUndefined({
                id: generateIdFromSourceOptions(sourceOptions),
                type: CatalogItemType.Layer,
                title: propertiesToForce?.title
                    ? propertiesToForce.title
                    : layer.Title,
                address: catalog.id,
                externalProvider: catalog.externalProvider,
                options: {
                    sourceOptions,
                    metadata: {
                        url: metadataUrl,
                        extern,
                        abstract: metadataAbstract,
                        type: baseSourceOptions.type
                    }
                }
            });
        })
            .filter((item) => item !== undefined);
    }
    /// ERSI
    getArcGISRESTItems(catalog, capabilities) {
        if (!capabilities) {
            return [];
        }
        const layers = !capabilities.layers
            ? []
            : capabilities.layers.filter((layer) => !layer.type || layer.type === 'Feature Layer');
        if (!capabilities.layers) {
            this.messageService.error('igo.geo.catalog.someUnavailable', 'igo.geo.catalog.unavailableTitle');
        }
        const regexes = (catalog.regFilters || []).map((pattern) => new RegExp(pattern));
        let abstract;
        if (capabilities.serviceDescription &&
            capabilities.serviceDescription.length) {
            const regex = /(<([^>]+)>)/gi;
            abstract = capabilities.serviceDescription.replace(regex, '');
        }
        return layers
            .map((layer) => {
            const propertiesToForce = this.computeForcedProperties(layer.name, catalog.forcedProperties);
            let baseAbstract;
            let extern = true;
            if (layer.Abstract) {
                baseAbstract = layer.Abstract;
            }
            else if (!layer.Abstract && catalog.abstract) {
                baseAbstract = catalog.abstract;
            }
            let metadataUrl = propertiesToForce?.metadataUrl || propertiesToForce?.metadataUrlAll;
            let metadataAbstract = propertiesToForce?.metadataAbstract ||
                propertiesToForce?.metadataAbstractAll ||
                baseAbstract;
            if (!propertiesToForce?.metadataUrl &&
                !propertiesToForce?.metadataUrlAll &&
                (propertiesToForce?.metadataAbstract ||
                    propertiesToForce?.metadataAbstractAll)) {
                extern = false;
            }
            if (propertiesToForce?.metadataAbstract &&
                propertiesToForce?.metadataUrlAll) {
                extern = false;
            }
            if (this.testLayerRegexes(layer.id, regexes) === false) {
                return undefined;
            }
            const baseSourceOptions = {
                type: TypeCatalog[catalog.type],
                url: catalog.url,
                crossOrigin: catalog.setCrossOriginAnonymous
                    ? 'anonymous'
                    : undefined,
                layer: layer.id,
                queryable: true,
                queryFormat: 'esrijson',
                matrixSet: catalog.matrixSet,
                optionsFromCapabilities: true,
                style: 'default'
            };
            const sourceOptions = Object.assign({}, baseSourceOptions, catalog.sourceOptions);
            return ObjectUtils.removeUndefined({
                id: generateIdFromSourceOptions(sourceOptions),
                type: CatalogItemType.Layer,
                title: propertiesToForce?.title
                    ? propertiesToForce.title
                    : layer.name,
                externalProvider: catalog.externalProvider,
                address: catalog.id,
                options: {
                    sourceOptions,
                    minResolution: getResolutionFromScale(layer.maxScale),
                    maxResolution: getResolutionFromScale(layer.minScale),
                    metadata: {
                        url: metadataUrl,
                        extern,
                        abstract: metadataAbstract,
                        type: baseSourceOptions.type
                    }
                }
            });
        })
            .filter((item) => item !== undefined);
    }
    testLayerRegexes(layerName, regexes) {
        if (regexes.length === 0) {
            return true;
        }
        return regexes.find((regex) => regex.test(layerName)) !== undefined;
    }
    retrieveLayerInfoFormat(layerNameFromCatalog, layersQueryFormat) {
        const currentLayerInfoFormat = layersQueryFormat.find((f) => f.layer === layerNameFromCatalog);
        const baseInfoFormat = layersQueryFormat.find((f) => f.layer === '*');
        let queryFormat;
        if (currentLayerInfoFormat) {
            queryFormat = currentLayerInfoFormat.queryFormat;
        }
        else if (baseInfoFormat) {
            queryFormat = baseInfoFormat.queryFormat;
        }
        return queryFormat;
    }
    findCatalogInfoFormat(catalog) {
        const layersQueryFormat = [];
        if (!catalog.queryFormat) {
            return layersQueryFormat;
        }
        Object.keys(catalog.queryFormat).forEach((configuredInfoFormat) => {
            if (catalog.queryFormat[configuredInfoFormat] instanceof Array) {
                catalog.queryFormat[configuredInfoFormat].forEach((layerName) => {
                    if (!layersQueryFormat.find((specific) => specific.layer === layerName)) {
                        layersQueryFormat.push({
                            layer: layerName,
                            queryFormat: configuredInfoFormat
                        });
                    }
                });
            }
            else {
                if (!layersQueryFormat.find((specific) => specific.layer === catalog.queryFormat[configuredInfoFormat])) {
                    layersQueryFormat.push({
                        layer: catalog.queryFormat[configuredInfoFormat],
                        queryFormat: configuredInfoFormat
                    });
                }
            }
        });
        return layersQueryFormat;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CatalogService, deps: [{ token: i1.HttpClient }, { token: i2.ConfigService }, { token: i2.LanguageService }, { token: i2.MessageService }, { token: CapabilitiesService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CatalogService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CatalogService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: i2.ConfigService }, { type: i2.LanguageService }, { type: i2.MessageService }, { type: CapabilitiesService }]; } });
class CatalogFactory {
    static createInstanceCatalog(options, catalogService) {
        let catalog;
        if (options.hasOwnProperty('composite')) {
            catalog = new CompositeCatalog(options, (catalog) => catalogService.loadCatalogCompositeLayerItems(catalog));
        }
        else if (options.type === TypeCatalog[TypeCatalog.baselayers]) {
            catalog = new BaselayersCatalog(options, (catalog) => catalogService.loadCatalogBaseLayerItems(catalog));
        }
        else if (options.type === TypeCatalog[TypeCatalog.arcgisrest]) {
            catalog = new ArcGISRestCatalog(options, (catalog) => catalogService.loadCatalogArcGISRestItems(catalog));
        }
        else if (options.type === TypeCatalog[TypeCatalog.tilearcgisrest]) {
            catalog = new TileOrImageArcGISRestCatalog(options, (catalog) => catalogService.loadCatalogArcGISRestItems(catalog), TypeCatalog.tilearcgisrest);
        }
        else if (options.type === TypeCatalog[TypeCatalog.imagearcgisrest]) {
            catalog = new TileOrImageArcGISRestCatalog(options, (catalog) => catalogService.loadCatalogArcGISRestItems(catalog), TypeCatalog.imagearcgisrest);
        }
        else if (options.type === TypeCatalog[TypeCatalog.wmts]) {
            catalog = new WMTSCatalog(options, (catalog) => catalogService.loadCatalogWMTSLayerItems(catalog));
        }
        else {
            catalog = new WMSCatalog(options, (catalog) => catalogService.loadCatalogWMSLayerItems(catalog));
        }
        return catalog;
    }
}

/**
 * Catalog browser layer item
 */
class CatalogBrowserLayerComponent {
    layerService;
    inRange$ = new BehaviorSubject(true);
    isPreview$ = new BehaviorSubject(false);
    isVisible$ = new BehaviorSubject(false);
    isPreview$$;
    resolution$$;
    layers$$;
    lastTimeoutRequest;
    layerLegendShown$ = new BehaviorSubject(false);
    igoLayer$ = new BehaviorSubject(undefined);
    mouseInsideAdd = false;
    resolution;
    catalogAllowLegend = false;
    /**
     * Catalog layer
     */
    layer;
    map;
    /**
     * Whether the layer is already added to the map
     */
    added = false;
    /**
     * Event emitted when the add/remove button is clicked
     */
    addedChange = new EventEmitter();
    addedLayerIsPreview = new EventEmitter();
    /**
     * @internal
     */
    get title() {
        return getEntityTitle(this.layer);
    }
    /**
     * @internal
     */
    get icon() {
        return getEntityIcon(this.layer) || 'layers';
    }
    constructor(layerService) {
        this.layerService = layerService;
    }
    ngOnInit() {
        this.isPreview$$ = this.isPreview$.subscribe((value) => this.addedLayerIsPreview.emit(value));
        this.layers$$ = this.map.layers$.subscribe(() => {
            this.isVisible();
        });
        this.resolution$$ = this.map.viewController.resolution$.subscribe((resolution) => {
            this.isInResolutionsRange(resolution);
            this.isVisible();
        });
    }
    ngOnDestroy() {
        this.isPreview$$.unsubscribe();
        this.resolution$$.unsubscribe();
        this.layers$$.unsubscribe();
    }
    computeTitleTooltip() {
        const layerOptions = this.layer.options;
        if (!layerOptions.tooltip) {
            return getEntityTitle(this.layer);
        }
        const layerTooltip = layerOptions.tooltip;
        const layerMetadata = layerOptions.metadata;
        switch (layerOptions.tooltip.type) {
            case TooltipType.TITLE:
                return this.layer.title;
            case TooltipType.ABSTRACT:
                if (layerMetadata && layerMetadata.abstract) {
                    return layerMetadata.abstract;
                }
                else {
                    return this.layer.title;
                }
            case TooltipType.CUSTOM:
                if (layerTooltip && layerTooltip.text) {
                    return layerTooltip.text;
                }
                else {
                    return this.layer.title;
                }
            default:
                return this.layer.title;
        }
    }
    /**
     * On mouse event, mouseenter /mouseleave
     * @internal
     */
    onMouseEvent(event) {
        this.onToggleClick(event);
    }
    askForLegend(event) {
        this.layerLegendShown$.next(!this.layerLegendShown$.value);
        this.layerService
            .createAsyncLayer(this.layer.options)
            .pipe(first())
            .subscribe((layer) => this.igoLayer$.next(layer));
    }
    /**
     * On toggle button click, emit the added change event
     * @internal
     */
    onToggleClick(event) {
        if (typeof this.lastTimeoutRequest !== 'undefined') {
            clearTimeout(this.lastTimeoutRequest);
        }
        if (event.type === 'mouseenter' && this.mouseInsideAdd) {
            return;
        }
        switch (event.type) {
            case 'click':
                if (!this.isPreview$.value) {
                    if (this.added) {
                        this.remove(event);
                    }
                    else {
                        this.add(event);
                    }
                }
                this.isPreview$.next(false);
                break;
            case 'mouseenter':
                if (!this.isPreview$.value && !this.added) {
                    this.lastTimeoutRequest = setTimeout(() => {
                        this.add(event);
                        this.isPreview$.next(true);
                    }, 500);
                }
                this.mouseInsideAdd = true;
                break;
            case 'mouseleave':
                if (this.isPreview$.value) {
                    this.remove(event);
                    this.isPreview$.next(false);
                }
                this.mouseInsideAdd = false;
                break;
            default:
                break;
        }
    }
    /**
     * Emit added change event with added = true
     */
    add(event) {
        if (!this.added) {
            this.added = true;
            this.addedChange.emit({ added: true, layer: this.layer, event });
        }
    }
    /**
     * Emit added change event with added = false
     */
    remove(event) {
        if (this.added) {
            this.added = false;
            this.addedChange.emit({ added: false, layer: this.layer, event });
        }
    }
    haveGroup() {
        return !(!this.layer.address || this.layer.address.split('.').length === 1);
    }
    isInResolutionsRange(resolution) {
        const minResolution = !this.layer.options.minResolution ||
            Number.isNaN(this.layer.options.minResolution)
            ? 0
            : this.layer.options.minResolution;
        const maxResolution = !this.layer.options.maxResolution ||
            Number.isNaN(this.layer.options.maxResolution)
            ? Infinity
            : this.layer.options.maxResolution;
        this.inRange$.next(resolution >= minResolution && resolution <= maxResolution);
    }
    isVisible() {
        if (this.layer?.id) {
            const oLayer = this.map.getLayerById(this.layer?.id);
            oLayer
                ? this.isVisible$.next(oLayer.visible)
                : this.isVisible$.next(false);
        }
    }
    getBadgeIcon() {
        if (this.inRange$.getValue()) {
            return this.isVisible$.getValue() ? '' : 'eye-off';
        }
        else {
            return 'eye-off';
        }
    }
    computeTooltip() {
        if (this.added) {
            if (this.isPreview$.value) {
                return 'igo.geo.catalog.layer.addToMap';
            }
            else if (this.inRange$.value) {
                return this.isVisible$.value
                    ? 'igo.geo.catalog.layer.removeFromMap'
                    : 'igo.geo.catalog.layer.removeFromMapNotVisible';
            }
            else {
                return 'igo.geo.catalog.layer.removeFromMapOutRange';
            }
        }
        else {
            return this.inRange$.value
                ? 'igo.geo.catalog.layer.addToMap'
                : 'igo.geo.catalog.layer.addToMapOutRange';
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CatalogBrowserLayerComponent, deps: [{ token: LayerService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: CatalogBrowserLayerComponent, selector: "igo-catalog-browser-layer", inputs: { resolution: "resolution", catalogAllowLegend: "catalogAllowLegend", layer: "layer", map: "map", added: "added" }, outputs: { addedChange: "addedChange", addedLayerIsPreview: "addedLayerIsPreview" }, ngImport: i0, template: "<mat-list-item>\n  <mat-icon\n    *ngIf=\"haveGroup()\"\n    class=\"catalog-browser-layer-carret\"\n    matListItemIcon\n    svgIcon=\"blank\"\n  ></mat-icon>\n  <span\n    matListItemTitle\n    matTooltipShowDelay=\"500\"\n    [ngClass]=\"catalogAllowLegend ? 'igo-cataloglayer-title' : ''\"\n    (click)=\"askForLegend($event)\"\n    [matTooltip]=\"computeTitleTooltip()\"\n  >\n    {{ title }}\n  </span>\n\n  <div matListItemMeta>\n    <button *ngIf=\"layer.externalProvider\" disabled=\"true\" mat-icon-button>\n      <mat-icon\n        class=\"igo-cataloglayer-external-icon\"\n        tooltip-position=\"below\"\n        matTooltipShowDelay=\"500\"\n        [matTooltip]=\"'igo.geo.catalog.externalProvider.layer' | translate\"\n        color=\"primary\"\n        (click)=\"$event.stopPropagation()\"\n        svgIcon=\"earth-arrow-right\"\n      >\n      </mat-icon>\n    </button>\n    <igo-metadata-button [layer]=\"layer\"></igo-metadata-button>\n\n    <button\n      (mouseenter)=\"onMouseEvent($event)\"\n      (mouseleave)=\"onMouseEvent($event)\"\n      mat-icon-button\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"computeTooltip() | translate\"\n      [color]=\"(isPreview$ | async) ? '' : added ? 'warn' : ''\"\n      (click)=\"onToggleClick($event)\"\n    >\n      <mat-icon\n        aria-hidden=\"false\"\n        matBadge=\"icon\"\n        [igoMatBadgeIcon]=\"getBadgeIcon()\"\n        igoMatBadgeColor=\"rgba(0,0,0,0.87)\"\n        igoMatBadgeBackgroundColor=\"none\"\n        igoMatBadgeInverseColor=\"true\"\n        [matBadgeHidden]=\"\n          ((inRange$ | async) && (isVisible$ | async) === true) ||\n          ((inRange$ | async) && !added) ||\n          ((inRange$ | async) && (isPreview$ | async))\n        \"\n        [matBadgeDisabled]=\"(inRange$ | async) === false\"\n        matBadgeSize=\"small\"\n        matBadgePosition=\"after\"\n        [svgIcon]=\"(isPreview$ | async) ? 'plus' : added ? 'delete' : 'plus'\"\n      >\n      </mat-icon>\n    </button>\n  </div>\n</mat-list-item>\n\n<div #legend class=\"igo-cataloglayer-legend-container\">\n  <igo-layer-legend\n    *ngIf=\"\n      (layerLegendShown$ | async) && (igoLayer$ | async) && catalogAllowLegend\n    \"\n    [layer]=\"igoLayer$ | async\"\n  >\n  </igo-layer-legend>\n</div>\n", styles: [".igo-cataloglayer-title{cursor:pointer}.catalog-browser-layer-carret{margin-right:16px}.igo-cataloglayer-legend-container{padding-left:18px;width:calc(100% - 18px);margin-left:40px}.igo-cataloglayer-external-icon{cursor:help}:host .mdc-list-item__end,:host .mdc-list-item__start{color:#000}\n"], dependencies: [{ kind: "directive", type: i2$2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i6.MatBadge, selector: "[matBadge]", inputs: ["matBadgeDisabled", "matBadgeColor", "matBadgeOverlap", "matBadgePosition", "matBadge", "matBadgeDescription", "matBadgeSize", "matBadgeHidden"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i5.MatListItem, selector: "mat-list-item, a[mat-list-item], button[mat-list-item]", inputs: ["activated"], exportAs: ["matListItem"] }, { kind: "directive", type: i5.MatListItemIcon, selector: "[matListItemIcon]" }, { kind: "directive", type: i5.MatListItemTitle, selector: "[matListItemTitle]" }, { kind: "directive", type: i5.MatListItemMeta, selector: "[matListItemMeta]" }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "directive", type: i9$1.IgoBadgeIconDirective, selector: "[igoMatBadgeIcon]", inputs: ["igoMatBadgeIcon", "matBadgeHidden", "matBadgeDisabled", "igoMatBadgeInverseColor", "igoMatBadgeInheritColor", "igoMatBadgeColor", "igoMatBadgeBackgroundColor"] }, { kind: "component", type: MetadataButtonComponent, selector: "igo-metadata-button", inputs: ["layer", "color"] }, { kind: "component", type: LayerLegendComponent, selector: "igo-layer-legend", inputs: ["updateLegendOnResolutionChange", "layer"] }, { kind: "pipe", type: i2$2.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CatalogBrowserLayerComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-catalog-browser-layer', changeDetection: ChangeDetectionStrategy.OnPush, template: "<mat-list-item>\n  <mat-icon\n    *ngIf=\"haveGroup()\"\n    class=\"catalog-browser-layer-carret\"\n    matListItemIcon\n    svgIcon=\"blank\"\n  ></mat-icon>\n  <span\n    matListItemTitle\n    matTooltipShowDelay=\"500\"\n    [ngClass]=\"catalogAllowLegend ? 'igo-cataloglayer-title' : ''\"\n    (click)=\"askForLegend($event)\"\n    [matTooltip]=\"computeTitleTooltip()\"\n  >\n    {{ title }}\n  </span>\n\n  <div matListItemMeta>\n    <button *ngIf=\"layer.externalProvider\" disabled=\"true\" mat-icon-button>\n      <mat-icon\n        class=\"igo-cataloglayer-external-icon\"\n        tooltip-position=\"below\"\n        matTooltipShowDelay=\"500\"\n        [matTooltip]=\"'igo.geo.catalog.externalProvider.layer' | translate\"\n        color=\"primary\"\n        (click)=\"$event.stopPropagation()\"\n        svgIcon=\"earth-arrow-right\"\n      >\n      </mat-icon>\n    </button>\n    <igo-metadata-button [layer]=\"layer\"></igo-metadata-button>\n\n    <button\n      (mouseenter)=\"onMouseEvent($event)\"\n      (mouseleave)=\"onMouseEvent($event)\"\n      mat-icon-button\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"computeTooltip() | translate\"\n      [color]=\"(isPreview$ | async) ? '' : added ? 'warn' : ''\"\n      (click)=\"onToggleClick($event)\"\n    >\n      <mat-icon\n        aria-hidden=\"false\"\n        matBadge=\"icon\"\n        [igoMatBadgeIcon]=\"getBadgeIcon()\"\n        igoMatBadgeColor=\"rgba(0,0,0,0.87)\"\n        igoMatBadgeBackgroundColor=\"none\"\n        igoMatBadgeInverseColor=\"true\"\n        [matBadgeHidden]=\"\n          ((inRange$ | async) && (isVisible$ | async) === true) ||\n          ((inRange$ | async) && !added) ||\n          ((inRange$ | async) && (isPreview$ | async))\n        \"\n        [matBadgeDisabled]=\"(inRange$ | async) === false\"\n        matBadgeSize=\"small\"\n        matBadgePosition=\"after\"\n        [svgIcon]=\"(isPreview$ | async) ? 'plus' : added ? 'delete' : 'plus'\"\n      >\n      </mat-icon>\n    </button>\n  </div>\n</mat-list-item>\n\n<div #legend class=\"igo-cataloglayer-legend-container\">\n  <igo-layer-legend\n    *ngIf=\"\n      (layerLegendShown$ | async) && (igoLayer$ | async) && catalogAllowLegend\n    \"\n    [layer]=\"igoLayer$ | async\"\n  >\n  </igo-layer-legend>\n</div>\n", styles: [".igo-cataloglayer-title{cursor:pointer}.catalog-browser-layer-carret{margin-right:16px}.igo-cataloglayer-legend-container{padding-left:18px;width:calc(100% - 18px);margin-left:40px}.igo-cataloglayer-external-icon{cursor:help}:host .mdc-list-item__end,:host .mdc-list-item__start{color:#000}\n"] }]
        }], ctorParameters: function () { return [{ type: LayerService }]; }, propDecorators: { resolution: [{
                type: Input
            }], catalogAllowLegend: [{
                type: Input
            }], layer: [{
                type: Input
            }], map: [{
                type: Input
            }], added: [{
                type: Input
            }], addedChange: [{
                type: Output
            }], addedLayerIsPreview: [{
                type: Output
            }] } });

/**
 * Catalog browser group item
 */
class CatalogBrowserGroupComponent {
    /**
     * Group's items store
     * @internal
     */
    store = new EntityStore([]);
    /**
     * Whether all the layers of the group are added
     * @internal
     */
    added$ = new BehaviorSubject(false);
    preview$ = new BehaviorSubject(false);
    /**
     * Whether the toggle button is disabled
     * @internal
     */
    disabled$ = new BehaviorSubject(false);
    /**
     * Catalog
     */
    catalog;
    /**
     * Catalog group
     */
    group;
    map;
    /**
     * Whether the group is collapsed
     */
    collapsed = true;
    resolution;
    catalogAllowLegend = false;
    /**
     * Whether the group can be toggled when it's collapsed
     */
    toggleCollapsed = true;
    /**
     * Parent catalog's items store state. Groups share a unique
     * EntityState that tracks the group and it's layers state (whether they are added or not).
     * Sharing a unique state would also allow us to expand this component to allow
     * the selection of a layer while unselecting any layer already selected in another group.
     * This could be useful to display some layer info before adding it, for example.
     */
    state;
    /**
     * Event emitted when the add/remove button of the group is clicked
     */
    addedChange = new EventEmitter();
    /**
     * Event emitted when the add/remove button of a layer is clicked
     */
    layerAddedChange = new EventEmitter();
    /**
     * @internal
     */
    get title() {
        return this.group.title;
    }
    /**
     * @internal
     */
    ngOnInit() {
        this.store.load(this.group.items);
        this.evaluateAdded();
        this.evaluateDisabled(this.collapsed);
        if (this.group.sortDirection !== undefined) {
            this.store.view.sort({
                direction: this.group.sortDirection,
                valueAccessor: (item) => item.title
            });
        }
    }
    ngOnDestroy() {
        this.store.destroy();
    }
    /**
     * @internal
     */
    isGroup(item) {
        return item.type === CatalogItemType.Group;
    }
    /**
     * @internal
     */
    isLayer(item) {
        return item.type === CatalogItemType.Layer;
    }
    /**
     * On toggle button click, emit the added change event
     * @internal
     */
    onToggleClick(event) {
        this.added$.value ? this.remove(event) : this.add(event);
    }
    /**
     * On toggle button click, emit the added change event
     * @internal
     */
    onToggleCollapsed(collapsed) {
        this.evaluateDisabled(collapsed);
    }
    /**
     * When a layer is added or removed, evaluate if all the layers of the group
     * are now added or removed. If so, consider that the group itself is added
     * or removed.
     * @internal
     * @param event Layer added change event
     */
    onLayerAddedChange(event) {
        this.layerAddedChange.emit(event);
        this.tryToggleGroup(event);
    }
    /**
     * Emit added change event with added = true
     */
    add(event) {
        this.added$.next(true);
        this.addedChange.emit({
            added: true,
            group: this.group,
            event
        });
    }
    /**
     * Emit added change event with added = true
     */
    remove(event) {
        this.added$.next(false);
        this.addedChange.emit({
            added: false,
            group: this.group,
            event
        });
    }
    onLayerPreview(event) {
        this.preview$.next(event);
    }
    /**
     * If all the layers of the group added or removed, add or remove the group itself.
     * @param event The last layer added change event to occur
     */
    tryToggleGroup(event) {
        const added = event.added;
        const layer = event.layer;
        const layersAdded = this.store.view
            .all()
            .filter((item) => item.id !== layer.id)
            .map((item) => this.state.get(item).added || false);
        if (layersAdded.every((value) => value === added)) {
            added ? this.add(event.event) : this.remove(event.event);
        }
        else if (this.added$.value === true) {
            this.added$.next(false);
        }
    }
    evaluateAdded() {
        const added = this.store.all().every((item) => {
            return (this.state.get(item).added || false) === true;
        });
        this.added$.next(added);
    }
    evaluateDisabled(collapsed) {
        let disabled = false;
        if (this.toggleCollapsed === false) {
            disabled = collapsed;
        }
        this.disabled$.next(disabled);
    }
    onTitleClick() {
        this.collapsed = !this.collapsed;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CatalogBrowserGroupComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: CatalogBrowserGroupComponent, selector: "igo-catalog-browser-group", inputs: { catalog: "catalog", group: "group", map: "map", collapsed: "collapsed", resolution: "resolution", catalogAllowLegend: "catalogAllowLegend", toggleCollapsed: "toggleCollapsed", state: "state" }, outputs: { addedChange: "addedChange", layerAddedChange: "layerAddedChange" }, ngImport: i0, template: "<mat-list-item>\n  <mat-icon\n    matListItemIcon\n    svgIcon=\"chevron-up\"\n    igoCollapse\n    class=\"igo-chevron catalog-browser-group-carret\"\n    [target]=\"items\"\n    [collapsed]=\"collapsed\"\n    (toggle)=\"onToggleCollapsed($event)\"\n  >\n  </mat-icon>\n\n  <span\n    class=\"igo-catalog-group-title\"\n    matListItemTitle\n    matTooltipShowDelay=\"500\"\n    [matTooltip]=\"title\"\n    (click)=\"onTitleClick()\"\n    >{{ title }}</span\n  >\n\n  <div matListItemMeta>\n    <button *ngIf=\"group.externalProvider\" disabled=\"true\" mat-icon-button>\n      <mat-icon\n        class=\"igo-cataloggroup-external-icon\"\n        *ngIf=\"group.externalProvider\"\n        tooltip-position=\"below\"\n        matTooltipShowDelay=\"500\"\n        [matTooltip]=\"'igo.geo.catalog.externalProvider.group' | translate\"\n        color=\"primary\"\n        (click)=\"$event.stopPropagation()\"\n        svgIcon=\"earth-arrow-right\"\n      >\n      </mat-icon>\n    </button>\n\n    <ng-container\n      *ngIf=\"(added$ | async) && (preview$ | async) === false; else notadded\"\n    >\n      <button\n        mat-icon-button\n        tooltip-position=\"below\"\n        matTooltipShowDelay=\"500\"\n        [matTooltip]=\"'igo.geo.catalog.group.removeFromMap' | translate\"\n        color=\"warn\"\n        [disabled]=\"disabled$ | async\"\n        (click)=\"onToggleClick($event)\"\n      >\n        <mat-icon svgIcon=\"delete\"></mat-icon>\n      </button>\n    </ng-container>\n\n    <ng-template #notadded>\n      <button\n        mat-icon-button\n        tooltip-position=\"below\"\n        matTooltipShowDelay=\"500\"\n        [matTooltip]=\"'igo.geo.catalog.group.addToMap' | translate\"\n        [disabled]=\"disabled$ | async\"\n        (click)=\"onToggleClick($event)\"\n      >\n        <mat-icon svgIcon=\"plus\"></mat-icon>\n      </button>\n    </ng-template>\n  </div>\n</mat-list-item>\n\n<div #items>\n  <ng-template ngFor let-item [ngForOf]=\"store.view.all$() | async\">\n    <ng-container *ngIf=\"isGroup(item)\">\n      <!-- todo: add display ans manage CatalogItemGroup -->\n    </ng-container>\n    <ng-container *ngIf=\"isLayer(item)\">\n      <igo-catalog-browser-layer\n        igoListItem\n        [layer]=\"item\"\n        [resolution]=\"resolution\"\n        [map]=\"map\"\n        [catalogAllowLegend]=\"catalogAllowLegend\"\n        [added]=\"state.get(item).added\"\n        (addedLayerIsPreview)=\"onLayerPreview($event)\"\n        (addedChange)=\"onLayerAddedChange($event)\"\n      >\n      </igo-catalog-browser-layer>\n    </ng-container>\n  </ng-template>\n</div>\n", styles: [".igo-catalog-group-title{cursor:pointer}.igo-cataloggroup-external-icon{cursor:help}.catalog-browser-group-carret{margin-right:16px}.igo-catalog-group-title{font-weight:500}:host .mdc-list-item__end,:host .mdc-list-item__start{color:#000}\n"], dependencies: [{ kind: "directive", type: i2$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i5.MatListItem, selector: "mat-list-item, a[mat-list-item], button[mat-list-item]", inputs: ["activated"], exportAs: ["matListItem"] }, { kind: "directive", type: i5.MatListItemIcon, selector: "[matListItemIcon]" }, { kind: "directive", type: i5.MatListItemTitle, selector: "[matListItemTitle]" }, { kind: "directive", type: i5.MatListItemMeta, selector: "[matListItemMeta]" }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "directive", type: i9$1.ListItemDirective, selector: "[igoListItem]", inputs: ["color", "focused", "selected", "disabled"], outputs: ["beforeSelect", "beforeFocus", "beforeUnselect", "beforeUnfocus", "beforeDisable", "beforeEnable", "focus", "unfocus", "select", "unselect", "disable", "enable"] }, { kind: "directive", type: i9$1.CollapseDirective, selector: "[igoCollapse]", inputs: ["target", "collapsed"], outputs: ["toggle"] }, { kind: "component", type: CatalogBrowserLayerComponent, selector: "igo-catalog-browser-layer", inputs: ["resolution", "catalogAllowLegend", "layer", "map", "added"], outputs: ["addedChange", "addedLayerIsPreview"] }, { kind: "pipe", type: i2$2.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CatalogBrowserGroupComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-catalog-browser-group', changeDetection: ChangeDetectionStrategy.OnPush, template: "<mat-list-item>\n  <mat-icon\n    matListItemIcon\n    svgIcon=\"chevron-up\"\n    igoCollapse\n    class=\"igo-chevron catalog-browser-group-carret\"\n    [target]=\"items\"\n    [collapsed]=\"collapsed\"\n    (toggle)=\"onToggleCollapsed($event)\"\n  >\n  </mat-icon>\n\n  <span\n    class=\"igo-catalog-group-title\"\n    matListItemTitle\n    matTooltipShowDelay=\"500\"\n    [matTooltip]=\"title\"\n    (click)=\"onTitleClick()\"\n    >{{ title }}</span\n  >\n\n  <div matListItemMeta>\n    <button *ngIf=\"group.externalProvider\" disabled=\"true\" mat-icon-button>\n      <mat-icon\n        class=\"igo-cataloggroup-external-icon\"\n        *ngIf=\"group.externalProvider\"\n        tooltip-position=\"below\"\n        matTooltipShowDelay=\"500\"\n        [matTooltip]=\"'igo.geo.catalog.externalProvider.group' | translate\"\n        color=\"primary\"\n        (click)=\"$event.stopPropagation()\"\n        svgIcon=\"earth-arrow-right\"\n      >\n      </mat-icon>\n    </button>\n\n    <ng-container\n      *ngIf=\"(added$ | async) && (preview$ | async) === false; else notadded\"\n    >\n      <button\n        mat-icon-button\n        tooltip-position=\"below\"\n        matTooltipShowDelay=\"500\"\n        [matTooltip]=\"'igo.geo.catalog.group.removeFromMap' | translate\"\n        color=\"warn\"\n        [disabled]=\"disabled$ | async\"\n        (click)=\"onToggleClick($event)\"\n      >\n        <mat-icon svgIcon=\"delete\"></mat-icon>\n      </button>\n    </ng-container>\n\n    <ng-template #notadded>\n      <button\n        mat-icon-button\n        tooltip-position=\"below\"\n        matTooltipShowDelay=\"500\"\n        [matTooltip]=\"'igo.geo.catalog.group.addToMap' | translate\"\n        [disabled]=\"disabled$ | async\"\n        (click)=\"onToggleClick($event)\"\n      >\n        <mat-icon svgIcon=\"plus\"></mat-icon>\n      </button>\n    </ng-template>\n  </div>\n</mat-list-item>\n\n<div #items>\n  <ng-template ngFor let-item [ngForOf]=\"store.view.all$() | async\">\n    <ng-container *ngIf=\"isGroup(item)\">\n      <!-- todo: add display ans manage CatalogItemGroup -->\n    </ng-container>\n    <ng-container *ngIf=\"isLayer(item)\">\n      <igo-catalog-browser-layer\n        igoListItem\n        [layer]=\"item\"\n        [resolution]=\"resolution\"\n        [map]=\"map\"\n        [catalogAllowLegend]=\"catalogAllowLegend\"\n        [added]=\"state.get(item).added\"\n        (addedLayerIsPreview)=\"onLayerPreview($event)\"\n        (addedChange)=\"onLayerAddedChange($event)\"\n      >\n      </igo-catalog-browser-layer>\n    </ng-container>\n  </ng-template>\n</div>\n", styles: [".igo-catalog-group-title{cursor:pointer}.igo-cataloggroup-external-icon{cursor:help}.catalog-browser-group-carret{margin-right:16px}.igo-catalog-group-title{font-weight:500}:host .mdc-list-item__end,:host .mdc-list-item__start{color:#000}\n"] }]
        }], propDecorators: { catalog: [{
                type: Input
            }], group: [{
                type: Input
            }], map: [{
                type: Input
            }], collapsed: [{
                type: Input
            }], resolution: [{
                type: Input
            }], catalogAllowLegend: [{
                type: Input
            }], toggleCollapsed: [{
                type: Input
            }], state: [{
                type: Input
            }], addedChange: [{
                type: Output
            }], layerAddedChange: [{
                type: Output
            }] } });

/**
 * Component to browse a catalog's groups and layers and display them on a map.
 */
class CatalogBrowserComponent {
    layerService;
    cdRef;
    /**
     * Catalog items store watcher
     */
    watcher;
    // private resolution$$: Subscription;
    get resolution$() {
        return this.map.viewController.resolution$;
    }
    catalogAllowLegend = false;
    /**
     * Catalog
     */
    catalog;
    /**
     * Store holding the catalog's items
     */
    store;
    /**
     * Map to add the catalog items to
     */
    map;
    /**
     * Whether a group can be toggled when it's collapsed
     */
    toggleCollapsedGroup = true;
    constructor(layerService, cdRef) {
        this.layerService = layerService;
        this.cdRef = cdRef;
    }
    /**
     * @internal
     */
    ngOnInit() {
        const currentItems = this.map.layers.map((layer) => {
            return {
                id: layer.options.source.id,
                title: layer.title,
                type: CatalogItemType.Layer
            };
        });
        this.store.state.updateMany(currentItems, { added: true }, true);
        if (this.catalog && this.catalog.sortDirection !== undefined) {
            this.store.view.sort({
                direction: this.catalog.sortDirection,
                valueAccessor: (item) => item.title
            });
        }
        const catalogShowLegend = this.catalog ? this.catalog.showLegend : false;
        this.catalogAllowLegend = catalogShowLegend
            ? catalogShowLegend
            : this.catalogAllowLegend;
        this.watcher = new EntityStoreWatcher(this.store, this.cdRef);
    }
    ngOnDestroy() {
        this.watcher.destroy();
    }
    /**
     * @internal
     */
    isGroup(item) {
        return item.type === CatalogItemType.Group;
    }
    /**
     * @internal
     */
    isLayer(item) {
        return item.type === CatalogItemType.Layer;
    }
    /**
     * When a layer is added or removed, add or remove it from the map
     * @internal
     * @param event Layer added event
     */
    onLayerAddedChange(event) {
        const layer = event.layer;
        this.store.state.update(layer, { added: event.added }, false);
        event.added
            ? this.addLayerToMap(layer, event)
            : this.removeLayerFromMap(layer);
    }
    /**
     * When a froup is added or removed, add or remove it from the map
     * @internal
     * @param event Group added event
     */
    onGroupAddedChange(event) {
        const group = event.group;
        this.store.state.update(group, { added: event.added }, false);
        event.added
            ? this.addGroupToMap(group, event)
            : this.removeGroupFromMap(group);
    }
    /**
     * Add layer to map
     * @param layer Catalog layer
     */
    addLayerToMap(layer, event) {
        this.addLayersToMap([layer], event);
    }
    /**
     * Remove layer from map
     * @param layer Catalog layer
     */
    removeLayerFromMap(layer) {
        this.removeLayersFromMap([layer]);
    }
    /**
     * Add multiple layers to map
     * @param layers Catalog layers
     */
    addLayersToMap(layers, event) {
        const layers$ = layers.map((layer) => {
            if (!layer.options.sourceOptions.optionsFromApi) {
                layer.options.sourceOptions.optionsFromApi = true;
            }
            if (this.catalog.profils?.length) {
                layer.options.security = { profils: this.catalog.profils };
            }
            return this.layerService.createAsyncLayer(layer.options);
        });
        zip(...layers$).subscribe((layers) => {
            if (event.event.type === 'click' && event.added) {
                this.map.layersAddedByClick$.next(layers);
            }
            this.store.state.updateMany(layers, { added: true });
            this.map.addLayers(layers);
        });
    }
    /**
     * Remove multiple layers from map
     * @param layers Catalog layers
     */
    removeLayersFromMap(layers) {
        layers.forEach((layer) => {
            this.store.state.update(layer, { added: false });
            if (layer.options.baseLayer === true) {
                const currLayer = this.map.getLayerById(layer.options.id);
                if (currLayer !== undefined) {
                    this.map.removeLayer(currLayer);
                }
            }
            else {
                const currLayer = this.map.getLayerById(layer.id);
                if (currLayer !== undefined) {
                    this.map.removeLayer(currLayer);
                }
            }
        });
    }
    /**
     * Sort the layers by title. asc or desc.
     * @internal
     */
    sortCatalogItemsByTitle(items, direction) {
        const returnItem = items.sort((a, b) => {
            const titleA = a.title.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
            const titleB = b.title.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
            if (titleA < titleB) {
                return -1;
            }
            if (titleA > titleB) {
                return 1;
            }
            return 0;
        });
        switch (direction) {
            case 'asc':
                return returnItem;
            case 'desc':
                return returnItem.reverse();
            default:
                return items;
        }
    }
    /**
     * Add all the layers of a group to map
     * @param group Catalog group
     */
    addGroupToMap(group, event) {
        let layers = group.items.filter((item) => {
            const added = this.store.state.get(item).added || false;
            return this.isLayer(item) && added === false;
        });
        if (group.sortDirection !== undefined) {
            layers = this.sortCatalogItemsByTitle(layers, group.sortDirection);
        }
        this.addLayersToMap(layers.reverse(), event);
    }
    /**
     * Remove all the layers of a group from map
     * @param group Catalog group
     */
    removeGroupFromMap(group) {
        const layers = group.items.filter((item) => {
            const added = this.store.state.get(item).added || false;
            return this.isLayer(item) && added === true;
        });
        this.removeLayersFromMap(layers);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CatalogBrowserComponent, deps: [{ token: LayerService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: CatalogBrowserComponent, selector: "igo-catalog-browser", inputs: { catalogAllowLegend: "catalogAllowLegend", catalog: "catalog", store: "store", map: "map", toggleCollapsedGroup: "toggleCollapsedGroup" }, ngImport: i0, template: "<igo-list [navigation]=\"false\" [selection]=\"false\">\n  <ng-template ngFor let-item [ngForOf]=\"store.view.all$() | async\">\n    <ng-container *ngIf=\"isGroup(item)\">\n      <igo-catalog-browser-group\n        [catalog]=\"catalog\"\n        [group]=\"item\"\n        [map]=\"map\"\n        [state]=\"store.state\"\n        [resolution]=\"resolution$ | async\"\n        [catalogAllowLegend]=\"catalogAllowLegend\"\n        [collapsed]=\"store.count === 1 ? false : true\"\n        [toggleCollapsed]=\"toggleCollapsedGroup\"\n        (addedChange)=\"onGroupAddedChange($event)\"\n        (layerAddedChange)=\"onLayerAddedChange($event)\"\n      >\n      </igo-catalog-browser-group>\n    </ng-container>\n\n    <ng-container *ngIf=\"isLayer(item)\">\n      <igo-catalog-browser-layer\n        igoListItem\n        [layer]=\"item\"\n        [map]=\"map\"\n        [resolution]=\"resolution$ | async\"\n        [catalogAllowLegend]=\"catalogAllowLegend\"\n        [added]=\"store.state.get(item).added\"\n        (addedChange)=\"onLayerAddedChange($event)\"\n      >\n      </igo-catalog-browser-layer>\n    </ng-container>\n  </ng-template>\n</igo-list>\n", dependencies: [{ kind: "directive", type: i2$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i9$1.ListItemDirective, selector: "[igoListItem]", inputs: ["color", "focused", "selected", "disabled"], outputs: ["beforeSelect", "beforeFocus", "beforeUnselect", "beforeUnfocus", "beforeDisable", "beforeEnable", "focus", "unfocus", "select", "unselect", "disable", "enable"] }, { kind: "component", type: i9$1.ListComponent, selector: "igo-list", inputs: ["navigation", "selection"] }, { kind: "component", type: CatalogBrowserGroupComponent, selector: "igo-catalog-browser-group", inputs: ["catalog", "group", "map", "collapsed", "resolution", "catalogAllowLegend", "toggleCollapsed", "state"], outputs: ["addedChange", "layerAddedChange"] }, { kind: "component", type: CatalogBrowserLayerComponent, selector: "igo-catalog-browser-layer", inputs: ["resolution", "catalogAllowLegend", "layer", "map", "added"], outputs: ["addedChange", "addedLayerIsPreview"] }, { kind: "pipe", type: i2$2.AsyncPipe, name: "async" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CatalogBrowserComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-catalog-browser', changeDetection: ChangeDetectionStrategy.OnPush, template: "<igo-list [navigation]=\"false\" [selection]=\"false\">\n  <ng-template ngFor let-item [ngForOf]=\"store.view.all$() | async\">\n    <ng-container *ngIf=\"isGroup(item)\">\n      <igo-catalog-browser-group\n        [catalog]=\"catalog\"\n        [group]=\"item\"\n        [map]=\"map\"\n        [state]=\"store.state\"\n        [resolution]=\"resolution$ | async\"\n        [catalogAllowLegend]=\"catalogAllowLegend\"\n        [collapsed]=\"store.count === 1 ? false : true\"\n        [toggleCollapsed]=\"toggleCollapsedGroup\"\n        (addedChange)=\"onGroupAddedChange($event)\"\n        (layerAddedChange)=\"onLayerAddedChange($event)\"\n      >\n      </igo-catalog-browser-group>\n    </ng-container>\n\n    <ng-container *ngIf=\"isLayer(item)\">\n      <igo-catalog-browser-layer\n        igoListItem\n        [layer]=\"item\"\n        [map]=\"map\"\n        [resolution]=\"resolution$ | async\"\n        [catalogAllowLegend]=\"catalogAllowLegend\"\n        [added]=\"store.state.get(item).added\"\n        (addedChange)=\"onLayerAddedChange($event)\"\n      >\n      </igo-catalog-browser-layer>\n    </ng-container>\n  </ng-template>\n</igo-list>\n" }]
        }], ctorParameters: function () { return [{ type: LayerService }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { catalogAllowLegend: [{
                type: Input
            }], catalog: [{
                type: Input
            }], store: [{
                type: Input
            }], map: [{
                type: Input
            }], toggleCollapsedGroup: [{
                type: Input
            }] } });

/**
 * @ignore
 */
class IgoCatalogBrowserModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoCatalogBrowserModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoCatalogBrowserModule, declarations: [CatalogBrowserComponent,
            CatalogBrowserGroupComponent,
            CatalogBrowserLayerComponent], imports: [CommonModule,
            MatBadgeModule,
            MatButtonModule,
            MatIconModule,
            MatListModule,
            MatTooltipModule,
            IgoMatBadgeIconModule,
            IgoLanguageModule,
            IgoListModule,
            IgoCollapsibleModule,
            IgoMetadataModule,
            IgoLayerModule], exports: [CatalogBrowserComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoCatalogBrowserModule, imports: [CommonModule,
            MatBadgeModule,
            MatButtonModule,
            MatIconModule,
            MatListModule,
            MatTooltipModule,
            IgoMatBadgeIconModule,
            IgoLanguageModule,
            IgoListModule,
            IgoCollapsibleModule,
            IgoMetadataModule,
            IgoLayerModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoCatalogBrowserModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        MatBadgeModule,
                        MatButtonModule,
                        MatIconModule,
                        MatListModule,
                        MatTooltipModule,
                        IgoMatBadgeIconModule,
                        IgoLanguageModule,
                        IgoListModule,
                        IgoCollapsibleModule,
                        IgoMetadataModule,
                        IgoLayerModule
                    ],
                    exports: [CatalogBrowserComponent],
                    declarations: [
                        CatalogBrowserComponent,
                        CatalogBrowserGroupComponent,
                        CatalogBrowserLayerComponent
                    ]
                }]
        }] });

class AddCatalogDialogComponent {
    formBuilder;
    languageService;
    configService;
    dialogRef;
    data;
    form;
    defaultAddedCatalogType = 'wms';
    addedCatalogType$$;
    predefinedCatalogsList$ = new BehaviorSubject([]);
    typeCapabilities;
    predefinedCatalogs = [];
    store;
    error = false;
    addedCatalog;
    emailAddress;
    storeViewAll$$;
    constructor(formBuilder, languageService, configService, dialogRef, data) {
        this.formBuilder = formBuilder;
        this.languageService = languageService;
        this.configService = configService;
        this.dialogRef = dialogRef;
        this.data = data;
        this.store = data.store;
        this.predefinedCatalogs = data.predefinedCatalogs;
        this.error = data.error;
        this.addedCatalog = data.addedCatalog;
        this.form = this.formBuilder.group({
            id: ['', []],
            title: ['', []],
            url: ['', [Validators.required]],
            type: [this.defaultAddedCatalogType, [Validators.required]]
        });
    }
    ngOnInit() {
        this.store.state.clear();
        this.typeCapabilities = Object.keys(TypeCapabilities);
        this.addedCatalogType$$ = this.form
            .get('type')
            .valueChanges.subscribe((value) => {
            if (value === 'wmts') {
                this.form.get('title').setValidators(Validators.required);
            }
            else {
                this.form.get('title').setValidators([]);
            }
            this.form.get('title').updateValueAndValidity();
        });
        this.computePredefinedCatalogList();
        this.storeViewAll$$ = this.store.view
            .all$()
            .subscribe(() => this.computePredefinedCatalogList());
        this.emailAddress = this.configService.getConfig('emailAddress');
    }
    ngOnDestroy() {
        this.addedCatalogType$$.unsubscribe();
        this.storeViewAll$$.unsubscribe();
    }
    changeUrlOrTitle(catalog) {
        this.form.patchValue(catalog);
        this.error = false;
        this.computePredefinedCatalogList();
    }
    computePredefinedCatalogList() {
        this.predefinedCatalogsList$.next(this.predefinedCatalogs.filter((c) => !this.store.get(c.id)));
    }
    addCatalog(addedCatalog) {
        this.error = false;
        this.dialogRef.close(addedCatalog);
    }
    cancel() {
        this.error = false;
        this.dialogRef.close();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: AddCatalogDialogComponent, deps: [{ token: i2$1.UntypedFormBuilder }, { token: i2.LanguageService }, { token: i2.ConfigService }, { token: i1$2.MatDialogRef }, { token: MAT_DIALOG_DATA, optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: AddCatalogDialogComponent, selector: "igo-add-catalog-dialog", ngImport: i0, template: "<h1 mat-dialog-title class=\"mat-typography\">\n  {{ 'igo.geo.catalog.library.addTitle' | translate }}\n</h1>\n<div mat-dialog-content class=\"mat-typography\">\n  <form class=\"igo-form\" [formGroup]=\"form\">\n    <div class=\"igo-input-container\">\n      <mat-form-field>\n        <input\n          type=\"text\"\n          formControlName=\"title\"\n          placeholder=\"{{ 'igo.geo.printForm.title' | translate }}\"\n          matInput\n          [matAutocomplete]=\"auto2\"\n        />\n        <mat-autocomplete\n          #auto2=\"matAutocomplete\"\n          (optionSelected)=\"changeUrlOrTitle($event.option.value)\"\n        >\n          <mat-option\n            *ngFor=\"let predefinedCatalog of predefinedCatalogsList$ | async\"\n            matTooltipShowDelay=\"500\"\n            [matTooltip]=\"predefinedCatalog.title\"\n            [value]=\"predefinedCatalog\"\n          >\n            {{ predefinedCatalog.title }}\n          </mat-option>\n        </mat-autocomplete>\n      </mat-form-field>\n    </div>\n    <div class=\"igo-input-container\">\n      <mat-form-field>\n        <input\n          type=\"text\"\n          formControlName=\"url\"\n          placeholder=\"URL\"\n          matInput\n          [matAutocomplete]=\"auto\"\n        />\n        <mat-autocomplete\n          #auto=\"matAutocomplete\"\n          (optionSelected)=\"changeUrlOrTitle($event.option.value)\"\n        >\n          <mat-option\n            *ngFor=\"let predefinedCatalog of predefinedCatalogsList$ | async\"\n            matTooltipShowDelay=\"500\"\n            [matTooltip]=\"predefinedCatalog.url\"\n            [value]=\"predefinedCatalog\"\n          >\n            {{ predefinedCatalog.url }}\n          </mat-option>\n        </mat-autocomplete>\n      </mat-form-field>\n    </div>\n    <div class=\"igo-input-container\">\n      <mat-form-field>\n        <mat-select formControlName=\"type\" placeholder=\"Type\">\n          <mat-option\n            *ngFor=\"let type of typeCapabilities\"\n            [value]=\"type\"\n            (click)=\"$event.stopPropagation()\"\n          >\n            <p matListItemTitle>{{ type }}</p>\n          </mat-option>\n        </mat-select>\n      </mat-form-field>\n    </div>\n  </form>\n  <span *ngIf=\"error && addedCatalog && emailAddress\">\n    <p class=\"error\">\n      {{\n        languageService.translate.instant(\n          'igo.geo.catalog.externalProvider.unavailableWithEmail',\n          { value: addedCatalog.url, email: emailAddress }\n        )\n      }}\n    </p>\n  </span>\n  <span *ngIf=\"error && addedCatalog && !emailAddress\">\n    <p class=\"error\">\n      {{\n        languageService.translate.instant('igo.geo.catalog.unavailable', {\n          value: addedCatalog.url\n        })\n      }}\n    </p>\n  </span>\n</div>\n<div mat-dialog-actions style=\"justify-content: center\">\n  <div class=\"igo-form-button-group add-catalog-button-top-padding\">\n    <button mat-raised-button type=\"button\" (click)=\"cancel()\">\n      {{ 'igo.geo.catalog.library.cancel' | translate }}\n    </button>\n    <button\n      id=\"addCatalogBtnDialog\"\n      mat-raised-button\n      type=\"button\"\n      color=\"primary\"\n      [disabled]=\"!form.valid\"\n      (click)=\"addCatalog(form.value)\"\n    >\n      {{ 'igo.geo.catalog.library.add' | translate }}\n    </button>\n  </div>\n</div>\n", styles: ["mat-form-field{width:100%}.add-catalog-button-top-padding{padding-top:25px}.igo-form{padding:10px 5px 5px}.igo-form-button-group{text-align:center}button{cursor:pointer}button#addCatalogBtnDialog[disabled=true]{cursor:default;background-color:#0000001f;color:#00000042}.error{color:red}\n"], dependencies: [{ kind: "directive", type: i2$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i5.MatListItemTitle, selector: "[matListItemTitle]" }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "component", type: i4$1.MatButton, selector: "    button[mat-button], button[mat-raised-button], button[mat-flat-button],    button[mat-stroked-button]  ", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "component", type: i8.MatFormField, selector: "mat-form-field", inputs: ["hideRequiredMarker", "color", "floatLabel", "appearance", "subscriptSizing", "hintLabel"], exportAs: ["matFormField"] }, { kind: "directive", type: i2$1.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { kind: "directive", type: i2$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i2$1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "directive", type: i2$1.FormControlName, selector: "[formControlName]", inputs: ["formControlName", "disabled", "ngModel"], outputs: ["ngModelChange"] }, { kind: "directive", type: i9$3.MatInput, selector: "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", inputs: ["disabled", "id", "placeholder", "name", "required", "type", "errorStateMatcher", "aria-describedby", "value", "readonly"], exportAs: ["matInput"] }, { kind: "component", type: i15.MatSelect, selector: "mat-select", inputs: ["disabled", "disableRipple", "tabIndex", "panelWidth", "hideSingleSelectionIndicator"], exportAs: ["matSelect"] }, { kind: "component", type: i9.MatOption, selector: "mat-option", exportAs: ["matOption"] }, { kind: "component", type: i6$2.MatAutocomplete, selector: "mat-autocomplete", inputs: ["disableRipple", "hideSingleSelectionIndicator"], exportAs: ["matAutocomplete"] }, { kind: "directive", type: i6$2.MatAutocompleteTrigger, selector: "input[matAutocomplete], textarea[matAutocomplete]", exportAs: ["matAutocompleteTrigger"] }, { kind: "directive", type: i1$2.MatDialogTitle, selector: "[mat-dialog-title], [matDialogTitle]", inputs: ["id"], exportAs: ["matDialogTitle"] }, { kind: "directive", type: i1$2.MatDialogContent, selector: "[mat-dialog-content], mat-dialog-content, [matDialogContent]" }, { kind: "directive", type: i1$2.MatDialogActions, selector: "[mat-dialog-actions], mat-dialog-actions, [matDialogActions]", inputs: ["align"] }, { kind: "pipe", type: i2$2.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: AddCatalogDialogComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-add-catalog-dialog', template: "<h1 mat-dialog-title class=\"mat-typography\">\n  {{ 'igo.geo.catalog.library.addTitle' | translate }}\n</h1>\n<div mat-dialog-content class=\"mat-typography\">\n  <form class=\"igo-form\" [formGroup]=\"form\">\n    <div class=\"igo-input-container\">\n      <mat-form-field>\n        <input\n          type=\"text\"\n          formControlName=\"title\"\n          placeholder=\"{{ 'igo.geo.printForm.title' | translate }}\"\n          matInput\n          [matAutocomplete]=\"auto2\"\n        />\n        <mat-autocomplete\n          #auto2=\"matAutocomplete\"\n          (optionSelected)=\"changeUrlOrTitle($event.option.value)\"\n        >\n          <mat-option\n            *ngFor=\"let predefinedCatalog of predefinedCatalogsList$ | async\"\n            matTooltipShowDelay=\"500\"\n            [matTooltip]=\"predefinedCatalog.title\"\n            [value]=\"predefinedCatalog\"\n          >\n            {{ predefinedCatalog.title }}\n          </mat-option>\n        </mat-autocomplete>\n      </mat-form-field>\n    </div>\n    <div class=\"igo-input-container\">\n      <mat-form-field>\n        <input\n          type=\"text\"\n          formControlName=\"url\"\n          placeholder=\"URL\"\n          matInput\n          [matAutocomplete]=\"auto\"\n        />\n        <mat-autocomplete\n          #auto=\"matAutocomplete\"\n          (optionSelected)=\"changeUrlOrTitle($event.option.value)\"\n        >\n          <mat-option\n            *ngFor=\"let predefinedCatalog of predefinedCatalogsList$ | async\"\n            matTooltipShowDelay=\"500\"\n            [matTooltip]=\"predefinedCatalog.url\"\n            [value]=\"predefinedCatalog\"\n          >\n            {{ predefinedCatalog.url }}\n          </mat-option>\n        </mat-autocomplete>\n      </mat-form-field>\n    </div>\n    <div class=\"igo-input-container\">\n      <mat-form-field>\n        <mat-select formControlName=\"type\" placeholder=\"Type\">\n          <mat-option\n            *ngFor=\"let type of typeCapabilities\"\n            [value]=\"type\"\n            (click)=\"$event.stopPropagation()\"\n          >\n            <p matListItemTitle>{{ type }}</p>\n          </mat-option>\n        </mat-select>\n      </mat-form-field>\n    </div>\n  </form>\n  <span *ngIf=\"error && addedCatalog && emailAddress\">\n    <p class=\"error\">\n      {{\n        languageService.translate.instant(\n          'igo.geo.catalog.externalProvider.unavailableWithEmail',\n          { value: addedCatalog.url, email: emailAddress }\n        )\n      }}\n    </p>\n  </span>\n  <span *ngIf=\"error && addedCatalog && !emailAddress\">\n    <p class=\"error\">\n      {{\n        languageService.translate.instant('igo.geo.catalog.unavailable', {\n          value: addedCatalog.url\n        })\n      }}\n    </p>\n  </span>\n</div>\n<div mat-dialog-actions style=\"justify-content: center\">\n  <div class=\"igo-form-button-group add-catalog-button-top-padding\">\n    <button mat-raised-button type=\"button\" (click)=\"cancel()\">\n      {{ 'igo.geo.catalog.library.cancel' | translate }}\n    </button>\n    <button\n      id=\"addCatalogBtnDialog\"\n      mat-raised-button\n      type=\"button\"\n      color=\"primary\"\n      [disabled]=\"!form.valid\"\n      (click)=\"addCatalog(form.value)\"\n    >\n      {{ 'igo.geo.catalog.library.add' | translate }}\n    </button>\n  </div>\n</div>\n", styles: ["mat-form-field{width:100%}.add-catalog-button-top-padding{padding-top:25px}.igo-form{padding:10px 5px 5px}.igo-form-button-group{text-align:center}button{cursor:pointer}button#addCatalogBtnDialog[disabled=true]{cursor:default;background-color:#0000001f;color:#00000042}.error{color:red}\n"] }]
        }], ctorParameters: function () { return [{ type: i2$1.UntypedFormBuilder }, { type: i2.LanguageService }, { type: i2.ConfigService }, { type: i1$2.MatDialogRef }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [MAT_DIALOG_DATA]
                }] }]; } });

/**
 * Catalog library item
 */
class CatalogLibaryItemComponent {
    /**
     * Catalog
     */
    catalog;
    /**
     * Map to add the catalog items to
     */
    map;
    catalogRemove = new EventEmitter();
    /**
     * @internal
     */
    get title() {
        return getEntityTitle(this.catalog);
    }
    removeCatalogFromLibrary(event) {
        event.stopPropagation();
        this.catalogRemove.emit();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CatalogLibaryItemComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: CatalogLibaryItemComponent, selector: "igo-catalog-library-item", inputs: { catalog: "catalog", map: "map" }, outputs: { catalogRemove: "catalogRemove" }, ngImport: i0, template: "<mat-list-item>\n  <span matListItemTitle>\n    {{ title }}\n  </span>\n  <div matListItemMeta>\n    <mat-icon\n      *ngIf=\"catalog.externalProvider\"\n      matListItemIcon\n      class=\"igo-external-provider\"\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"'igo.geo.catalog.externalProvider.catalog' | translate\"\n      color=\"primary\"\n      (click)=\"$event.stopPropagation()\"\n      svgIcon=\"earth-arrow-right\"\n    >\n    </mat-icon>\n    <button\n      *ngIf=\"catalog.removable\"\n      mat-icon-button\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"'igo.geo.catalog.library.remove' | translate\"\n      color=\"warn\"\n      (click)=\"removeCatalogFromLibrary($event)\"\n    >\n      <mat-icon svgIcon=\"delete\"></mat-icon>\n    </button>\n\n    <button\n      class=\"igo-blank\"\n      *ngIf=\"!catalog.removable\"\n      disabled=\"true\"\n      mat-icon-button\n    >\n      <mat-icon svgIcon=\"blank\"></mat-icon>\n    </button>\n  </div>\n</mat-list-item>\n", styles: [".igo-blank{cursor:pointer}.igo-external-provider{cursor:help}\n"], dependencies: [{ kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i5.MatListItem, selector: "mat-list-item, a[mat-list-item], button[mat-list-item]", inputs: ["activated"], exportAs: ["matListItem"] }, { kind: "directive", type: i5.MatListItemIcon, selector: "[matListItemIcon]" }, { kind: "directive", type: i5.MatListItemTitle, selector: "[matListItemTitle]" }, { kind: "directive", type: i5.MatListItemMeta, selector: "[matListItemMeta]" }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CatalogLibaryItemComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-catalog-library-item', changeDetection: ChangeDetectionStrategy.OnPush, template: "<mat-list-item>\n  <span matListItemTitle>\n    {{ title }}\n  </span>\n  <div matListItemMeta>\n    <mat-icon\n      *ngIf=\"catalog.externalProvider\"\n      matListItemIcon\n      class=\"igo-external-provider\"\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"'igo.geo.catalog.externalProvider.catalog' | translate\"\n      color=\"primary\"\n      (click)=\"$event.stopPropagation()\"\n      svgIcon=\"earth-arrow-right\"\n    >\n    </mat-icon>\n    <button\n      *ngIf=\"catalog.removable\"\n      mat-icon-button\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"'igo.geo.catalog.library.remove' | translate\"\n      color=\"warn\"\n      (click)=\"removeCatalogFromLibrary($event)\"\n    >\n      <mat-icon svgIcon=\"delete\"></mat-icon>\n    </button>\n\n    <button\n      class=\"igo-blank\"\n      *ngIf=\"!catalog.removable\"\n      disabled=\"true\"\n      mat-icon-button\n    >\n      <mat-icon svgIcon=\"blank\"></mat-icon>\n    </button>\n  </div>\n</mat-list-item>\n", styles: [".igo-blank{cursor:pointer}.igo-external-provider{cursor:help}\n"] }]
        }], propDecorators: { catalog: [{
                type: Input
            }], map: [{
                type: Input
            }], catalogRemove: [{
                type: Output
            }] } });

/**
 * Component to browse a list of available catalogs
 */
class CatalogLibaryComponent {
    capabilitiesService;
    messageService;
    storageService;
    dialog;
    /**
     * Store holding the catalogs
     */
    store;
    /**
     * Map to add the catalog items to
     */
    map;
    /**
     * Determine if the form to add a catalog is allowed
     */
    addCatalogAllowed = false;
    /**
     * Determine if the form to add a catalog is allowed
     */
    predefinedCatalogs = [];
    /**
     * Event emitted a catalog is selected or unselected
     */
    catalogSelectChange = new EventEmitter();
    submitDisabled = true;
    addingCatalog$$;
    get addedCatalogs() {
        return (this.storageService.get('addedCatalogs') || []);
    }
    set addedCatalogs(catalogs) {
        this.storageService.set('addedCatalogs', catalogs);
    }
    constructor(capabilitiesService, messageService, storageService, dialog) {
        this.capabilitiesService = capabilitiesService;
        this.messageService = messageService;
        this.storageService = storageService;
        this.dialog = dialog;
    }
    /**
     * @internal
     */
    ngOnInit() {
        this.store.state.clear();
        this.predefinedCatalogs = this.predefinedCatalogs.map((c) => {
            c.id = Md5.hashStr((c.type || 'wms') + standardizeUrl(c.url));
            c.title = c.title === '' || !c.title ? c.url : c.title;
            return c;
        });
    }
    getCatalogs() {
        return this.store.view.all$();
    }
    /**
     * When a catalog is selected, update it's state in the store
     * and emit the catalog select change event
     * @internal
     */
    onCatalogSelect(catalog) {
        this.store.state.update(catalog, {
            selected: true,
            focused: true
        }, true);
        this.catalogSelectChange.emit({ selected: true, catalog });
    }
    unsubscribeAddingCatalog() {
        if (this.addingCatalog$$) {
            this.addingCatalog$$.unsubscribe();
        }
    }
    addCatalog(addedCatalog) {
        if (!addedCatalog) {
            return;
        }
        let id = Md5.hashStr(addedCatalog.type + standardizeUrl(addedCatalog.url));
        const predefinedCatalog = this.predefinedCatalogs.find((c) => c.id === addedCatalog.id);
        if (predefinedCatalog) {
            addedCatalog.version = predefinedCatalog.version;
            addedCatalog.externalProvider = predefinedCatalog.externalProvider;
            id = predefinedCatalog.id;
        }
        if (this.store.get(id)) {
            this.messageService.alert('igo.geo.catalog.library.inlist.message', 'igo.geo.catalog.library.inlist.title');
            return;
        }
        this.unsubscribeAddingCatalog();
        this.addingCatalog$$ = this.capabilitiesService
            .getCapabilities(addedCatalog.type, addedCatalog.url, addedCatalog.version)
            .pipe(catchError((e) => {
            if (e.error) {
                this.addCatalogDialog(true, addedCatalog);
                e.error.caught = true;
                return e;
            }
            this.messageService.error('igo.geo.catalog.unavailable', 'igo.geo.catalog.unavailableTitle', undefined, { value: addedCatalog.url });
            throw e;
        }))
            .subscribe((capabilities) => {
            let title;
            let version;
            switch (addedCatalog.type) {
                case 'wms':
                    title = addedCatalog.title || capabilities.Service.Title;
                    version = addedCatalog.version || capabilities.version;
                    break;
                case 'arcgisrest':
                case 'imagearcgisrest':
                case 'tilearcgisrest':
                    title = addedCatalog.title || capabilities.mapName;
                    break;
                case 'wmts':
                    title =
                        addedCatalog.title ||
                            capabilities.ServiceIdentification.ServiceType;
                    break;
                default:
                    title = addedCatalog.title;
            }
            const catalogToAdd = ObjectUtils.removeUndefined(Object.assign({}, predefinedCatalog, ObjectUtils.removeUndefined({
                id,
                title,
                url: addedCatalog.url,
                type: addedCatalog.type || 'wms',
                externalProvider: addedCatalog.externalProvider || false,
                removable: true,
                version
            })));
            this.store.insert(catalogToAdd);
            const newCatalogs = this.addedCatalogs.slice(0);
            newCatalogs.push(catalogToAdd);
            this.addedCatalogs = newCatalogs;
            this.unsubscribeAddingCatalog();
        });
    }
    ngOnDestroy() {
        this.unsubscribeAddingCatalog();
    }
    onCatalogRemove(catalog) {
        this.store.delete(catalog);
        this.addedCatalogs = this.addedCatalogs
            .slice(0)
            .filter((c) => c.id !== catalog.id);
    }
    addCatalogDialog(error, addedCatalog) {
        const dialogRef = this.dialog.open(AddCatalogDialogComponent, {
            width: '700px',
            data: {
                predefinedCatalogs: this.predefinedCatalogs,
                store: this.store,
                error,
                addedCatalog
            }
        });
        dialogRef.afterClosed().subscribe((catalog) => {
            this.addCatalog(catalog);
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CatalogLibaryComponent, deps: [{ token: CapabilitiesService }, { token: i2.MessageService }, { token: i2.StorageService }, { token: i1$2.MatDialog }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: CatalogLibaryComponent, selector: "igo-catalog-library", inputs: { store: "store", map: "map", addCatalogAllowed: "addCatalogAllowed", predefinedCatalogs: "predefinedCatalogs" }, outputs: { catalogSelectChange: "catalogSelectChange" }, ngImport: i0, template: "<igo-list [navigation]=\"false\">\n  <ng-template ngFor let-catalog [ngForOf]=\"getCatalogs() | async\">\n    <igo-catalog-library-item\n      igoListItem\n      color=\"accent\"\n      [map]=\"map\"\n      [catalog]=\"catalog\"\n      (catalogRemove)=\"onCatalogRemove(catalog)\"\n      (select)=\"onCatalogSelect(catalog)\"\n    >\n    </igo-catalog-library-item>\n  </ng-template>\n</igo-list>\n\n<div *ngIf=\"addCatalogAllowed\" class=\"btnAddCatalog\">\n  <button\n    mat-raised-button\n    [matTooltip]=\"'igo.geo.catalog.library.addBtn' | translate\"\n    matTooltipPosition=\"above\"\n    color=\"primary\"\n    (click)=\"addCatalogDialog()\"\n  >\n    {{ 'igo.geo.catalog.library.addBtn' | translate }}\n    <mat-icon svgIcon=\"earth-plus\"></mat-icon>\n  </button>\n</div>\n", styles: [":host igo-list{height:auto}:host .btnAddCatalog{justify-content:center;display:flex;margin:30px 0}\n"], dependencies: [{ kind: "directive", type: i2$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "directive", type: i9$1.ListItemDirective, selector: "[igoListItem]", inputs: ["color", "focused", "selected", "disabled"], outputs: ["beforeSelect", "beforeFocus", "beforeUnselect", "beforeUnfocus", "beforeDisable", "beforeEnable", "focus", "unfocus", "select", "unselect", "disable", "enable"] }, { kind: "component", type: i9$1.ListComponent, selector: "igo-list", inputs: ["navigation", "selection"] }, { kind: "component", type: i4$1.MatButton, selector: "    button[mat-button], button[mat-raised-button], button[mat-flat-button],    button[mat-stroked-button]  ", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "component", type: CatalogLibaryItemComponent, selector: "igo-catalog-library-item", inputs: ["catalog", "map"], outputs: ["catalogRemove"] }, { kind: "pipe", type: i2$2.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CatalogLibaryComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-catalog-library', changeDetection: ChangeDetectionStrategy.OnPush, template: "<igo-list [navigation]=\"false\">\n  <ng-template ngFor let-catalog [ngForOf]=\"getCatalogs() | async\">\n    <igo-catalog-library-item\n      igoListItem\n      color=\"accent\"\n      [map]=\"map\"\n      [catalog]=\"catalog\"\n      (catalogRemove)=\"onCatalogRemove(catalog)\"\n      (select)=\"onCatalogSelect(catalog)\"\n    >\n    </igo-catalog-library-item>\n  </ng-template>\n</igo-list>\n\n<div *ngIf=\"addCatalogAllowed\" class=\"btnAddCatalog\">\n  <button\n    mat-raised-button\n    [matTooltip]=\"'igo.geo.catalog.library.addBtn' | translate\"\n    matTooltipPosition=\"above\"\n    color=\"primary\"\n    (click)=\"addCatalogDialog()\"\n  >\n    {{ 'igo.geo.catalog.library.addBtn' | translate }}\n    <mat-icon svgIcon=\"earth-plus\"></mat-icon>\n  </button>\n</div>\n", styles: [":host igo-list{height:auto}:host .btnAddCatalog{justify-content:center;display:flex;margin:30px 0}\n"] }]
        }], ctorParameters: function () { return [{ type: CapabilitiesService }, { type: i2.MessageService }, { type: i2.StorageService }, { type: i1$2.MatDialog }]; }, propDecorators: { store: [{
                type: Input
            }], map: [{
                type: Input
            }], addCatalogAllowed: [{
                type: Input
            }], predefinedCatalogs: [{
                type: Input
            }], catalogSelectChange: [{
                type: Output
            }] } });

/**
 * @ignore
 */
class IgoCatalogLibraryModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoCatalogLibraryModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoCatalogLibraryModule, declarations: [CatalogLibaryComponent,
            CatalogLibaryItemComponent,
            AddCatalogDialogComponent], imports: [CommonModule,
            MatIconModule,
            MatBadgeModule,
            MatListModule,
            MatTooltipModule,
            IgoListModule,
            IgoLanguageModule,
            MatButtonModule,
            MatFormFieldModule,
            ReactiveFormsModule,
            MatInputModule,
            MatSelectModule,
            MatAutocompleteModule,
            MatDialogModule], exports: [CatalogLibaryComponent, AddCatalogDialogComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoCatalogLibraryModule, imports: [CommonModule,
            MatIconModule,
            MatBadgeModule,
            MatListModule,
            MatTooltipModule,
            IgoListModule,
            IgoLanguageModule,
            MatButtonModule,
            MatFormFieldModule,
            ReactiveFormsModule,
            MatInputModule,
            MatSelectModule,
            MatAutocompleteModule,
            MatDialogModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoCatalogLibraryModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        MatIconModule,
                        MatBadgeModule,
                        MatListModule,
                        MatTooltipModule,
                        IgoListModule,
                        IgoLanguageModule,
                        MatButtonModule,
                        MatFormFieldModule,
                        ReactiveFormsModule,
                        MatInputModule,
                        MatSelectModule,
                        MatAutocompleteModule,
                        MatDialogModule
                    ],
                    exports: [CatalogLibaryComponent, AddCatalogDialogComponent],
                    declarations: [
                        CatalogLibaryComponent,
                        CatalogLibaryItemComponent,
                        AddCatalogDialogComponent
                    ]
                }]
        }] });

class IgoCatalogModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoCatalogModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoCatalogModule, imports: [CommonModule,
            MatBadgeModule,
            MatIconModule,
            MatListModule,
            MatTooltipModule,
            IgoMatBadgeIconModule,
            IgoListModule,
            IgoCollapsibleModule], exports: [IgoCatalogBrowserModule, IgoCatalogLibraryModule] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoCatalogModule, imports: [CommonModule,
            MatBadgeModule,
            MatIconModule,
            MatListModule,
            MatTooltipModule,
            IgoMatBadgeIconModule,
            IgoListModule,
            IgoCollapsibleModule, IgoCatalogBrowserModule, IgoCatalogLibraryModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoCatalogModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        MatBadgeModule,
                        MatIconModule,
                        MatListModule,
                        MatTooltipModule,
                        IgoMatBadgeIconModule,
                        IgoListModule,
                        IgoCollapsibleModule
                    ],
                    exports: [IgoCatalogBrowserModule, IgoCatalogLibraryModule],
                    declarations: []
                }]
        }] });

class IgoDataSourceModule {
    static forRoot() {
        return {
            ngModule: IgoDataSourceModule,
            providers: []
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoDataSourceModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoDataSourceModule });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoDataSourceModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoDataSourceModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [],
                    exports: [],
                    declarations: []
                }]
        }] });

/**
 * Get all the layers legend
 * @return Array of legend
 */
function getLayersLegends(layers, view) {
    const legends = [];
    for (const layer of layers) {
        const legendOptions = layer.options.legendOptions;
        if (layer.visible === false) {
            continue;
        }
        const legendUrls = layer.dataSource.getLegend(undefined, view) || [];
        for (const legendUrl of legendUrls) {
            if (legendUrl.url === undefined) {
                continue;
            }
            // Add legend info to the list
            legends.push({
                title: layer.title || '',
                url: legendUrl.url,
                display: legendOptions?.display === undefined ? true : legendOptions.display,
                isInResolutionsRange: layer.isInResolutionsRange
            });
        }
    }
    return legends;
}

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2016-2017 Dan "Ducky" Little
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
function jsGeoPdfPlugin(jsPDFAPI) {
    const setGeoArea = function (pdfExt, geoExt) {
        const bbox = pdfExt.join(' ');
        // the ordering may seem odd here but PDF
        //  flips the Y axis upside down and this accounts for that
        //  change.
        const minx = geoExt[0];
        const maxx = geoExt[2];
        const maxy = geoExt[1];
        const miny = geoExt[3];
        const bounds = [miny, minx, maxy, minx, maxy, maxx, miny, maxx].join(' ');
        const bbox_obj = this.internal.newAdditionalObject();
        const bounds_obj = this.internal.newAdditionalObject();
        const proj_obj = this.internal.newAdditionalObject();
        proj_obj.content =
            '<< /EPSG 3857 /Type /PROJCS /WKT (PROJCS["WGS_1984_Web_Mercator_Auxiliary_Sphere"' +
                ',GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0]' +
                ',UNIT["Degree",0.017453292519943295]],PROJECTION["Mercator_Auxiliary_Sphere"],PARAMETER["False_Easting",0.0]' +
                ',PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",0.0],PARAMETER["Standard_Parallel_1",0.0]' +
                ',PARAMETER["Auxiliary_Sphere_Type",0.0],UNIT["Meter",1.0]]) >>';
        bounds_obj.content =
            '<< /Bounds [ 0 1 0 0 1 0 1 1 ] /GCS ' +
                proj_obj.objId +
                ' 0 R /GPTS [ ' +
                bounds +
                ' ] /LPTS [ 0 1 0 0 1 0 1 1 ] /Subtype /GEO /Type /Measure >>';
        bbox_obj.content =
            '<< /BBox [ ' +
                bbox +
                ' ] /Measure ' +
                bounds_obj.objId +
                ' 0 R /Name (Layer) /Type /Viewport >>';
        const title_obj = this.internal.newAdditionalObject();
        const date = new Date().toLocaleDateString('en-CA');
        title_obj.content = '<< /Name IGO2 /Type /OCG /Date ' + date + ' >>';
        return bbox_obj.objId;
    };
    jsPDFAPI.setGeoArea = function (pdfExt, geoExt) {
        this.internal.events.subscribe('putPage', function () {
            const bbox_id = setGeoArea.call(this, pdfExt, geoExt);
            this.internal.write('/VP [ ' + bbox_id + ' 0 R ]');
        });
    };
}

const PrintOutputFormat = strEnum(['Pdf', 'Image']);
const PrintPaperFormat = strEnum([
    'A0',
    'A1',
    'A2',
    'A3',
    'A4',
    'A5',
    'Letter',
    'Legal'
]);
const PrintOrientation = strEnum(['landscape', 'portrait']);
const PrintResolution = ['72', '96', '150', '300'];
const PrintSaveImageFormat = strEnum([
    'Bmp',
    'Gif',
    'Jpeg',
    'Png',
    'Tiff'
]);
const PrintLegendPosition = strEnum([
    'none',
    'topright',
    'topleft',
    'bottomleft',
    'bottomright',
    'newpage'
]);

class PrintService {
    http;
    messageService;
    activityService;
    languageService;
    configService;
    zipFile;
    nbFileToProcess;
    activityId;
    imgSizeAdded;
    mapPrintExtent;
    TEXTPDFFONT = {
        titleFont: 'Times',
        titleFontStyle: 'bold',
        subtitleFont: 'Times',
        subtitleFontStyle: 'bold',
        commentFont: 'courier',
        commentFontStyle: 'normal',
        commentFontSize: 12
    };
    constructor(http, messageService, activityService, languageService, configService) {
        this.http = http;
        this.messageService = messageService;
        this.activityService = activityService;
        this.languageService = languageService;
        this.configService = configService;
    }
    print(map, options) {
        const status$ = new Subject();
        const paperFormat = options.paperFormat;
        const resolution = +options.resolution; // Default is 96
        const orientation = options.orientation;
        const legendPostion = options.legendPosition;
        this.activityId = this.activityService.register();
        jsGeoPdfPlugin(jsPDF.API);
        const doc = new jsPDF({
            orientation,
            format: paperFormat.toLowerCase(),
            unit: 'mm' // default
        });
        const dimensions = [
            doc.internal.pageSize.width,
            doc.internal.pageSize.height
        ];
        const margins = [10, 10, 10, 10];
        const width = dimensions[0] - margins[3] - margins[1];
        const height = dimensions[1] - margins[0] - margins[2];
        const size = [width, height];
        let titleSizes;
        let subtitleSizes;
        // if paper format A1 or A0 add margin top
        if ((options.title !== '' || options.subtitle !== '') &&
            (paperFormat === PrintPaperFormat.A1 ||
                paperFormat === PrintPaperFormat.A0)) {
            margins[0] += 10;
        }
        // PDF title
        const fontSizeInPt = Math.round(2 * (height + 145) * 0.05) / 2; //calculate the fontSize title from the page height.
        if (options.title !== undefined && options.title !== '') {
            titleSizes = this.getTextPdfObjectSizeAndMarg(options.title, margins, this.TEXTPDFFONT.titleFont, fontSizeInPt, this.TEXTPDFFONT.titleFontStyle, doc);
            this.addTextInPdfDoc(doc, options.title, this.TEXTPDFFONT.titleFont, this.TEXTPDFFONT.titleFontStyle, titleSizes.fontSize, titleSizes.marginLeft + margins[3], margins[0]);
            margins[0] = titleSizes.height + margins[0]; // cumulative margin top for next elem to place in pdf doc
        }
        // PDF subtitle
        if (options.subtitle !== undefined && options.subtitle !== '') {
            subtitleSizes = this.getTextPdfObjectSizeAndMarg(options.subtitle, margins, this.TEXTPDFFONT.subtitleFont, options.title !== '' ? titleSizes.fontSize * 0.7 : fontSizeInPt * 0.7, // 70% size of title
            this.TEXTPDFFONT.subtitleFontStyle, doc);
            this.addTextInPdfDoc(doc, options.subtitle, this.TEXTPDFFONT.subtitleFont, this.TEXTPDFFONT.subtitleFontStyle, subtitleSizes.fontSize, subtitleSizes.marginLeft + margins[3], margins[0]);
            margins[0] += 5; // cumulative marg top for next elem to place in pdf doc. 5 is a fix it could be adjust
        }
        if (options.showProjection === true || options.showScale === true) {
            this.addProjScale(doc, map, resolution, options.showProjection, options.showScale);
        }
        if (options.comment !== undefined && options.comment !== '') {
            this.addComment(doc, options.comment);
        }
        this.addMap(doc, map, resolution, size, margins, legendPostion).subscribe(async (status) => {
            if (status === SubjectStatus.Done) {
                await this.handleMeasureLayer(doc, map, margins);
                const width = this.imgSizeAdded[0];
                const height = this.imgSizeAdded[1];
                this.addGeoRef(doc, width, height, margins);
                if (options.legendPosition !== 'none') {
                    if (['topleft', 'topright', 'bottomleft', 'bottomright'].indexOf(options.legendPosition) > -1) {
                        await this.addLegendSamePage(doc, map, margins, resolution, options.legendPosition);
                    }
                    else if (options.legendPosition === 'newpage') {
                        await this.addLegend(doc, map, margins, resolution);
                    }
                }
                else {
                    await this.saveDoc(doc);
                }
            }
            if (status === SubjectStatus.Done || status === SubjectStatus.Error) {
                this.activityService.unregister(this.activityId);
                status$.next(SubjectStatus.Done);
            }
        });
        return status$;
    }
    // ref GeoMoose https://github.com/geomoose/gm3/tree/main/src/gm3/components/print
    addGeoRef(doc, width, height, margins) {
        const unit = 'mm';
        const docHeight = doc.internal.pageSize.getHeight();
        // x,y = margin left-bottom corner for img in pdf doc
        const x = margins[3];
        const y = docHeight - margins[0] - height;
        let pdf_extents = [x, y, x + width, y + height];
        for (let i = 0; i < pdf_extents.length; i++) {
            pdf_extents[i] = this.pdf_units2points(pdf_extents[i], unit);
        }
        doc.setGeoArea(pdf_extents, this.mapPrintExtent);
    }
    /**
     * Add measure overlay on the map on the document when the measure layer is present
     * @param  doc - Pdf document where measure tooltip will be added
     * @param  map - Map of the app
     * @param  margins - Page margins
     */
    async handleMeasureLayer(doc, map, margins) {
        if (map.layers.find((layer) => layer.visible && layer.id.startsWith('igo-measures-'))) {
            let canvasOverlayHTMLMeasures;
            const mapOverlayMeasuresHTML = map.ol.getOverlayContainer();
            await html2canvas(mapOverlayMeasuresHTML, {
                scale: 1,
                backgroundColor: null
            }).then((e) => {
                canvasOverlayHTMLMeasures = e;
            });
            this.addCanvas(doc, canvasOverlayHTMLMeasures, margins); // this adds measure overlays
        }
    }
    /**
     * Get html code for all layers legend
     * @param  map IgoMap
     * @param  width The width that the legend need to be
     * @return Html code for the legend
     */
    getLayersLegendHtml(map$1, width, resolution) {
        return new Observable((observer) => {
            let html = '';
            const legends = getLayersLegends(map$1.layers, {
                resolution: map$1.viewController.getResolution(),
                extent: map$1.viewController.getExtent(),
                projection: map$1.viewController.getOlProjection().getCode(),
                // scale: map.viewController.getScale(resolution),
                size: map$1.ol.getSize()
            });
            if (legends.filter((l) => l.display === true).length === 0) {
                observer.next(html);
                observer.complete();
                return;
            }
            // Define important style to be sure that all container is convert
            // to image not just visible part
            html += '<style media="screen" type="text/css">';
            html +=
                '.html2canvas-container { width: ' +
                    width +
                    'mm !important; height: 2000px !important; }';
            html += 'table.tableLegend {table-layout: auto;}';
            html +=
                'div.styleLegend {padding-top: 5px; padding-right:5px;padding-left:5px;padding-bottom:5px;}';
            html += '</style>';
            // The font size will also be lowered afterwards (globally along the legend size)
            // this allows having a good relative font size here and to keep ajusting the legend size
            // while keeping good relative font size
            html += '<font size="3" face="Times" >';
            html += '<div class="styleLegend">';
            html += '<table class="tableLegend" >';
            // For each legend, define an html table cell
            const images$ = legends
                .filter((l) => l.display && l.isInResolutionsRange === true)
                .map((legend) => this.getDataImage(legend.url).pipe(map((dataImage) => {
                let htmlImg = '<tr><td>' + legend.title.toUpperCase() + '</td></tr>';
                htmlImg += '<tr><td><img src="' + dataImage + '"></td></tr>';
                return htmlImg;
            })));
            forkJoin(images$).subscribe((dataImages) => {
                html = dataImages.reduce((acc, current) => (acc += current), html);
                html += '</table>';
                html += '</div>';
                observer.next(html);
                observer.complete();
            });
        });
    }
    getDataImage(url) {
        const secureIMG = new SecureImagePipe(this.http, this.configService);
        return secureIMG.transform(url);
    }
    /**
     * Get all the legend in a single image
     * * @param  format - Image format. default value to "png"
     * @return The image of the legend
     */
    async getLayersLegendImage(map, format = 'png', doZipFile, resolution) {
        const status$ = new Subject();
        // Get html code for the legend
        const width = 200; // milimeters unit, originally define for document pdf
        let html = await this.getLayersLegendHtml(map, width, resolution).toPromise();
        format = format.toLowerCase();
        // If no legend show No LEGEND in an image
        if (html.length === 0) {
            html = '<font size="12" face="Courier New" >';
            html += '<div align="center"><b>NO LEGEND</b></div>';
        }
        // Create div to contain html code for legend
        const div = window.document.createElement('div');
        div.style.position = 'absolute';
        div.style.top = '0';
        div.style.zIndex = '-1';
        // Add html code to convert in the new window
        window.document.body.appendChild(div);
        div.innerHTML = html;
        await this.timeout(1);
        const canvas = await html2canvas(div, { useCORS: true }).catch((e) => {
            console.log(e);
        });
        this.removeHtmlElement(div);
        if (canvas) {
            let status = SubjectStatus.Done;
            try {
                if (!doZipFile) {
                    // Save the canvas as file
                    this.saveCanvasImageAsFile(canvas, 'legendImage', format);
                }
                else {
                    // Add the canvas to zip
                    this.generateCanvaFileToZip(canvas, 'legendImage' + '.' + format);
                }
            }
            catch (err) {
                status = SubjectStatus.Error;
            }
            status$.next(status);
        }
        return status$;
    }
    removeHtmlElement(element) {
        element.parentNode.removeChild(element);
    }
    getTextPdfObjectSizeAndMarg(text, margins, font, fontSizeInPt, fontStyle, doc) {
        const pdfResolution = 96;
        const docWidth = doc.internal.pageSize.getWidth();
        const pageWidth = docWidth - margins[1] - margins[3];
        // important to set it first, the textDimension change when font change!
        doc.setFont(font, fontStyle);
        doc.setFontSize(fontSizeInPt);
        let textDimensions = doc.getTextDimensions(text);
        let textMarginLeft;
        if (textDimensions.w > pageWidth) {
            // if the text is to long, reduce fontSize 70% and the overflow with be cut in print...
            textMarginLeft = 0;
            fontSizeInPt = fontSizeInPt * 0.7;
            doc.setFontSize(fontSizeInPt);
            textDimensions = doc.getTextDimensions(text);
        }
        else {
            textMarginLeft = (pageWidth - textDimensions.w) / 2;
        }
        return {
            fontSize: fontSizeInPt,
            marginLeft: textMarginLeft,
            height: textDimensions.h
        };
    }
    /**
     * Add comment to the document
     * * @param  doc - pdf document
     * * @param  comment - Comment to add in the document
     */
    addComment(doc, comment) {
        const commentMarginLeft = 10; //margin left and bottom is fix
        const commentMarginBottom = 10;
        const marginTop = doc.internal.pageSize.height - commentMarginBottom;
        this.addTextInPdfDoc(doc, comment, this.TEXTPDFFONT.commentFont, this.TEXTPDFFONT.commentFontStyle, this.TEXTPDFFONT.commentFontSize, commentMarginLeft, marginTop, true);
    }
    addTextInPdfDoc(doc, textToAdd, textFont, textFontStyle, textFontSize, textMarginLeft, textMarginTop, isComment = false) {
        doc.setFont(textFont, textFontStyle);
        doc.setFontSize(textFontSize);
        if (isComment) {
            textToAdd = doc.splitTextToSize(textToAdd, doc.internal.pageSize.getWidth() - textMarginLeft * 3);
        }
        doc.text(textToAdd, textMarginLeft, textMarginTop);
    }
    /**
     * Add projection and/or scale to the document
     * @param  doc - pdf document
     * @param  map - Map of the app
     * @param  dpi - DPI resolution of the document
     * @param  projection - Bool to indicate if projection need to be added
     * @param  scale - Bool to indicate if scale need to be added
     */
    addProjScale(doc, map, dpi, projection, scale) {
        const translate = this.languageService.translate;
        const projScaleSize = 12;
        const projScaleMarginLeft = 10;
        const marginBottom = 15;
        const heightPixels = doc.internal.pageSize.height - marginBottom;
        let textProjScale = '';
        if (projection === true) {
            const projText = translate.instant('igo.geo.printForm.projection');
            textProjScale += projText + ': ' + map.projection;
        }
        if (scale === true) {
            if (projection === true) {
                textProjScale += '   ';
            }
            const scaleText = translate.instant('igo.geo.printForm.scale');
            const mapScale = map.viewController.getScale(dpi);
            textProjScale += scaleText + ': ~ 1 / ' + formatScale(mapScale);
        }
        doc.setFont('courier');
        doc.setFontSize(projScaleSize);
        doc.text(textProjScale, projScaleMarginLeft, heightPixels);
    }
    /**
     * Add the legend to the document
     * @param  doc - Pdf document where legend will be added
     * @param  map - Map of the app
     * @param  margins - Page margins
     */
    async addLegend(doc, map, margins, resolution) {
        // Get html code for the legend
        const width = doc.internal.pageSize.width;
        const html = await this.getLayersLegendHtml(map, width, resolution).toPromise();
        // If no legend, save the map directly
        if (html === '') {
            await this.saveDoc(doc);
            return true;
        }
        // Create div to contain html code for legend
        const div = window.document.createElement('div');
        div.style.position = 'absolute';
        div.style.top = '0';
        div.style.zIndex = '-1';
        // Add html code to convert in the new window
        window.document.body.appendChild(div);
        div.innerHTML = html;
        await this.timeout(1);
        const canvas = await html2canvas(div, { useCORS: true }).catch((e) => {
            console.log(e);
        });
        this.removeHtmlElement(div);
        if (canvas) {
            const pourcentageReduction = 0.85;
            const imageSize = [
                (pourcentageReduction * (25.4 * canvas.width)) / resolution,
                (pourcentageReduction * (25.4 * canvas.height)) / resolution
            ];
            let imgData;
            doc.addPage();
            imgData = canvas.toDataURL('image/png');
            doc.addImage(imgData, 'PNG', 10, 10, imageSize[0], imageSize[1]);
        }
        await this.saveDoc(doc);
    }
    /**
     * Add the legend to the document
     * @param  doc - Pdf document where legend will be added
     * @param  map - Map of the app
     * @param  margins - Page margins
     */
    async addLegendSamePage(doc, map, margins, resolution, legendPosition) {
        // Get html code for the legend
        const width = doc.internal.pageSize.width;
        const html = await this.getLayersLegendHtml(map, width, resolution).toPromise();
        // If no legend, save the map directly
        if (html === '') {
            await this.saveDoc(doc);
            return true;
        }
        // Create div to contain html code for legend
        const div = window.document.createElement('div');
        div.style.position = 'absolute';
        div.style.top = '0';
        div.style.zIndex = '-1';
        // Add html code to convert in the new window
        window.document.body.appendChild(div);
        div.innerHTML = html;
        await this.timeout(1);
        const canvas = await html2canvas(div, { useCORS: true }).catch((e) => {
            console.log(e);
        });
        this.removeHtmlElement(div);
        let marginsLegend;
        if (canvas) {
            const pourcentageReduction = 0.85;
            const imageSize = [
                (pourcentageReduction * (25.4 * canvas.width)) / resolution,
                (pourcentageReduction * (25.4 * canvas.height)) / resolution
            ];
            // Move the legend to the correct position on the page
            if (legendPosition === 'bottomright') {
                marginsLegend = [
                    doc.internal.pageSize.height - margins[2] - imageSize[1],
                    margins[1],
                    margins[2],
                    doc.internal.pageSize.width - margins[1] - imageSize[0]
                ];
            }
            else if (legendPosition === 'topright') {
                marginsLegend = [
                    margins[0],
                    margins[1],
                    doc.internal.pageSize.height - margins[0] - imageSize[1],
                    doc.internal.pageSize.width - margins[1] - imageSize[0]
                ];
            }
            else if (legendPosition === 'bottomleft') {
                // When the legend is in the bottom left, raise the legend slightly upward so that attributions are visible
                marginsLegend = [
                    doc.internal.pageSize.height - margins[2] - imageSize[1] - 15,
                    doc.internal.pageSize.width - margins[3] - imageSize[0],
                    margins[2] + 15,
                    margins[3]
                ];
            }
            else if (legendPosition === 'topleft') {
                marginsLegend = [
                    margins[0],
                    doc.internal.pageSize.width - margins[3] - imageSize[0],
                    doc.internal.pageSize.height - margins[0] - imageSize[1],
                    margins[3]
                ];
            }
            this.addCanvas(doc, canvas, marginsLegend); // this adds the legend
            await this.saveDoc(doc);
        }
    }
    defineNbFileToProcess(nbFileToProcess) {
        this.nbFileToProcess = nbFileToProcess;
    }
    timeout(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
    }
    addCanvas(doc, canvas, margins) {
        let image;
        if (canvas) {
            image = canvas.toDataURL('image/png');
        }
        if (image !== undefined) {
            if (image.length < 20) {
                console.log('Warning: An image cannot be print in pdf file');
                return;
            }
            const imageSize = this.getImageSizeToFitPdf(doc, canvas, margins);
            doc.addImage(image, 'PNG', margins[3], margins[0], imageSize[0], imageSize[1]);
            doc.rect(margins[3], margins[0], imageSize[0], imageSize[1]);
            this.imgSizeAdded = imageSize; // keep img size for georef later
        }
    }
    // TODO fix printing with image resolution
    addMap(doc, map, resolution, docSize, margins, legendPostion) {
        const mapSize = map.ol.getSize();
        const viewResolution = map.ol.getView().getResolution();
        const dimensionPixels = this.setMapResolution(map, docSize, resolution, viewResolution);
        const status$ = new Subject();
        let timeout;
        map.ol.once('rendercomplete', async (event) => {
            const mapCanvas = event.target
                .getViewport()
                .getElementsByTagName('canvas');
            const mapResultCanvas = await this.drawMap(dimensionPixels, mapCanvas);
            this.mapPrintExtent = map.viewController.getExtent('EPSG:3857');
            this.resetOriginalMapSize(map, mapSize, viewResolution);
            await this.drawMapControls(map, mapResultCanvas, legendPostion);
            const mapStatus$$ = map.status$.subscribe((mapStatus) => {
                clearTimeout(timeout);
                if (mapStatus !== SubjectStatus.Done) {
                    return;
                }
                mapStatus$$.unsubscribe();
                let status = SubjectStatus.Done;
                try {
                    if (mapResultCanvas.width !== 0) {
                        this.addCanvas(doc, mapResultCanvas, margins);
                    }
                }
                catch (err) {
                    status = SubjectStatus.Error;
                    this.messageService.error('igo.geo.printForm.corsErrorMessageBody', 'igo.geo.printForm.corsErrorMessageHeader');
                }
                status$.next(status);
            });
            // If no loading as started after 200ms, then probably no loading
            // is required.
            timeout = window.setTimeout(() => {
                mapStatus$$.unsubscribe();
                let status = SubjectStatus.Done;
                try {
                    if (mapResultCanvas.width !== 0) {
                        this.addCanvas(doc, mapResultCanvas, margins);
                    }
                }
                catch (err) {
                    status = SubjectStatus.Error;
                    this.messageService.error('igo.geo.printForm.corsErrorMessageBody', 'igo.geo.printForm.corsErrorMessageHeader');
                }
                this.resetOriginalMapSize(map, mapSize, viewResolution);
                status$.next(status);
            }, 200);
        });
        return status$;
    }
    setMapResolution(map, initialSize, resolution, viewResolution) {
        const mapSize = map.ol.getSize();
        const widthPixels = Math.round((initialSize[0] * resolution) / 25.4);
        const heightPixels = Math.round((initialSize[1] * resolution) / 25.4);
        // Set print size
        const printSize = [widthPixels, heightPixels];
        map.ol.setSize(printSize);
        const scaling = Math.min(widthPixels / mapSize[0], heightPixels / mapSize[1]);
        map.ol.getView().setResolution(viewResolution / scaling);
        return [widthPixels, heightPixels];
    }
    resetOriginalMapSize(map, initialSize, viewResolution) {
        map.ol.setSize(initialSize);
        map.ol.getView().setResolution(viewResolution);
        map.ol.updateSize();
        map.ol.renderSync();
    }
    async drawMap(size, mapCanvas) {
        const mapResultCanvas = document.createElement('canvas');
        mapResultCanvas.width = size[0];
        mapResultCanvas.height = size[1];
        for (let index = 0; index < mapCanvas.length; index++) {
            const canvas = mapCanvas[index];
            if (canvas.width > 0) {
                this.handleCanvas(canvas, mapResultCanvas);
            }
        }
        return mapResultCanvas;
    }
    handleCanvas(canvas, mapResultCanvas) {
        const mapContextResult = mapResultCanvas.getContext('2d');
        const opacity = canvas.parentElement.style.opacity || canvas.style.opacity;
        mapContextResult.globalAlpha = opacity === '' ? 1 : Number(opacity);
        const transform = canvas.style.transform;
        let matrix;
        if (transform) {
            // Get the transform parameters from the style's transform matrix
            matrix = transform
                .match(/^matrix\(([^\(]*)\)$/)[1]
                .split(',')
                .map(Number);
        }
        else {
            matrix = [
                parseFloat(canvas.style.width) / canvas.width,
                0,
                0,
                parseFloat(canvas.style.height) / canvas.height,
                0,
                0
            ];
        }
        CanvasRenderingContext2D.prototype.setTransform.apply(mapContextResult, matrix);
        const backgroundColor = canvas.parentElement.style.backgroundColor;
        if (backgroundColor) {
            mapContextResult.fillStyle = backgroundColor;
            mapContextResult.fillRect(0, 0, canvas.width, canvas.height);
        }
        mapContextResult.drawImage(canvas, 0, 0);
        mapContextResult.globalAlpha = 1;
        // reset canvas transform to initial
        mapContextResult.setTransform(1, 0, 0, 1, 0, 0);
    }
    async drawMapControls(map, canvas, position) {
        const context = canvas.getContext('2d');
        // Get the scale and attribution
        // we use cloneNode to modify the nodes to print without modifying it on the page, using deep:true to get children
        const mapOverlayHTML = map.ol
            .getOverlayContainerStopEvent()
            .cloneNode(true);
        // add North Direction to mapOverly
        await this.addNorthDirection(mapOverlayHTML, position);
        // add map Attribution designe to print
        await this.addAttribution(mapOverlayHTML);
        // set 'OverlayContainer' size to print size
        mapOverlayHTML.style.width = canvas.width + 'px';
        mapOverlayHTML.style.height = canvas.height + 'px';
        // we add zindex -1 to not show modification to the user
        mapOverlayHTML.style.zIndex = '-1';
        // and make sure html2canvas to render the image correctly
        document
            .getElementsByClassName('ol-viewport')[0]
            .appendChild(mapOverlayHTML);
        // Change the styles of hyperlink in the printed version
        // Transform the Overlay into a canvas
        // scale is necessary to make it in google chrome
        // background as null because otherwise it is white and cover the map
        // allowtaint is to allow rendering images in the attributions
        // useCORS: true pour permettre de renderer les images (ne marche pas en local)
        const canvasOverlayHTML = await html2canvas(mapOverlayHTML, {
            scale: 1,
            backgroundColor: null,
            allowTaint: true,
            useCORS: true
        });
        if (canvasOverlayHTML.width !== 0 && canvasOverlayHTML.height !== 0) {
            context.drawImage(canvasOverlayHTML, 0, 0);
        }
        // remove 'mapOverlayHTML' after generating canvas
        mapOverlayHTML.remove();
    }
    async addNorthDirection(mapOverlayHTML, position) {
        const northDirection = document
            .getElementsByTagName('igo-rotation-button')[0]
            .cloneNode(true);
        const HTMLButton = northDirection.getElementsByTagName('button')[0];
        if (!HTMLButton) {
            return null;
        }
        // in case legend position is topright
        // we change rotate btn to topleft
        if (position === 'topright') {
            northDirection.style.width = 'inherit';
            northDirection.style.left = '10px';
        }
        HTMLButton.parentElement.style.background = 'transparent';
        HTMLButton.style.color = '#000';
        mapOverlayHTML.appendChild(northDirection);
    }
    async addAttribution(mapOverlayHTML) {
        const HTMLattribution = mapOverlayHTML.getElementsByClassName('ol-attribution')[0];
        const HTMLButton = HTMLattribution.getElementsByTagName('button')[0];
        if (!HTMLButton) {
            return null;
        }
        HTMLButton.setAttribute('data-html2canvas-ignore', 'true');
        const olCollapsed = HTMLattribution.classList.contains('ol-collapsed');
        if (olCollapsed) {
            HTMLattribution.classList.remove('ol-collapsed');
        }
    }
    /**
     * Download an image of the map with addition of informations
     * @param  map - Map of the app
     * @param  format - Image format. default value to "png"
     * @param  projection - Indicate if projection need to be add. Default to false
     * @param  scale - Indicate if scale need to be add. Default to false
     * @param  legend - Indicate if the legend of layers need to be download. Default to false
     * @param  title - Title to add for the map - Default to blank
     * @param  subtitle - Subtitle to add for the map - Default to blank
     * @param  comment - Comment to add for the map - Default to blank
     * @param  doZipFile - Indicate if we do a zip with the file
     * @return Image file of the map with extension format given as parameter
     */
    downloadMapImage(map, printResolution, format = 'png', projection = false, scale = false, title = '', subtitle = '', comment = '', doZipFile = true, legendPosition) {
        const status$ = new Subject();
        this.activityId = this.activityService.register();
        const translate = this.languageService.translate;
        format = format.toLowerCase();
        const resolution = +printResolution;
        const initialMapSize = map.ol.getSize();
        const viewResolution = map.ol.getView().getResolution();
        map.ol.once('rendercomplete', async (event) => {
            const size = map.ol.getSize();
            const mapCanvas = event.target
                .getViewport()
                .getElementsByTagName('canvas');
            const mapResultCanvas = await this.drawMap(size, mapCanvas);
            this.resetOriginalMapSize(map, initialMapSize, viewResolution);
            await this.drawMapControls(map, mapResultCanvas, legendPosition);
            // Check the legendPosition
            if (legendPosition !== 'none') {
                if (['topleft', 'topright', 'bottomleft', 'bottomright'].indexOf(legendPosition) > -1) {
                    await this.addLegendToImage(mapResultCanvas, map, resolution, legendPosition, format);
                }
                else if (legendPosition === 'newpage') {
                    await this.getLayersLegendImage(map, format, doZipFile, resolution);
                }
            }
            // add other information to final canvas before exporting
            const newCanvas = document.createElement('canvas');
            const newContext = newCanvas.getContext('2d');
            // Postion in height to set the canvas in new canvas
            let positionHCanvas = 0;
            // Get height/width of map canvas
            const width = mapResultCanvas.width;
            let height = mapResultCanvas.height;
            // Set Font to calculate comment width
            newContext.font = '20px Calibri';
            const commentWidth = newContext.measureText(comment).width;
            // Add height for title if defined
            height = title !== '' ? height + 30 : height;
            // Add height for title if defined
            height = subtitle !== '' ? height + 30 : height;
            // Add height for projection or scale (same line) if defined
            height = projection !== false || scale !== false ? height + 30 : height;
            const positionHProjScale = height - 10;
            // Define number of line depending of the comment length
            const commentNbLine = Math.ceil(commentWidth / width);
            // Add height for multiline comment if defined
            height = comment !== '' ? height + commentNbLine * 30 : height;
            let positionHComment = height - commentNbLine * 20 + 5;
            // Set the new canvas with the new calculated size
            newCanvas.width = width;
            newCanvas.height = height;
            if (['bmp', 'gif', 'jpeg', 'png', 'tiff'].indexOf(format) > -1) {
                // Patch Jpeg default black background to white
                if (format === 'jpeg' ||
                    title !== '' ||
                    subtitle !== '' ||
                    comment !== '' ||
                    projection !== false ||
                    scale !== false) {
                    newContext.fillStyle = '#ffffff';
                    newContext.fillRect(0, 0, width, height);
                    newContext.fillStyle = '#000000';
                }
            }
            // If a title need to be added to canvas
            if (title !== '') {
                // Set font for title
                // Adjust according to title length
                newContext.font = '26px Calibri';
                positionHCanvas = 30;
                newContext.textAlign = 'center';
                newContext.fillText(title, width / 2, 20, width * 0.9);
            }
            if (subtitle !== '') {
                // Set font for subtitle
                // Adjust according to title length
                newContext.font = '26px Calibri';
                positionHCanvas = 60;
                newContext.textAlign = 'center';
                newContext.fillText(subtitle, width / 2, 50, width * 0.9);
            }
            // Set font for next section
            newContext.font = '20px Calibri';
            // If projection or/end scale need to be added to canvas
            if (projection !== false || scale !== false) {
                let projectionScaleText = '';
                if (projection !== false) {
                    const projText = translate.instant('igo.geo.printForm.projection');
                    projectionScaleText = projText + ': ' + map.projection + '         ';
                }
                if (scale !== false) {
                    const scaleText = translate.instant('igo.geo.printForm.scale');
                    const mapScale = map.viewController.getScale(resolution);
                    projectionScaleText += scaleText + ': ~ 1 / ' + formatScale(mapScale);
                }
                newContext.textAlign = 'center';
                newContext.fillText(projectionScaleText, width / 2, positionHProjScale, width * 0.9);
            }
            // If a comment need to be added to canvas
            if (comment !== '') {
                newContext.textAlign = 'center';
                // If only one line, no need to multiline the comment
                if (commentNbLine === 1) {
                    newContext.fillText(comment, width / 2, positionHComment);
                }
                else {
                    // Separate the setenses to be approx. the same length
                    const nbCommentChar = comment.length;
                    const CommentLengthToCut = Math.floor(nbCommentChar / commentNbLine);
                    let commentCurrentLine = '';
                    let positionFirstCutChar = 0;
                    let positionLastBlank;
                    // Loop for the number of line calculated
                    for (let i = 0; i < commentNbLine; i++) {
                        // For all line except last
                        if (commentNbLine - 1 > i) {
                            // Get comment current line to find the right place tu cut comment
                            commentCurrentLine = comment.substr(positionFirstCutChar, CommentLengthToCut);
                            // Cut the setence at blank
                            positionLastBlank = commentCurrentLine.lastIndexOf(' ');
                            newContext.fillText(commentCurrentLine.substr(0, positionLastBlank), width / 2, positionHComment);
                            positionFirstCutChar += positionLastBlank;
                            // Go to next line for insertion
                            positionHComment += 20;
                        }
                        else {
                            // Don't cut last part
                            newContext.fillText(comment.substr(positionFirstCutChar), width / 2, positionHComment);
                        }
                    }
                }
            }
            newContext.drawImage(mapResultCanvas, 0, positionHCanvas);
            let status = SubjectStatus.Done;
            let fileNameWithExt = 'map.' + format;
            if (format.toLowerCase() === 'tiff') {
                fileNameWithExt =
                    'map' + map.projection.replace(':', '_') + '.' + format;
            }
            try {
                // Save the canvas as file
                if (!doZipFile) {
                    this.saveCanvasImageAsFile(newCanvas, fileNameWithExt, format);
                }
                else if (format.toLowerCase() === 'tiff') {
                    // Add the canvas to zip
                    this.generateCanvaFileToZip(newCanvas, fileNameWithExt);
                }
                else {
                    // Add the canvas to zip
                    this.generateCanvaFileToZip(newCanvas, fileNameWithExt);
                }
            }
            catch (err) {
                status = SubjectStatus.Error;
            }
            status$.next(status);
            if (format.toLowerCase() === 'tiff') {
                const tfwFileNameWithExt = fileNameWithExt.substring(0, fileNameWithExt.toLowerCase().indexOf('.tiff')) + '.tfw';
                const tiwContent = this.getWorldFileInformation(map);
                const blob = new Blob([tiwContent], {
                    type: 'text/plain;charset=utf-8'
                });
                if (!doZipFile) {
                    // saveAs automaticly replace ':' for '_'
                    saveAs(blob, tfwFileNameWithExt);
                    this.saveFileProcessing();
                }
                else {
                    // Add the canvas to zip
                    this.addFileToZip(tfwFileNameWithExt, blob);
                }
            }
        });
        this.setMapImageResolution(map, initialMapSize, resolution, viewResolution);
        return status$;
    }
    setMapImageResolution(map, initialMapSize, resolution, viewResolution) {
        const scaleFactor = resolution / 96;
        const newMapSize = [
            Math.round(initialMapSize[0] * scaleFactor),
            Math.round(initialMapSize[1] * scaleFactor) // height
        ];
        map.ol.setSize(newMapSize);
        const scaling = Math.min(newMapSize[0] / initialMapSize[0], newMapSize[1] / initialMapSize[1]);
        const view = map.ol.getView();
        view.setResolution(viewResolution / scaling);
        map.ol.renderSync();
    }
    /**
     * Create and Add Legend to the map canvas
     * @param  canvas Canvas of the map
     * @param  map Map of the app
     * @param  resolution Resolution of map
     * @param  legendPosition Legend position
     * @param  format Image format
     */
    async addLegendToImage(canvas, map, resolution, legendPosition, format) {
        const fileNameWithExt = 'map.' + format;
        const context = canvas.getContext('2d');
        // Get html code for the legend
        const html = await this.getLayersLegendHtml(map, canvas.width, resolution).toPromise();
        // If no legend, save the map directly
        if (html === '') {
            await this.saveCanvasImageAsFile(canvas, fileNameWithExt, format);
            return true;
        }
        // Create div to contain html code for legend
        const div = window.document.createElement('div');
        div.style.position = 'absolute';
        div.style.top = '0';
        div.style.zIndex = '-1';
        // Add html code to convert in the new window
        window.document.body.appendChild(div);
        div.innerHTML = html;
        await this.timeout(1);
        const canvasLegend = await html2canvas(div, { useCORS: true }).catch((e) => {
            console.log(e);
        });
        if (canvasLegend) {
            const canvasHeight = canvas.height;
            const canvasWidth = canvas.width;
            const legendHeight = canvasLegend.height;
            const legendWidth = canvasLegend.width;
            // Move the legend to the correct position on the page
            const offset = canvasHeight * 0.01;
            let legendX;
            let legendY;
            if (legendPosition === 'bottomright') {
                legendX = canvasWidth - legendWidth - offset;
                legendY = canvasHeight - legendHeight - offset;
            }
            else if (legendPosition === 'topright') {
                legendX = canvasWidth - legendWidth - offset;
                legendY = offset;
            }
            else if (legendPosition === 'bottomleft') {
                legendX = offset;
                legendY = canvasHeight - legendHeight - offset - 15;
            }
            else if (legendPosition === 'topleft') {
                legendX = offset;
                legendY = offset;
            }
            context.drawImage(canvasLegend, legendX, legendY, legendWidth, legendHeight);
            context.strokeRect(legendX, legendY, legendWidth, legendHeight);
            this.removeHtmlElement(div);
            return true;
        }
    }
    renderMap(map, size, extent) {
        map.ol.updateSize();
        map.ol.renderSync();
    }
    /**
     * Save document
     * @param  doc - Document to save
     */
    async saveDoc(doc) {
        await doc.save('map_georef.pdf', { returnPromise: true });
    }
    /**
     * Calculate the best Image size to fit in pdf
     * @param doc - Pdf Document
     * @param canvas - Canvas of image
     * @param margins - Page margins
     */
    getImageSizeToFitPdf(doc, canvas, margins) {
        // Define variable to calculate best size to fit in one page
        const pageHeight = doc.internal.pageSize.getHeight() - (margins[0] + margins[2] + 10);
        const pageWidth = doc.internal.pageSize.getWidth() - (margins[1] + margins[3]);
        const canHeight = this.pdf_units2points(canvas.height, 'mm');
        const canWidth = this.pdf_units2points(canvas.width, 'mm');
        const heightRatio = canHeight / pageHeight;
        const widthRatio = canWidth / pageWidth;
        const maxRatio = heightRatio > widthRatio ? heightRatio : widthRatio;
        const imgHeigh = maxRatio > 1 ? canHeight / maxRatio : canHeight;
        const imgWidth = maxRatio > 1 ? canWidth / maxRatio : canWidth;
        return [imgWidth, imgHeigh];
    }
    /**
     * Get a world file information for tiff
     * @param  map - Map of the app
     */
    getWorldFileInformation(map) {
        const currentResolution = map.viewController.getResolution();
        const currentExtent = map.viewController.getExtent(); // Return [minx, miny, maxx, maxy]
        return [
            currentResolution,
            0,
            0,
            -currentResolution,
            currentExtent[0] + currentResolution / 0.5,
            currentExtent[3] - currentResolution / 0.5
        ].join('\n');
    }
    /**
     * Save canvas image as file
     * @param canvas - Canvas to save
     * @param name - Name of the file
     * @param format - file format
     */
    saveCanvasImageAsFile(canvas, nameWithExt, format) {
        const blobFormat = 'image/' + format;
        const that = this;
        try {
            canvas.toDataURL(); // Just to make the catch trigger wihtout toBlob Error throw not catched
            canvas.toBlob((blob) => {
                // download image
                saveAs(blob, nameWithExt);
                that.saveFileProcessing();
            }, blobFormat);
        }
        catch (err) {
            this.messageService.error('igo.geo.printForm.corsErrorMessageBody', 'igo.geo.printForm.corsErrorMessageHeader');
        }
    }
    /**
     * Add file to a zip
     * @param canvas - File to add to the zip
     * @param  name -Name of the fileoverview
     */
    generateCanvaFileToZip(canvas, name) {
        const blobFormat = 'image/' + 'jpeg';
        const that = this;
        if (!this.hasOwnProperty('zipFile') ||
            typeof this.zipFile === 'undefined') {
            this.zipFile = new JSZip();
        }
        try {
            canvas.toDataURL(); // Just to make the catch trigger wihtout toBlob Error throw not catched
            if (navigator.msSaveBlob) {
                this.addFileToZip(name, canvas.msToBlob());
            }
            else {
                canvas.toBlob((blob) => {
                    that.addFileToZip(name, blob);
                }, blobFormat);
            }
        }
        catch (err) {
            this.messageService.error('igo.geo.printForm.corsErrorMessageBody', 'igo.geo.printForm.corsErrorMessageHeader');
        }
    }
    /**
     * Add file to zip, if all file are zipped, download
     * @param name - Name of the files
     * @param blob - Contain of file
     */
    addFileToZip(name, blob) {
        // add file to zip
        this.zipFile.file(name, blob);
        this.nbFileToProcess--;
        // If all files are proccessed
        if (this.nbFileToProcess === 0) {
            // Download zip file
            this.getZipFile();
            // Stop loading
            this.activityService.unregister(this.activityId);
        }
    }
    saveFileProcessing() {
        this.nbFileToProcess--;
        // If all files are proccessed
        if (this.nbFileToProcess === 0) {
            // Stop loading
            this.activityService.unregister(this.activityId);
        }
    }
    /**
     * Get the zipped file
     * @return Retun a zip file
     */
    getZipFile() {
        const that = this;
        this.zipFile.generateAsync({ type: 'blob' }).then((blob) => {
            // 1) generate the zip file
            saveAs(blob, 'map.zip');
            delete that.zipFile;
        });
    }
    pdf_units2points(n, unit) {
        let k = 1;
        // this code is borrowed from jsPDF
        //  as it does not expose a public API
        //  for converting units to points.
        switch (unit) {
            case 'pt':
                k = 1;
                break;
            case 'mm':
                k = 72 / 25.4;
                break;
            case 'cm':
                k = 72 / 2.54;
                break;
            case 'in':
                k = 72;
                break;
            case 'px':
                k = 96 / 72;
                break;
            case 'pc':
                k = 12;
                break;
            case 'em':
                k = 12;
                break;
            case 'ex':
                k = 6;
                break;
            default:
                throw new Error('Invalid unit: ' + unit);
        }
        return n * k;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PrintService, deps: [{ token: i1.HttpClient }, { token: i2.MessageService }, { token: i2.ActivityService }, { token: i2.LanguageService }, { token: i2.ConfigService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PrintService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PrintService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: i2.MessageService }, { type: i2.ActivityService }, { type: i2.LanguageService }, { type: i2.ConfigService }]; } });

class DirectionsSource {
}

class DirectionsSourceService {
    sources;
    constructor(sources) {
        this.sources = sources;
    }
}
function directionsSourceServiceFactory(sources) {
    return new DirectionsSourceService(sources);
}
function provideDirectionsSourceService() {
    return {
        provide: DirectionsSourceService,
        useFactory: directionsSourceServiceFactory,
        deps: [DirectionsSource]
    };
}

var DirectionsFormat;
(function (DirectionsFormat) {
    DirectionsFormat[DirectionsFormat["GeoJSON"] = 0] = "GeoJSON";
    DirectionsFormat[DirectionsFormat["JSON"] = 1] = "JSON";
})(DirectionsFormat || (DirectionsFormat = {}));
var SourceDirectionsType;
(function (SourceDirectionsType) {
    SourceDirectionsType["Route"] = "route";
    SourceDirectionsType["Trip"] = "trip";
})(SourceDirectionsType || (SourceDirectionsType = {}));
var ProposalType;
(function (ProposalType) {
    ProposalType["Coord"] = "coord";
    ProposalType["Text"] = "text";
})(ProposalType || (ProposalType = {}));
var DirectionType;
(function (DirectionType) {
    DirectionType["Stop"] = "stop";
    DirectionType["Route"] = "route";
    DirectionType["Vertex"] = "vertex";
})(DirectionType || (DirectionType = {}));
var DirectionRelativePositionType;
(function (DirectionRelativePositionType) {
    DirectionRelativePositionType["Start"] = "start";
    DirectionRelativePositionType["Intermediate"] = "intermediate";
    DirectionRelativePositionType["End"] = "end";
})(DirectionRelativePositionType || (DirectionRelativePositionType = {}));

/**
 * Function that updat the sort of the list base on the provided field.
 * @param source stop store
 * @param direction asc / desc sort order
 * @param field the field to use to sort the view
 */
function updateStoreSorting(stopsStore, direction = 'asc', field = 'position') {
    stopsStore.view.sort({
        direction,
        valueAccessor: (entity) => entity[field]
    });
}
function computeRelativePosition(index, totalLength) {
    let relativePosition = DirectionRelativePositionType.Intermediate;
    if (index === 0) {
        relativePosition = DirectionRelativePositionType.Start;
    }
    else if (index === totalLength - 1) {
        relativePosition = DirectionRelativePositionType.End;
    }
    return relativePosition;
}
function computeStopsPosition(stopsStore) {
    const stopsToComputePosition = [...stopsStore.all()];
    stopsToComputePosition.sort((a, b) => a.position - b.position);
    stopsToComputePosition.map((stop, i) => {
        stop.position = i;
        stop.relativePosition = computeRelativePosition(stop.position, stopsToComputePosition.length);
    });
    if (stopsToComputePosition) {
        stopsStore.updateMany(stopsToComputePosition);
    }
}
/**
 * Function that add a stop to the stop store. Stop are always added before the last stop.
 * @param stopsStore stop store as an EntityStore
 */
function addStopToStore(stopsStore) {
    const id = uuid();
    const stops = stopsStore.all();
    let positions;
    if (stopsStore.count === 0) {
        positions = [0];
    }
    else {
        positions = stops.map((stop) => stop.position);
    }
    const maxPosition = Math.max(...positions);
    const insertPosition = maxPosition;
    const lastPosition = maxPosition + 1;
    const stopToUpdate = stopsStore
        .all()
        .find((stop) => stop.position === maxPosition);
    if (stopToUpdate) {
        stopToUpdate.position = lastPosition;
        stopToUpdate.relativePosition = computeRelativePosition(lastPosition, stopsStore.count + 1);
    }
    stopsStore.insert({
        id,
        position: insertPosition,
        relativePosition: computeRelativePosition(insertPosition, stopsStore.count + 1)
    });
    updateStoreSorting(stopsStore);
    return stopsStore.get(id);
}
function removeStopFromStore(stopsStore, stop) {
    stopsStore.delete(stop);
    computeStopsPosition(stopsStore);
}
/**
 * Create a style for the directions stops and routes
 * @param feature OlFeature
 * @returns OL style function
 */
function directionsStyle(feature, resolution) {
    const vertexStyle = [
        new olStyle.Style({
            geometry: feature.getGeometry(),
            image: new olStyle.Circle({
                radius: 7,
                stroke: new olStyle.Stroke({ color: '#FF0000', width: 3 })
            })
        })
    ];
    const stopStyle = createOverlayMarkerStyle({
        text: feature.get('stopText'),
        opacity: feature.get('stopOpacity'),
        markerColor: feature.get('stopColor'),
        markerOutlineColor: [255, 255, 255]
    });
    const routeStyle = [
        new olStyle.Style({
            stroke: new olStyle.Stroke({
                color: `rgba(106, 121, 130, ${feature.get('active') ? 0.75 : 0})`,
                width: 10
            })
        }),
        new olStyle.Style({
            stroke: new olStyle.Stroke({
                color: `rgba(79, 169, 221, ${feature.get('active') ? 0.75 : 0})`,
                width: 6
            })
        })
    ];
    if (feature.get('type') === DirectionType.Stop) {
        return stopStyle;
    }
    if (feature.get('type') === 'vertex') {
        return vertexStyle;
    }
    if (feature.get('type') === DirectionType.Route) {
        return routeStyle;
    }
}
function initStopsFeatureStore(stopsFeatureStore, languageService) {
    const loadingStrategy = new FeatureStoreLoadingStrategy({
        motion: FeatureMotion.None
    });
    const stopsLayer = new VectorLayer({
        isIgoInternalLayer: true,
        id: 'igo-direction-stops-layer',
        title: languageService.translate.instant('igo.geo.directionsForm.stopLayer'),
        zIndex: 911,
        source: new FeatureDataSource(),
        showInLayerList: true,
        workspace: {
            enabled: false
        },
        linkedLayers: {
            linkId: 'igo-direction-stops-layer',
            links: [
                {
                    syncedDelete: true,
                    linkedIds: ['igo-direction-route-layer'],
                    properties: []
                }
            ]
        },
        exportable: true,
        browsable: false,
        style: directionsStyle
    });
    tryBindStoreLayer(stopsFeatureStore, stopsLayer);
    stopsFeatureStore.layer.visible = true;
    tryAddLoadingStrategy(stopsFeatureStore, loadingStrategy);
}
function initRoutesFeatureStore(routesFeatureStore, languageService) {
    const loadingStrategy = new FeatureStoreLoadingStrategy({
        motion: FeatureMotion.None
    });
    const routeLayer = new VectorLayer({
        isIgoInternalLayer: true,
        id: 'igo-direction-route-layer',
        title: languageService.translate.instant('igo.geo.directionsForm.routeLayer'),
        zIndex: 910,
        source: new FeatureDataSource(),
        showInLayerList: true,
        workspace: {
            enabled: false
        },
        linkedLayers: {
            linkId: 'igo-direction-route-layer'
        },
        exportable: true,
        browsable: false,
        style: directionsStyle
    });
    tryBindStoreLayer(routesFeatureStore, routeLayer);
    routesFeatureStore.layer.visible = true;
    tryAddLoadingStrategy(routesFeatureStore, loadingStrategy);
}
function initStepFeatureStore(stepFeatureStore) {
    const loadingStrategy = new FeatureStoreLoadingStrategy({
        motion: FeatureMotion.None
    });
    const stepLayer = new VectorLayer({
        isIgoInternalLayer: true,
        id: 'igo-direction-step-layer',
        title: '',
        zIndex: 910,
        source: new FeatureDataSource(),
        showInLayerList: false,
        workspace: {
            enabled: false
        },
        linkedLayers: {
            linkId: 'igo-direction-route-layer'
        },
        exportable: false,
        browsable: false,
        style: directionsStyle
    });
    tryBindStoreLayer(stepFeatureStore, stepLayer);
    stepFeatureStore.layer.visible = true;
    tryAddLoadingStrategy(stepFeatureStore, loadingStrategy);
}
function addStopToStopsFeatureStore(stop, stopsStore, stopsFeatureStore, projection, languageService) {
    let stopColor;
    let stopText;
    switch (stop.relativePosition) {
        case DirectionRelativePositionType.Start:
            stopColor = '#008000';
            stopText = languageService.translate.instant('igo.geo.directionsForm.start');
            break;
        case DirectionRelativePositionType.End:
            stopColor = '#f64139';
            stopText = languageService.translate.instant('igo.geo.directionsForm.end');
            break;
        default:
            stopColor = '#ffd700';
            stopText =
                languageService.translate.instant('igo.geo.directionsForm.intermediate') +
                    ' #' +
                    stop.position;
            break;
    }
    const geometry = new olgeom.Point(olproj.transform(stop.coordinates, projection, stopsFeatureStore.map.projection));
    const geojsonGeom = new OlGeoJSON().writeGeometryObject(geometry, {
        featureProjection: stopsFeatureStore.map.projection,
        dataProjection: stopsFeatureStore.map.projection
    });
    const previousStop = stopsFeatureStore.get(stop.id);
    const previousStopRevision = previousStop ? previousStop.meta.revision : 0;
    const stopFeatureStore = {
        type: FEATURE,
        geometry: geojsonGeom,
        projection: stopsFeatureStore.map.projection,
        properties: {
            id: stop.id,
            type: DirectionType.Stop,
            stopText,
            stopColor,
            stopOpacity: 1,
            stop
        },
        meta: {
            id: stop.id,
            revision: previousStopRevision + 1
        },
        ol: new OlFeature({ geometry })
    };
    stopsFeatureStore.update(stopFeatureStore);
}
function addDirectionToRoutesFeatureStore(routesFeatureStore, direction, projection, active = false, moveToExtent = false) {
    const geom = direction.geometry.coordinates;
    const geometry4326 = new olgeom.LineString(geom);
    const geometry = geometry4326.transform(projection, routesFeatureStore.map.projection);
    const geojsonGeom = new OlGeoJSON().writeGeometryObject(geometry, {
        featureProjection: routesFeatureStore.map.projection,
        dataProjection: routesFeatureStore.map.projection
    });
    const previousRoute = routesFeatureStore.get(direction.id);
    const previousRouteRevision = previousRoute ? previousRoute.meta.revision : 0;
    const routeFeatureStore = {
        type: FEATURE,
        geometry: geojsonGeom,
        projection: routesFeatureStore.map.projection,
        properties: {
            id: direction.id,
            type: DirectionType.Route,
            active,
            direction
        },
        meta: {
            id: direction.id,
            revision: previousRouteRevision + 1
        },
        ol: new OlFeature({ geometry })
    };
    routesFeatureStore.update(routeFeatureStore);
}
function formatDistance(distance) {
    if (distance === 0) {
        return;
    }
    if (distance >= 100000) {
        return NumberUtils.roundToNDecimal(Math.round(distance) / 1000, 1) + ' km';
    }
    if (distance >= 10000) {
        return (NumberUtils.roundToNDecimal(Math.round(distance) / 100 / 10, 1) + ' km');
    }
    if (distance >= 1000) {
        return (NumberUtils.roundToNDecimal(Math.round(distance) / 100 / 10, 1) + ' km');
    }
    return NumberUtils.roundToNDecimal(distance, 0) + ' m';
}
function formatDuration(duration) {
    if (duration >= 3600) {
        const hour = Math.floor(duration / 3600);
        const minute = Math.round((duration / 3600 - hour) * 60);
        if (minute === 60) {
            return hour + 1 + ' h';
        }
        return hour + ' h ' + minute + ' min';
    }
    if (duration >= 60) {
        return Math.round(duration / 60) + ' min';
    }
    return duration + ' s';
}
function formatInstruction(type, modifier, route, direction, stepPosition, exit, languageService, lastStep = false) {
    const translate = languageService.translate;
    let directive;
    let image = 'forward';
    let cssClass = 'rotate-270';
    const translatedDirection = translateBearing(direction, languageService);
    const translatedModifier = translateModifier(modifier, languageService);
    const prefix = modifier === 'straight'
        ? ''
        : translate.instant('igo.geo.directions.modifier.prefix');
    let aggregatedDirection = prefix + translatedModifier;
    if (modifier?.search('slight') >= 0) {
        aggregatedDirection = translatedModifier;
    }
    if (modifier === 'uturn') {
        image = 'forward';
        cssClass = 'rotate-90';
    }
    else if (modifier === 'sharp right') {
        image = 'subdirectory-arrow-right';
        cssClass = 'icon-flipped';
    }
    else if (modifier === 'right') {
        image = 'subdirectory-arrow-right';
        cssClass = 'icon-flipped';
    }
    else if (modifier === 'slight right') {
        image = 'forward';
        cssClass = 'rotate-290';
    }
    else if (modifier === 'straight') {
        image = 'forward';
    }
    else if (modifier === 'slight left') {
        image = 'forward';
        cssClass = 'rotate-250';
    }
    else if (modifier === 'left') {
        image = 'subdirectory-arrow-left';
        cssClass = 'icon-flipped';
    }
    else if (modifier === 'sharp left') {
        image = 'subdirectory-arrow-left';
        cssClass = 'icon-flipped';
    }
    if (type === 'turn') {
        if (modifier === 'straight') {
            directive = translate.instant('igo.geo.directions.turn.straight', {
                route
            });
        }
        else if (modifier === 'uturn') {
            directive = translate.instant('igo.geo.directions.turn.uturn', { route });
        }
        else {
            directive = translate.instant('igo.geo.directions.turn.else', {
                route,
                aggregatedDirection,
                translatedModifier
            });
        }
    }
    else if (type === 'new name') {
        directive = translate.instant('igo.geo.directions.new name', {
            route,
            translatedDirection
        });
        image = 'compass';
        cssClass = '';
    }
    else if (type === 'depart') {
        directive = translate.instant('igo.geo.directions.depart', {
            route,
            translatedDirection
        });
        image = 'compass';
        cssClass = '';
    }
    else if (type === 'arrive') {
        if (lastStep) {
            const coma = !translatedModifier ? '' : ', ';
            aggregatedDirection = !translatedModifier ? '' : aggregatedDirection;
            directive = translate.instant('igo.geo.directions.arrive.lastStep', {
                coma,
                aggregatedDirection
            });
        }
        else {
            directive = translate.instant('igo.geo.directions.arrive.intermediate', {
                route
            });
            image = 'map-marker';
            cssClass = '';
        }
    }
    else if (type === 'merge') {
        directive = translate.instant('igo.geo.directions.merge', { route });
        image = 'forward';
        cssClass = 'rotate-270';
    }
    else if (type === 'on ramp') {
        directive = translate.instant('igo.geo.directions.on ramp', {
            aggregatedDirection
        });
    }
    else if (type === 'off ramp') {
        directive = translate.instant('igo.geo.directions.off ramp', {
            aggregatedDirection
        });
    }
    else if (type === 'fork') {
        if (modifier.search('left') >= 0) {
            directive = translate.instant('igo.geo.directions.fork.left', { route });
        }
        else if (modifier.search('right') >= 0) {
            directive = translate.instant('igo.geo.directions.fork.right', { route });
        }
        else {
            directive = translate.instant('igo.geo.directions.fork.else', { route });
        }
    }
    else if (type === 'end of road') {
        directive = translate.instant('igo.geo.directions.end of road', {
            translatedModifier,
            route
        });
    }
    else if (type === 'use lane') {
        directive = translate.instant('igo.geo.directions.use lane');
    }
    else if (type === 'continue' && modifier !== 'uturn') {
        directive = translate.instant('igo.geo.directions.continue.notUturn', {
            route
        });
        image = 'forward';
        cssClass = 'rotate-270';
    }
    else if (type === 'roundabout') {
        const cntSuffix = exit === 1
            ? translate.instant('igo.geo.directions.cntSuffix.first')
            : translate.instant('igo.geo.directions.cntSuffix.secondAndMore');
        directive = translate.instant('igo.geo.directions.roundabout', {
            exit,
            cntSuffix,
            route
        });
        image = 'chart-donut';
        cssClass = '';
    }
    else if (type === 'rotary') {
        directive = translate.instant('igo.geo.directions.rotary');
        image = 'chart-donut';
        cssClass = '';
    }
    else if (type === 'roundabout turn') {
        directive = translate.instant('igo.geo.directions.roundabout turn');
        image = 'chart-donut';
        cssClass = '';
    }
    else if (type === 'exit roundabout') {
        directive = translate.instant('igo.geo.directions.exit roundabout', {
            route
        });
        image = 'forward';
        cssClass = 'rotate-270';
    }
    else if (type === 'notification') {
        directive = translate.instant('igo.geo.directions.notification');
    }
    else if (modifier === 'uturn') {
        directive = translate.instant('igo.geo.directions.uturnText', {
            translatedDirection,
            route
        });
    }
    else {
        directive = translate.instant('igo.geo.directions.unknown');
    }
    image = lastStep ? 'flag-variant' : image;
    cssClass = lastStep ? '' : cssClass;
    image = stepPosition === 0 ? 'compass' : image;
    cssClass = stepPosition === 0 ? '' : cssClass;
    return { instruction: directive, image, cssClass };
}
function translateModifier(modifier, languageService) {
    const translate = languageService.translate;
    if (modifier === 'uturn') {
        return translate.instant('igo.geo.directions.uturn');
    }
    else if (modifier === 'sharp right') {
        return translate.instant('igo.geo.directions.sharp right');
    }
    else if (modifier === 'right') {
        return translate.instant('igo.geo.directions.right');
    }
    else if (modifier === 'slight right') {
        return translate.instant('igo.geo.directions.slight right');
    }
    else if (modifier === 'sharp left') {
        return languageService.translate.instant('igo.geo.directions.sharp left');
    }
    else if (modifier === 'left') {
        return languageService.translate.instant('igo.geo.directions.left');
    }
    else if (modifier === 'slight left') {
        return languageService.translate.instant('igo.geo.directions.slight left');
    }
    else if (modifier === 'straight') {
        return languageService.translate.instant('igo.geo.directions.straight');
    }
    else {
        return modifier;
    }
}
function translateBearing(bearing, languageService) {
    const translate = languageService.translate;
    if (bearing >= 337 || bearing < 23) {
        return translate.instant('igo.geo.cardinalPoints.n');
    }
    else if (bearing < 67) {
        return translate.instant('igo.geo.cardinalPoints.ne');
    }
    else if (bearing < 113) {
        return translate.instant('igo.geo.cardinalPoints.e');
    }
    else if (bearing < 157) {
        return translate.instant('igo.geo.cardinalPoints.se');
    }
    else if (bearing < 203) {
        return translate.instant('igo.geo.cardinalPoints.s');
    }
    else if (bearing < 247) {
        return translate.instant('igo.geo.cardinalPoints.sw');
    }
    else if (bearing < 293) {
        return translate.instant('igo.geo.cardinalPoints.w');
    }
    else if (bearing < 337) {
        return translate.instant('igo.geo.cardinalPoints.nw');
    }
    else {
        return;
    }
}

class DirectionsService {
    directionsSourceService;
    configService;
    languageService;
    printService;
    document;
    activityService;
    constructor(directionsSourceService, configService, languageService, printService, document, activityService) {
        this.directionsSourceService = directionsSourceService;
        this.configService = configService;
        this.languageService = languageService;
        this.printService = printService;
        this.document = document;
        this.activityService = activityService;
    }
    route(coordinates, directionsOptions = {}) {
        if (coordinates.length === 0) {
            return;
        }
        return this.directionsSourceService.sources
            .filter((source) => source.enabled)
            .map((source) => this.routeSource(source, coordinates, directionsOptions));
    }
    routeSource(source, coordinates, directionsOptions = {}) {
        const request = source.route(coordinates, directionsOptions);
        return request;
    }
    downloadDirection(map, direction) {
        const activityId = this.activityService.register();
        const status$ = new Subject();
        const doc = new jsPDF({
            orientation: 'p',
            format: 'Letter',
            unit: 'mm' // default
        });
        const dimensions = [
            doc.internal.pageSize.width,
            doc.internal.pageSize.height
        ];
        const margins = [10, 10, 10, 10];
        const width = dimensions[0];
        const height = dimensions[1] - margins[0] - margins[2];
        const size = [width, height];
        const title = `${direction.title} (${formatDistance(direction.distance)}, ${formatDuration(direction.duration)})`;
        const titlePosition = 25;
        doc.text(title, doc.internal.pageSize.width / 2, titlePosition, {
            align: 'center'
        });
        margins[0] += 20;
        const resolution = 96; // Default is 96
        this.printService
            .addMap(doc, map, resolution, size, margins, PrintLegendPosition.none)
            .subscribe(async (status) => {
            if (status === SubjectStatus.Done) {
                await this.addInstructions(doc, direction, title);
                this.setPageHeaderFooter(doc);
                await doc.save(`${title}.pdf`, { returnPromise: true });
            }
            this.activityService.unregister(activityId);
            status$.next(status);
        });
        return status$;
    }
    async setHTMLTableContent(direction) {
        const data = await this.directionsInstruction(direction);
        const table = document.createElement('table');
        const tblBody = document.createElement('tbody');
        for (let index = 0; index < data.length; index++) {
            const element = data[index];
            var row = document.createElement('tr');
            var cellImage = document.createElement('td');
            var cellText = document.createElement('td');
            // icon
            const img = document.createElement('img');
            img.src = element.icon;
            // instruction text
            const span = document.createElement('span');
            span.innerHTML = element.instruction;
            cellImage.appendChild(img);
            cellText.appendChild(span);
            if (element.distance) {
                const spanDistance = document.createElement('span');
                spanDistance.style.verticalAlign = 'middle';
                spanDistance.innerHTML =
                    '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' + element.distance;
                cellText.appendChild(spanDistance);
            }
            row.append(cellImage);
            row.append(cellText);
            tblBody.appendChild(row);
        }
        table.appendChild(tblBody);
        return table;
    }
    async directionsInstruction(direction) {
        const matListItems = this.document
            .getElementsByTagName('igo-directions-results')[0]
            .getElementsByTagName('mat-list')[0];
        const matListItem = matListItems.getElementsByTagName('mat-list-item');
        // convert icon list to base64
        let iconsArray = [];
        for (let index = 0; index < matListItem.length; index++) {
            const element = matListItem[index];
            const icon = element.getElementsByTagName('mat-icon')[0];
            const iconName = icon.getAttribute('data-mat-icon-name');
            const found = iconsArray.some((el) => el.name === iconName);
            if (!found) {
                const iconCanvas = await html2canvas(icon, { scale: 3 });
                iconsArray.push({ name: iconName, icon: iconCanvas.toDataURL() });
            }
        }
        let formattedDirection = [];
        for (let i = 0; i < direction.steps.length; i++) {
            const step = direction.steps[i];
            const instruction = formatInstruction(step.maneuver.type, step.maneuver.modifier, step.name, step.maneuver.bearing_after, i, step.maneuver.exit, this.languageService, i === direction.steps.length - 1);
            const distance = formatDistance(step.distance);
            formattedDirection.push({
                instruction: i + 1 + '. ' + instruction.instruction,
                icon: iconsArray.find((icon) => icon.name === instruction.image).icon,
                distance: distance ? '(' + distance + ')' : undefined
            });
        }
        return formattedDirection;
    }
    async addInstructions(doc, direction, title) {
        doc.addPage();
        const titlePosition = 25;
        doc.text(title, doc.internal.pageSize.width / 2, titlePosition, {
            align: 'center'
        });
        const HTMLtable = await this.setHTMLTableContent(direction);
        const tablePos = titlePosition + 5;
        doc.autoTable({
            html: HTMLtable,
            startY: tablePos,
            margin: { top: 20, bottom: 20 },
            columnStyles: {
                0: { cellWidth: 10 }
            },
            theme: 'plain',
            styles: {
                fontSize: 12
            },
            didDrawCell: function (data) {
                if (data.column.index === 0 && data.cell.section === 'body') {
                    data.row.height = 10;
                    const td = data.cell.raw;
                    const img = td.getElementsByTagName('img')[0];
                    doc.addImage(img.src, data.cell.x, data.cell.y, 8, 8);
                }
            }
        });
    }
    setPageHeaderFooter(doc) {
        const pageCount = doc.getNumberOfPages();
        const date = moment(Date.now()).format('DD/MM/YYYY hh:mm').toString();
        const logoConfig = this.configService.getConfig('directionsSources.logo');
        const logo = logoConfig ? logoConfig : 'assets/logo.png';
        for (let index = 0; index < pageCount; index++) {
            doc.setPage(index);
            doc.setFontSize(8);
            const pageSize = doc.internal.pageSize;
            const pageHeight = pageSize.height
                ? pageSize.height
                : pageSize.getHeight();
            const width = pageSize.width ? pageSize.width : pageSize.getWidth();
            doc.text(date, 10, 10, { baseline: 'top' });
            doc.addImage(logo, 'PNG', width - 20, 5, 10, 10);
            doc.text(date, 10, pageHeight - 10);
            doc.text('Page ' + doc.getCurrentPageInfo().pageNumber + ' / ' + pageCount, width - 20, pageHeight - 10);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DirectionsService, deps: [{ token: DirectionsSourceService }, { token: i2.ConfigService }, { token: i2.LanguageService }, { token: PrintService }, { token: DOCUMENT }, { token: i2.ActivityService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DirectionsService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DirectionsService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: DirectionsSourceService }, { type: i2.ConfigService }, { type: i2.LanguageService }, { type: PrintService }, { type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i2.ActivityService }]; } });

/**
 * The class is a specialized version of an EntityStore that stores
 * stops.
 */
class StopsStore extends EntityStore {
    storeInitialized$ = new BehaviorSubject(false);
    clearStops() {
        this.storeInitialized$.next(false);
        this.clear();
    }
}
class StopsFeatureStore extends FeatureStore {
}
class RoutesFeatureStore extends FeatureStore {
}
class StepFeatureStore extends FeatureStore {
}

class DirectionsButtonsComponent {
    languageService;
    messageService;
    route;
    directionsService;
    get activeRoute() {
        return this.routesFeatureStore
            .all()
            .find((route) => route.properties.active);
    }
    contextUri;
    zoomToActiveRoute$ = new Subject();
    stopsStore;
    routesFeatureStore;
    stepFeatureStore;
    disabled$ = new BehaviorSubject(false);
    constructor(languageService, messageService, route, directionsService) {
        this.languageService = languageService;
        this.messageService = messageService;
        this.route = route;
        this.directionsService = directionsService;
    }
    resetStops() {
        this.stopsStore.clearStops();
    }
    // stop are always added before the last stop.
    addStop() {
        addStopToStore(this.stopsStore);
    }
    copyLinkToClipboard() {
        const successful = Clipboard.copy(this.getUrl());
        if (successful) {
            this.messageService.success('igo.geo.directionsForm.dialog.copyMsgLink', 'igo.geo.directionsForm.dialog.copyTitle');
        }
    }
    zoomRoute() {
        this.zoomToActiveRoute$.next();
    }
    copyDirectionsToClipboard() {
        const directionsBody = this.directionsToText();
        const successful = Clipboard.copy(directionsBody);
        if (successful) {
            this.messageService.success('igo.geo.directionsForm.dialog.copyMsg', 'igo.geo.directionsForm.dialog.copyTitle');
        }
    }
    directionsToText() {
        const indent = '\t';
        let activeRouteDirective = this.languageService.translate.instant('igo.geo.directionsForm.instructions') + ':\n';
        let wayPointList = '';
        const summary = this.languageService.translate.instant('igo.geo.directionsForm.summary') +
            ': \n' +
            indent +
            this.activeRoute.properties.direction.title +
            '\n' +
            indent +
            formatDistance(this.activeRoute.properties.direction.distance) +
            '\n' +
            indent +
            formatDuration(this.activeRoute.properties.direction.duration) +
            '\n\n' +
            this.languageService.translate.instant('igo.geo.directionsForm.stopsList') +
            ':\n';
        const url = this.languageService.translate.instant('igo.geo.directionsForm.link') +
            ':\n' +
            indent +
            this.getUrl();
        let wayPointsCnt = 1;
        this.stopsStore.view.all().forEach((stop) => {
            let coord = '';
            let stopText = '';
            if (stop.text !== roundCoordTo(stop.coordinates).join(',')) {
                stopText = stop.text;
                coord = ` ( ${roundCoordTo(stop.coordinates).join(',')} )`;
            }
            else {
                stopText = roundCoordTo(stop.coordinates).join(',');
            }
            wayPointList =
                wayPointList +
                    indent +
                    wayPointsCnt.toLocaleString() +
                    '. ' +
                    stopText +
                    coord +
                    '\n';
            wayPointsCnt++;
        });
        let localCnt = 0;
        this.activeRoute.properties.direction.steps.forEach((step) => {
            const instruction = this.formatStep(step, localCnt).instruction;
            const distance = formatDistance(step.distance) === undefined
                ? ''
                : ' (' + formatDistance(step.distance) + ')';
            activeRouteDirective =
                activeRouteDirective +
                    indent +
                    (localCnt + 1).toLocaleString() +
                    '. ' +
                    instruction +
                    distance +
                    '\n';
            localCnt++;
        });
        const directionsBody = summary + wayPointList + '\n' + url + '\n\n' + activeRouteDirective;
        return directionsBody;
    }
    formatStep(step, cnt) {
        return formatInstruction(step.maneuver.type, step.maneuver.modifier, step.name, step.maneuver.bearing_after, cnt, step.maneuver.exit, this.languageService, cnt === this.activeRoute.properties.direction.steps.length - 1);
    }
    getUrl() {
        if (!this.route) {
            return;
        }
        let context = '';
        if (this.contextUri) {
            context = `context=${this.contextUri}&`;
        }
        const pos = this.routesFeatureStore
            .all()
            .map((direction) => direction.properties.id)
            .indexOf(this.activeRoute.properties.id);
        let routingOptions = '';
        if (pos !== 0) {
            const routingOptionsKey = this.route.options.directionsOptionsKey;
            routingOptions = `&${routingOptionsKey}=result:${pos}`;
        }
        const directionsKey = this.route.options.directionsCoordKey;
        const stopsCoordinates = this.stopsStore.view
            .all()
            .map((stop) => roundCoordTo(stop.coordinates, 6));
        let directionsUrl = '';
        if (stopsCoordinates.length >= 2) {
            directionsUrl = `${directionsKey}=${stopsCoordinates.join(';')}`;
            return `${location.origin}${location.pathname}?${context}tool=directions&sidenav=1&${directionsUrl}${routingOptions}`;
        }
        return;
    }
    printDirections() {
        this.stepFeatureStore.clear();
        this.disabled$.next(true);
        this.directionsService
            .downloadDirection(this.routesFeatureStore.map, this.activeRoute.properties.direction)
            .subscribe(() => {
            this.disabled$.next(false);
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DirectionsButtonsComponent, deps: [{ token: i2.LanguageService }, { token: i2.MessageService }, { token: i2.RouteService, optional: true }, { token: DirectionsService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DirectionsButtonsComponent, selector: "igo-directions-buttons", inputs: { contextUri: "contextUri", zoomToActiveRoute$: "zoomToActiveRoute$", stopsStore: "stopsStore", routesFeatureStore: "routesFeatureStore", stepFeatureStore: "stepFeatureStore" }, ngImport: i0, template: "<div class=\"igo-form-button-group\">\n  <button\n    mat-icon-button\n    tooltip-position=\"below\"\n    matTooltipShowDelay=\"500\"\n    [matTooltip]=\"'igo.geo.directionsForm.addStop' | translate\"\n    color=\"primary\"\n    (click)=\"addStop()\"\n  >\n    <mat-icon svgIcon=\"map-marker-plus\"></mat-icon>\n  </button>\n  <button\n    mat-icon-button\n    tooltip-position=\"below\"\n    matTooltipShowDelay=\"500\"\n    *ngIf=\"\n      (routesFeatureStore.count$ | async) >= 1 ||\n      (stopsStore.count$ | async) >= 1\n    \"\n    [matTooltip]=\"'igo.geo.directionsForm.resetDirectionsBtn' | translate\"\n    color=\"warn\"\n    (click)=\"resetStops()\"\n  >\n    <mat-icon svgIcon=\"file-restore\"></mat-icon>\n  </button>\n  <button\n    mat-icon-button\n    tooltip-position=\"below\"\n    matTooltipShowDelay=\"500\"\n    *ngIf=\"(routesFeatureStore.count$ | async) >= 1\"\n    (click)=\"zoomRoute()\"\n    [matTooltip]=\"'igo.geo.directionsForm.zoomRoute' | translate\"\n    color=\"primary\"\n  >\n    <mat-icon svgIcon=\"magnify-plus-outline\"></mat-icon>\n  </button>\n  <button\n    mat-icon-button\n    tooltip-position=\"below\"\n    matTooltipShowDelay=\"500\"\n    *ngIf=\"(routesFeatureStore.count$ | async) >= 1\"\n    (click)=\"copyDirectionsToClipboard()\"\n    [matTooltip]=\"'igo.geo.directionsForm.copy' | translate\"\n    color=\"primary\"\n  >\n    <mat-icon svgIcon=\"content-copy\"></mat-icon>\n  </button>\n  <button\n    mat-icon-button\n    tooltip-position=\"below\"\n    matTooltipShowDelay=\"500\"\n    *ngIf=\"(routesFeatureStore.count$ | async) >= 1\"\n    (click)=\"copyLinkToClipboard()\"\n    [matTooltip]=\"'igo.geo.directionsForm.link' | translate\"\n    color=\"primary\"\n  >\n    <mat-icon svgIcon=\"link\"></mat-icon>\n  </button>\n\n  <button\n    mat-icon-button\n    tooltip-position=\"below\"\n    matTooltipShowDelay=\"500\"\n    *ngIf=\"(routesFeatureStore.count$ | async) >= 1\"\n    (click)=\"printDirections()\"\n    [disabled]=\"disabled$ | async\"\n    [matTooltip]=\"'igo.geo.directionsForm.print' | translate\"\n    color=\"primary\"\n  >\n    <mat-icon svgIcon=\"printer\"></mat-icon>\n  </button>\n</div>\n", styles: [""], dependencies: [{ kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "pipe", type: i2$2.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DirectionsButtonsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-directions-buttons', template: "<div class=\"igo-form-button-group\">\n  <button\n    mat-icon-button\n    tooltip-position=\"below\"\n    matTooltipShowDelay=\"500\"\n    [matTooltip]=\"'igo.geo.directionsForm.addStop' | translate\"\n    color=\"primary\"\n    (click)=\"addStop()\"\n  >\n    <mat-icon svgIcon=\"map-marker-plus\"></mat-icon>\n  </button>\n  <button\n    mat-icon-button\n    tooltip-position=\"below\"\n    matTooltipShowDelay=\"500\"\n    *ngIf=\"\n      (routesFeatureStore.count$ | async) >= 1 ||\n      (stopsStore.count$ | async) >= 1\n    \"\n    [matTooltip]=\"'igo.geo.directionsForm.resetDirectionsBtn' | translate\"\n    color=\"warn\"\n    (click)=\"resetStops()\"\n  >\n    <mat-icon svgIcon=\"file-restore\"></mat-icon>\n  </button>\n  <button\n    mat-icon-button\n    tooltip-position=\"below\"\n    matTooltipShowDelay=\"500\"\n    *ngIf=\"(routesFeatureStore.count$ | async) >= 1\"\n    (click)=\"zoomRoute()\"\n    [matTooltip]=\"'igo.geo.directionsForm.zoomRoute' | translate\"\n    color=\"primary\"\n  >\n    <mat-icon svgIcon=\"magnify-plus-outline\"></mat-icon>\n  </button>\n  <button\n    mat-icon-button\n    tooltip-position=\"below\"\n    matTooltipShowDelay=\"500\"\n    *ngIf=\"(routesFeatureStore.count$ | async) >= 1\"\n    (click)=\"copyDirectionsToClipboard()\"\n    [matTooltip]=\"'igo.geo.directionsForm.copy' | translate\"\n    color=\"primary\"\n  >\n    <mat-icon svgIcon=\"content-copy\"></mat-icon>\n  </button>\n  <button\n    mat-icon-button\n    tooltip-position=\"below\"\n    matTooltipShowDelay=\"500\"\n    *ngIf=\"(routesFeatureStore.count$ | async) >= 1\"\n    (click)=\"copyLinkToClipboard()\"\n    [matTooltip]=\"'igo.geo.directionsForm.link' | translate\"\n    color=\"primary\"\n  >\n    <mat-icon svgIcon=\"link\"></mat-icon>\n  </button>\n\n  <button\n    mat-icon-button\n    tooltip-position=\"below\"\n    matTooltipShowDelay=\"500\"\n    *ngIf=\"(routesFeatureStore.count$ | async) >= 1\"\n    (click)=\"printDirections()\"\n    [disabled]=\"disabled$ | async\"\n    [matTooltip]=\"'igo.geo.directionsForm.print' | translate\"\n    color=\"primary\"\n  >\n    <mat-icon svgIcon=\"printer\"></mat-icon>\n  </button>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i2.LanguageService }, { type: i2.MessageService }, { type: i2.RouteService, decorators: [{
                    type: Optional
                }] }, { type: DirectionsService }]; }, propDecorators: { contextUri: [{
                type: Input
            }], zoomToActiveRoute$: [{
                type: Input
            }], stopsStore: [{
                type: Input
            }], routesFeatureStore: [{
                type: Input
            }], stepFeatureStore: [{
                type: Input
            }] } });

class DirectionsInputsComponent {
    languageService;
    invalidKeys = ['Control', 'Shift', 'Alt'];
    onMapClickEventKeys = [];
    stopWithHover;
    stopIsDragged = false;
    stopsStore;
    stopsFeatureStore;
    projection;
    coordRoundedDecimals = 6;
    debounce = 200;
    length = 2;
    stopInputHasFocus = new EventEmitter(false);
    constructor(languageService) {
        this.languageService = languageService;
    }
    ngOnDestroy() {
        this.unlistenMapSingleClick();
    }
    onStopEnter(stop) {
        this.stopWithHover = stop;
    }
    onStopLeave() {
        this.stopWithHover = undefined;
    }
    getOptionText(option) {
        if (option instanceof Object) {
            return option?.meta ? option.meta.title : '';
        }
        return option;
    }
    chooseProposal(event, stop) {
        const result = event.option.value;
        if (result) {
            let geomCoord;
            const geom = result.geometry;
            if (geom.type === 'Point') {
                geomCoord = geom.coordinates;
            }
            else {
                const point = pointOnFeature(result.geometry);
                geomCoord = [
                    point.geometry.coordinates[0],
                    point.geometry.coordinates[1]
                ];
            }
            if (geomCoord) {
                stop.coordinates = geomCoord;
                stop.text = result.meta.title;
                this.stopsStore.update(stop);
            }
        }
    }
    setStopText(event, stop) {
        this.unlistenMapSingleClick();
        const term = event.target.value;
        if (term.length === 0) {
            this.clearStop(stop);
        }
        else if (this.validateTerm(term)) {
            stop.text = term;
            this.stopsStore.update(stop);
        }
    }
    validateTerm(term) {
        if (this.keyIsValid(term) &&
            (term.length >= this.length || term.length === 0)) {
            return true;
        }
        return false;
    }
    keyIsValid(key) {
        return this.invalidKeys.find((value) => value === key) === undefined;
    }
    getNgClass(stop) {
        if (!this.stopWithHover) {
            return 'igo-input-container';
        }
        else if (stop.id === this.stopWithHover.id) {
            return 'igo-input-container reduce';
        }
        else {
            return 'igo-input-container';
        }
    }
    getPlaceholder(stop) {
        let extra = '';
        if (stop.relativePosition) {
            if (stop.relativePosition === DirectionRelativePositionType.Intermediate) {
                extra = ' #' + stop.position;
            }
            return (this.languageService.translate.instant('igo.geo.directionsForm.' + stop.relativePosition) + extra);
        }
        else {
            return '';
        }
    }
    removeStop(stop) {
        removeStopFromStore(this.stopsStore, stop);
    }
    clearStop(stop) {
        this.stopsStore.update({
            id: stop.id,
            relativePosition: stop.relativePosition,
            position: stop.position
        });
    }
    drop(event) {
        this.moveStops(event.previousIndex, event.currentIndex);
    }
    moveStops(fromIndex, toIndex) {
        if (fromIndex !== toIndex) {
            const stops = [...this.stopsStore.view.all()];
            moveItemInArray(stops, fromIndex, toIndex);
            stops.map((stop, i) => {
                stop.relativePosition = computeRelativePosition(i, stops.length);
                stop.position = i;
            });
            this.stopsStore.updateMany(stops);
            updateStoreSorting(this.stopsStore);
        }
    }
    onInputFocus(stop) {
        if (!stop.text || stop.text?.length === 0) {
            this.unlistenMapSingleClick();
            this.stopInputHasFocus.emit(true);
            this.listenMapSingleClick(stop);
        }
    }
    listenMapSingleClick(stop) {
        const key = this.stopsFeatureStore.layer.map.ol.once('singleclick', (event) => {
            const clickCoordinates = olproj.transform(event.coordinate, this.stopsFeatureStore.layer.map.projection, this.projection);
            const roundedCoord = roundCoordTo(clickCoordinates, this.coordRoundedDecimals);
            stop.text = roundedCoord.join(',');
            stop.coordinates = roundedCoord;
            this.stopsStore.update(stop);
            setTimeout(() => {
                this.stopInputHasFocus.emit(false);
            }, 500);
        });
        this.onMapClickEventKeys.push(key);
    }
    unlistenMapSingleClick() {
        this.onMapClickEventKeys.map((key) => {
            olObservable.unByKey(key);
        });
        this.onMapClickEventKeys = [];
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DirectionsInputsComponent, deps: [{ token: i2.LanguageService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DirectionsInputsComponent, selector: "igo-directions-inputs", inputs: { stopsStore: "stopsStore", stopsFeatureStore: "stopsFeatureStore", projection: "projection", coordRoundedDecimals: "coordRoundedDecimals", debounce: "debounce", length: "length" }, outputs: { stopInputHasFocus: "stopInputHasFocus" }, ngImport: i0, template: "<div cdkDropList class=\"stops-list\" (cdkDropListDropped)=\"drop($event)\">\n  <div\n    touchleave\n    (touchenter)=\"onStopEnter(stop)\"\n    (touchleave)=\"onStopLeave()\"\n    (mouseover)=\"onStopEnter(stop)\"\n    (mouseleave)=\"onStopLeave()\"\n    (cdkDragStarted)=\"stopIsDragged = true\"\n    (cdkDragEnded)=\"stopIsDragged = false\"\n    cdkDragLockAxis=\"y\"\n    class=\"stop-box\"\n    *ngFor=\"let stop of stopsStore.view.all$() | async; let i = index\"\n    cdkDrag\n  >\n    <div [ngClass]=\"getNgClass(stop)\">\n      <mat-form-field subscriptSizing=\"dynamic\">\n        <mat-label>{{ getPlaceholder(stop) }}</mat-label>\n        <input\n          id=\"{{ stop.id }}\"\n          type=\"text\"\n          [placeholder]=\"getPlaceholder(stop)\"\n          matTooltipShowDelay=\"500\"\n          [matTooltip]=\"stop.text\"\n          aria-label=\"Number\"\n          matInput\n          (focus)=\"onInputFocus(stop)\"\n          [(ngModel)]=\"stop.text\"\n          (keyup)=\"setStopText($event, stop)\"\n          (keydown.enter)=\"$event.preventDefault()\"\n          [matAutocomplete]=\"auto\"\n        />\n        <button\n          *ngIf=\"\n            (stop.text || stop.coordinates) &&\n            stopWithHover &&\n            stop.id === stopWithHover.id\n          \"\n          mat-icon-button\n          matSuffix\n          matTooltipShowDelay=\"500\"\n          [matTooltip]=\"'igo.geo.directionsForm.clearStop' | translate\"\n          color=\"warn\"\n          aria-label=\"Clear\"\n          (click)=\"clearStop(stop)\"\n        >\n          <mat-icon svgIcon=\"close\"></mat-icon>\n        </button>\n\n        <mat-autocomplete\n          [displayWith]=\"getOptionText\"\n          #auto=\"matAutocomplete\"\n          (optionSelected)=\"chooseProposal($event, stop)\"\n        >\n          <mat-optgroup\n            *ngFor=\"let source of stop.searchProposals\"\n            [label]=\"source.source.title\"\n            [disabled]=\"source.source.enabled === false\"\n          >\n            <mat-option\n              *ngFor=\"let result of source.results\"\n              [value]=\"result\"\n              matTooltipShowDelay=\"500\"\n              [matTooltip]=\"result.meta ? result.meta.title : ''\"\n            >\n              {{ result.meta ? result.meta.title : '' }}\n            </mat-option>\n          </mat-optgroup>\n        </mat-autocomplete>\n      </mat-form-field>\n    </div>\n\n    <div\n      *ngIf=\"!stopIsDragged && stopWithHover && stop.id === stopWithHover.id\"\n      class=\"igo-form-button-group\"\n    >\n      <button\n        class=\"swipe-vertical\"\n        cdkDragHandle\n        mat-icon-button\n        tooltip-position=\"below\"\n        matTooltipShowDelay=\"500\"\n        [matTooltip]=\"'igo.geo.directionsForm.moveStop' | translate\"\n        color=\"primary\"\n      >\n        <mat-icon svgIcon=\"gesture-swipe-vertical\"></mat-icon>\n      </button>\n\n      <button\n        *ngIf=\"(stopsStore.count$ | async) > 2\"\n        mat-icon-button\n        tooltip-position=\"below\"\n        matTooltipShowDelay=\"500\"\n        [matTooltip]=\"'igo.geo.directionsForm.removeStop' | translate\"\n        color=\"warn\"\n        (click)=\"removeStop(stop)\"\n      >\n        <mat-icon svgIcon=\"delete\"></mat-icon>\n      </button>\n    </div>\n  </div>\n</div>\n", styles: [":host .igo-input-container{display:flex;width:100%}:host .igo-input-container mat-form-field{flex:1}:host .igo-form-button-group{display:flex;align-items:center;padding-left:12px}:host .stops-list{max-width:100%;min-height:60px;display:block;background:#fff;border-radius:4px;overflow:hidden;padding:20px 10px}:host .swipe-vertical{cursor:move}:host .stop-box{color:#000000de;display:flex;flex-direction:row;align-items:center;justify-content:space-between;box-sizing:border-box;background:#fff}:host .stop-box:not(:last-child){margin-bottom:16px}:host .cdk-drag-preview{box-sizing:border-box;border-radius:4px;box-shadow:0 5px 5px -3px #0003,0 8px 10px 1px #00000024,0 3px 14px 2px #0000001f}:host .cdk-drag-placeholder{opacity:0}:host .cdk-drag-animating{transition:transform .25s cubic-bezier(0,0,.2,1)}:host .stops-list.cdk-drop-list-dragging .stop-box:not(.cdk-drag-placeholder){transition:transform .25s cubic-bezier(0,0,.2,1)}\n"], dependencies: [{ kind: "directive", type: i2$2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.CdkDropList, selector: "[cdkDropList], cdk-drop-list", inputs: ["cdkDropListConnectedTo", "cdkDropListData", "cdkDropListOrientation", "id", "cdkDropListLockAxis", "cdkDropListDisabled", "cdkDropListSortingDisabled", "cdkDropListEnterPredicate", "cdkDropListSortPredicate", "cdkDropListAutoScrollDisabled", "cdkDropListAutoScrollStep"], outputs: ["cdkDropListDropped", "cdkDropListEntered", "cdkDropListExited", "cdkDropListSorted"], exportAs: ["cdkDropList"] }, { kind: "directive", type: i3.CdkDrag, selector: "[cdkDrag]", inputs: ["cdkDragData", "cdkDragLockAxis", "cdkDragRootElement", "cdkDragBoundary", "cdkDragStartDelay", "cdkDragFreeDragPosition", "cdkDragDisabled", "cdkDragConstrainPosition", "cdkDragPreviewClass", "cdkDragPreviewContainer"], outputs: ["cdkDragStarted", "cdkDragReleased", "cdkDragEnded", "cdkDragEntered", "cdkDragExited", "cdkDragDropped", "cdkDragMoved"], exportAs: ["cdkDrag"] }, { kind: "directive", type: i3.CdkDragHandle, selector: "[cdkDragHandle]", inputs: ["cdkDragHandleDisabled"] }, { kind: "directive", type: i2$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "component", type: i8.MatFormField, selector: "mat-form-field", inputs: ["hideRequiredMarker", "color", "floatLabel", "appearance", "subscriptSizing", "hintLabel"], exportAs: ["matFormField"] }, { kind: "directive", type: i8.MatLabel, selector: "mat-label" }, { kind: "directive", type: i8.MatSuffix, selector: "[matSuffix], [matIconSuffix], [matTextSuffix]", inputs: ["matTextSuffix"] }, { kind: "directive", type: i9$3.MatInput, selector: "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", inputs: ["disabled", "id", "placeholder", "name", "required", "type", "errorStateMatcher", "aria-describedby", "value", "readonly"], exportAs: ["matInput"] }, { kind: "component", type: i9.MatOption, selector: "mat-option", exportAs: ["matOption"] }, { kind: "component", type: i9.MatOptgroup, selector: "mat-optgroup", inputs: ["disabled"], exportAs: ["matOptgroup"] }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "component", type: i6$2.MatAutocomplete, selector: "mat-autocomplete", inputs: ["disableRipple", "hideSingleSelectionIndicator"], exportAs: ["matAutocomplete"] }, { kind: "directive", type: i6$2.MatAutocompleteTrigger, selector: "input[matAutocomplete], textarea[matAutocomplete]", exportAs: ["matAutocompleteTrigger"] }, { kind: "pipe", type: i2$2.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DirectionsInputsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-directions-inputs', template: "<div cdkDropList class=\"stops-list\" (cdkDropListDropped)=\"drop($event)\">\n  <div\n    touchleave\n    (touchenter)=\"onStopEnter(stop)\"\n    (touchleave)=\"onStopLeave()\"\n    (mouseover)=\"onStopEnter(stop)\"\n    (mouseleave)=\"onStopLeave()\"\n    (cdkDragStarted)=\"stopIsDragged = true\"\n    (cdkDragEnded)=\"stopIsDragged = false\"\n    cdkDragLockAxis=\"y\"\n    class=\"stop-box\"\n    *ngFor=\"let stop of stopsStore.view.all$() | async; let i = index\"\n    cdkDrag\n  >\n    <div [ngClass]=\"getNgClass(stop)\">\n      <mat-form-field subscriptSizing=\"dynamic\">\n        <mat-label>{{ getPlaceholder(stop) }}</mat-label>\n        <input\n          id=\"{{ stop.id }}\"\n          type=\"text\"\n          [placeholder]=\"getPlaceholder(stop)\"\n          matTooltipShowDelay=\"500\"\n          [matTooltip]=\"stop.text\"\n          aria-label=\"Number\"\n          matInput\n          (focus)=\"onInputFocus(stop)\"\n          [(ngModel)]=\"stop.text\"\n          (keyup)=\"setStopText($event, stop)\"\n          (keydown.enter)=\"$event.preventDefault()\"\n          [matAutocomplete]=\"auto\"\n        />\n        <button\n          *ngIf=\"\n            (stop.text || stop.coordinates) &&\n            stopWithHover &&\n            stop.id === stopWithHover.id\n          \"\n          mat-icon-button\n          matSuffix\n          matTooltipShowDelay=\"500\"\n          [matTooltip]=\"'igo.geo.directionsForm.clearStop' | translate\"\n          color=\"warn\"\n          aria-label=\"Clear\"\n          (click)=\"clearStop(stop)\"\n        >\n          <mat-icon svgIcon=\"close\"></mat-icon>\n        </button>\n\n        <mat-autocomplete\n          [displayWith]=\"getOptionText\"\n          #auto=\"matAutocomplete\"\n          (optionSelected)=\"chooseProposal($event, stop)\"\n        >\n          <mat-optgroup\n            *ngFor=\"let source of stop.searchProposals\"\n            [label]=\"source.source.title\"\n            [disabled]=\"source.source.enabled === false\"\n          >\n            <mat-option\n              *ngFor=\"let result of source.results\"\n              [value]=\"result\"\n              matTooltipShowDelay=\"500\"\n              [matTooltip]=\"result.meta ? result.meta.title : ''\"\n            >\n              {{ result.meta ? result.meta.title : '' }}\n            </mat-option>\n          </mat-optgroup>\n        </mat-autocomplete>\n      </mat-form-field>\n    </div>\n\n    <div\n      *ngIf=\"!stopIsDragged && stopWithHover && stop.id === stopWithHover.id\"\n      class=\"igo-form-button-group\"\n    >\n      <button\n        class=\"swipe-vertical\"\n        cdkDragHandle\n        mat-icon-button\n        tooltip-position=\"below\"\n        matTooltipShowDelay=\"500\"\n        [matTooltip]=\"'igo.geo.directionsForm.moveStop' | translate\"\n        color=\"primary\"\n      >\n        <mat-icon svgIcon=\"gesture-swipe-vertical\"></mat-icon>\n      </button>\n\n      <button\n        *ngIf=\"(stopsStore.count$ | async) > 2\"\n        mat-icon-button\n        tooltip-position=\"below\"\n        matTooltipShowDelay=\"500\"\n        [matTooltip]=\"'igo.geo.directionsForm.removeStop' | translate\"\n        color=\"warn\"\n        (click)=\"removeStop(stop)\"\n      >\n        <mat-icon svgIcon=\"delete\"></mat-icon>\n      </button>\n    </div>\n  </div>\n</div>\n", styles: [":host .igo-input-container{display:flex;width:100%}:host .igo-input-container mat-form-field{flex:1}:host .igo-form-button-group{display:flex;align-items:center;padding-left:12px}:host .stops-list{max-width:100%;min-height:60px;display:block;background:#fff;border-radius:4px;overflow:hidden;padding:20px 10px}:host .swipe-vertical{cursor:move}:host .stop-box{color:#000000de;display:flex;flex-direction:row;align-items:center;justify-content:space-between;box-sizing:border-box;background:#fff}:host .stop-box:not(:last-child){margin-bottom:16px}:host .cdk-drag-preview{box-sizing:border-box;border-radius:4px;box-shadow:0 5px 5px -3px #0003,0 8px 10px 1px #00000024,0 3px 14px 2px #0000001f}:host .cdk-drag-placeholder{opacity:0}:host .cdk-drag-animating{transition:transform .25s cubic-bezier(0,0,.2,1)}:host .stops-list.cdk-drop-list-dragging .stop-box:not(.cdk-drag-placeholder){transition:transform .25s cubic-bezier(0,0,.2,1)}\n"] }]
        }], ctorParameters: function () { return [{ type: i2.LanguageService }]; }, propDecorators: { stopsStore: [{
                type: Input
            }], stopsFeatureStore: [{
                type: Input
            }], projection: [{
                type: Input
            }], coordRoundedDecimals: [{
                type: Input
            }], debounce: [{
                type: Input
            }], length: [{
                type: Input
            }], stopInputHasFocus: [{
                type: Output
            }] } });

class DirectionsResultsComponent {
    languageService;
    cdRef;
    activeDirection;
    directions;
    entities$$;
    routesFeatureStore;
    stepFeatureStore;
    constructor(languageService, cdRef) {
        this.languageService = languageService;
        this.cdRef = cdRef;
    }
    ngOnInit() {
        this.entities$$ = this.routesFeatureStore.entities$
            .pipe(debounceTime(200))
            .subscribe((entities) => {
            const activeFeatureWithDirection = entities.find((entity) => entity.properties.active);
            this.directions = entities.map((entity) => entity.properties.direction);
            if (activeFeatureWithDirection) {
                this.activeDirection =
                    activeFeatureWithDirection.properties.direction;
            }
            else {
                this.activeDirection = undefined;
            }
            this.cdRef.detectChanges();
        });
    }
    ngOnDestroy() {
        this.entities$$.unsubscribe();
    }
    changeRoute() {
        this.routesFeatureStore.entities$.value.map((entity) => (entity.properties.active = !entity.properties.active));
        this.routesFeatureStore.layer.ol
            .getSource()
            .getFeatures()
            .map((feature) => feature.set('active', !feature.get('active')));
    }
    formatDistance(distance) {
        return formatDistance(distance);
    }
    formatDuration(duration) {
        return formatDuration(duration);
    }
    formatStep(step, cnt) {
        return formatInstruction(step.maneuver.type, step.maneuver.modifier, step.name, step.maneuver.bearing_after, cnt, step.maneuver.exit, this.languageService, cnt === this.activeDirection.steps.length - 1);
    }
    onStepsListBlur() {
        this.stepFeatureStore.clear();
    }
    showSegment(step, zoomToExtent = false) {
        this.showRouteSegmentGeometry(step, zoomToExtent);
    }
    showRouteSegmentGeometry(step, zoomToExtent = false) {
        const coordinates = step.geometry.coordinates;
        const vertexId = 'vertex';
        const geometry4326 = new olgeom.LineString(coordinates);
        const geometryMapProjection = geometry4326.transform('EPSG:4326', this.stepFeatureStore.layer.map.projection);
        const routeSegmentCoordinates = geometryMapProjection.getCoordinates();
        const lastPoint = routeSegmentCoordinates[0];
        const geometry = new olgeom.Point(lastPoint);
        const feature = new OlFeature({ geometry });
        const geojsonGeom = new OlGeoJSON().writeGeometryObject(geometry, {
            featureProjection: this.stepFeatureStore.layer.map.projection,
            dataProjection: this.stepFeatureStore.layer.map.projection
        });
        const previousVertex = this.stepFeatureStore.get(vertexId);
        const previousVertexRevision = previousVertex
            ? previousVertex.meta.revision
            : 0;
        const stepFeature = {
            type: FEATURE,
            geometry: geojsonGeom,
            projection: this.stepFeatureStore.layer.map.projection,
            properties: {
                id: vertexId,
                step,
                type: DirectionType.Vertex
            },
            meta: {
                id: vertexId,
                revision: previousVertexRevision + 1
            },
            ol: feature
        };
        this.stepFeatureStore.update(stepFeature);
        if (zoomToExtent) {
            this.stepFeatureStore.layer.map.viewController.zoomToExtent(feature.getGeometry().getExtent());
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DirectionsResultsComponent, deps: [{ token: i2.LanguageService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DirectionsResultsComponent, selector: "igo-directions-results", inputs: { routesFeatureStore: "routesFeatureStore", stepFeatureStore: "stepFeatureStore" }, ngImport: i0, template: "<div class=\"igo-input-container\" *ngIf=\"directions && activeDirection\">\n  <mat-form-field *ngIf=\"directions && directions.length > 1\">\n    <mat-label>{{\n      'igo.geo.directionsForm.drivingOptions' | translate\n    }}</mat-label>\n    <mat-select\n      placeholder=\"{{ 'igo.geo.directionsForm.drivingOptions' | translate }}\"\n      (selectionChange)=\"changeRoute()\"\n      [(ngModel)]=\"activeDirection\"\n    >\n      <mat-option\n        *ngFor=\"let direction of directions; let cnt = index\"\n        [value]=\"direction\"\n      >\n        Option {{ cnt + 1 }} : {{ formatDistance(direction.distance) }} ({{\n          formatDuration(direction.duration)\n        }})\n      </mat-option>\n    </mat-select>\n  </mat-form-field>\n\n  <mat-divider *ngIf=\"directions && directions.length === 0\"></mat-divider>\n\n  <mat-list (mouseleave)=\"onStepsListBlur()\">\n    <h2 mat-header class=\"igo-route-title\">{{ activeDirection.title }}</h2>\n    <span class=\"mat-caption\">\n      {{ formatDistance(activeDirection.distance) }},\n      {{ formatDuration(activeDirection.duration) }}\n    </span>\n    <mat-list-item\n      class=\"igo-steps\"\n      (mouseenter)=\"showSegment(step)\"\n      (click)=\"showSegment(step, true)\"\n      *ngFor=\"let step of activeDirection.steps; let cnt = index\"\n      igoListItem\n    >\n      <mat-icon\n        [ngClass]=\"formatStep(step, cnt).cssClass\"\n        matListItemIcon\n        svgIcon=\"{{ formatStep(step, cnt).image }}\"\n      >\n      </mat-icon>\n\n      <span class=\"igo-step-text\">\n        {{ cnt + 1 }}. {{ formatStep(step, cnt).instruction }}\n      </span>\n      <span matListItemMeta>\n        {{ formatDistance(step.distance) }}\n      </span>\n    </mat-list-item>\n\n    <mat-divider></mat-divider>\n  </mat-list>\n</div>\n", styles: [".igo-input-container{width:100%;padding:20px 10px;box-sizing:border-box}.igo-input-container mat-form-field{width:70%}.igo-route-title{font-weight:700}.igo-steps{cursor:pointer;padding:35px 0}.igo-steps .igo-step-text{overflow-wrap:break-word;word-wrap:break-word;white-space:pre-wrap}.mat-mdc-list-item{word-wrap:break-word!important;white-space:pre-wrap!important}.rotate-90{transform:rotate(90deg)}.rotate-45{transform:rotate(45deg)}.rotate-270{transform:rotate(270deg)}.rotate-250{transform:rotate(250deg)}.rotate-290{transform:rotate(290deg)}.icon-flipped{transform:scaleY(-1)}\n"], dependencies: [{ kind: "directive", type: i2$2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i5.MatList, selector: "mat-list", exportAs: ["matList"] }, { kind: "component", type: i5.MatListItem, selector: "mat-list-item, a[mat-list-item], button[mat-list-item]", inputs: ["activated"], exportAs: ["matListItem"] }, { kind: "directive", type: i5.MatListItemIcon, selector: "[matListItemIcon]" }, { kind: "component", type: i9$2.MatDivider, selector: "mat-divider", inputs: ["vertical", "inset"] }, { kind: "directive", type: i5.MatListItemMeta, selector: "[matListItemMeta]" }, { kind: "component", type: i8.MatFormField, selector: "mat-form-field", inputs: ["hideRequiredMarker", "color", "floatLabel", "appearance", "subscriptSizing", "hintLabel"], exportAs: ["matFormField"] }, { kind: "directive", type: i8.MatLabel, selector: "mat-label" }, { kind: "component", type: i9.MatOption, selector: "mat-option", exportAs: ["matOption"] }, { kind: "component", type: i15.MatSelect, selector: "mat-select", inputs: ["disabled", "disableRipple", "tabIndex", "panelWidth", "hideSingleSelectionIndicator"], exportAs: ["matSelect"] }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DirectionsResultsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-directions-results', template: "<div class=\"igo-input-container\" *ngIf=\"directions && activeDirection\">\n  <mat-form-field *ngIf=\"directions && directions.length > 1\">\n    <mat-label>{{\n      'igo.geo.directionsForm.drivingOptions' | translate\n    }}</mat-label>\n    <mat-select\n      placeholder=\"{{ 'igo.geo.directionsForm.drivingOptions' | translate }}\"\n      (selectionChange)=\"changeRoute()\"\n      [(ngModel)]=\"activeDirection\"\n    >\n      <mat-option\n        *ngFor=\"let direction of directions; let cnt = index\"\n        [value]=\"direction\"\n      >\n        Option {{ cnt + 1 }} : {{ formatDistance(direction.distance) }} ({{\n          formatDuration(direction.duration)\n        }})\n      </mat-option>\n    </mat-select>\n  </mat-form-field>\n\n  <mat-divider *ngIf=\"directions && directions.length === 0\"></mat-divider>\n\n  <mat-list (mouseleave)=\"onStepsListBlur()\">\n    <h2 mat-header class=\"igo-route-title\">{{ activeDirection.title }}</h2>\n    <span class=\"mat-caption\">\n      {{ formatDistance(activeDirection.distance) }},\n      {{ formatDuration(activeDirection.duration) }}\n    </span>\n    <mat-list-item\n      class=\"igo-steps\"\n      (mouseenter)=\"showSegment(step)\"\n      (click)=\"showSegment(step, true)\"\n      *ngFor=\"let step of activeDirection.steps; let cnt = index\"\n      igoListItem\n    >\n      <mat-icon\n        [ngClass]=\"formatStep(step, cnt).cssClass\"\n        matListItemIcon\n        svgIcon=\"{{ formatStep(step, cnt).image }}\"\n      >\n      </mat-icon>\n\n      <span class=\"igo-step-text\">\n        {{ cnt + 1 }}. {{ formatStep(step, cnt).instruction }}\n      </span>\n      <span matListItemMeta>\n        {{ formatDistance(step.distance) }}\n      </span>\n    </mat-list-item>\n\n    <mat-divider></mat-divider>\n  </mat-list>\n</div>\n", styles: [".igo-input-container{width:100%;padding:20px 10px;box-sizing:border-box}.igo-input-container mat-form-field{width:70%}.igo-route-title{font-weight:700}.igo-steps{cursor:pointer;padding:35px 0}.igo-steps .igo-step-text{overflow-wrap:break-word;word-wrap:break-word;white-space:pre-wrap}.mat-mdc-list-item{word-wrap:break-word!important;white-space:pre-wrap!important}.rotate-90{transform:rotate(90deg)}.rotate-45{transform:rotate(45deg)}.rotate-270{transform:rotate(270deg)}.rotate-250{transform:rotate(250deg)}.rotate-290{transform:rotate(290deg)}.icon-flipped{transform:scaleY(-1)}\n"] }]
        }], ctorParameters: function () { return [{ type: i2.LanguageService }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { routesFeatureStore: [{
                type: Input
            }], stepFeatureStore: [{
                type: Input
            }] } });

class ZoomButtonComponent {
    map;
    color;
    get zoom() {
        return this.map.viewController.getZoom();
    }
    get minZoom() {
        return this.map.viewController.olView.getMinZoom() || 1;
    }
    get maxZoom() {
        return this.map.viewController.olView.getMaxZoom();
    }
    constructor() { }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ZoomButtonComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: ZoomButtonComponent, selector: "igo-zoom-button", inputs: { map: "map", color: "color" }, ngImport: i0, template: "<div class=\"igo-zoom-button-container\">\n  <button\n    mat-icon-button\n    [matTooltip]=\"'igo.geo.mapButtons.zoomIn' | translate: { zoom: zoom + 1 }\"\n    matTooltipPosition=\"left\"\n    [color]=\"color\"\n    [disabled]=\"zoom >= maxZoom\"\n    (click)=\"map.viewController.zoomIn()\"\n  >\n    <mat-icon svgIcon=\"plus\"></mat-icon>\n  </button>\n\n  <button\n    mat-icon-button\n    [matTooltip]=\"'igo.geo.mapButtons.zoomOut' | translate: { zoom: zoom - 1 }\"\n    matTooltipPosition=\"left\"\n    [color]=\"color\"\n    [disabled]=\"zoom <= minZoom\"\n    (click)=\"map.viewController.zoomOut()\"\n  >\n    <mat-icon svgIcon=\"minus\"></mat-icon>\n  </button>\n</div>\n", styles: [":host button{border-radius:0!important}:host button .mat-ripple,:host button .mdc-icon-button__ripple{border-radius:0!important}:host .igo-zoom-button-container{width:40px}:host .igo-zoom-button-container button{background-color:#fff}:host .igo-zoom-button-container button:hover{background-color:#efefef}:host .igo-zoom-button-container button:first-child{margin-bottom:2px}\n"], dependencies: [{ kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ZoomButtonComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-zoom-button', template: "<div class=\"igo-zoom-button-container\">\n  <button\n    mat-icon-button\n    [matTooltip]=\"'igo.geo.mapButtons.zoomIn' | translate: { zoom: zoom + 1 }\"\n    matTooltipPosition=\"left\"\n    [color]=\"color\"\n    [disabled]=\"zoom >= maxZoom\"\n    (click)=\"map.viewController.zoomIn()\"\n  >\n    <mat-icon svgIcon=\"plus\"></mat-icon>\n  </button>\n\n  <button\n    mat-icon-button\n    [matTooltip]=\"'igo.geo.mapButtons.zoomOut' | translate: { zoom: zoom - 1 }\"\n    matTooltipPosition=\"left\"\n    [color]=\"color\"\n    [disabled]=\"zoom <= minZoom\"\n    (click)=\"map.viewController.zoomOut()\"\n  >\n    <mat-icon svgIcon=\"minus\"></mat-icon>\n  </button>\n</div>\n", styles: [":host button{border-radius:0!important}:host button .mat-ripple,:host button .mdc-icon-button__ripple{border-radius:0!important}:host .igo-zoom-button-container{width:40px}:host .igo-zoom-button-container button{background-color:#fff}:host .igo-zoom-button-container button:hover{background-color:#efefef}:host .igo-zoom-button-container button:first-child{margin-bottom:2px}\n"] }]
        }], ctorParameters: function () { return []; }, propDecorators: { map: [{
                type: Input
            }], color: [{
                type: Input
            }] } });

class MenuButtonComponent {
    configService;
    get sidenavOpened() {
        return this._sidenavOpenend;
    }
    set sidenavOpened(value) {
        this._sidenavOpenend = value;
        this.getClassMenuButton();
    }
    _sidenavOpenend;
    openSidenav = new EventEmitter();
    useThemeColor;
    menuButtonClass;
    constructor(configService) {
        this.configService = configService;
        const configValue = this.configService.getConfig('menu.button.useThemeColor');
        this.useThemeColor = configValue !== undefined ? configValue : false;
    }
    getClassMenuButton() {
        this.menuButtonClass = {
            'menu-button-white-background': !this.useThemeColor
        };
    }
    onToggleSidenavClick() {
        this.openSidenav.emit();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: MenuButtonComponent, deps: [{ token: i2.ConfigService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: MenuButtonComponent, selector: "igo-menu-button", inputs: { sidenavOpened: "sidenavOpened" }, outputs: { openSidenav: "openSidenav" }, ngImport: i0, template: "<button\n  mat-icon-button\n  id=\"menu-button\"\n  [ngClass]=\"menuButtonClass\"\n  tooltip-position=\"below\"\n  matTooltipShowDelay=\"500\"\n  [matTooltip]=\"(sidenavOpened ? 'menu.close' : 'menu.open') | translate\"\n  (click)=\"onToggleSidenavClick()\"\n>\n  <mat-icon svgIcon=\"menu\"></mat-icon>\n</button>\n", styles: [":host button{border-radius:0!important}:host button .mat-ripple,:host button .mdc-icon-button__ripple{border-radius:0!important}\n"], dependencies: [{ kind: "directive", type: i2$2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: MenuButtonComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-menu-button', template: "<button\n  mat-icon-button\n  id=\"menu-button\"\n  [ngClass]=\"menuButtonClass\"\n  tooltip-position=\"below\"\n  matTooltipShowDelay=\"500\"\n  [matTooltip]=\"(sidenavOpened ? 'menu.close' : 'menu.open') | translate\"\n  (click)=\"onToggleSidenavClick()\"\n>\n  <mat-icon svgIcon=\"menu\"></mat-icon>\n</button>\n", styles: [":host button{border-radius:0!important}:host button .mat-ripple,:host button .mdc-icon-button__ripple{border-radius:0!important}\n"] }]
        }], ctorParameters: function () { return [{ type: i2.ConfigService }]; }, propDecorators: { sidenavOpened: [{
                type: Input
            }], openSidenav: [{
                type: Output
            }] } });

class GeolocateButtonComponent {
    configService;
    tracking$$;
    icon$ = new BehaviorSubject('crosshairs-gps');
    get map() {
        return this._map;
    }
    set map(value) {
        this._map = value;
    }
    _map;
    get color() {
        return this._color;
    }
    set color(value) {
        this._color = value;
    }
    _color;
    constructor(configService) {
        this.configService = configService;
    }
    ngAfterContentInit() {
        this.map.ol.once('rendercomplete', () => {
            this.tracking$$ = this.map.geolocationController.tracking$.subscribe((tracking) => {
                if (tracking) {
                    this.icon$.next('crosshairs-gps');
                }
                else {
                    this.configService.getConfig('geolocate.basic')
                        ? this.icon$.next('crosshairs-gps')
                        : this.icon$.next('crosshairs');
                }
            });
        });
    }
    ngOnDestroy() {
        if (this.tracking$$) {
            this.tracking$$.unsubscribe();
        }
    }
    onGeolocationClick() {
        const tracking = this.map.geolocationController.tracking;
        this.map.geolocationController.tracking = tracking ? false : true;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GeolocateButtonComponent, deps: [{ token: i2.ConfigService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: GeolocateButtonComponent, selector: "igo-geolocate-button", inputs: { map: "map", color: "color" }, ngImport: i0, template: "<div class=\"igo-geolocate-button-container\" *ngIf=\"map.geolocationController\">\n  <button\n    mat-icon-button\n    [matTooltip]=\"\n      map.geolocationController.tracking\n        ? ('igo.geo.mapButtons.geolocateInactive' | translate)\n        : ('igo.geo.mapButtons.geolocate' | translate)\n    \"\n    matTooltipPosition=\"left\"\n    [color]=\"color\"\n    (click)=\"onGeolocationClick()\"\n  >\n    <mat-icon svgIcon=\"{{ icon$ | async }}\"></mat-icon>\n  </button>\n</div>\n", styles: [":host button{border-radius:0!important}:host button .mat-ripple,:host button .mdc-icon-button__ripple{border-radius:0!important}:host .igo-geolocate-button-container{width:40px;background-color:#fff}:host .igo-geolocate-button-container:hover{background-color:#efefef}\n"], dependencies: [{ kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "pipe", type: i2$2.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GeolocateButtonComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-geolocate-button', template: "<div class=\"igo-geolocate-button-container\" *ngIf=\"map.geolocationController\">\n  <button\n    mat-icon-button\n    [matTooltip]=\"\n      map.geolocationController.tracking\n        ? ('igo.geo.mapButtons.geolocateInactive' | translate)\n        : ('igo.geo.mapButtons.geolocate' | translate)\n    \"\n    matTooltipPosition=\"left\"\n    [color]=\"color\"\n    (click)=\"onGeolocationClick()\"\n  >\n    <mat-icon svgIcon=\"{{ icon$ | async }}\"></mat-icon>\n  </button>\n</div>\n", styles: [":host button{border-radius:0!important}:host button .mat-ripple,:host button .mdc-icon-button__ripple{border-radius:0!important}:host .igo-geolocate-button-container{width:40px;background-color:#fff}:host .igo-geolocate-button-container:hover{background-color:#efefef}\n"] }]
        }], ctorParameters: function () { return [{ type: i2.ConfigService }]; }, propDecorators: { map: [{
                type: Input
            }], color: [{
                type: Input
            }] } });

/*
Button to center the map to the home extent
*/
class HomeExtentButtonComponent {
    configService;
    map;
    color;
    extentOverride;
    centerOverride;
    zoomOverride;
    homeExtentButtonExtent;
    homeExtentButtonCenter;
    homeExtentButtonZoom;
    constructor(configService) {
        this.configService = configService;
        this.computeHomeExtent();
    }
    computeHomeExtent() {
        const homeExtentButtonOptions = this.configService.getConfig('homeExtentButton');
        this.homeExtentButtonExtent =
            this.extentOverride || homeExtentButtonOptions?.homeExtButtonExtent;
        this.homeExtentButtonCenter =
            this.centerOverride || homeExtentButtonOptions?.homeExtButtonCenter;
        this.homeExtentButtonZoom =
            this.zoomOverride || homeExtentButtonOptions?.homeExtButtonZoom;
        // priority over extent if these 2 properties are defined;
        if (this.centerOverride && this.zoomOverride) {
            this.homeExtentButtonExtent = undefined;
        }
    }
    onToggleClick() {
        this.computeHomeExtent();
        if (this.homeExtentButtonExtent) {
            this.map.viewController.zoomToExtent(this.homeExtentButtonExtent);
        }
        else if (this.homeExtentButtonCenter && this.homeExtentButtonZoom) {
            const center = olproj.fromLonLat(this.homeExtentButtonCenter, this.map.viewController.olView.getProjection().getCode());
            this.map.viewController.olView.setCenter(center);
            this.map.viewController.zoomTo(this.homeExtentButtonZoom);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: HomeExtentButtonComponent, deps: [{ token: i2.ConfigService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: HomeExtentButtonComponent, selector: "igo-home-extent-button", inputs: { map: "map", color: "color", extentOverride: "extentOverride", centerOverride: "centerOverride", zoomOverride: "zoomOverride" }, ngImport: i0, template: "<div class=\"igo-home-extent-button-container\">\n  <button\n    mat-icon-button\n    [matTooltip]=\"'igo.geo.mapButtons.home-extent' | translate\"\n    matTooltipPosition=\"left\"\n    [color]=\"color\"\n    (click)=\"onToggleClick()\"\n  >\n    <mat-icon svgIcon=\"home-map-marker\"></mat-icon>\n  </button>\n</div>\n", styles: [":host button{border-radius:0!important}:host button .mat-ripple,:host button .mdc-icon-button__ripple{border-radius:0!important}:host .igo-home-extent-button-container{width:40px;background-color:#fff}:host .igo-home-extent-button-container:hover{background-color:#efefef}\n"], dependencies: [{ kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: HomeExtentButtonComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-home-extent-button', template: "<div class=\"igo-home-extent-button-container\">\n  <button\n    mat-icon-button\n    [matTooltip]=\"'igo.geo.mapButtons.home-extent' | translate\"\n    matTooltipPosition=\"left\"\n    [color]=\"color\"\n    (click)=\"onToggleClick()\"\n  >\n    <mat-icon svgIcon=\"home-map-marker\"></mat-icon>\n  </button>\n</div>\n", styles: [":host button{border-radius:0!important}:host button .mat-ripple,:host button .mdc-icon-button__ripple{border-radius:0!important}:host .igo-home-extent-button-container{width:40px;background-color:#fff}:host .igo-home-extent-button-container:hover{background-color:#efefef}\n"] }]
        }], ctorParameters: function () { return [{ type: i2.ConfigService }]; }, propDecorators: { map: [{
                type: Input
            }], color: [{
                type: Input
            }], extentOverride: [{
                type: Input
            }], centerOverride: [{
                type: Input
            }], zoomOverride: [{
                type: Input
            }] } });

class OfflineButtonComponent {
    btnStyle = 'onlineStyle';
    map;
    color;
    enabled = false;
    constructor() { }
    ngOnInit() {
        this.map.forcedOffline$.next(this.enabled);
    }
    onClick() {
        this.enabled = !this.enabled;
        this.handleButtonStyle();
        this.map.forcedOffline$.next(this.enabled);
    }
    handleButtonStyle() {
        if (this.enabled) {
            this.btnStyle = 'offlineStyle';
        }
        else {
            this.btnStyle = 'onlineStyle';
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OfflineButtonComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: OfflineButtonComponent, selector: "igo-offline-button", inputs: { map: "map", color: "color", enabled: "enabled" }, ngImport: i0, template: "<div class=\"igo-user-button-container\">\n  <button\n    mat-icon-button\n    [matTooltip]=\"\n      enabled\n        ? ('igo.geo.mapButtons.online' | translate)\n        : ('igo.geo.mapButtons.offline' | translate)\n    \"\n    matTooltipPosition=\"left\"\n    [ngClass]=\"[btnStyle]\"\n    [color]=\"enabled ? color : null\"\n    (click)=\"onClick()\"\n  >\n    <mat-icon svgIcon=\"wifi-strength-off\"></mat-icon>\n  </button>\n</div>\n", styles: [":host button{border-radius:0!important}:host button .mat-ripple,:host button .mdc-icon-button__ripple{border-radius:0!important}:host .onlineStyle{width:40px;background-color:#fff}:host .onlineStyle:hover{background-color:#efefef}:host .offlineStyle{width:40px;background-color:#b9b9b9}\n"], dependencies: [{ kind: "directive", type: i2$2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OfflineButtonComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-offline-button', template: "<div class=\"igo-user-button-container\">\n  <button\n    mat-icon-button\n    [matTooltip]=\"\n      enabled\n        ? ('igo.geo.mapButtons.online' | translate)\n        : ('igo.geo.mapButtons.offline' | translate)\n    \"\n    matTooltipPosition=\"left\"\n    [ngClass]=\"[btnStyle]\"\n    [color]=\"enabled ? color : null\"\n    (click)=\"onClick()\"\n  >\n    <mat-icon svgIcon=\"wifi-strength-off\"></mat-icon>\n  </button>\n</div>\n", styles: [":host button{border-radius:0!important}:host button .mat-ripple,:host button .mdc-icon-button__ripple{border-radius:0!important}:host .onlineStyle{width:40px;background-color:#fff}:host .onlineStyle:hover{background-color:#efefef}:host .offlineStyle{width:40px;background-color:#b9b9b9}\n"] }]
        }], ctorParameters: function () { return []; }, propDecorators: { map: [{
                type: Input
            }], color: [{
                type: Input
            }], enabled: [{
                type: Input
            }] } });

/**
 * Prevent display sleep and enable wake lock in all Android and iOS web browsers.
 * On iOS, the Wake Lock API is not supported
 * https://developer.mozilla.org/en-US/docs/Web/API/Screen_Wake_Lock_API
 * On not supported browser, a fake video is used to keep the screen open.
 *
 * TODO: When the API will be supported by every browser, We should remove the NoSleep.js dependency
 * and replace it by a WakeLock API implementation.
 */
class WakeLockButtonComponent {
    storageService;
    color = 'primary';
    get enabled() {
        return this.storageService.get('wakeLockEnabled');
    }
    set enabled(value) {
        this.storageService.set('wakeLockEnabled', value);
    }
    noSleep;
    icon$ = new BehaviorSubject('sleep');
    visible = false;
    constructor(storageService) {
        this.storageService = storageService;
        this.noSleep = new NoSleep();
        const nonWakeLockApiBrowser = userAgent.satisfies({
            ie: '>0',
            edge: '<84',
            chrome: '<84',
            firefox: '>0',
            opera: '<70',
            safari: '>0'
        });
        if (nonWakeLockApiBrowser) {
            this.disableWakeLock();
            this.enabled = false;
            window.addEventListener('blur', () => {
                this.disableWakeLock();
                this.enabled = false;
            });
        }
        this.enabled ? this.enableWakeLock() : this.disableWakeLock();
    }
    /**
     * Prevent display sleep and enable wake lock in all Android and iOS web browsers.
     * On iOS, the Wake Lock API is not supported
     * https://developer.mozilla.org/en-US/docs/Web/API/Screen_Wake_Lock_API
     * On not supported browser, a fake video is used to keep the screen open.
     */
    enableWakeLock() {
        this.noSleep.enable();
        this.enabled = true;
        this.icon$.next('sleep-off');
    }
    /**
     * Let display sleep
     */
    disableWakeLock() {
        this.noSleep.disable();
        this.enabled = false;
        this.icon$.next('sleep');
    }
    toggleWakeLock() {
        if (this.enabled) {
            this.disableWakeLock();
        }
        else {
            this.enableWakeLock();
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: WakeLockButtonComponent, deps: [{ token: i2.StorageService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: WakeLockButtonComponent, selector: "igo-wake-lock-button", inputs: { color: "color", enabled: "enabled" }, ngImport: i0, template: "<div class=\"igo-wake-lock-button-container\">\n  <button\n    [color]=\"color\"\n    mat-icon-button\n    [matTooltip]=\"\n      enabled\n        ? ('igo.geo.mapButtons.preventScreenLock' | translate)\n        : ('igo.geo.mapButtons.letScreenLock' | translate)\n    \"\n    matTooltipPosition=\"left\"\n    (click)=\"toggleWakeLock()\"\n  >\n    <mat-icon svgIcon=\"{{ icon$ | async }}\"></mat-icon>\n  </button>\n</div>\n", styles: [":host button{border-radius:0!important}:host button .mat-ripple,:host button .mdc-icon-button__ripple{border-radius:0!important}:host .igo-wake-lock-button-container{width:40px;background-color:#fff}:host .igo-wake-lock-button-container:hover{background-color:#efefef}\n"], dependencies: [{ kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "pipe", type: i2$2.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: WakeLockButtonComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-wake-lock-button', template: "<div class=\"igo-wake-lock-button-container\">\n  <button\n    [color]=\"color\"\n    mat-icon-button\n    [matTooltip]=\"\n      enabled\n        ? ('igo.geo.mapButtons.preventScreenLock' | translate)\n        : ('igo.geo.mapButtons.letScreenLock' | translate)\n    \"\n    matTooltipPosition=\"left\"\n    (click)=\"toggleWakeLock()\"\n  >\n    <mat-icon svgIcon=\"{{ icon$ | async }}\"></mat-icon>\n  </button>\n</div>\n", styles: [":host button{border-radius:0!important}:host button .mat-ripple,:host button .mdc-icon-button__ripple{border-radius:0!important}:host .igo-wake-lock-button-container{width:40px;background-color:#fff}:host .igo-wake-lock-button-container:hover{background-color:#efefef}\n"] }]
        }], ctorParameters: function () { return [{ type: i2.StorageService }]; }, propDecorators: { color: [{
                type: Input
            }], enabled: [{
                type: Input
            }] } });

function baseLayersSwitcherSlideInOut() {
    return trigger('baseLayerSwitcherState', [
        state('collapseIcon', style({
            height: '40px',
            width: '40px',
            overflow: 'hidden'
        })),
        state('collapseMap', style({
            height: '80px',
            overflow: 'hidden'
        })),
        state('expand', style({
            overflow: 'hidden'
        })),
        transition('collapse => expand', animate('200ms')),
        transition('expand => collapse', animate('200ms'))
    ]);
}

const LAYER = 'Layer';

class MiniBaseMapComponent {
    layerService;
    appRef;
    map;
    disabled;
    title;
    get display() {
        return this._display;
    }
    set display(value) {
        this._display = value;
        this.basemap.ol.getView().changed();
    }
    _display;
    get baseLayer() {
        return this._baseLayer;
    }
    set baseLayer(value) {
        this._baseLayer = value;
        this.handleBaseLayerChanged(value);
    }
    _baseLayer;
    basemap = new IgoMap({
        controls: {},
        interactions: false
    });
    constructor(layerService, appRef) {
        this.layerService = layerService;
        this.appRef = appRef;
    }
    ngAfterViewInit() {
        this.handleMainMapViewChange(this.map.ol.getView());
        this.map.viewController.olView.on('change', (change) => {
            this.handleMainMapViewChange(change.target);
        });
        this.map.ol.on('pointerdrag', (change) => {
            this.handleMainMapViewChange(change.target.getView());
        });
    }
    ngOnDestroy() {
        this.map.viewController.olView.un('change', (change) => {
            this.handleMainMapViewChange(change.target);
        });
        this.map.ol.un('pointerdrag', (change) => {
            this.handleMainMapViewChange(change.target.getView());
        });
    }
    changeBaseLayer(baseLayer) {
        if (this.disabled) {
            return;
        }
        this.map.changeBaseLayer(baseLayer);
        this.appRef.tick();
    }
    handleMainMapViewChange(mainMapView) {
        const mainMapViewProperties = mainMapView.getProperties();
        this.basemap.viewController.olView.setResolution(mainMapViewProperties.resolution);
        this.basemap.viewController.olView.setRotation(mainMapViewProperties.rotation);
        this.basemap.viewController.olView.setCenter(this.map.viewController.getCenter());
    }
    handleBaseLayerChanged(baselayer) {
        this.basemap.removeAllLayers();
        const options = Object.assign(Object.create(baselayer.options), baselayer.options, {
            visible: true,
            baseLayer: false
        });
        const layer = this.layerService.createLayer(options);
        this.basemap.addLayer(layer);
        this.handleLinkedBaseLayer(layer);
    }
    handleLinkedBaseLayer(baselayer) {
        const linkedLayers = baselayer.options.linkedLayers;
        if (!linkedLayers) {
            return;
        }
        const links = linkedLayers.links;
        const isParentLayer = links ? true : false;
        if (isParentLayer) {
            // search for child layers
            links.map((link) => {
                link.linkedIds.map((linkedId) => {
                    const layerToApply = this.map.layers.find((layer) => layer.options.linkedLayers?.linkId === linkedId);
                    if (layerToApply) {
                        const linkedLayerOptions = Object.assign(Object.create(layerToApply.options), layerToApply.options, {
                            zIndex: 9000,
                            visible: layerToApply.options.linkedLayers?.showInMiniBaseMap ?? true,
                            baseLayer: false
                        });
                        this.basemap.addLayer(this.layerService.createLayer(linkedLayerOptions));
                    }
                });
            });
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: MiniBaseMapComponent, deps: [{ token: LayerService }, { token: i0.ApplicationRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: MiniBaseMapComponent, selector: "igo-mini-basemap", inputs: { map: "map", disabled: "disabled", title: "title", display: "display", baseLayer: "baseLayer" }, ngImport: i0, template: "<div class=\"igo-mini-basemap-container\">\n  <div *ngIf=\"display\" (click)=\"changeBaseLayer(baseLayer)\">\n    <igo-map-browser [map]=\"basemap\"></igo-map-browser>\n    <div *ngIf=\"title\" class=\"igo-mini-basemap-title\">{{ title }}</div>\n  </div>\n</div>\n", styles: [".igo-mini-basemap-container{width:80px;height:80px;background-color:#ffffff03;border:2px solid white;box-shadow:0 1px 4px #0000004d;cursor:pointer}.igo-mini-basemap-container:hover .igo-mini-basemap-title{color:#000;text-shadow:0 0 5px white}.igo-mini-basemap-container>div{width:100%;height:100%}.igo-mini-basemap-title{position:relative;top:-76px;height:76px;width:76px;text-align:center;vertical-align:bottom;color:#fff;text-shadow:0 0 5px black;white-space:normal;display:flex;align-items:flex-end;justify-content:center}\n"], dependencies: [{ kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: MapBrowserComponent, selector: "igo-map-browser", inputs: ["map", "view"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: MiniBaseMapComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-mini-basemap', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div class=\"igo-mini-basemap-container\">\n  <div *ngIf=\"display\" (click)=\"changeBaseLayer(baseLayer)\">\n    <igo-map-browser [map]=\"basemap\"></igo-map-browser>\n    <div *ngIf=\"title\" class=\"igo-mini-basemap-title\">{{ title }}</div>\n  </div>\n</div>\n", styles: [".igo-mini-basemap-container{width:80px;height:80px;background-color:#ffffff03;border:2px solid white;box-shadow:0 1px 4px #0000004d;cursor:pointer}.igo-mini-basemap-container:hover .igo-mini-basemap-title{color:#000;text-shadow:0 0 5px white}.igo-mini-basemap-container>div{width:100%;height:100%}.igo-mini-basemap-title{position:relative;top:-76px;height:76px;width:76px;text-align:center;vertical-align:bottom;color:#fff;text-shadow:0 0 5px black;white-space:normal;display:flex;align-items:flex-end;justify-content:center}\n"] }]
        }], ctorParameters: function () { return [{ type: LayerService }, { type: i0.ApplicationRef }]; }, propDecorators: { map: [{
                type: Input
            }], disabled: [{
                type: Input
            }], title: [{
                type: Input
            }], display: [{
                type: Input
            }], baseLayer: [{
                type: Input
            }] } });

class BaseLayersSwitcherComponent {
    mediaService;
    map;
    useStaticIcon;
    _baseLayers = [];
    expand = true;
    showButton = true;
    layers$$;
    get hasMoreThanTwo() {
        return this.baseLayers.length > 1;
    }
    constructor(mediaService) {
        this.mediaService = mediaService;
        const media = this.mediaService.media$.value;
        if (media === Media.Mobile && this.useStaticIcon === undefined) {
            this.useStaticIcon = true;
        }
    }
    ngAfterViewInit() {
        this.layers$$ = this.map.layers$.subscribe((arrayLayers) => {
            this._baseLayers = arrayLayers.filter((l) => l.baseLayer);
        });
    }
    ngOnDestroy() {
        this.layers$$.unsubscribe();
    }
    collapseOrExpand() {
        if (this.hasMoreThanTwo || this.useStaticIcon) {
            this.expand = !this.expand;
        }
        else {
            this.expand = false;
        }
    }
    get baseLayers() {
        const mapResolution = this.map.viewController.getResolution();
        const mapZoom = this.map.viewController.getZoom();
        const bl = this._baseLayers.filter((l) => {
            return ((!l.options.maxResolution ||
                mapResolution <= l.options.maxResolution) &&
                (!l.options.minResolution ||
                    mapResolution >= l.options.minResolution) &&
                (!l.options.source.options.maxZoom ||
                    mapZoom <= l.options.source.options.maxZoom) &&
                (!l.options.source.options.minZoom ||
                    mapZoom >= l.options.source.options.minZoom));
        });
        const blHidden = bl.filter((l) => !l.visible);
        return blHidden.length + 1 === bl.length ? blHidden : bl;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BaseLayersSwitcherComponent, deps: [{ token: i2.MediaService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: BaseLayersSwitcherComponent, selector: "igo-baselayers-switcher", inputs: { map: "map", useStaticIcon: "useStaticIcon" }, ngImport: i0, template: "<div\r\n  *ngIf=\"baseLayers.length > 0\"\r\n  class=\"igo-baselayers-switcher-container\"\r\n  [ngClass]=\"{ 'container-expand': expand }\"\r\n  [@baseLayerSwitcherState]=\"\r\n    expand ? 'expand' : useStaticIcon ? 'collapseIcon' : 'collapseMap'\r\n  \"\r\n  (@baseLayerSwitcherState.start)=\"showButton = false\"\r\n  (@baseLayerSwitcherState.done)=\"showButton = true\"\r\n  (click)=\"collapseOrExpand()\"\r\n>\r\n  <div\r\n    *ngIf=\"useStaticIcon && !expand && showButton\"\r\n    class=\"igo-baselayers-switcher-button-container\"\r\n  >\r\n    <button\r\n      mat-icon-button\r\n      [matTooltip]=\"'igo.geo.mapButtons.baselayerSwitcher' | translate\"\r\n      matTooltipPosition=\"right\"\r\n      color=\"primary\"\r\n    >\r\n      <mat-icon svgIcon=\"image-multiple\"></mat-icon>\r\n    </button>\r\n  </div>\r\n\r\n  <div class=\"basemap-list\">\r\n    <igo-mini-basemap\r\n      *ngFor=\"let baseLayer of baseLayers; let i = index\"\r\n      [map]=\"map\"\r\n      [baseLayer]=\"baseLayer\"\r\n      [title]=\"\r\n        baseLayers.length > 2 && !expand\r\n          ? ('igo.geo.baselayersSwitcher.title' | translate)\r\n          : baseLayer.title\r\n      \"\r\n      [display]=\"expand || (i === 0 && !useStaticIcon)\"\r\n      [disabled]=\"!expand && baseLayers.length > 1\"\r\n    >\r\n    </igo-mini-basemap>\r\n  </div>\r\n\r\n  <div *ngIf=\"hasMoreThanTwo\" class=\"more-baselayers\">\r\n    <mat-icon\r\n      class=\"material-icons mat-icon\"\r\n      color=\"primary\"\r\n      svgIcon=\"menu-down\"\r\n    ></mat-icon>\r\n  </div>\r\n</div>\r\n", styles: [":host button{border-radius:0!important}:host button .mat-ripple,:host button .mdc-icon-button__ripple{border-radius:0!important}.basemap-list igo-mini-basemap{display:block}.basemap-list igo-mini-basemap:not(:first-child){margin-top:4px}.igo-baselayers-switcher-container{height:auto;position:relative}.container-expand{overflow:hidden;border-width:0}.more-baselayers{width:80px;height:20px;background-color:#fff;text-align:center;cursor:pointer}.more-baselayers:hover{background-color:#efefef}.igo-baselayers-switcher-button-container{width:40px;background-color:#fff}.igo-baselayers-switcher-button-container:hover{background-color:#efefef}\n"], dependencies: [{ kind: "directive", type: i2$2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "component", type: MiniBaseMapComponent, selector: "igo-mini-basemap", inputs: ["map", "disabled", "title", "display", "baseLayer"] }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }], animations: [baseLayersSwitcherSlideInOut()] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BaseLayersSwitcherComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-baselayers-switcher', animations: [baseLayersSwitcherSlideInOut()], template: "<div\r\n  *ngIf=\"baseLayers.length > 0\"\r\n  class=\"igo-baselayers-switcher-container\"\r\n  [ngClass]=\"{ 'container-expand': expand }\"\r\n  [@baseLayerSwitcherState]=\"\r\n    expand ? 'expand' : useStaticIcon ? 'collapseIcon' : 'collapseMap'\r\n  \"\r\n  (@baseLayerSwitcherState.start)=\"showButton = false\"\r\n  (@baseLayerSwitcherState.done)=\"showButton = true\"\r\n  (click)=\"collapseOrExpand()\"\r\n>\r\n  <div\r\n    *ngIf=\"useStaticIcon && !expand && showButton\"\r\n    class=\"igo-baselayers-switcher-button-container\"\r\n  >\r\n    <button\r\n      mat-icon-button\r\n      [matTooltip]=\"'igo.geo.mapButtons.baselayerSwitcher' | translate\"\r\n      matTooltipPosition=\"right\"\r\n      color=\"primary\"\r\n    >\r\n      <mat-icon svgIcon=\"image-multiple\"></mat-icon>\r\n    </button>\r\n  </div>\r\n\r\n  <div class=\"basemap-list\">\r\n    <igo-mini-basemap\r\n      *ngFor=\"let baseLayer of baseLayers; let i = index\"\r\n      [map]=\"map\"\r\n      [baseLayer]=\"baseLayer\"\r\n      [title]=\"\r\n        baseLayers.length > 2 && !expand\r\n          ? ('igo.geo.baselayersSwitcher.title' | translate)\r\n          : baseLayer.title\r\n      \"\r\n      [display]=\"expand || (i === 0 && !useStaticIcon)\"\r\n      [disabled]=\"!expand && baseLayers.length > 1\"\r\n    >\r\n    </igo-mini-basemap>\r\n  </div>\r\n\r\n  <div *ngIf=\"hasMoreThanTwo\" class=\"more-baselayers\">\r\n    <mat-icon\r\n      class=\"material-icons mat-icon\"\r\n      color=\"primary\"\r\n      svgIcon=\"menu-down\"\r\n    ></mat-icon>\r\n  </div>\r\n</div>\r\n", styles: [":host button{border-radius:0!important}:host button .mat-ripple,:host button .mdc-icon-button__ripple{border-radius:0!important}.basemap-list igo-mini-basemap{display:block}.basemap-list igo-mini-basemap:not(:first-child){margin-top:4px}.igo-baselayers-switcher-container{height:auto;position:relative}.container-expand{overflow:hidden;border-width:0}.more-baselayers{width:80px;height:20px;background-color:#fff;text-align:center;cursor:pointer}.more-baselayers:hover{background-color:#efefef}.igo-baselayers-switcher-button-container{width:40px;background-color:#fff}.igo-baselayers-switcher-button-container:hover{background-color:#efefef}\n"] }]
        }], ctorParameters: function () { return [{ type: i2.MediaService }]; }, propDecorators: { map: [{
                type: Input
            }], useStaticIcon: [{
                type: Input
            }] } });

class RotationButtonComponent {
    rotated$ = new BehaviorSubject(false);
    azimuthRounded = 0;
    rotationRounded = 0;
    currentStyle$ = new BehaviorSubject({
        transform: 'rotate(0rad)'
    });
    map;
    showIfNoRotation;
    color;
    constructor() { }
    ngAfterContentInit() {
        this.map.viewController.rotation$.subscribe((r) => {
            const radians = r || 0;
            const deg = (radians * 180) / Math.PI;
            this.rotationRounded = Math.round(deg);
            this.azimuthRounded = Math.round(bearingToAzimuth(deg * -1));
            this.currentStyle$.next({
                transform: 'rotate(' + radians + 'rad)'
            });
            this.rotated$.next(radians !== 0);
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: RotationButtonComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: RotationButtonComponent, selector: "igo-rotation-button", inputs: { map: "map", showIfNoRotation: "showIfNoRotation", color: "color" }, ngImport: i0, template: "<div\n  *ngIf=\"((rotated$ | async) && !showIfNoRotation) || showIfNoRotation\"\n  class=\"igo-rotation-button-container\"\n  [matTooltip]=\"\n    (rotated$ | async)\n      ? ('igo.geo.mapButtons.resetRotation'\n        | translate: { azimuth: azimuthRounded, rotation: rotationRounded })\n      : ('igo.geo.mapButtons.tipRotation' | translate)\n  \"\n  matTooltipPosition=\"left\"\n>\n  <button\n    mat-icon-button\n    matTooltipPosition=\"left\"\n    [color]=\"color\"\n    [disabled]=\"(rotated$ | async) === false\"\n    (click)=\"map.viewController.resetRotation()\"\n  >\n    <mat-icon [ngStyle]=\"currentStyle$ | async\" svgIcon=\"navigation\">\n    </mat-icon>\n  </button>\n</div>\n", styles: [":host button{border-radius:0!important}:host button .mat-ripple,:host button .mdc-icon-button__ripple{border-radius:0!important}:host .igo-rotation-button-container{width:40px;background-color:#fff}:host .igo-rotation-button-container:hover{background-color:#efefef}\n"], dependencies: [{ kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2$2.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "pipe", type: i2$2.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: RotationButtonComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-rotation-button', template: "<div\n  *ngIf=\"((rotated$ | async) && !showIfNoRotation) || showIfNoRotation\"\n  class=\"igo-rotation-button-container\"\n  [matTooltip]=\"\n    (rotated$ | async)\n      ? ('igo.geo.mapButtons.resetRotation'\n        | translate: { azimuth: azimuthRounded, rotation: rotationRounded })\n      : ('igo.geo.mapButtons.tipRotation' | translate)\n  \"\n  matTooltipPosition=\"left\"\n>\n  <button\n    mat-icon-button\n    matTooltipPosition=\"left\"\n    [color]=\"color\"\n    [disabled]=\"(rotated$ | async) === false\"\n    (click)=\"map.viewController.resetRotation()\"\n  >\n    <mat-icon [ngStyle]=\"currentStyle$ | async\" svgIcon=\"navigation\">\n    </mat-icon>\n  </button>\n</div>\n", styles: [":host button{border-radius:0!important}:host button .mat-ripple,:host button .mdc-icon-button__ripple{border-radius:0!important}:host .igo-rotation-button-container{width:40px;background-color:#fff}:host .igo-rotation-button-container:hover{background-color:#efefef}\n"] }]
        }], ctorParameters: function () { return []; }, propDecorators: { map: [{
                type: Input
            }], showIfNoRotation: [{
                type: Input
            }], color: [{
                type: Input
            }] } });

/**
 * Tool to swipe the layers
 */
class SwipeControlComponent {
    /**
     * Get an active map
     */
    map;
    /**
     * The list of layers for swipe
     */
    layers;
    /**
     * Final position of the swiped element
     */
    pos1;
    /**
     * Intermediate position of the swiped element
     */
    pos3;
    /**
     * State of draggable action
     */
    inDragAction = false;
    /**
     * Listener of toggle from advanced-map-tool
     */
    swipeEnabled$$;
    /**
     * Binder of prerender on the same element
     */
    boundPrerender = this.prerender.bind(this);
    constructor() { }
    /**
     * Get the list of layers for swipe and activate of deactivate the swipe
     * @internal
     */
    ngAfterViewInit() {
        this.getListOfLayers();
        this.swipeEnabled$$ = this.map.swipeEnabled$.subscribe((value) => {
            value ? this.displaySwipe() : this.displaySwipeOff();
        });
        this.letZoom();
    }
    /**
     * Clear the overlay layer and any interaction added by this component.
     * @internal
     */
    ngOnDestroy() {
        this.swipeEnabled$$.unsubscribe();
        this.map.swipeEnabled$.unsubscribe();
        this.displaySwipeOff();
    }
    /**
     * Display a swipe-element and render the layers
     */
    displaySwipe() {
        if (this.swipeId) {
            this.swipeId.style.visibility = 'visible';
        }
        this.layers.map((layer) => layer.ol.on('prerender', this.boundPrerender));
        this.layers.map((layer) => layer.ol.on('postrender', this.postrender));
        this.map.ol.render();
    }
    /**
     * Clear a swipe-element and render the layers on the initial state
     */
    displaySwipeOff() {
        if (this.swipeId) {
            this.swipeId.style.visibility = 'hidden';
        }
        this.layers.map((layer) => layer.ol.un('prerender', this.boundPrerender));
        this.layers.map((layer) => layer.ol.un('postrender', this.postrender));
        this.map.ol.render();
        this.layers = [];
    }
    /**
     * Getter of element
     */
    get swipeId() {
        return document.getElementById('igo-layer-swipe');
    }
    /**
     * Get the list of layers for swipe
     */
    getListOfLayers() {
        this.map.selectedFeatures$.subscribe((layers) => {
            this.layers = [];
            if (layers !== null) {
                for (const layer of layers) {
                    if (!this.layers.includes(layer)) {
                        this.layers.push(layer);
                    }
                }
            }
        });
    }
    /**
     * Get a position of click or touch
     */
    dragDown(event) {
        this.inDragAction = true;
        event.preventDefault();
        if (event.type === 'mousedown') {
            this.pos3 = event.clientX;
            this.mouseSwipe();
            document.onmouseup = this.closeDragMouseElement;
        }
        else if (event.type === 'touchstart') {
            document.getElementById('arrows').style.visibility = 'hidden';
            this.pos3 = event.touches[0].clientX;
            this.touchSwipe();
            document.ontouchend = this.closeDragTouchElement;
        }
    }
    /**
     * Moving a line with a mouse
     */
    mouseSwipe() {
        document.addEventListener('mousemove', (event) => {
            if (this.inDragAction) {
                event.preventDefault();
                this.pos1 = this.pos3 - event.clientX;
                this.pos3 = event.clientX;
                this.swipeId.style.left = this.swipeId.offsetLeft - this.pos1 + 'px';
            }
            this.map.ol.render();
        });
    }
    /**
     * Moving a line with a touch
     */
    touchSwipe() {
        document.addEventListener('touchmove', (event) => {
            if (this.inDragAction) {
                event.preventDefault();
                document.getElementById('arrows').style.visibility = 'hidden';
                this.pos1 = this.pos3 - event.changedTouches[0].clientX;
                this.pos3 = event.changedTouches[0].clientX;
                this.swipeId.style.left = this.swipeId.offsetLeft - this.pos1 + 'px';
            }
            this.map.ol.render();
        });
    }
    /**
     * Deactivate a listener of a mouse-action
     */
    closeDragMouseElement() {
        document.onmouseup = null;
        document.onmousemove = null;
        this.inDragAction = false;
    }
    /**
     * Deactivate a listener of a touch-action
     */
    closeDragTouchElement() {
        document.ontouchend = null;
        document.ontouchmove = null;
        document.getElementById('arrows').style.visibility = 'visible';
        this.inDragAction = false;
    }
    /**
     * Cut the image of a layer by the position of swiped-element
     */
    prerender(event) {
        const ctx = event.context;
        const mapSize = this.map.ol.getSize();
        const width = this.swipeId.offsetLeft;
        const tl = getRenderPixel(event, [width, 0]);
        const tr = getRenderPixel(event, [0, 0]);
        const bl = getRenderPixel(event, [width, mapSize[1]]);
        const br = getRenderPixel(event, [0, mapSize[1]]);
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(tl[0], tl[1]);
        ctx.lineTo(bl[0], bl[1]);
        ctx.lineTo(br[0], br[1]);
        ctx.lineTo(tr[0], tr[1]);
        ctx.closePath();
        ctx.clip();
    }
    /**
     * Save a current state of the context
     */
    postrender(event) {
        event.context.restore();
        event.context.save();
    }
    /**
     * Zoom on div
     */
    letZoom() {
        document.getElementById('igo-layer-swipe').addEventListener('wheel', (event) => {
            event.deltaY > 0
                ? this.map.viewController.zoomOut()
                : this.map.viewController.zoomIn();
        }, true);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SwipeControlComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: SwipeControlComponent, selector: "igo-swipe-control", inputs: { map: "map" }, ngImport: i0, template: "<div\n  class=\"igo-swipe-control-container\"\n  id=\"igo-layer-swipe\"\n  (mousedown)=\"dragDown($event)\"\n  (mouseup)=\"closeDragMouseElement()\"\n  (touchstart)=\"dragDown($event)\"\n  (touchend)=\"closeDragTouchElement()\"\n>\n  <div class=\"igo-swipe-control-line\"></div>\n\n  <div class=\"igo-swipe-control-arrows\" id=\"arrows\">\n    <div class=\"igo-arrow-left\"></div>\n    <div class=\"igo-arrow-right\"></div>\n  </div>\n</div>\n", styles: [".igo-swipe-control-container{position:absolute;width:80px;height:100%;top:0%;left:50%;cursor:grab;z-index:1;transform:translate(-40px)}.igo-swipe-control-container:active{cursor:grabbing}.igo-swipe-control-line{position:absolute;width:4px;height:100%;top:50%;left:50%;transform:translate(-50%,-50%);background-color:#5e5a5a}.igo-swipe-control-arrows{position:absolute;width:32px;height:32px;left:50%;top:50%;transform:translate(-50%,-50%);margin-top:-16px;padding:5px 4px;background-color:#5e5a5a;z-index:2;-webkit-tap-highlight-color:rgba(0,0,0,0)}.igo-swipe-control-arrows div{display:inline-block;width:0;height:0;border-top:10px solid transparent;border-bottom:10px solid transparent}.igo-swipe-control-arrows .igo-arrow-right{margin-left:4px;border-left:10px solid white}.igo-swipe-control-arrows .igo-arrow-left{border-right:10px solid white}.igo-swipe-control-arrows:active{display:none}\n"] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SwipeControlComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-swipe-control', template: "<div\n  class=\"igo-swipe-control-container\"\n  id=\"igo-layer-swipe\"\n  (mousedown)=\"dragDown($event)\"\n  (mouseup)=\"closeDragMouseElement()\"\n  (touchstart)=\"dragDown($event)\"\n  (touchend)=\"closeDragTouchElement()\"\n>\n  <div class=\"igo-swipe-control-line\"></div>\n\n  <div class=\"igo-swipe-control-arrows\" id=\"arrows\">\n    <div class=\"igo-arrow-left\"></div>\n    <div class=\"igo-arrow-right\"></div>\n  </div>\n</div>\n", styles: [".igo-swipe-control-container{position:absolute;width:80px;height:100%;top:0%;left:50%;cursor:grab;z-index:1;transform:translate(-40px)}.igo-swipe-control-container:active{cursor:grabbing}.igo-swipe-control-line{position:absolute;width:4px;height:100%;top:50%;left:50%;transform:translate(-50%,-50%);background-color:#5e5a5a}.igo-swipe-control-arrows{position:absolute;width:32px;height:32px;left:50%;top:50%;transform:translate(-50%,-50%);margin-top:-16px;padding:5px 4px;background-color:#5e5a5a;z-index:2;-webkit-tap-highlight-color:rgba(0,0,0,0)}.igo-swipe-control-arrows div{display:inline-block;width:0;height:0;border-top:10px solid transparent;border-bottom:10px solid transparent}.igo-swipe-control-arrows .igo-arrow-right{margin-left:4px;border-left:10px solid white}.igo-swipe-control-arrows .igo-arrow-left{border-right:10px solid white}.igo-swipe-control-arrows:active{display:none}\n"] }]
        }], ctorParameters: function () { return []; }, propDecorators: { map: [{
                type: Input
            }] } });

/**
 * Tool to display the center of the map
 */
class MapCenterComponent {
    /**
     * Get an active map
     */
    map;
    /**
     * Listener of toggle from advanced-map-tool
     */
    displayCenter$$;
    constructor() { }
    /**
     * Set a visibility for cursor of the center of the map
     */
    ngAfterViewInit() {
        if (this.map) {
            this.displayCenter$$ = this.map.mapCenter$.subscribe((value) => {
                value
                    ? (document.getElementById('mapCenter').style.visibility = 'visible')
                    : (document.getElementById('mapCenter').style.visibility = 'hidden');
            });
        }
        this.letZoom();
    }
    /**
     * Destroyer of a component
     */
    ngOnDestroy() {
        if (this.displayCenter$$) {
            this.displayCenter$$.unsubscribe();
        }
    }
    /**
     * Zoom on div
     */
    letZoom() {
        document.getElementById('mapCenter').addEventListener('wheel', (event) => {
            event.deltaY > 0
                ? this.map.viewController.zoomOut()
                : this.map.viewController.zoomIn();
        }, true);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: MapCenterComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: MapCenterComponent, selector: "igo-map-center", inputs: { map: "map" }, ngImport: i0, template: "<div class=\"mapCenter\" id=\"mapCenter\">\n  <div class=\"vertical\"></div>\n  <div class=\"horizontal\"></div>\n</div>\n", styles: [".mapCenter{width:30px;height:30px;position:absolute;top:50%;left:50%;transform:translate(-15px,-15px);pointer-events:none}.mapCenter .vertical,.mapCenter .horizontal{width:4px;height:30px;position:absolute;left:13px;background-color:#000}.mapCenter .horizontal{transform:rotate(90deg)}\n"] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: MapCenterComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-map-center', template: "<div class=\"mapCenter\" id=\"mapCenter\">\n  <div class=\"vertical\"></div>\n  <div class=\"horizontal\"></div>\n</div>\n", styles: [".mapCenter{width:30px;height:30px;position:absolute;top:50%;left:50%;transform:translate(-15px,-15px);pointer-events:none}.mapCenter .vertical,.mapCenter .horizontal{width:4px;height:30px;position:absolute;left:13px;background-color:#000}.mapCenter .horizontal{transform:rotate(90deg)}\n"] }]
        }], ctorParameters: function () { return []; }, propDecorators: { map: [{
                type: Input
            }] } });

class InfoSectionComponent {
    infoContent = '';
    constructor() { }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: InfoSectionComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: InfoSectionComponent, selector: "igo-info-section", inputs: { infoContent: "infoContent" }, ngImport: i0, template: "<div *ngIf=\"infoContent && infoContent.length\" class=\"infoSection\">\n  <pre>{{ infoContent }}</pre>\n</div>\n", styles: [".infoSection{border-radius:10px;background-color:#6e6e6e66;padding:2.5px;position:absolute;text-align:center;top:5px;left:50%;text-shadow:0 0 5px white,0 0 10px white,0 0 15px white}@media only screen and (orientation:portrait) and (max-width: 599px),only screen and (orientation:landscape) and (max-width: 959px){.infoSection{top:50px;left:10%}}\n"], dependencies: [{ kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: InfoSectionComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-info-section', template: "<div *ngIf=\"infoContent && infoContent.length\" class=\"infoSection\">\n  <pre>{{ infoContent }}</pre>\n</div>\n", styles: [".infoSection{border-radius:10px;background-color:#6e6e6e66;padding:2.5px;position:absolute;text-align:center;top:5px;left:50%;text-shadow:0 0 5px white,0 0 10px white,0 0 15px white}@media only screen and (orientation:portrait) and (max-width: 599px),only screen and (orientation:landscape) and (max-width: 959px){.infoSection{top:50px;left:10%}}\n"] }]
        }], ctorParameters: function () { return []; }, propDecorators: { infoContent: [{
                type: Input
            }] } });

class QueryService {
    http;
    messageService;
    languageService;
    queryEnabled = true;
    defaultFeatureCount = 20; // default feature count
    featureCount = 20; // feature count
    previousMessageIds = [];
    constructor(http, messageService, languageService) {
        this.http = http;
        this.messageService = messageService;
        this.languageService = languageService;
    }
    query(layers, options) {
        if (this.previousMessageIds.length) {
            this.previousMessageIds.forEach((id) => {
                this.messageService.remove(id);
            });
        }
        const newLayers = layers
            .filter((layer) => layer.visible && layer.isInResolutionsRange)
            .map((layer) => this.queryLayer(layer, options));
        // the directive accept array in this format [observable, observable...]
        // if we use multiple 'url' in queryUrl so the result => this form [observable, observable, [observable, observable]]
        // so we need to flat the array
        let flatArray = [].concat.apply([], newLayers);
        return flatArray;
    }
    queryLayer(layer, options) {
        const url = this.getQueryUrl(layer.dataSource, options, false, layer.map.viewController.getExtent());
        if (!url) {
            return of([]);
        }
        const resolution = layer.map.viewController.getResolution();
        const scale = layer.map.viewController.getScale();
        if (layer.dataSource.options.queryFormat ===
            QueryFormat.HTMLGML2) {
            if (typeof url === 'string') {
                const urlGml = this.getQueryUrl(layer.dataSource, options, true);
                return this.http.get(urlGml, { responseType: 'text' }).pipe(mergeMap((gmlRes) => {
                    const mergedGML = this.mergeGML(gmlRes, url, layer);
                    const imposedGeom = mergedGML[0];
                    const imposedProperties = mergedGML[1];
                    return this.http
                        .get(url, { responseType: 'text' })
                        .pipe(map((res) => this.extractData(res, layer, options, url, imposedGeom, imposedProperties)));
                }));
            }
            const urlGmls = this.getQueryUrl(layer.dataSource, options, true);
            let observables = [];
            for (let i = 0; i < urlGmls.length; i++) {
                const element = urlGmls[i];
                if (this.checkScaleAndResolution(resolution, scale, element)) {
                    observables.push(this.requestDataForHTMLGML2(element.url, url[i].url, layer, options));
                }
            }
            return observables;
        }
        else {
            if (typeof url === 'string') {
                const request = this.http.get(url, { responseType: 'text' });
                return request.pipe(map((res) => this.extractData(res, layer, options, url)));
            }
            let observables = [];
            for (let i = 0; i < url.length; i++) {
                const element = url[i];
                if (this.checkScaleAndResolution(resolution, scale, element)) {
                    const request = this.http.get(element.url, { responseType: 'text' });
                    observables.push(request.pipe(map((res) => this.extractData(res, layer, options, element.url))));
                }
            }
            return observables;
        }
    }
    requestDataForHTMLGML2(urlGml, url, layer, options) {
        return this.http.get(urlGml, { responseType: 'text' }).pipe(mergeMap((gmlRes) => {
            const mergedGML = this.mergeGML(gmlRes, url, layer);
            const imposedGeom = mergedGML[0];
            const imposedProperties = mergedGML[1];
            return this.http
                .get(url, { responseType: 'text' })
                .pipe(map((res) => this.extractData(res, layer, options, url, imposedGeom, imposedProperties)));
        }));
    }
    checkScaleAndResolution(resolution, scale, element) {
        let checkScale;
        let checkResolution;
        if (!element.minResolution &&
            !element.maxResolution &&
            !element.minScale &&
            !element.maxScale) {
            return true;
        }
        else {
            /******************* checking Resolution *******************/
            if (element.minResolution && element.maxResolution) {
                // if "minResolution" and "maxResolution" exists check if resoltion is between
                if (resolution >= element.minResolution &&
                    resolution <= element.maxResolution) {
                    checkResolution = true;
                }
            }
            else {
                // check if "minResolution" or "maxResolution" exists
                if (element.minResolution && resolution >= element.minResolution) {
                    checkResolution = true;
                }
                if (element.maxResolution && resolution <= element.maxResolution) {
                    checkResolution = true;
                }
            }
            /******************* checking Scale *******************/
            if (element.minScale && element.maxScale) {
                // if "minScale" and "maxScale" exists check if scale is between
                if (scale > element.minScale && scale < element.maxScale) {
                    checkScale = true;
                }
            }
            else {
                // check if "minScale" or "maxScale" exists
                if (element.maxScale && scale <= element.maxScale) {
                    checkScale = true;
                }
                if (element.minScale && scale >= element.minScale) {
                    checkScale = true;
                }
            }
            /******************* result of checking *******************/
            if (checkScale === true && checkResolution === true) {
                return true;
            }
            else if ((checkResolution === true && !checkScale) ||
                (checkScale === true && !checkResolution)) {
                return true;
            }
            else {
                return false;
            }
        }
    }
    mergeGML(gmlRes, url, layer) {
        const parser = new olFormatGML2();
        let features = parser.readFeatures(gmlRes);
        // Handle non standard GML output (MapServer)
        if (features.length === 0) {
            const wmsParser = new olformat.WMSGetFeatureInfo();
            features = wmsParser.readFeatures(gmlRes);
        }
        const olmline = new olgeom.MultiLineString([]);
        let pts;
        const ptsArray = [];
        let olmpoly = new olgeom.MultiPolygon([]);
        let firstFeatureType;
        const nbFeatures = features.length;
        // Check if geometry intersect bbox
        // for geoserver getfeatureinfo response in data projection, not call projection
        const searchParams = this.getQueryParams(url.toLowerCase());
        const bboxRaw = searchParams.bbox;
        const bbox = bboxRaw.split(',');
        const bboxExtent = olextent.createEmpty();
        olextent.extend(bboxExtent, bbox);
        const outBboxExtent = false;
        let titleContent;
        let queryTileField;
        if (layer.options?.source?.options) {
            const dataSourceOptions = layer.options.source
                .options;
            if (dataSourceOptions.queryTitle) {
                queryTileField = dataSourceOptions.queryTitle;
            }
        }
        features.map((feature) => {
            if (queryTileField) {
                let queryTitleContent = feature.getProperties()[queryTileField];
                if (queryTitleContent) {
                    titleContent = !titleContent
                        ? queryTitleContent
                        : `${titleContent},${queryTitleContent}`;
                }
            }
            /*  if (!feature.getGeometry().simplify(100).intersectsExtent(bboxExtent)) {
              outBboxExtent = true;
              // TODO: Check to project the geometry?
            }*/
            const featureGeometryCoordinates = feature.getGeometry().getCoordinates();
            const featureGeometryType = feature.getGeometry().getType();
            if (!firstFeatureType && !outBboxExtent) {
                firstFeatureType = featureGeometryType;
            }
            if (!outBboxExtent) {
                switch (featureGeometryType) {
                    case 'Point':
                        if (nbFeatures === 1) {
                            pts = new olgeom.Point(featureGeometryCoordinates, 'XY');
                        }
                        else {
                            ptsArray.push(featureGeometryCoordinates);
                        }
                        break;
                    case 'LineString':
                        olmline.appendLineString(new olgeom.LineString(featureGeometryCoordinates, 'XY'));
                        break;
                    case 'Polygon':
                        olmpoly.appendPolygon(new olgeom.Polygon(featureGeometryCoordinates, 'XY'));
                        break;
                    case 'MultiPolygon':
                        olmpoly = new olgeom.MultiPolygon(featureGeometryCoordinates, 'XY');
                        break;
                    default:
                        return;
                }
            }
        });
        let olmpts;
        if (ptsArray.length === 0 && pts) {
            olmpts = {
                type: pts.getType(),
                coordinates: pts.getCoordinates()
            };
        }
        else {
            olmpts = {
                type: 'Polygon',
                coordinates: [this.convexHull(ptsArray)]
            };
        }
        let returnGeometry;
        switch (firstFeatureType) {
            case 'LineString':
                returnGeometry = {
                    type: olmline.getType(),
                    coordinates: olmline.getCoordinates()
                };
                break;
            case 'Point':
                returnGeometry = olmpts;
                break;
            case 'Polygon':
                returnGeometry = {
                    type: olmpoly.getType(),
                    coordinates: olmpoly.getCoordinates()
                };
                break;
            case 'MultiPolygon':
                returnGeometry = {
                    type: olmpoly.getType(),
                    coordinates: olmpoly.getCoordinates()
                };
                break;
        }
        const imposedProperties = {};
        if (queryTileField) {
            imposedProperties[queryTileField] = titleContent;
        }
        return [returnGeometry, imposedProperties];
    }
    cross(a, b, o) {
        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);
    }
    /**
     * @param points An array of [X, Y] coordinates
     * This method is use instead of turf.js convexHull because Turf needs at least 3 point to make a hull.
     * https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain#JavaScript
     */
    convexHull(points) {
        points.sort((a, b) => {
            return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];
        });
        const lower = [];
        for (const point of points) {
            while (lower.length >= 2 &&
                this.cross(lower[lower.length - 2], lower[lower.length - 1], point) <= 0) {
                lower.pop();
            }
            lower.push(point);
        }
        const upper = [];
        for (let i = points.length - 1; i >= 0; i--) {
            while (upper.length >= 2 &&
                this.cross(upper[upper.length - 2], upper[upper.length - 1], points[i]) <= 0) {
                upper.pop();
            }
            upper.push(points[i]);
        }
        upper.pop();
        lower.pop();
        return lower.concat(upper);
    }
    extractData(res, layer, options, url, imposedGeometry, imposedProperties) {
        const queryDataSource = layer.dataSource;
        const allowedFieldsAndAlias = this.getAllowedFieldsAndAlias(layer);
        let features = [];
        switch (queryDataSource.options.queryFormat) {
            case QueryFormat.GML3:
                features = this.extractGML3Data(res, layer.zIndex, allowedFieldsAndAlias);
                break;
            case QueryFormat.JSON:
            case QueryFormat.GEOJSON:
            case QueryFormat.GEOJSON2:
                features = this.extractGeoJSONData(res, layer.zIndex, allowedFieldsAndAlias);
                break;
            case QueryFormat.ESRIJSON:
                features = this.extractEsriJSONData(res, layer.zIndex, allowedFieldsAndAlias);
                break;
            case QueryFormat.TEXT:
                features = this.extractTextData(res);
                break;
            case QueryFormat.HTML:
                features = this.extractHtmlData(res, queryDataSource.queryHtmlTarget, url);
                break;
            case QueryFormat.HTMLGML2:
                features = this.extractHtmlData(res, queryDataSource.queryHtmlTarget, url, imposedGeometry, imposedProperties);
                break;
            case QueryFormat.GML2:
            default:
                features = this.extractGML2Data(res, layer, allowedFieldsAndAlias);
                break;
        }
        if (features.length > 0 &&
            (features[0].geometry === null || !features[0].geometry)) {
            const geomToAdd = this.createGeometryFromUrlClick(url);
            for (const feature of features) {
                feature.geometry = geomToAdd;
            }
        }
        const wmsDatasource = layer.dataSource;
        const featureCount = wmsDatasource.params?.FEATURE_COUNT
            ? new RegExp('FEATURE_COUNT=' + this.featureCount)
            : new RegExp('FEATURE_COUNT=' + this.defaultFeatureCount);
        if (featureCount.test(url) &&
            ((wmsDatasource.params?.FEATURE_COUNT &&
                this.featureCount > 1 &&
                features.length === this.featureCount) ||
                (!wmsDatasource.params?.FEATURE_COUNT &&
                    features.length === this.defaultFeatureCount))) {
            const messageObj = this.messageService.info('igo.geo.query.featureCountMax', undefined, undefined, { value: layer.title });
            this.previousMessageIds.push(messageObj.toastId);
        }
        return features.map((feature, index) => {
            const mapLabel = feature.properties[queryDataSource.mapLabel];
            let exclude;
            if (layer.options.sourceOptions?.type === 'wms') {
                const sourceOptions = layer.options
                    .sourceOptions;
                exclude = sourceOptions ? sourceOptions.excludeAttribute : undefined;
            }
            let title = this.getQueryTitle(feature, layer);
            if (!title && features.length > 1) {
                title = `${layer.title} (${index + 1})`;
            }
            else if (!title) {
                title = layer.title;
            }
            const meta = Object.assign({}, feature.meta || {}, {
                id: uuid(),
                title,
                mapTitle: mapLabel,
                sourceTitle: layer.title,
                order: 1000 - layer.zIndex,
                excludeAttribute: exclude
            });
            return Object.assign(feature, {
                meta,
                projection: queryDataSource.options.type === 'carto'
                    ? 'EPSG:4326'
                    : options.projection
            });
        });
    }
    createGeometryFromUrlClick(url) {
        const searchParams = this.getQueryParams(url.toLowerCase());
        const bboxRaw = searchParams.bbox;
        const width = parseInt(searchParams.width, 10);
        const height = parseInt(searchParams.height, 10);
        const xPosition = parseInt(searchParams.i || searchParams.x, 10);
        const yPosition = parseInt(searchParams.j || searchParams.y, 10);
        const bbox = bboxRaw.split(',');
        let threshold = (Math.abs(parseFloat(bbox[0])) - Math.abs(parseFloat(bbox[2]))) * 0.05;
        // for context in degree (EPSG:4326,4269...)
        if (Math.abs(parseFloat(bbox[0])) < 180) {
            threshold = 0.045;
        }
        const clickx = parseFloat(bbox[0]) +
            (Math.abs(parseFloat(bbox[0]) - parseFloat(bbox[2])) * xPosition) /
                width -
            threshold;
        const clicky = parseFloat(bbox[1]) +
            (Math.abs(parseFloat(bbox[1]) - parseFloat(bbox[3])) * yPosition) /
                height -
            threshold;
        const clickx1 = clickx + threshold * 2;
        const clicky1 = clicky + threshold * 2;
        const wktPoly = 'POLYGON((' +
            clickx +
            ' ' +
            clicky +
            ', ' +
            clickx +
            ' ' +
            clicky1 +
            ', ' +
            clickx1 +
            ' ' +
            clicky1 +
            ', ' +
            clickx1 +
            ' ' +
            clicky +
            ', ' +
            clickx +
            ' ' +
            clicky +
            '))';
        const format = new olformat.WKT();
        const tenPercentWidthGeom = format.readFeature(wktPoly);
        const f = tenPercentWidthGeom.getGeometry();
        const newGeom = {
            type: f.getType(),
            coordinates: f.getCoordinates()
        };
        return newGeom;
    }
    extractGML2Data(res, zIndex, allowedFieldsAndAlias) {
        const parser = new olFormatGML2();
        let features = parser.readFeatures(res);
        // Handle non standard GML output (MapServer)
        if (features.length === 0) {
            const wmsParser = new olformat.WMSGetFeatureInfo();
            try {
                features = wmsParser.readFeatures(res);
            }
            catch (e) {
                console.warn('query.service: Multipolygons are badly managed in mapserver in GML2. Use another format.');
            }
        }
        return features.map((feature) => this.featureToResult(feature, zIndex, allowedFieldsAndAlias));
    }
    extractGML3Data(res, zIndex, allowedFieldsAndAlias) {
        const parser = new olFormatGML3();
        let features = [];
        try {
            features = parser.readFeatures(res);
        }
        catch (e) {
            console.warn('query.service: GML3 is not well supported');
        }
        return features.map((feature) => this.featureToResult(feature, zIndex, allowedFieldsAndAlias));
    }
    extractGeoJSONData(res, zIndex, allowedFieldsAndAlias) {
        let features = [];
        try {
            features = JSON.parse(res.replace(/(\r|\n)/g, ' ')).features;
        }
        catch (e) {
            console.warn('query.service: Unable to parse geojson', '\n', res);
        }
        features.map((feature) => (feature.meta = {
            id: uuid(),
            order: 1000 - zIndex,
            alias: allowedFieldsAndAlias
        }));
        return features;
    }
    extractEsriJSONData(res, zIndex, allowedFieldsAndAlias) {
        if (res) {
            try {
                if (JSON.parse(res).error) {
                    return [];
                }
            }
            catch (e) { }
        }
        const parser = new olFormatEsriJSON();
        const features = parser.readFeatures(res);
        return features.map((feature) => this.featureToResult(feature, zIndex, allowedFieldsAndAlias));
    }
    extractTextData(res) {
        // TODO
        return [];
    }
    extractHtmlData(res, htmlTarget, url, imposedGeometry, imposedProperties) {
        const searchParams = this.getQueryParams(url.toLowerCase());
        const projection = searchParams.crs || searchParams.srs || 'EPSG:3857';
        const geomToAdd = this.createGeometryFromUrlClick(url);
        if (htmlTarget !== QueryHtmlTarget.BLANK &&
            htmlTarget !== QueryHtmlTarget.IFRAME) {
            htmlTarget = QueryHtmlTarget.IFRAME;
        }
        const bodyTagStart = res.toLowerCase().indexOf('<body>');
        const bodyTagEnd = res.toLowerCase().lastIndexOf('</body>') + 7;
        // replace \r \n  and ' ' with '' to validate if the body is really empty. Clear all the html tags from body
        const body = striptags(res.slice(bodyTagStart, bodyTagEnd).replace(/(\r|\n|\s)/g, ''));
        if (body === '' || res === '') {
            return [];
        }
        return [
            {
                type: FEATURE,
                projection,
                properties: Object.assign({ target: htmlTarget, body: res, url }, imposedProperties),
                geometry: imposedGeometry || geomToAdd
            }
        ];
    }
    getQueryParams(url) {
        const queryString = url.split('?');
        if (!queryString[1]) {
            return;
        }
        const pairs = queryString[1].split('&');
        const result = {};
        pairs.forEach((pair) => {
            pair = pair.split('=');
            result[pair[0]] = decodeURIComponent(pair[1] || '');
        });
        return result;
    }
    featureToResult(featureOL, zIndex, allowedFieldsAndAlias) {
        const featureGeometry = featureOL.getGeometry();
        const properties = Object.assign({}, featureOL.getProperties());
        delete properties.geometry;
        delete properties.GEOMETRIE;
        delete properties.boundedBy;
        delete properties.shape;
        delete properties.SHAPE;
        delete properties.SHAPE_S;
        delete properties.SHAPE_L;
        delete properties.SHAPE_P;
        delete properties.the_geom;
        delete properties.geom;
        delete properties.geom32198;
        let geometry;
        if (featureGeometry) {
            geometry = {
                type: featureGeometry.getType(),
                coordinates: featureGeometry.getCoordinates()
            };
        }
        return {
            type: FEATURE,
            projection: undefined,
            properties,
            geometry,
            meta: {
                id: uuid(),
                order: 1000 - zIndex,
                alias: allowedFieldsAndAlias
            }
        };
    }
    getQueryUrl(datasource, options, forceGML2 = false, mapExtent) {
        let url;
        if (datasource.options.queryUrls) {
            return this.getCustomQueryUrl(datasource, options, mapExtent);
        }
        switch (datasource.constructor) {
            case WMSDataSource:
                const wmsDatasource = datasource;
                const WMSGetFeatureInfoOptions = {
                    INFO_FORMAT: wmsDatasource.params.INFO_FORMAT ||
                        this.getMimeInfoFormat(datasource.options.queryFormat),
                    QUERY_LAYERS: wmsDatasource.params.LAYERS,
                    FEATURE_COUNT: wmsDatasource.params.FEATURE_COUNT || this.defaultFeatureCount
                };
                if (wmsDatasource.params.FEATURE_COUNT) {
                    this.featureCount = wmsDatasource.params.FEATURE_COUNT;
                }
                if (forceGML2) {
                    WMSGetFeatureInfoOptions.INFO_FORMAT = this.getMimeInfoFormat(QueryFormat.GML2);
                }
                url = wmsDatasource.ol.getFeatureInfoUrl(options.coordinates, options.resolution, options.projection, WMSGetFeatureInfoOptions);
                // const wmsVersion =
                //   wmsDatasource.params.VERSION ||
                //   wmsDatasource.params.version ||
                //   '1.3.0';
                // if (wmsVersion !== '1.3.0') {
                //   url = url.replace('&I=', '&X=');
                //   url = url.replace('&J=', '&Y=');
                // }
                break;
            case CartoDataSource:
                const cartoDatasource = datasource;
                const baseUrl = 'https://' +
                    cartoDatasource.options.account +
                    '.carto.com/api/v2/sql?';
                const format = 'format=GeoJSON';
                const sql = '&q=' + cartoDatasource.options.config.layers[0].options.sql;
                const clause = ' WHERE ST_Intersects(the_geom_webmercator,ST_BUFFER(ST_SetSRID(ST_POINT(';
                const meters = cartoDatasource.options.queryPrecision
                    ? cartoDatasource.options.queryPrecision
                    : '1000';
                const coordinates = options.coordinates[0] +
                    ',' +
                    options.coordinates[1] +
                    '),3857),' +
                    meters +
                    '))';
                url = `${baseUrl}${format}${sql}${clause}${coordinates}`;
                break;
            case ImageArcGISRestDataSource:
            case TileArcGISRestDataSource:
                const tileArcGISRestDatasource = datasource;
                const deltaX = Math.abs(mapExtent[0] - mapExtent[2]);
                const deltaY = Math.abs(mapExtent[1] - mapExtent[3]);
                const maxDelta = deltaX > deltaY ? deltaX : deltaY;
                const clickBuffer = maxDelta * 0.005;
                const threshold = tileArcGISRestDatasource.options.queryPrecision
                    ? tileArcGISRestDatasource.options.queryPrecision
                    : clickBuffer;
                const extent = olextent.buffer(olextent.boundingExtent([options.coordinates]), threshold);
                const serviceUrl = tileArcGISRestDatasource.options.url +
                    '/' +
                    tileArcGISRestDatasource.options.layer +
                    '/query/';
                const geometry = encodeURIComponent('{"xmin":' +
                    extent[0] +
                    ',"ymin":' +
                    extent[1] +
                    ',"xmax":' +
                    extent[2] +
                    ',"ymax":' +
                    extent[3] +
                    ',"spatialReference":{"wkid":102100}}');
                const params = [
                    'f=json',
                    `geometry=${geometry}`,
                    'geometryType=esriGeometryEnvelope',
                    'inSR=102100',
                    'spatialRel=esriSpatialRelIntersects',
                    'outFields=*',
                    'returnGeometry=true',
                    'outSR=102100'
                ];
                url = `${serviceUrl}?${params.join('&')}`;
                break;
            default:
                break;
        }
        return url;
    }
    getMimeInfoFormat(queryFormat) {
        let mime = 'application/vnd.ogc.gml';
        const keyEnum = Object.keys(QueryFormat).find((key) => QueryFormat[key] === queryFormat);
        if (keyEnum) {
            mime = QueryFormatMimeType[keyEnum];
        }
        return mime;
    }
    getAllowedFieldsAndAlias(layer) {
        let allowedFieldsAndAlias;
        if (layer.options?.source?.options?.sourceFields &&
            layer.options.source.options.sourceFields.length >= 1) {
            allowedFieldsAndAlias = {};
            layer.options.source.options.sourceFields.forEach((sourceField) => {
                const alias = sourceField.alias ? sourceField.alias : sourceField.name;
                allowedFieldsAndAlias[sourceField.name] = alias;
            });
        }
        return allowedFieldsAndAlias;
    }
    getQueryTitle(feature, layer) {
        let title;
        if (layer.options?.source?.options) {
            const dataSourceOptions = layer.options.source
                .options;
            if (dataSourceOptions.queryTitle) {
                title = this.getLabelMatch(feature, dataSourceOptions.queryTitle);
            }
        }
        return title;
    }
    getLabelMatch(feature, labelMatch) {
        let label = labelMatch;
        const labelToGet = Array.from(labelMatch.matchAll(/\$\{([^\{\}]+)\}/g));
        labelToGet.forEach((v) => {
            label = label.replace(v[0], feature.properties[v[1]]);
        });
        // Nothing done? check feature's attribute
        if (labelToGet.length === 0 && label === labelMatch) {
            label = feature.properties[labelMatch] || labelMatch;
        }
        return label;
    }
    /**
     * @param datasource QueryableDataSource
     * @param options QueryOptions
     * @mapExtent extent of the map when click event
     *
     */
    getCustomQueryUrl(datasource, options, mapExtent) {
        const extent = olextent.getForViewAndSize(options.coordinates, options.resolution, 0, [101, 101]);
        return datasource.options.queryUrls.map((item) => {
            let data = {
                url: item.url
                    .replace(/\{bbox\}/g, extent.join(','))
                    .replace(/\{x\}/g, options.coordinates[0].toString())
                    .replace(/\{y\}/g, options.coordinates[1].toString())
                    .replace(/\{resolution\}/g, options.resolution.toString())
                    .replace(/\{srid\}/g, options.projection.replace('EPSG:', ''))
            };
            // if the queryFormat changed to "QueryFormat.HTMLGML2": mapExtent will be undefined
            // we need to check "mapExtent" befor replace variables in the url
            if (mapExtent) {
                data.url
                    .replace(/\{xmin\}/g, mapExtent[0].toString())
                    .replace(/\{ymin\}/g, mapExtent[1].toString())
                    .replace(/\{xmax\}/g, mapExtent[2].toString())
                    .replace(/\{ymax\}/g, mapExtent[3].toString());
            }
            if (item.maxResolution) {
                data.maxResolution = item.maxResolution;
            }
            if (item.minResolution) {
                data.minResolution = item.minResolution;
            }
            if (item.minScale) {
                data.minScale = item.minScale;
            }
            if (item.maxScale) {
                data.maxScale = item.maxScale;
            }
            return data;
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: QueryService, deps: [{ token: i1.HttpClient }, { token: i2.MessageService }, { token: i2.LanguageService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: QueryService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: QueryService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: i2.MessageService }, { type: i2.LanguageService }]; } });

/**
 * Service where all available search sources are registered.
 */
class SearchSourceService {
    sources;
    constructor(sources) {
        this.sources = sources;
    }
    /**
     * Return available search sources
     * @returns Search sources
     */
    getSources() {
        return this.sources;
    }
    /**
     * Return enabled search sources
     * @returns Search sources
     */
    getEnabledSources() {
        return this.getSources().filter((source) => source.enabled === true);
    }
    /**
     * Enable search sources of given type
     * @param type Search type
     * @todo It would be better to track the enabled search sources
     *  without updating their 'enabled' property.
     */
    enableSourcesByType(type) {
        this.getSources().forEach((source) => {
            if (source.constructor.type === type) {
                source.enabled = true;
            }
            else {
                source.enabled = false;
            }
        });
    }
    /**
     * Set Param from the selected settings
     * @param source search-source
     * @param setting settings
     */
    setParamFromSetting(source, setting) {
        source.setParamFromSetting(setting);
    }
    /**
     * Set Param from the selected settings
     * @param source search-source
     * @param setting settings
     */
    setWorkspaces(source, workspaces) {
        source.setWorkspaces(workspaces);
    }
}

/**
 * Function that checks whether a search source implements TextSearch
 * @param source Search source
 * @returns True if the search source implements TextSearch
 */
function sourceCanSearch(source) {
    return source.search !== undefined;
}
/**
 * Function that checks whether a search source implements ReverseSearch
 * @param source Search source
 * @returns True if the search source implements ReverseSearch
 */
function sourceCanReverseSearch(source) {
    return source.reverseSearch !== undefined;
}
/**
 * Function that checks whether a search source implements ReverseSearch AND is shown in the pointer summary
 * @param source Search source
 * @returns True if the search source implements ReverseSearch AND is shown in the pointer summary
 */
function sourceCanReverseSearchAsSummary(source) {
    return (source.reverseSearch !== undefined &&
        source.showInPointerSummary === true);
}
/**
 * Return a search result out of an Feature. This is used to adapt
 * the IGO query module to the new Feature/SearchResult interfaces
 * @param feature feature
 * @param source Search source
 * @returns SearchResult
 */
function featureToSearchResult(feature, source) {
    if (feature.properties) {
        delete feature.properties.geometry;
        delete feature.properties.GEOMETRIE;
        delete feature.properties.boundedBy;
        delete feature.properties.shape;
        delete feature.properties.SHAPE;
        delete feature.properties.SHAPE_S;
        delete feature.properties.SHAPE_L;
        delete feature.properties.SHAPE_P;
        delete feature.properties.the_geom;
        delete feature.properties.geom;
        delete feature.properties.geom32198;
    }
    feature.sourceId = source.getId();
    return {
        source,
        data: feature,
        meta: {
            dataType: FEATURE,
            id: feature.meta.id,
            title: feature.meta.title,
            icon: feature.meta.icon || 'map-marker'
        }
    };
}
function findDiff(str1, str2) {
    let diff = '';
    str2.split('').forEach((val, i) => {
        if (val !== str1.charAt(i)) {
            diff += val;
        }
    });
    return diff;
}
/**
 * Return a score calculation based on "from" term with the "to" term,
 * where the perfect match is 100 and a total difference is 0 or under.
 * @param from string
 * @param to string
 * @param caseSensitive boolean
 * @returns number
 */
function computeTermSimilarity(from, to, caseSensitive = false) {
    if (!from || !to) {
        return 0;
    }
    const termFrom = caseSensitive ? from : from.toString().toLowerCase();
    const termTo = caseSensitive ? to : to.toString().toLowerCase();
    const fromToDiff = findDiff(termFrom, termTo);
    const toFromDiff = findDiff(termTo, termFrom);
    const totalDiff = fromToDiff + toFromDiff;
    let delta = 0;
    if (totalDiff.length) {
        delta = (totalDiff.length / termFrom.length) * 100;
    }
    return 100 - Math.floor(delta);
}

/**
 * This service perform researches in all the search sources enabled.
 * It returns Research objects who's 'request' property needs to be
 * subscribed to in order to trigger the research. This services has
 * keeps internal state of the researches it performed
 * and the results they yielded.
 */
class SearchService {
    searchSourceService;
    mapService;
    storageService;
    constructor(searchSourceService, mapService, storageService) {
        this.searchSourceService = searchSourceService;
        this.mapService = mapService;
        this.storageService = storageService;
    }
    /**
     * Perform a research by text
     * @param term Any text
     * @returns Researches
     */
    search(term, options = {}) {
        if (!this.termIsValid(term)) {
            return [];
        }
        const proj = this.mapService.getMap()?.projection || 'EPSG:3857';
        const response = stringToLonLat(term, proj, {
            forceNA: options.forceNA
        });
        if (response.lonLat) {
            return this.reverseSearch(response.lonLat, {
                distance: response.radius,
                conf: response.conf
            });
        }
        else if (response.message) {
            console.log(response.message);
        }
        options.extent = this.mapService
            .getMap()
            ?.viewController.getExtent('EPSG:4326');
        let sources;
        if (options.getEnabledOnly || options.getEnabledOnly === undefined) {
            sources = this.searchSourceService.getEnabledSources();
        }
        else {
            sources = this.searchSourceService.getSources();
        }
        if (options.sourceId) {
            sources = sources.filter((source) => source.getId() === options.sourceId);
        }
        else if (options.searchType) {
            sources = sources.filter((source) => source.getType() === options.searchType);
        }
        sources = sources.filter(sourceCanSearch);
        return this.searchSources(sources, term, options);
    }
    /**
     * Perform a research by lon/lat
     * @param lonLat Any lon/lat coordinates
     * @returns Researches
     */
    reverseSearch(lonLat, options, asPointerSummary = false) {
        const reverseSourceFonction = asPointerSummary
            ? sourceCanReverseSearchAsSummary
            : sourceCanReverseSearch;
        const sources = this.searchSourceService
            .getEnabledSources()
            .filter(reverseSourceFonction);
        const reverseSearchCoordsFormat = this.storageService.get('reverseSearchCoordsFormatEnabled') || false;
        return this.reverseSearchSources(sources, lonLat, options || {}, reverseSearchCoordsFormat);
    }
    /**
     * Create a text research out of all given search sources
     * @param sources Search sources that implement TextSearch
     * @param term Search term
     * @returns Observable of Researches
     */
    searchSources(sources, term, options) {
        return sources.map((source) => {
            return {
                request: source.search(term, options),
                reverse: false,
                source
            };
        });
    }
    /**
     * Create a reverse research out of all given search sources
     * @param sources Search sources that implement ReverseSearch
     * @param lonLat Any lon/lat coordinates
     * @returns Observable of Researches
     */
    reverseSearchSources(sources, lonLat, options, reverseSearchCoordsFormat) {
        return sources.map((source) => {
            return {
                request: source.reverseSearch(lonLat, options, reverseSearchCoordsFormat),
                reverse: true,
                source
            };
        });
    }
    /**
     * Validate that a search term is valid
     * @param term Search term
     * @returns True if the search term is valid
     */
    termIsValid(term) {
        return typeof term === 'string' && term !== '';
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SearchService, deps: [{ token: SearchSourceService }, { token: MapService }, { token: i2.StorageService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SearchService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SearchService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: SearchSourceService }, { type: MapService }, { type: i2.StorageService }]; } });

class DirectionsComponent {
    cdRef;
    languageService;
    directionsService;
    searchService;
    queryService;
    watcher;
    projection = 'EPSG:4326';
    zoomRoute$$;
    storeEmpty$$;
    storeChange$$;
    routesQueries$$ = [];
    selectStopInteraction;
    translateStop;
    selectedRoute;
    focusOnStop = false;
    isTranslating = false;
    previousStops = [];
    searchs$$ = [];
    contextUri;
    stopsStore;
    stopsFeatureStore;
    routesFeatureStore;
    stepFeatureStore;
    debounce = 200;
    length = 2;
    coordRoundedDecimals = 6;
    zoomToActiveRoute$ = new Subject();
    /**
     * Wheter one of the direction control is active
     * @internal
     */
    get directionControlIsActive() {
        return !this.queryService.queryEnabled;
    }
    get interactions() {
        return [this.selectStopInteraction, this.translateStop, this.selectedRoute];
    }
    constructor(cdRef, languageService, directionsService, searchService, queryService) {
        this.cdRef = cdRef;
        this.languageService = languageService;
        this.directionsService = directionsService;
        this.searchService = searchService;
        this.queryService = queryService;
    }
    ngOnInit() {
        this.queryService.queryEnabled = false;
        this.initEntityStores();
        setTimeout(() => {
            initStopsFeatureStore(this.stopsFeatureStore, this.languageService);
            initRoutesFeatureStore(this.routesFeatureStore, this.languageService);
            initStepFeatureStore(this.stepFeatureStore);
            this.initOlInteraction();
        }, 1);
    }
    ngOnDestroy() {
        this.queryService.queryEnabled = true;
        this.storeEmpty$$.unsubscribe();
        this.storeChange$$.unsubscribe();
        this.routesQueries$$.map((u) => u.unsubscribe());
        this.zoomRoute$$.unsubscribe();
        this.freezeStores();
    }
    freezeStores() {
        this.interactions.map((interaction) => this.routesFeatureStore.layer.map.ol.removeInteraction(interaction));
        this.stopsFeatureStore.deactivateStrategyOfType(FeatureStoreLoadingStrategy);
        this.routesFeatureStore.deactivateStrategyOfType(FeatureStoreLoadingStrategy);
        this.stepFeatureStore.deactivateStrategyOfType(FeatureStoreLoadingStrategy);
    }
    initEntityStores() {
        this.watcher = new EntityStoreWatcher(this.stopsStore, this.cdRef);
        this.monitorEmptyEntityStore();
        this.monitorEntityStoreChange();
        this.monitorActiveRouteZoom();
    }
    monitorActiveRouteZoom() {
        this.zoomRoute$$ = this.zoomToActiveRoute$.subscribe(() => {
            if (this.routesFeatureStore.count >= 1) {
                const activeRoute = this.routesFeatureStore
                    .all()
                    .find((route) => route.properties.active);
                if (activeRoute) {
                    activeRoute.ol.getGeometry();
                    const routeExtent = activeRoute.ol.getGeometry().getExtent();
                    this.routesFeatureStore.layer.map.viewController.zoomToExtent(routeExtent);
                }
            }
        });
    }
    initOlInteraction() {
        this.selectStopInteraction = new olInteraction.Select({
            layers: [this.stopsFeatureStore.layer.ol],
            hitTolerance: 7,
            condition: (event) => {
                return event.type === 'pointermove' && !event.dragging;
            }
        });
        this.translateStop = new olInteraction.Translate({
            features: this.selectStopInteraction.getFeatures()
        });
        this.translateStop.on('translating', (evt) => {
            this.isTranslating = true;
            this.executeStopTranslation(evt.features);
        });
        this.translateStop.on('translateend', (evt) => {
            this.isTranslating = false;
            this.executeStopTranslation(evt.features);
        });
        this.selectedRoute = new olInteraction.Select({
            layers: [this.routesFeatureStore.layer.ol],
            condition: olCondition.click,
            hitTolerance: 7,
            filter: (feature) => {
                return (feature.get('type') === DirectionType.Route &&
                    feature.get('active') &&
                    !this.isTranslating);
            }
        });
        this.selectedRoute.on('select', (evt) => {
            if (this.focusOnStop === false) {
                const selectCoordinates = roundCoordTo(olproj.transform(evt.mapBrowserEvent.coordinate, this.routesFeatureStore.layer.map.projection, this.projection), this.coordRoundedDecimals);
                const addedStop = addStopToStore(this.stopsStore);
                addedStop.text = selectCoordinates.join(',');
                addedStop.coordinates = [selectCoordinates[0], selectCoordinates[1]];
            }
        });
        this.interactions.map((interaction) => this.routesFeatureStore.layer.map.ol.addInteraction(interaction));
    }
    onStopInputHasFocusChange(stopInputHasFocus) {
        stopInputHasFocus
            ? this.routesFeatureStore.layer.map.ol.removeInteraction(this.selectedRoute)
            : this.routesFeatureStore.layer.map.ol.addInteraction(this.selectedRoute);
    }
    executeStopTranslation(features) {
        if (features.getLength() === 0) {
            return;
        }
        const firstFeature = features.getArray()[0];
        const translatedStopId = firstFeature.getId();
        const translationCoordinates = olproj.transform(firstFeature.getGeometry().getCoordinates(), this.stopsFeatureStore.layer.map.projection, this.projection);
        const translatedStop = this.stopsStore.get(translatedStopId);
        const roundedCoord = roundCoordTo(translationCoordinates, this.coordRoundedDecimals);
        translatedStop.coordinates = roundedCoord;
        translatedStop.text = roundedCoord.join(',');
        this.stopsStore.update(translatedStop);
    }
    monitorEmptyEntityStore() {
        // Watch if the store is empty to reset it
        this.storeEmpty$$ = this.stopsStore.count$
            .pipe(distinctUntilChanged())
            .subscribe((count) => {
            if (count < 2) {
                addStopToStore(this.stopsStore);
                if (this.stopsStore.count === 2) {
                    this.stopsStore.storeInitialized$.next(true);
                    return;
                }
                this.stopsStore.storeInitialized$.next(false);
            }
            this.routesQueries$$.map((u) => u.unsubscribe());
        });
    }
    monitorEntityStoreChange() {
        this.storeChange$$ = this.stopsStore.entities$
            .pipe(debounceTime(this.debounce))
            .subscribe((stops) => {
            this.handleStopDiff(stops);
            updateStoreSorting(this.stopsStore);
            this.handleStopsFeature();
            this.getRoutes(this.isTranslating);
        });
    }
    cancelSearch() {
        this.searchs$$.map((s) => s.unsubscribe());
    }
    handleStopDiff(stops) {
        const simplifiedStops = stops.map((stop) => {
            return ObjectUtils.removeUndefined({
                ...{ id: stop.id, text: stop.text, coordinates: stop.coordinates }
            });
        });
        const diff = ChangeUtils.findChanges(this.previousStops, simplifiedStops, [
            'coordinates'
        ]);
        const stopIdToProcess = diff.added.concat(diff.modified);
        if (stopIdToProcess) {
            stopIdToProcess.map((change) => {
                const changedStop = change.newValue;
                if (changedStop) {
                    const stop = this.stopsStore.get(changedStop.id);
                    const term = stop.text;
                    if (!term || term.length === 0) {
                        return;
                    }
                    const response = stringToLonLat(term, this.stopsFeatureStore.layer.map.projection);
                    let researches;
                    let isCoord = false;
                    if (response.lonLat) {
                        isCoord = true;
                    }
                    researches = this.searchService.search(term, {
                        searchType: 'Feature'
                    });
                    this.cancelSearch();
                    const requests$ = researches.map((res) => res.request.pipe(map((results) => results.filter((r) => isCoord
                        ? r.data.geometry.type === 'Point' && r.data.geometry
                        : r.data.geometry))));
                    this.searchs$$ = requests$.map((request) => {
                        return request
                            .pipe(map((results) => results.filter((r) => isCoord
                            ? r.data.geometry.type === 'Point' && r.data.geometry
                            : r.data.geometry)))
                            .subscribe((res) => {
                            if (res.length > 0) {
                                const source = res[0].source;
                                const meta = res[0].meta;
                                const results = res.map((r) => r.data);
                                if (!stop.searchProposals) {
                                    stop.searchProposals = [];
                                }
                                stop.searchProposals = stop.searchProposals.filter((sp) => sp.type ===
                                    (isCoord ? ProposalType.Coord : ProposalType.Text));
                                let storedSource = stop.searchProposals.find((sp) => sp.source === source);
                                if (storedSource) {
                                    storedSource.results = results;
                                }
                                else {
                                    stop.searchProposals.push({
                                        type: isCoord ? ProposalType.Coord : ProposalType.Text,
                                        source,
                                        meta,
                                        results
                                    });
                                }
                            }
                            this.cdRef.detectChanges();
                        });
                    });
                }
            });
        }
        this.previousStops = simplifiedStops;
    }
    handleStopsFeature() {
        const stops = this.stopsStore.all();
        const stopsWithCoordinates = stops.filter((stop) => stop.coordinates);
        stopsWithCoordinates.map((stop) => this.addStopOverlay(stop));
        this.stopsFeatureStore
            .all()
            .map((stopFeature) => {
            if (!this.stopsStore.get(stopFeature.properties.id)) {
                this.stopsFeatureStore.delete(stopFeature);
            }
        });
        const stopsWithoutCoordinates = stops.filter((stop) => !stop.coordinates);
        stopsWithoutCoordinates.map((stop) => {
            const stopFeature = this.stopsFeatureStore.get(stop.id);
            if (stopFeature) {
                this.stopsFeatureStore.delete(stopFeature);
            }
        });
    }
    getRoutes(isOverview = false) {
        const stopsWithCoordinates = this.stopsStore.view
            .all()
            .filter((stop) => stop.coordinates);
        if (stopsWithCoordinates.length < 2) {
            this.routesFeatureStore.deleteMany(this.routesFeatureStore.all());
            return;
        }
        const roundedCoordinates = stopsWithCoordinates.map((stop) => {
            const roundedCoord = roundCoordTo(stop.coordinates, this.coordRoundedDecimals);
            return roundedCoord;
        });
        const overviewDirectionsOptions = {
            overview: true,
            steps: false,
            alternatives: false,
            continue_straight: false
        };
        this.routesQueries$$.map((u) => u.unsubscribe());
        const routeResponse = this.directionsService.route(roundedCoordinates, isOverview ? overviewDirectionsOptions : undefined);
        if (routeResponse) {
            routeResponse.map((res) => this.routesQueries$$.push(res.subscribe((directions) => {
                this.routesFeatureStore.deleteMany(this.routesFeatureStore.all());
                directions.map((direction) => addDirectionToRoutesFeatureStore(this.routesFeatureStore, direction, this.projection, direction === directions[0] ? true : false));
            })));
        }
    }
    addStopOverlay(stop) {
        addStopToStopsFeatureStore(stop, this.stopsStore, this.stopsFeatureStore, this.projection, this.languageService);
    }
    onToggleDirectionsControl(isActive) {
        this.queryService.queryEnabled = !isActive;
        const ol = this.routesFeatureStore.layer.map.ol;
        this.interactions.map((interaction) => isActive
            ? ol.addInteraction(interaction)
            : ol.removeInteraction(interaction));
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DirectionsComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i2.LanguageService }, { token: DirectionsService }, { token: SearchService }, { token: QueryService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DirectionsComponent, selector: "igo-directions", inputs: { contextUri: "contextUri", stopsStore: "stopsStore", stopsFeatureStore: "stopsFeatureStore", routesFeatureStore: "routesFeatureStore", stepFeatureStore: "stepFeatureStore", debounce: "debounce", length: "length", coordRoundedDecimals: "coordRoundedDecimals", zoomToActiveRoute$: "zoomToActiveRoute$" }, ngImport: i0, template: "<div class=\"directions-options\">\n  <mat-slide-toggle\n    [checked]=\"directionControlIsActive\"\n    [labelPosition]=\"'before'\"\n    (change)=\"onToggleDirectionsControl($event.checked)\"\n  >\n    {{ 'igo.geo.directionsForm.toggleActive' | translate }}\n  </mat-slide-toggle>\n</div>\n\n<igo-directions-buttons\n  [stepFeatureStore]=\"stepFeatureStore\"\n  [contextUri]=\"contextUri\"\n  [zoomToActiveRoute$]=\"zoomToActiveRoute$\"\n  [routesFeatureStore]=\"routesFeatureStore\"\n  [stopsStore]=\"stopsStore\"\n></igo-directions-buttons>\n\n<igo-directions-inputs\n  (stopInputHasFocus)=\"onStopInputHasFocusChange($event)\"\n  [coordRoundedDecimals]=\"coordRoundedDecimals\"\n  [projection]=\"projection\"\n  [stopsFeatureStore]=\"stopsFeatureStore\"\n  [stopsStore]=\"stopsStore\"\n  [debounce]=\"debounce\"\n  [length]=\"length\"\n></igo-directions-inputs>\n\n<igo-directions-results\n  [stepFeatureStore]=\"stepFeatureStore\"\n  [routesFeatureStore]=\"routesFeatureStore\"\n></igo-directions-results>\n", styles: [".directions-options mat-slide-toggle{width:100%;padding:10px}.directions-options mat-slide-toggle ::ng-deep .mdc-form-field{width:100%}.directions-options mat-slide-toggle ::ng-deep .mdc-label{margin-left:0;width:calc(100% - 60px)}\n"], dependencies: [{ kind: "component", type: i7.MatSlideToggle, selector: "mat-slide-toggle", inputs: ["disabled", "disableRipple", "color", "tabIndex"], exportAs: ["matSlideToggle"] }, { kind: "component", type: DirectionsInputsComponent, selector: "igo-directions-inputs", inputs: ["stopsStore", "stopsFeatureStore", "projection", "coordRoundedDecimals", "debounce", "length"], outputs: ["stopInputHasFocus"] }, { kind: "component", type: DirectionsButtonsComponent, selector: "igo-directions-buttons", inputs: ["contextUri", "zoomToActiveRoute$", "stopsStore", "routesFeatureStore", "stepFeatureStore"] }, { kind: "component", type: DirectionsResultsComponent, selector: "igo-directions-results", inputs: ["routesFeatureStore", "stepFeatureStore"] }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DirectionsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-directions', template: "<div class=\"directions-options\">\n  <mat-slide-toggle\n    [checked]=\"directionControlIsActive\"\n    [labelPosition]=\"'before'\"\n    (change)=\"onToggleDirectionsControl($event.checked)\"\n  >\n    {{ 'igo.geo.directionsForm.toggleActive' | translate }}\n  </mat-slide-toggle>\n</div>\n\n<igo-directions-buttons\n  [stepFeatureStore]=\"stepFeatureStore\"\n  [contextUri]=\"contextUri\"\n  [zoomToActiveRoute$]=\"zoomToActiveRoute$\"\n  [routesFeatureStore]=\"routesFeatureStore\"\n  [stopsStore]=\"stopsStore\"\n></igo-directions-buttons>\n\n<igo-directions-inputs\n  (stopInputHasFocus)=\"onStopInputHasFocusChange($event)\"\n  [coordRoundedDecimals]=\"coordRoundedDecimals\"\n  [projection]=\"projection\"\n  [stopsFeatureStore]=\"stopsFeatureStore\"\n  [stopsStore]=\"stopsStore\"\n  [debounce]=\"debounce\"\n  [length]=\"length\"\n></igo-directions-inputs>\n\n<igo-directions-results\n  [stepFeatureStore]=\"stepFeatureStore\"\n  [routesFeatureStore]=\"routesFeatureStore\"\n></igo-directions-results>\n", styles: [".directions-options mat-slide-toggle{width:100%;padding:10px}.directions-options mat-slide-toggle ::ng-deep .mdc-form-field{width:100%}.directions-options mat-slide-toggle ::ng-deep .mdc-label{margin-left:0;width:calc(100% - 60px)}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i2.LanguageService }, { type: DirectionsService }, { type: SearchService }, { type: QueryService }]; }, propDecorators: { contextUri: [{
                type: Input
            }], stopsStore: [{
                type: Input
            }], stopsFeatureStore: [{
                type: Input
            }], routesFeatureStore: [{
                type: Input
            }], stepFeatureStore: [{
                type: Input
            }], debounce: [{
                type: Input
            }], length: [{
                type: Input
            }], coordRoundedDecimals: [{
                type: Input
            }], zoomToActiveRoute$: [{
                type: Input
            }] } });

class IgoDirectionsModule {
    static forRoot() {
        return {
            ngModule: IgoDirectionsModule
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoDirectionsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoDirectionsModule, declarations: [DirectionsComponent,
            DirectionsInputsComponent,
            DirectionsButtonsComponent,
            DirectionsResultsComponent], imports: [CommonModule,
            DragDropModule,
            FormsModule,
            ReactiveFormsModule,
            MatIconModule,
            MatButtonModule,
            MatListModule,
            MatDividerModule,
            MatFormFieldModule,
            MatInputModule,
            MatOptionModule,
            MatSelectModule,
            MatSlideToggleModule,
            MatTooltipModule,
            MatAutocompleteModule,
            IgoLanguageModule], exports: [DirectionsComponent,
            DirectionsInputsComponent,
            DirectionsButtonsComponent,
            DirectionsResultsComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoDirectionsModule, providers: [provideDirectionsSourceService()], imports: [CommonModule,
            DragDropModule,
            FormsModule,
            ReactiveFormsModule,
            MatIconModule,
            MatButtonModule,
            MatListModule,
            MatDividerModule,
            MatFormFieldModule,
            MatInputModule,
            MatOptionModule,
            MatSelectModule,
            MatSlideToggleModule,
            MatTooltipModule,
            MatAutocompleteModule,
            IgoLanguageModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoDirectionsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        DragDropModule,
                        FormsModule,
                        ReactiveFormsModule,
                        MatIconModule,
                        MatButtonModule,
                        MatListModule,
                        MatDividerModule,
                        MatFormFieldModule,
                        MatInputModule,
                        MatOptionModule,
                        MatSelectModule,
                        MatSlideToggleModule,
                        MatTooltipModule,
                        MatAutocompleteModule,
                        IgoLanguageModule
                    ],
                    exports: [
                        DirectionsComponent,
                        DirectionsInputsComponent,
                        DirectionsButtonsComponent,
                        DirectionsResultsComponent
                    ],
                    declarations: [
                        DirectionsComponent,
                        DirectionsInputsComponent,
                        DirectionsButtonsComponent,
                        DirectionsResultsComponent
                    ],
                    providers: [provideDirectionsSourceService()]
                }]
        }] });

class FilterableDataSourcePipe {
    transform(value, arg) {
        let layers;
        if (arg === 'time') {
            layers = value.filter((layer) => {
                const datasource = layer.dataSource;
                return (this.isTimeFilterable(datasource) &&
                    datasource.options.timeFilter !== undefined &&
                    Object.keys(datasource.options.timeFilter).length);
            });
        }
        if (arg === 'ogc') {
            layers = value.filter((layer) => {
                const datasource = layer.dataSource;
                return this.isOgcFilterable(datasource);
            });
        }
        return layers;
    }
    isTimeFilterable(dataSource) {
        if (dataSource.options.type !== 'wms') {
            return false;
        }
        return dataSource.options.timeFilterable;
    }
    isOgcFilterable(dataSource) {
        let isOgcFilterable = false;
        if (dataSource.options.ogcFilters &&
            dataSource.options.ogcFilters.enabled &&
            dataSource.options.ogcFilters.editable) {
            isOgcFilterable = true;
        }
        if (dataSource.options.ogcFilters &&
            dataSource.options.ogcFilters.enabled &&
            (dataSource.options.ogcFilters.pushButtons ||
                dataSource.options.ogcFilters.checkboxes ||
                dataSource.options.ogcFilters.radioButtons ||
                dataSource.options.ogcFilters.select ||
                dataSource.options.ogcFilters.autocomplete)) {
            isOgcFilterable = true;
        }
        return isOgcFilterable;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterableDataSourcePipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
    static ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: FilterableDataSourcePipe, name: "filterableDataSource" });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FilterableDataSourcePipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'filterableDataSource'
                }]
        }] });

class TimeFilterService {
    constructor() { }
    filterByDate(datasource, date) {
        let time;
        let newdateform;
        let newdateformStart;
        let newdateformEnd;
        if (Array.isArray(date)) {
            const dates = [];
            if (date[0]) {
                newdateformStart = this.reformatDateTime(date[0]);
                dates.push(date[0]);
            }
            if (date[1]) {
                newdateformEnd = this.reformatDateTime(date[1]);
                dates.push(date[1]);
            }
            if (dates.length === 2 && newdateformStart !== newdateformEnd) {
                if (datasource instanceof TileArcGISRestDataSource) {
                    time = newdateformStart + ',' + newdateformEnd;
                }
                else {
                    time = newdateformStart + '/' + newdateformEnd;
                }
            }
            if (newdateformStart === newdateformEnd) {
                time = newdateformStart;
            }
        }
        else if (date) {
            newdateform = this.reformatDateTime(date);
            time = newdateform;
        }
        const params = { TIME: time };
        datasource.ol.updateParams(params);
        if (datasource instanceof WMSDataSource) {
            const wmsDataSource = datasource;
            wmsDataSource.setTimeFilter(wmsDataSource.timeFilter, true);
        }
    }
    filterByYear(datasource, year) {
        let time;
        let newdateformStart;
        let newdateformEnd;
        if (Array.isArray(year)) {
            const years = [];
            if (year[0]) {
                newdateformStart = year[0];
                years.push(year[0]);
            }
            if (year[1]) {
                newdateformEnd = year[1];
                years.push(year[1]);
            }
            if (years.length === 2 && newdateformStart !== newdateformEnd) {
                if (datasource instanceof TileArcGISRestDataSource) {
                    time = newdateformStart + ',' + newdateformEnd;
                }
                else {
                    time = newdateformStart + '/' + newdateformEnd;
                }
            }
            if (newdateformStart === newdateformEnd) {
                time = newdateformStart;
            }
        }
        else {
            // to reset filter.
            time = year;
        }
        const params = { TIME: time };
        datasource.ol.updateParams(params);
        if (datasource instanceof WMSDataSource) {
            const wmsDataSource = datasource;
            wmsDataSource.setTimeFilter(wmsDataSource.timeFilter, true);
        }
    }
    reformatDateTime(value) {
        const year = value.getFullYear();
        let month = value.getMonth() + 1;
        let day = value.getUTCDate();
        let hour = value.getUTCHours();
        let minute = value.getUTCMinutes();
        if (Number(month) < 10) {
            month = '0' + month;
        }
        if (Number(day) < 10) {
            day = '0' + day;
        }
        if (Number(hour) < 10) {
            hour = '0' + hour;
        }
        if (Number(minute) < 10) {
            minute = '0' + minute;
        }
        return year + '-' + month + '-' + day + 'T' + hour + ':' + minute + ':00Z';
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TimeFilterService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TimeFilterService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TimeFilterService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return []; } });

class OGCFilterService {
    constructor() { }
    filterByOgc(wmsDatasource, filterString) {
        const appliedFilter = new OgcFilterWriter().formatProcessedOgcFilter(filterString, wmsDatasource.options.params.LAYERS);
        wmsDatasource.ol.updateParams({ FILTER: appliedFilter });
    }
    setOgcWFSFiltersOptions(wfsDatasource) {
        const options = wfsDatasource.options;
        const ogcFilterWriter = new OgcFilterWriter();
        if (options.ogcFilters.enabled && options.ogcFilters.filters) {
            options.ogcFilters.filters = ogcFilterWriter.checkIgoFiltersProperties(options.ogcFilters.filters, options.paramsWFS.fieldNameGeometry, new olProjection({ code: options.paramsWFS.srsName }), true);
            if (!options.ogcFilters.interfaceOgcFilters) {
                options.ogcFilters.interfaceOgcFilters =
                    ogcFilterWriter.defineInterfaceFilterSequence(options.ogcFilters.filters, options.paramsWFS.fieldNameGeometry);
            }
        }
    }
    setOgcWMSFiltersOptions(wmsDatasource) {
        const options = wmsDatasource.options;
        const ogcFilterWriter = new OgcFilterWriter();
        if (options.ogcFilters.enabled && options.ogcFilters.filters) {
            options.ogcFilters.filters = ogcFilterWriter.checkIgoFiltersProperties(options.ogcFilters.filters, options.fieldNameGeometry, undefined, true);
            if (!options.ogcFilters.interfaceOgcFilters) {
                options.ogcFilters.interfaceOgcFilters =
                    ogcFilterWriter.defineInterfaceFilterSequence(
                    // With some wms server, this param must be set to make spatials call.
                    options.ogcFilters.filters, options.fieldNameGeometry);
            }
            this.filterByOgc(wmsDatasource, ogcFilterWriter.buildFilter(options.ogcFilters.filters, undefined, undefined, undefined, wmsDatasource.options));
            options.filtered = true;
        }
        else {
            options.ogcFilters.filters = undefined;
            options.ogcFilters.interfaceOgcFilters = [];
            options.filtered = false;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OGCFilterService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OGCFilterService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OGCFilterService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return []; } });

var SpatialFilterQueryType;
(function (SpatialFilterQueryType) {
    SpatialFilterQueryType["AdmRegion"] = "AdmRegion";
    SpatialFilterQueryType["Mun"] = "Mun";
    SpatialFilterQueryType["Arrond"] = "Arrond";
    SpatialFilterQueryType["CircFed"] = "CircFed";
    SpatialFilterQueryType["CircProv"] = "CircProv";
    SpatialFilterQueryType["DirReg"] = "DirReg";
    SpatialFilterQueryType["MRC"] = "MRC";
    SpatialFilterQueryType["RegTour"] = "RegTour";
})(SpatialFilterQueryType || (SpatialFilterQueryType = {}));
var SpatialFilterType;
(function (SpatialFilterType) {
    SpatialFilterType["Predefined"] = "Predefined";
    SpatialFilterType["Polygon"] = "Polygon";
    SpatialFilterType["Point"] = "Point";
})(SpatialFilterType || (SpatialFilterType = {}));
var SpatialFilterItemType;
(function (SpatialFilterItemType) {
    SpatialFilterItemType["Address"] = "Address";
    SpatialFilterItemType["Thematics"] = "Thematics";
})(SpatialFilterItemType || (SpatialFilterItemType = {}));

class SpatialFilterService {
    http;
    languageService;
    configService;
    baseUrl = 'https://geoegl.msp.gouv.qc.ca/apis/terrapi/';
    /*
     * Type association with URL
     */
    urlFilterList = {
        AdmRegion: 'regadmin',
        Arrond: 'arrondissements',
        CircFed: 'circ-fed',
        CircProv: 'circ-prov',
        DirReg: 'dir-reg',
        MRC: 'mrc',
        Mun: 'municipalites',
        RegTour: 'tourisme',
        bornes: 'bornes-sumi',
        hydro: 'hydro',
        routes: 'routes'
    };
    constructor(http, languageService, configService) {
        this.http = http;
        this.languageService = languageService;
        this.configService = configService;
        this.baseUrl =
            this.configService.getConfig('spatialFilter.url') || this.baseUrl;
    }
    getKeyByValue(object, value) {
        return Object.keys(object).find((key) => object[key] === value);
    }
    /*
     * Loading data for spatial filter list component (NO GEOMETRY)
     */
    loadFilterList(type) {
        const urlPath = type;
        if (urlPath) {
            return this.http
                .get(this.baseUrl + this.urlFilterList[urlPath])
                .pipe(map((featureCollection) => featureCollection.features.map((f) => {
                f.meta = {
                    id: f.properties.code
                };
                return f;
            })));
        }
    }
    /*
     * Loading item list (STRING)
     */
    loadThematicsList() {
        const url = 'types';
        const items = [];
        return this.http.get(this.baseUrl + url).pipe(map((types) => {
            types.forEach((type) => {
                if (type.startsWith('lieux')) {
                    const item = {
                        name: undefined,
                        source: type
                    };
                    let substr = type.substring(6, type.length);
                    let name = substr;
                    if (substr.includes('.')) {
                        const index = substr.indexOf('.');
                        name = substr.substring(index + 1, substr.length);
                        substr = substr.substring(0, index);
                    }
                    try {
                        item.name = this.languageService.translate.instant('igo.geo.terrapi.' + name);
                    }
                    catch (e) {
                        item.name =
                            name.substring(0, 1).toUpperCase() +
                                name.substring(1, name.length - 1);
                    }
                    try {
                        item.group = this.languageService.translate.instant('igo.geo.spatialFilter.group.' + substr);
                    }
                    catch (e) {
                        item.group =
                            substr.substring(0, 1).toUpperCase() +
                                substr.substring(1, name.length - 1);
                    }
                    items.push(item);
                }
                else {
                    if (this.getKeyByValue(this.urlFilterList, type)) {
                        const item = {
                            name: undefined,
                            source: type
                        };
                        const name = this.getKeyByValue(this.urlFilterList, type);
                        try {
                            item.name = this.languageService.translate.instant('igo.geo.terrapi.' + name);
                        }
                        catch (e) {
                            item.name =
                                name.substring(0, 1).toUpperCase() +
                                    name.substring(1, name.length - 1);
                        }
                        item.source = type;
                        items.push(item);
                    }
                }
            });
            return items;
        }));
    }
    /*
     * Loading data for spatial filter item component (Address or Thematics) depends on predefined zone or draw zone (feature)
     */
    loadFilterItem(feature, itemType, type, thematic, buffer) {
        if (type) {
            // Predefined type
            const urlType = type;
            const url = this.baseUrl + this.urlFilterList[urlType];
            let urlItem = '';
            if (itemType === SpatialFilterItemType.Address) {
                urlItem = 'adresses';
                return this.http
                    .get(url + '/' + feature.properties.code + '/' + urlItem, {
                    params: {
                        geometry: 'true',
                        icon: 'true',
                        bufferInput: buffer.toString(),
                        simplified: '100'
                    }
                })
                    .pipe(map((featureCollection) => featureCollection.features.map((f) => {
                    f.meta = {
                        id: f.properties.code,
                        title: this.languageService.translate.instant('igo.geo.spatialFilter.Address'),
                        icon: f.icon
                    };
                    return f;
                })));
            }
            else {
                // If thematics search
                urlItem = thematic.source;
                return this.http
                    .get(url + '/' + feature.properties.code + '/' + urlItem, {
                    params: {
                        geometry: 'true',
                        icon: 'true',
                        bufferInput: buffer.toString(),
                        simplified: '100'
                    }
                })
                    .pipe(map((featureCollection) => featureCollection.features.map((f) => {
                    f.meta = {
                        id: f.properties.code,
                        title: thematic.name,
                        icon: f.icon
                    };
                    return f;
                })));
            }
        }
        else {
            // Draw type
            const url = this.baseUrl + 'locate';
            if (itemType === SpatialFilterItemType.Address) {
                const urlItem = '?type=adresses';
                return this.http
                    .post(url + urlItem, {
                    geometry: 'true',
                    icon: 'true',
                    loc: JSON.stringify(feature),
                    bufferInput: buffer.toString(),
                    simplified: '100'
                })
                    .pipe(map((featureCollection) => featureCollection.features.map((f) => {
                    f.meta = {
                        id: f.properties.code,
                        title: this.languageService.translate.instant('igo.geo.spatialFilter.Address'),
                        icon: f.icon
                    };
                    return f;
                })));
            }
            else {
                // If thematics search
                const urlItem = '?type=' + thematic.source;
                return this.http
                    .post(url + urlItem, {
                    geometry: 'true',
                    icon: 'true',
                    loc: JSON.stringify(feature),
                    bufferInput: buffer.toString(),
                    simplified: '100'
                })
                    .pipe(map((featureCollection) => featureCollection.features.map((f) => {
                    f.meta = {
                        id: f.properties.code,
                        title: thematic.name,
                        icon: f.icon
                    };
                    return f;
                })));
            }
        }
    }
    /*
     * Get one territory by id (WITH GEOMETRY)
     */
    loadItemById(feature, type) {
        const featureType = this.urlFilterList[type];
        const featureCode = '/' + feature.properties.code;
        if (featureType && featureCode) {
            return this.http
                .get(this.baseUrl + featureType + featureCode, {
                params: {
                    geometry: 'true'
                }
            })
                .pipe(map((f) => {
                f.meta = {
                    id: f.properties.code,
                    alias: f.properties.nom,
                    title: f.properties.nom
                };
                return f;
            }));
        }
    }
    /*
     * Get buffer geometry
     */
    loadBufferGeometry(feature, filterType, buffer, type) {
        if (filterType === SpatialFilterType.Predefined) {
            const featureType = this.urlFilterList[type];
            const featureCode = '/' + feature.properties.code;
            if (featureType && featureCode) {
                return this.http
                    .get(this.baseUrl + featureType + featureCode, {
                    params: {
                        geometry: '100',
                        bufferOutput: buffer.toString()
                    }
                })
                    .pipe(map((f) => {
                    f.meta = {
                        id: f.properties.code,
                        alias: f.properties.nom,
                        title: f.properties.nom
                    };
                    return f;
                }));
            }
        }
        else {
            return this.http
                .post(this.baseUrl + 'geospatial/buffer?', {
                buffer,
                loc: JSON.stringify(feature)
            })
                .pipe(map((f) => {
                return f;
            }));
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SpatialFilterService, deps: [{ token: i1.HttpClient }, { token: i2.LanguageService }, { token: i2.ConfigService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SpatialFilterService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SpatialFilterService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: i2.LanguageService }, { type: i2.ConfigService }]; } });

class DownloadService {
    messageService;
    constructor(messageService) {
        this.messageService = messageService;
    }
    open(layer) {
        this.messageService.success('igo.geo.download.start', 'igo.geo.download.title');
        const DSOptions = layer.dataSource.options;
        if (Object.keys(DSOptions.download).length > 0) {
            if (DSOptions.download.dynamicUrl &&
                DSOptions.download.url === undefined) {
                let wfsOptions;
                let currentProj = new olProjection({ code: layer.map.projection });
                const paramsWFS = layer.dataSource.options.paramsWFS;
                if (paramsWFS && Object.keys(paramsWFS).length > 0) {
                    currentProj = paramsWFS.srsName
                        ? new olProjection({ code: paramsWFS.srsName })
                        : currentProj;
                    wfsOptions = layer.dataSource.options.paramsWFS;
                }
                else {
                    wfsOptions = layer.dataSource.options.params;
                }
                const currentExtent = olproj.transformExtent(layer.map.viewController.getExtent(), new olProjection({ code: layer.map.projection }), currentProj);
                const outputFormatDownload = wfsOptions.outputFormatDownload === undefined
                    ? wfsOptions.outputFormat === undefined
                        ? ''
                        : 'outputformat=' + wfsOptions.outputFormat
                    : 'outputformat=' + wfsOptions.outputFormatDownload;
                const baseurl = DSOptions.download.dynamicUrl
                    .replace(/&?outputformat=[^&]*/gi, '')
                    .replace(/&?filter=[^&]*/gi, '')
                    .replace(/&?bbox=[^&]*/gi, '');
                const ogcFilters = layer.dataSource.options.ogcFilters;
                let filterQueryString;
                filterQueryString = new OgcFilterWriter().handleOgcFiltersAppliedValue(layer.dataSource.options, ogcFilters.geometryName, currentExtent, currentProj);
                if (!filterQueryString) {
                    // Prevent getting all the features for empty filter
                    filterQueryString = new OgcFilterWriter().buildFilter(undefined, currentExtent, currentProj, ogcFilters.geometryName);
                }
                else {
                    filterQueryString = 'filter=' + encodeURIComponent(filterQueryString);
                }
                window.open(`${baseurl}&${filterQueryString}&${outputFormatDownload}`, '_blank');
            }
            else if (DSOptions.download) {
                window.open(DSOptions.download.url, '_blank');
            }
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DownloadService, deps: [{ token: i2.MessageService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DownloadService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DownloadService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i2.MessageService }]; } });

class DownloadButtonComponent {
    downloadService;
    get layer() {
        return this._layer;
    }
    set layer(value) {
        this._layer = value;
    }
    _layer;
    get color() {
        return this._color;
    }
    set color(value) {
        this._color = value;
    }
    _color = 'primary';
    constructor(downloadService) {
        this.downloadService = downloadService;
    }
    openDownload(layer) {
        this.downloadService.open(layer);
    }
    get options() {
        if (!this.layer) {
            return;
        }
        return this.layer.dataSource.options;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DownloadButtonComponent, deps: [{ token: DownloadService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DownloadButtonComponent, selector: "igo-download-button", inputs: { layer: "layer", color: "color" }, ngImport: i0, template: "<button\n  *ngIf=\"\n    options &&\n    options.download &&\n    (options.download['dynamicUrl'] || options.download['url'])\n  \"\n  mat-icon-button\n  tooltip-position=\"below\"\n  matTooltipShowDelay=\"500\"\n  [matTooltip]=\"'igo.geo.download.action' | translate\"\n  [color]=\"color\"\n  (click)=\"openDownload(layer)\"\n>\n  <mat-icon svgIcon=\"download\"></mat-icon>\n</button>\n", styles: [""], dependencies: [{ kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DownloadButtonComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-download-button', changeDetection: ChangeDetectionStrategy.OnPush, template: "<button\n  *ngIf=\"\n    options &&\n    options.download &&\n    (options.download['dynamicUrl'] || options.download['url'])\n  \"\n  mat-icon-button\n  tooltip-position=\"below\"\n  matTooltipShowDelay=\"500\"\n  [matTooltip]=\"'igo.geo.download.action' | translate\"\n  [color]=\"color\"\n  (click)=\"openDownload(layer)\"\n>\n  <mat-icon svgIcon=\"download\"></mat-icon>\n</button>\n" }]
        }], ctorParameters: function () { return [{ type: DownloadService }]; }, propDecorators: { layer: [{
                type: Input
            }], color: [{
                type: Input
            }] } });

class IgoDownloadModule {
    static forRoot() {
        return {
            ngModule: IgoDownloadModule
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoDownloadModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoDownloadModule, declarations: [DownloadButtonComponent], imports: [CommonModule,
            MatIconModule,
            MatButtonModule,
            MatTooltipModule,
            IgoLanguageModule], exports: [DownloadButtonComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoDownloadModule, imports: [CommonModule,
            MatIconModule,
            MatButtonModule,
            MatTooltipModule,
            IgoLanguageModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoDownloadModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        MatIconModule,
                        MatButtonModule,
                        MatTooltipModule,
                        IgoLanguageModule
                    ],
                    exports: [DownloadButtonComponent],
                    declarations: [DownloadButtonComponent]
                }]
        }] });

class DrawLayerPopupComponent {
    dialogRef;
    confirmFlag = false;
    constructor(dialogRef) {
        this.dialogRef = dialogRef;
    }
    cancelDrawing() {
        this.dialogRef.close();
    }
    confirm(labelString) {
        this.confirmFlag = true;
        this.dialogRef.close(labelString);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DrawLayerPopupComponent, deps: [{ token: i1$2.MatDialogRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DrawLayerPopupComponent, selector: "igo-draw-popup-component", inputs: { confirmFlag: "confirmFlag" }, ngImport: i0, template: "<div mat-dialog-content>\n  <p class=\"mat-typography\">\n    {{ 'igo.geo.draw.layer.layerDialogInstruction' | translate }}\n  </p>\n  <mat-form-field class=\"example-full-width\">\n    <input\n      #input\n      matInput\n      placeholder=\"{{ 'igo.geo.draw.layer.title' | translate }}\"\n    />\n  </mat-form-field>\n</div>\n<div mat-dialog-actions>\n  <button mat-raised-button (click)=\"cancelDrawing()\">\n    {{ 'igo.geo.draw.cancel' | translate }}\n  </button>\n  <button mat-raised-button color=\"primary\" (click)=\"confirm(input.value)\">\n    OK\n  </button>\n</div>\n", styles: [":host .fields-container{display:flex}\n"], dependencies: [{ kind: "component", type: i4$1.MatButton, selector: "    button[mat-button], button[mat-raised-button], button[mat-flat-button],    button[mat-stroked-button]  ", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "component", type: i8.MatFormField, selector: "mat-form-field", inputs: ["hideRequiredMarker", "color", "floatLabel", "appearance", "subscriptSizing", "hintLabel"], exportAs: ["matFormField"] }, { kind: "directive", type: i9$3.MatInput, selector: "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", inputs: ["disabled", "id", "placeholder", "name", "required", "type", "errorStateMatcher", "aria-describedby", "value", "readonly"], exportAs: ["matInput"] }, { kind: "directive", type: i1$2.MatDialogContent, selector: "[mat-dialog-content], mat-dialog-content, [matDialogContent]" }, { kind: "directive", type: i1$2.MatDialogActions, selector: "[mat-dialog-actions], mat-dialog-actions, [matDialogActions]", inputs: ["align"] }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DrawLayerPopupComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-draw-popup-component', template: "<div mat-dialog-content>\n  <p class=\"mat-typography\">\n    {{ 'igo.geo.draw.layer.layerDialogInstruction' | translate }}\n  </p>\n  <mat-form-field class=\"example-full-width\">\n    <input\n      #input\n      matInput\n      placeholder=\"{{ 'igo.geo.draw.layer.title' | translate }}\"\n    />\n  </mat-form-field>\n</div>\n<div mat-dialog-actions>\n  <button mat-raised-button (click)=\"cancelDrawing()\">\n    {{ 'igo.geo.draw.cancel' | translate }}\n  </button>\n  <button mat-raised-button color=\"primary\" (click)=\"confirm(input.value)\">\n    OK\n  </button>\n</div>\n", styles: [":host .fields-container{display:flex}\n"] }]
        }], ctorParameters: function () { return [{ type: i1$2.MatDialogRef }]; }, propDecorators: { confirmFlag: [{
                type: Input
            }] } });

const MEASURE_UNIT_AUTO = 'auto';
var MeasureType;
(function (MeasureType) {
    MeasureType["Length"] = "length";
    MeasureType["Area"] = "area";
})(MeasureType || (MeasureType = {}));
var MeasureLengthUnit;
(function (MeasureLengthUnit) {
    MeasureLengthUnit["Meters"] = "meters";
    MeasureLengthUnit["Kilometers"] = "kilometers";
    MeasureLengthUnit["Miles"] = "miles";
    MeasureLengthUnit["Feet"] = "feet";
})(MeasureLengthUnit || (MeasureLengthUnit = {}));
const MeasureLengthUnitAbbreviation = {
    [MeasureLengthUnit.Meters]: 'm',
    [MeasureLengthUnit.Kilometers]: 'km',
    [MeasureLengthUnit.Miles]: 'mi',
    [MeasureLengthUnit.Feet]: 'ft'
};
var MeasureAreaUnit;
(function (MeasureAreaUnit) {
    MeasureAreaUnit["SquareMeters"] = "squareMeters";
    MeasureAreaUnit["SquareKilometers"] = "squareKilometers";
    MeasureAreaUnit["SquareMiles"] = "squareMiles";
    MeasureAreaUnit["SquareFeet"] = "squareFeet";
    MeasureAreaUnit["Hectares"] = "hectares";
    MeasureAreaUnit["Acres"] = "acres";
})(MeasureAreaUnit || (MeasureAreaUnit = {}));
const MeasureAreaUnitAbbreviation = {
    [MeasureAreaUnit.SquareMeters]: 'm²',
    [MeasureAreaUnit.SquareKilometers]: 'km²',
    [MeasureAreaUnit.SquareMiles]: 'mi²',
    [MeasureAreaUnit.SquareFeet]: 'ft²',
    [MeasureAreaUnit.Hectares]: 'ha',
    [MeasureAreaUnit.Acres]: 'ac'
};

/**
 * Convert value from meters to kilometers
 * @param value Value in meters
 * @returns Value in kilometers
 */
function metersToKilometers(value) {
    return value * 0.001;
}
/**
 * Convert value from meters to feet
 * @param value Value in meters
 * @returns Value in feet
 */
function metersToFeet(value) {
    return value * 3.2808;
}
/**
 * Convert value from meters to miles
 * @param value Value in meters
 * @returns Value in miles
 */
function metersToMiles(value) {
    return value * 0.000621;
}
/**
 * Convert value from square meters to square kilometers
 * @param value Value in square meters
 * @returns Value in square kilometers
 */
function squareMetersToSquareKilometers(value) {
    return value * 0.000001;
}
/**
 * Convert value from square meters to square miles
 * @param value Value in square meters
 * @returns Value in square miles
 */
function squareMetersToSquareMiles(value) {
    return value * 0.0000003861;
}
/**
 * Convert value from square meters to square feet
 * @param value Value in square meters
 * @returns Value in square feet
 */
function squareMetersToSquareFeet(value) {
    return value * 10.764;
}
/**
 * Convert value from square meters to hectares
 * @param value Value in square meters
 * @returns Value in hectares
 */
function squareMetersToHectares(value) {
    return value * 0.0001;
}
/**
 * Convert value from square meters to acres
 * @param value Value in square meters
 * @returns Value in acres
 */
function squareMetersToAcres(value) {
    return value * 0.00024711;
}
/**
 * Convert value from meters to the specified length unit
 * @param value Value in meters
 * @param unit Length unit
 * @returns Value in unit
 */
function metersToUnit(value, unit) {
    const conversionMapper = new Map([
        [MeasureLengthUnit.Meters, (val) => val],
        [MeasureLengthUnit.Kilometers, metersToKilometers],
        [MeasureLengthUnit.Miles, metersToMiles],
        [MeasureLengthUnit.Feet, metersToFeet]
    ]);
    const conversion = conversionMapper.get(unit);
    return conversion ? conversion(value) : undefined;
}
/**
 * Convert value from square meters to the specified area unit
 * @param value Value in meters
 * @param unit Area unit
 * @returns Value in unit
 */
function squareMetersToUnit(value, unit) {
    const conversionMapper = new Map([
        [MeasureAreaUnit.SquareMeters, (val) => val],
        [MeasureAreaUnit.SquareKilometers, squareMetersToSquareKilometers],
        [MeasureAreaUnit.SquareMiles, squareMetersToSquareMiles],
        [MeasureAreaUnit.SquareFeet, squareMetersToSquareFeet],
        [MeasureAreaUnit.Hectares, squareMetersToHectares],
        [MeasureAreaUnit.Acres, squareMetersToAcres]
    ]);
    const conversion = conversionMapper.get(unit);
    return conversion ? conversion(value) : undefined;
}
/**
 * This method format a measure to a readable format
 * @param measure Measure
 * @param options Formatting options
 * @returns Formatted measure
 */
function formatMeasure(measure, options, languageService) {
    let decimal = options.decimal;
    if (decimal === undefined || decimal < 0) {
        decimal = 1;
    }
    const parts = [];
    if (options.locale !== undefined) {
        parts.push(measure.toLocaleString(options.locale, {
            minimumFractionDigits: decimal,
            maximumFractionDigits: decimal
        }));
    }
    else {
        parts.push(measure.toFixed(decimal).toString());
    }
    if (options.unit !== undefined && options.unitAbbr === true) {
        if (languageService) {
            parts.push(MeasureLengthUnitAbbreviation[options.unit]
                ? languageService.translate.instant('igo.geo.measure.' + MeasureLengthUnitAbbreviation[options.unit])
                : languageService.translate.instant('igo.geo.measure.' + MeasureAreaUnitAbbreviation[options.unit]));
        }
        else {
            parts.push(MeasureLengthUnitAbbreviation[options.unit] ||
                MeasureAreaUnitAbbreviation[options.unit]);
        }
    }
    return parts.filter((p) => p !== undefined).join(' ');
}
/**
 * Compute best length measure unit for a given measure in meters
 * @param value Value in meters
 * @returns Measure unit
 */
function computeBestLengthUnit(value) {
    let unit = MeasureLengthUnit.Meters;
    let converted = value;
    const possibleUnits = [MeasureLengthUnit.Kilometers];
    while (converted > 1000 && possibleUnits.length > 0) {
        unit = possibleUnits.pop();
        converted = metersToUnit(value, unit);
    }
    return unit;
}
/**
 * Compute best length measure unit for a given measure in square meters
 * @param value Value in meters
 * @returns Measure unit
 */
function computeBestAreaUnit(value) {
    let unit = MeasureAreaUnit.SquareMeters;
    let converted = value;
    const possibleUnits = [MeasureAreaUnit.SquareKilometers];
    while (converted > 1000000 && possibleUnits.length > 0) {
        unit = possibleUnits.pop();
        converted = squareMetersToUnit(value, unit);
    }
    return unit;
}
/**
 * Create a default style for a measure interaction
 * @returns OL style
 */
function createMeasureInteractionStyle() {
    return new olStyle.Style({
        stroke: new olStyle.Stroke({
            color: '#ffcc33',
            lineDash: [10, 10],
            width: 2
        }),
        fill: new olStyle.Fill({
            color: 'rgba(255, 255, 255, 0.2)'
        }),
        image: new olStyle.Circle({
            radius: 5,
            stroke: new olStyle.Stroke({
                color: '#ffcc33'
            }),
            fill: new olStyle.Fill({
                color: 'rgba(255, 255, 255, 0.2)'
            })
        })
    });
}
/**
 * Create a default style for a measure layer
 * @returns OL style
 */
function createMeasureLayerStyle() {
    return new olStyle.Style({
        stroke: new olStyle.Stroke({
            color: '#ffcc33',
            width: 2
        }),
        fill: new olStyle.Fill({
            color: 'rgba(255, 255, 255, 0.2)'
        })
    });
}
/**
 * Compute the length in meters of an OL geometry with a given projection
 * @param olGeometry Ol geometry
 * @param projection olGeometry's projection
 * @returns Length in meters
 */
function measureOlGeometryLength(olGeometry, projection) {
    if (olGeometry instanceof OlPoint) {
        return undefined;
    }
    if (olGeometry.getFlatCoordinates().length === 0) {
        return undefined;
    }
    return getLength(olGeometry, { projection });
}
/**
 * Compute the area in square meters of an OL geometry with a given projection
 * @param olGeometry Ol geometry
 * @param projection olGeometry's projection
 * @returns Area in square meters
 */
function measureOlGeometryArea(olGeometry, projection) {
    if (olGeometry instanceof OlPoint || olGeometry instanceof OlLineString) {
        return undefined;
    }
    if (olGeometry.getFlatCoordinates().length === 0) {
        return undefined;
    }
    return getArea(olGeometry, { projection });
}
/**
 * Compute the area (square meters), length (meters) and last length (meters)
 * of an OL geometry with a given projection.
 * @param olGeometry Ol geometry
 * @param projection olGeometry's projection
 * @returns Computed measure
 */
function measureOlGeometry(olGeometry, projection) {
    const length = measureOlGeometryLength(olGeometry, projection);
    const area = measureOlGeometryArea(olGeometry, projection);
    const lengths = [];
    const coordinates = olGeometry.getFlatCoordinates();
    const coordinatesLength = coordinates.length;
    for (let i = 0; i <= coordinatesLength - 4; i += 2) {
        const olSegment = new OlLineString([
            [coordinates[i], coordinates[i + 1]],
            [coordinates[i + 2], coordinates[i + 3]]
        ]);
        lengths.push(measureOlGeometryLength(olSegment, projection));
    }
    return {
        area,
        length,
        lengths
    };
}
/**
 * Update an OL geometry midpoints and return an array of those points
 * @param olGeometry OL Geometry
 * @returns OL points
 */
function updateOlGeometryMidpoints(olGeometry) {
    let olMidpoints;
    if (olGeometry instanceof OlPoint) {
        const olMidpointPoint = new OlPoint(olGeometry.getFlatCoordinates());
        olMidpoints = new Array(1);
        olMidpoints[0] = olMidpointPoint;
    }
    else {
        olMidpoints = getOlGeometryMidpoints(olGeometry);
        // TODO: handle multi geometries
        const coordinates = olGeometry.getFlatCoordinates();
        const midpointsLength = olMidpoints.length;
        for (let i = 0; i < midpointsLength; i++) {
            const j = i * 2;
            const olSegment = new OlLineString([
                [coordinates[j], coordinates[j + 1]],
                [coordinates[j + 2], coordinates[j + 3]]
            ]);
            const midpointCoordinate = olSegment.getCoordinateAt(0.5);
            const olMidpoint = olMidpoints[i];
            if (olMidpoint !== undefined) {
                olMidpoint.setCoordinates(midpointCoordinate);
            }
            else {
                olMidpoints[i] = new OlPoint(midpointCoordinate);
            }
        }
    }
    return olMidpoints;
}
/**
 * Clear an OL geometry midpoints and return an array of those points
 * @param olGeometry OL Geometry
 */
function clearOlGeometryMidpoints(olGeometry) {
    const olMidpoints = olGeometry.get('_midpoints') || [];
    const midpointsLength = olMidpoints.length;
    for (let i = 0; i < midpointsLength; i++) {
        const olMidpoint = olMidpoints[i];
        if (olMidpoint !== undefined) {
            if (olMidpoint !== undefined) {
                clearOlMidpointTooltip(olMidpoint);
            }
        }
    }
    olGeometry.set('_midpoints', undefined, true);
    return olMidpoints;
}
/**
 * Return an array of  OL geometry midpoints, if any
 * @param olGeometry OL Geometry
 * @returns OL points
 */
function getOlGeometryMidpoints(olGeometry) {
    let expectedNumber;
    if (olGeometry instanceof OlCircle) {
        expectedNumber = 0;
    }
    else {
        expectedNumber = Math.max(olGeometry.getFlatCoordinates().length / 2 - 1, 0);
    }
    // TODO: This works but it's quite messy. If time permits,
    // clean this. Maybe a Tooltip class could handle that
    let olMidpoints = olGeometry.get('_midpoints');
    if (olMidpoints === undefined) {
        if (olGeometry instanceof OlPoint) {
            olMidpoints = new Array(1);
        }
        else {
            olMidpoints = new Array(expectedNumber);
        }
        olGeometry.set('_midpoints', olMidpoints, true);
        return olMidpoints;
    }
    if (expectedNumber === 0) {
        return olMidpoints;
    }
    if (expectedNumber === olMidpoints.length) {
        return olMidpoints;
    }
    if (expectedNumber > olMidpoints.length) {
        olMidpoints.push(...new Array(expectedNumber - olMidpoints.length));
        return olMidpoints;
    }
    for (let i = expectedNumber; i < olMidpoints.length; i++) {
        const olMidpoint = olMidpoints[expectedNumber];
        if (olMidpoint !== undefined) {
            clearOlMidpointTooltip(olMidpoint);
        }
    }
    olMidpoints.splice(expectedNumber);
    return olMidpoints;
}
/**
 * Remove an OL midpoint's tooltip from the map
 * @param olMidpoint OL Point
 */
function clearOlMidpointTooltip(olMidpoint) {
    const olTooltip = olMidpoint.get('_tooltip');
    if (olTooltip !== undefined) {
        const olMap = olTooltip.getMap();
        if (olMap !== undefined) {
            olMap.removeOverlay(olTooltip);
        }
    }
}
/**
 * Add an OL overlay at each midpoint and return an array of those overlays
 * @param olGeometry OL Geometry
 * @returns OL overlays
 */
function updateOlTooltipsAtMidpoints(olGeometry) {
    const olMidpoints = updateOlGeometryMidpoints(olGeometry);
    let typeGeom = '';
    if (olGeometry instanceof OlLineString) {
        typeGeom = 'line-';
    }
    else if (olGeometry instanceof OlPolygon) {
        typeGeom = 'polygone-';
    }
    const olTooltips = olMidpoints.map((olMidpoint) => {
        let olTooltip = olMidpoint.get('_tooltip');
        if (olTooltip === undefined) {
            olTooltip = createOlTooltipAtPoint(olMidpoint, false, typeGeom);
        }
        else {
            olTooltip.setPosition(olMidpoint.getFlatCoordinates());
        }
        return olTooltip;
    });
    return olTooltips;
}
/**
 * Return an array of OL overlay at midspoints, if any
 * @param olGeometry OL Geometry
 * @returns OL overlays
 */
function getOlTooltipsAtMidpoints(olGeometry) {
    const olMidpoints = getOlGeometryMidpoints(olGeometry);
    return olMidpoints.map((olMidpoint) => {
        return olMidpoint ? olMidpoint.get('_tooltip') : undefined;
    });
}
/**
 * Update an OL geometry center and return it
 * @param olGeometry OL Geometry
 * @returns OL point
 */
function updateOlGeometryCenter(olGeometry) {
    let olCenter = olGeometry.get('_center');
    const centerCoordinate = getCenter(olGeometry.getExtent());
    if (olCenter !== undefined) {
        olCenter.setCoordinates(centerCoordinate);
    }
    else {
        olCenter = new OlPoint(centerCoordinate);
        olGeometry.set('_center', olCenter);
    }
    return olCenter;
}
/**
 * Add an OL overlay at the center of a geometry and return that overlay
 * @param olGeometry OL Geometry
 * @returns OL overlay
 */
function updateOlTooltipAtCenter(olGeometry) {
    const olCenter = updateOlGeometryCenter(olGeometry);
    let olTooltip = olCenter.get('_tooltip');
    if (olTooltip === undefined) {
        olTooltip = createOlTooltipAtPoint(olCenter, true);
    }
    else {
        olTooltip.setPosition(olCenter.getFlatCoordinates());
    }
    return olTooltip;
}
/**
 * Return an array of OL overlay at midspoints, if any
 * @param olGeometry OL Geometry
 * @returns OL overlays
 */
function getOlTooltipAtCenter(olGeometry) {
    const olCenter = olGeometry.get('_center');
    return olCenter ? olCenter.get('_tooltip') : undefined;
}
/**
 * Get all the tooltips of an OL geometry
 * @param olGeometry OL Geometry
 * @returns OL overlays
 */
function getTooltipsOfOlGeometry(olGeometry) {
    const olTooltips = [].concat(getOlTooltipsAtMidpoints(olGeometry) || []);
    const olCenterTooltip = getOlTooltipAtCenter(olGeometry);
    if (olCenterTooltip !== undefined) {
        olTooltips.push(olCenterTooltip);
    }
    return olTooltips;
}
/**
 * Create an OL overlay at a point and bind the overlay to the point
 * @param olPoint OL Point
 * @returns OL overlay
 */
function createOlTooltipAtPoint(olPoint, center = false, srcGeomType = '') {
    const olTooltip = new OlOverlay({
        element: document.createElement('div'),
        offset: [-30, -10],
        className: (center
            ? [
                'igo-map-tooltip',
                'igo-map-tooltip-measure',
                'igo-map-tooltip-measure-area'
            ]
            : [
                'igo-map-tooltip',
                'igo-map-tooltip-measure',
                `igo-map-tooltip-measure-${srcGeomType}segments`
            ]).join(' '),
        stopEvent: false
    });
    olTooltip.setPosition(olPoint.getFlatCoordinates());
    olPoint.set('_tooltip', olTooltip);
    return olTooltip;
}

var GeometryType;
(function (GeometryType) {
    GeometryType["Point"] = "Point";
    GeometryType["LineString"] = "LineString";
    GeometryType["Polygon"] = "Polygon";
    GeometryType["Circle"] = "Circle";
})(GeometryType || (GeometryType = {}));
var LabelType;
(function (LabelType) {
    LabelType["Coordinates"] = "Coordinates";
    LabelType["Length"] = "Length";
    LabelType["Area"] = "Area";
    LabelType["Predefined"] = "Predefined";
    LabelType["Custom"] = "Custom";
})(LabelType || (LabelType = {}));
var CoordinatesUnit;
(function (CoordinatesUnit) {
    CoordinatesUnit["DecimalDegree"] = "DD";
    CoordinatesUnit["DegreesMinutesSeconds"] = "DMS";
})(CoordinatesUnit || (CoordinatesUnit = {}));

/**
 * Create a default style
 * @param fillColor the fill color
 * @param strokeColor the stroke color
 * @param strokeWidth the stroke width
 * @param label a label
 * @returns OL style
 */
function createInteractionStyle(fillColor, strokeColor, strokeWidth, label) {
    return new olStyle.Style({
        stroke: new olStyle.Stroke({
            color: strokeColor ? strokeColor : 'rgba(143,7,7,1)',
            width: strokeWidth ? strokeWidth : 1
        }),
        fill: new olStyle.Fill({
            color: fillColor ? fillColor : 'rgba(255,255,255,0.4)'
        }),
        image: new olStyle.Circle({
            radius: 5,
            stroke: new olStyle.Stroke({
                color: strokeColor ? strokeColor : 'rgba(143,7,7,1)',
                width: strokeWidth ? strokeWidth : 1
            }),
            fill: new olStyle.Fill({
                color: fillColor ? fillColor : 'rgba(255,255,255,0.4)'
            })
        })
    });
}
/**
 * Add an OL overlay at each midpoint and return an array of those overlays
 * @param olGeometry OL Geometry
 * @returns OL overlays
 */
function updateOlTooltipsDrawAtMidpoints(olGeometry) {
    let olMidpoints;
    if (olGeometry instanceof OlPoint) {
        const olMidpointPoint = new OlPoint(olGeometry.getFlatCoordinates());
        olMidpoints = new Array(1);
        olMidpoints[0] = olMidpointPoint;
        olGeometry.setProperties({ _midpoints: olMidpoints }, true);
    }
    else if (olGeometry instanceof OlCircle) {
        const olMidpointPoint = new OlPoint(olGeometry.getCenter());
        olMidpoints = new Array(1);
        olMidpoints[0] = olMidpointPoint;
        olGeometry.setProperties({ _midpoints: olMidpoints }, true);
    }
    else {
        olMidpoints = updateOlGeometryMidpoints(olGeometry);
    }
    const olTooltips = olMidpoints.map((olMidpoint) => {
        let olTooltip = olMidpoint.get('_tooltip');
        if (olTooltip === undefined) {
            olTooltip = createOlTooltipDrawAtPoint(olMidpoint);
        }
        else {
            olTooltip.setPosition(olMidpoint.getFlatCoordinates());
        }
        return olTooltip;
    });
    return olTooltips;
}
/**
 * Add an OL overlay at the center of a geometry and return that overlay
 * @param olGeometry OL Geometry
 * @returns OL overlay
 */
function updateOlTooltipDrawAtCenter(olGeometry) {
    const olCenter = updateOlGeometryCenter(olGeometry);
    let olTooltip = olCenter.get('_tooltip');
    if (olTooltip === undefined) {
        olTooltip = createOlTooltipDrawAtPoint(olCenter);
    }
    else {
        olTooltip.setPosition(olCenter.getFlatCoordinates());
    }
    return olTooltip;
}
/**
 * Create an OL overlay at a point and bind the overlay to the point
 * @param olPoint OL Point
 * @returns OL overlay
 */
function createOlTooltipDrawAtPoint(olPoint) {
    const olTooltip = new OlOverlay({
        element: document.createElement('div'),
        offset: [-30, -10],
        className: ['igo-map-tooltip', 'igo-map-tooltip-draw'].join(' '),
        stopEvent: false
    });
    olTooltip.setPosition(olPoint.getFlatCoordinates());
    olPoint.set('_tooltip', olTooltip);
    return olTooltip;
}
function DDtoDMS(value, unit) {
    const conversionMapper = new Map([
        [
            CoordinatesUnit.DecimalDegree,
            (val) => {
                if (typeof val[0] === 'number') {
                    return roundCoordToString(val, 5);
                }
                else {
                    const numVal = [Number(val[0]), Number(val[1])];
                    return roundCoordToString(numVal, 5);
                }
            }
        ],
        [
            CoordinatesUnit.DegreesMinutesSeconds,
            (val) => convertDDToDMS(val, 2)
        ]
    ]);
    let conversion = conversionMapper.get(unit);
    return conversion ? conversion(value) : undefined;
}

class DrawPopupComponent {
    languageService;
    dialogRef;
    data;
    confirmFlag = false;
    labelFlag = LabelType.Custom;
    coordinatesMeasureUnit;
    lengthMeasureUnit;
    areaMeasureUnit;
    geometryType = GeometryType;
    labelType = LabelType;
    arrayBuiltInType = [];
    currentLabel;
    currentCoordinates;
    currentArea;
    currentLength;
    olGeometryType = undefined;
    lengthInMeters;
    areaInMetersSquare;
    coordinatesInDD;
    currentCoordinatesUnit;
    longlatDD;
    labelLength;
    polygonCheck = 0; // Count for polygon label types checkboxes
    constructor(languageService, dialogRef, data) {
        this.languageService = languageService;
        this.dialogRef = dialogRef;
        this.data = data;
        this.currentLabel = this.data.olGeometry.get('draw');
        this.labelLength = this.currentLabel ? this.currentLabel.length : 0;
        let olGeometry;
        const projection = this.data.map.ol.getView().getProjection();
        if (this.data.olGeometry instanceof OlFeature) {
            if (this.data.olGeometry.get('rad')) {
                const longitudeLatitude = [
                    this.data.olGeometry.get('longitude'),
                    this.data.olGeometry.get('latitude')
                ];
                this.olGeometryType = GeometryType.Circle;
                olGeometry = new OlCircle(longitudeLatitude, this.data.olGeometry.get('rad'));
            }
            else {
                this.olGeometryType = this.data.olGeometry.getGeometry().getType();
                olGeometry = this.data.olGeometry.get('geometry');
            }
        }
        else {
            this.olGeometryType = this.data.olGeometry.getType();
            olGeometry = this.data.olGeometry;
        }
        if (this.olGeometryType === GeometryType.Point ||
            this.olGeometryType === GeometryType.Circle) {
            if (this.data.olGeometry instanceof OlFeature) {
                let longitude = this.data.olGeometry.get('longitude');
                let latitude = this.data.olGeometry.get('latitude');
                this.longlatDD = roundCoordTo([longitude, latitude], 5);
                this.coordinatesInDD = '(' + latitude + ', ' + longitude + ')';
            }
            else {
                let point4326 = transform(this.data.olGeometry.getFlatCoordinates(), projection, 'EPSG:4326');
                this.longlatDD = roundCoordTo([point4326[0], point4326[1]], 5);
                this.coordinatesInDD =
                    '(' + this.longlatDD[1] + ', ' + this.longlatDD[0] + ')';
            }
            this.currentCoordinates = this.coordinatesInDD;
        }
        if (this.olGeometryType === GeometryType.LineString) {
            this.lengthInMeters = measureOlGeometryLength(olGeometry, projection.getCode()).toFixed(2);
            this.currentLength = this.lengthInMeters;
        }
        else if (this.olGeometryType === GeometryType.Polygon) {
            this.lengthInMeters = measureOlGeometryLength(olGeometry, projection.getCode()).toFixed(2);
            this.currentLength = this.lengthInMeters;
            this.areaInMetersSquare = measureOlGeometryArea(olGeometry, projection.getCode()).toFixed(2);
            this.currentArea = this.areaInMetersSquare;
        }
        else if (this.olGeometryType === GeometryType.Circle) {
            let circularPolygon = fromCircle(olGeometry, 10000);
            const radius = this.getRadius(circularPolygon);
            this.lengthInMeters = radius.toFixed(2);
            this.currentLength = this.lengthInMeters;
            this.areaInMetersSquare = measureOlGeometryArea(circularPolygon, projection.getCode()).toFixed(2);
            this.currentArea = this.areaInMetersSquare;
        }
        if (data.olGeometry.get('labelType') === LabelType.Coordinates) {
            this.onLabelTypeChange(LabelType.Predefined);
            this.onLabelTypeChange(LabelType.Coordinates, true);
            this.coordinatesMeasureUnit = data.olGeometry.get('measureUnit');
        }
        else if (data.olGeometry.get('labelType') === LabelType.Length) {
            this.onLabelTypeChange(LabelType.Predefined);
            this.onLabelTypeChange(LabelType.Length, true);
            this.lengthMeasureUnit = data.olGeometry.get('measureUnit');
        }
        else if (data.olGeometry.get('labelType') === LabelType.Area) {
            this.onLabelTypeChange(LabelType.Predefined);
            this.onLabelTypeChange(LabelType.Area, true);
            this.areaMeasureUnit = data.olGeometry.get('measureUnit');
        }
        else if (data.olGeometry.get('labelType')?.length === 2) {
            this.onLabelTypeChange(LabelType.Predefined);
            this.onLabelTypeChange(LabelType.Length, true);
            this.onLabelTypeChange(LabelType.Area, true);
            this.lengthMeasureUnit = data.olGeometry.get('measureUnit')[0];
            this.areaMeasureUnit = data.olGeometry.get('measureUnit')[1];
        }
        this.buildArrayType();
    }
    /**
     * HTML Interactions
     */
    cancelDrawing() {
        this.dialogRef.close();
    }
    confirm(input) {
        this.confirmFlag = true;
        if (this.labelFlag === LabelType.Predefined) {
            this.dialogRef.close();
        }
        else if (this.labelFlag === LabelType.Custom) {
            this.dialogRef.close({
                label: input
            });
        }
        else if (this.labelFlag === LabelType.Coordinates) {
            this.dialogRef.close({
                label: this.currentCoordinates,
                measureUnit: this.coordinatesMeasureUnit
            });
        }
        else if (this.olGeometryType === GeometryType.Polygon) {
            if (this.polygonCheck === 2) {
                this.labelFlag = [LabelType.Length, LabelType.Area];
                this.dialogRef.close({
                    label: 'P: ' +
                        this.currentLength +
                        ' ' +
                        MeasureLengthUnitAbbreviation[MeasureLengthUnit.Meters] +
                        '\n' +
                        this.languageService.translate.instant('igo.geo.draw.labelType.A') +
                        this.currentArea +
                        ' ' +
                        MeasureAreaUnitAbbreviation[MeasureAreaUnit.SquareMeters],
                    measureUnit: [this.lengthMeasureUnit, this.areaMeasureUnit]
                });
            }
            else {
                this.labelFlag === LabelType.Length
                    ? this.dialogRef.close({
                        label: 'P: ' +
                            this.currentLength +
                            ' ' +
                            MeasureLengthUnitAbbreviation[this.lengthMeasureUnit],
                        measureUnit: this.lengthMeasureUnit
                    })
                    : this.dialogRef.close({
                        label: this.currentArea +
                            ' ' +
                            MeasureAreaUnitAbbreviation[this.areaMeasureUnit],
                        measureUnit: this.areaMeasureUnit
                    });
            }
        }
        else if (this.labelFlag === LabelType.Length) {
            if (this.olGeometryType === GeometryType.Circle) {
                this.dialogRef.close({
                    label: 'R: ' +
                        this.currentLength +
                        ' ' +
                        MeasureLengthUnitAbbreviation[this.lengthMeasureUnit],
                    measureUnit: this.lengthMeasureUnit
                });
            }
            else if (this.olGeometryType === GeometryType.LineString) {
                this.dialogRef.close({
                    label: this.currentLength +
                        ' ' +
                        MeasureLengthUnitAbbreviation[this.lengthMeasureUnit],
                    measureUnit: this.lengthMeasureUnit
                });
            }
        }
        else if (this.labelFlag === LabelType.Area) {
            this.dialogRef.close({
                label: this.currentArea +
                    ' ' +
                    MeasureAreaUnitAbbreviation[this.areaMeasureUnit],
                measureUnit: this.areaMeasureUnit
            });
        }
    }
    onLabelTypeChange(labelType, checked) {
        if (labelType !== LabelType.Predefined &&
            labelType !== LabelType.Custom &&
            this.olGeometryType === GeometryType.Polygon) {
            this.arrayBuiltInType.find((type) => type.value === labelType)
                ? (this.arrayBuiltInType.find((type) => type.value === labelType).checked = checked)
                : (this.labelFlag = undefined);
            checked
                ? (this.labelFlag = labelType)
                : (this.labelFlag = this.arrayBuiltInType.find((type) => type.checked)
                    ?.value);
        }
        else {
            this.labelFlag = labelType;
        }
        if (labelType === LabelType.Predefined) {
            if (this.olGeometryType === GeometryType.Point) {
                this.labelFlag = LabelType.Coordinates;
                this.currentCoordinates = this.coordinatesInDD;
                this.coordinatesMeasureUnit = CoordinatesUnit.DecimalDegree;
            }
            else if (this.olGeometryType === GeometryType.LineString) {
                this.labelFlag = LabelType.Length;
                this.currentLength = this.lengthInMeters;
                this.lengthMeasureUnit = MeasureLengthUnit.Meters;
            }
        }
        else if (labelType === LabelType.Area) {
            this.currentArea = this.areaInMetersSquare;
            this.areaMeasureUnit = MeasureAreaUnit.SquareMeters;
        }
        else if (labelType === LabelType.Length) {
            this.currentLength = this.lengthInMeters;
            this.lengthMeasureUnit = MeasureLengthUnit.Meters;
        }
        else if (this.labelFlag === LabelType.Coordinates) {
            this.currentCoordinates = this.coordinatesInDD;
            this.coordinatesMeasureUnit = CoordinatesUnit.DecimalDegree;
        }
        const labeltypes = [this.labelType.Length, this.labelType.Area];
        if (this.olGeometryType === GeometryType.Polygon &&
            labeltypes.includes(labelType)) {
            checked ? (this.polygonCheck += 1) : (this.polygonCheck -= 1);
        }
        else {
            this.polygonCheck = 0;
        }
    }
    onChangeLengthUnit(lengthUnit) {
        this.lengthMeasureUnit = lengthUnit;
        this.currentLength = metersToUnit(Number(this.lengthInMeters), lengthUnit).toFixed(2);
    }
    onChangeAreaUnit(areaUnit) {
        this.areaMeasureUnit = areaUnit;
        this.currentArea = squareMetersToUnit(Number(this.areaInMetersSquare), areaUnit).toFixed(2);
    }
    onChangeCoordinateUnit(coordinatesUnit) {
        this.coordinatesMeasureUnit = coordinatesUnit;
        let coordinates = DDtoDMS(this.longlatDD, coordinatesUnit);
        this.currentCoordinates =
            '(' + coordinates[1] + ', ' + coordinates[0] + ')';
    }
    buildArrayType() {
        for (const labelType of Object.values(LabelType)) {
            if (labelType !== LabelType.Custom &&
                labelType !== LabelType.Predefined) {
                this.arrayBuiltInType.push({
                    value: labelType,
                    checked: this.selectOptions(labelType) ||
                        this.labelFlag === labelType ||
                        (this.polygonCheck === 2 && labelType !== LabelType.Coordinates)
                });
            }
        }
    }
    noLabelButton() {
        if (this.labelFlag === LabelType.Predefined ||
            (this.labelFlag === LabelType.Custom && this.labelLength === 0)) {
            return this.languageService.translate.instant('igo.geo.draw.noLabel');
        }
        return 'OK';
    }
    get customOrPredefined() {
        if (this.labelFlag === LabelType.Custom) {
            return LabelType.Custom;
        }
        return LabelType.Predefined;
    }
    optionAvailable(currentOption) {
        switch (this.olGeometryType) {
            case GeometryType.Point:
                if (currentOption === LabelType.Coordinates) {
                    return false;
                }
                return true;
            case GeometryType.LineString:
                if (currentOption === LabelType.Length) {
                    return false;
                }
                return true;
            case GeometryType.Polygon:
                if (currentOption === LabelType.Coordinates) {
                    return true;
                }
                return false;
            default:
                return false;
        }
    }
    get allLengthUnits() {
        return Object.values(MeasureLengthUnit);
    }
    getLengthUnitEnum(lengthUnit) {
        return MeasureLengthUnitAbbreviation[lengthUnit];
    }
    get allAreaUnits() {
        return Object.values(MeasureAreaUnit);
    }
    get allCoordinatesUnits() {
        return Object.values(CoordinatesUnit);
    }
    getAreaUnitEnum(areaUnit) {
        return MeasureAreaUnitAbbreviation[areaUnit];
    }
    getRadius(olGeometry) {
        const length = getLength(olGeometry);
        return Number(length / (2 * Math.PI));
    }
    get lengthLabelT() {
        if (this.olGeometryType === GeometryType.Polygon) {
            return this.languageService.translate.instant('igo.geo.measure.perimeter');
        }
        if (this.olGeometryType === GeometryType.Circle) {
            return this.languageService.translate.instant('igo.geo.search.coordinates.radius');
        }
        return this.languageService.translate.instant('igo.geo.draw.labelType.Length');
    }
    getLabelLength(event) {
        this.labelLength = event.length;
    }
    selectOptions(option) {
        if (this.olGeometryType === GeometryType.Point) {
            return option === LabelType.Coordinates;
        }
        else if (this.olGeometryType === GeometryType.LineString) {
            return option === LabelType.Length;
        }
    }
    getProperLengthLabel(option) {
        if (option === LabelType.Length) {
            if (this.olGeometryType === GeometryType.Polygon) {
                return this.languageService.translate.instant('igo.geo.measure.perimeter');
            }
            if (this.olGeometryType === GeometryType.Circle) {
                return this.languageService.translate.instant('igo.geo.search.coordinates.radius');
            }
            return this.languageService.translate.instant('igo.geo.draw.labelType.Length');
        }
        return this.languageService.translate.instant('igo.geo.draw.labelType.' + option);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DrawPopupComponent, deps: [{ token: i2.LanguageService }, { token: i1$2.MatDialogRef }, { token: MAT_DIALOG_DATA }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DrawPopupComponent, selector: "igo-draw-popup-component", inputs: { confirmFlag: "confirmFlag", labelFlag: "labelFlag", coordinatesMeasureUnit: "coordinatesMeasureUnit", lengthMeasureUnit: "lengthMeasureUnit", areaMeasureUnit: "areaMeasureUnit" }, ngImport: i0, template: "<h2 mat-dialog-title>\n  {{ 'igo.geo.draw.popupTitle' | translate }}\n</h2>\n\n<ng-container *ngIf=\"labelFlag !== labelType.Custom\">\n  <div mat-dialog-content class=\"geometry-type-toggle\">\n    <div class=\"button-toggle-container\">\n      <mat-button-toggle-group\n        (change)=\"onLabelTypeChange($event.value)\"\n        [value]=\"customOrPredefined\"\n      >\n        <mat-button-toggle [value]=\"labelType.Custom\">\n          {{ 'igo.geo.draw.labelType.custom' | translate }}\n        </mat-button-toggle>\n        <mat-button-toggle [value]=\"labelType.Predefined\">\n          {{ 'igo.geo.draw.labelType.predefined' | translate }}\n        </mat-button-toggle>\n      </mat-button-toggle-group>\n    </div>\n    <div>\n      <p>\n        {{ 'igo.geo.draw.builtInInstructions' | translate }}\n      </p>\n      <mat-radio-group *ngIf=\"olGeometryType !== 'Polygon'\">\n        <mat-radio-button\n          *ngFor=\"let option of arrayBuiltInType\"\n          [value]=\"option.value\"\n          [disabled]=\"optionAvailable(option.value)\"\n          (change)=\"onLabelTypeChange($event.value)\"\n          [checked]=\"option.checked\"\n        >\n          {{ getProperLengthLabel(option.value) }}\n        </mat-radio-button>\n      </mat-radio-group>\n      <ng-container *ngIf=\"olGeometryType === 'Polygon'\">\n        <mat-checkbox\n          *ngFor=\"let option of arrayBuiltInType\"\n          class=\"mat-typography\"\n          [value]=\"option.value\"\n          [disabled]=\"optionAvailable(option.value)\"\n          (change)=\"onLabelTypeChange($event.source.value, $event.checked)\"\n          [checked]=\"option.checked\"\n        >\n          {{ getProperLengthLabel(option.value) }}\n        </mat-checkbox>\n      </ng-container>\n      <div *ngIf=\"labelFlag === labelType.Coordinates\" class=\"fields-container\">\n        <mat-form-field class=\"readOnly-Input\">\n          <mat-label>(Latitude, Longitude)</mat-label>\n          <input\n            #input\n            matInput\n            placeholder=\"(Latitude, Longitude)\"\n            value=\"{{ currentCoordinates }}\"\n            readonly\n          />\n        </mat-form-field>\n        <mat-form-field class=\"unit-field\">\n          <mat-select\n            [value]=\"coordinatesMeasureUnit\"\n            (selectionChange)=\"onChangeCoordinateUnit($event.value)\"\n          >\n            <mat-option *ngFor=\"let unit of allCoordinatesUnits\" [value]=\"unit\">\n              {{ unit }}\n            </mat-option>\n          </mat-select>\n        </mat-form-field>\n      </div>\n      <div\n        *ngIf=\"labelFlag === labelType.Length || polygonCheck === 2\"\n        class=\"fields-container\"\n      >\n        <mat-form-field class=\"readOnly-Input\">\n          <mat-label>{{ lengthLabelT }}</mat-label>\n          <input\n            #input\n            matInput\n            placeholder=\"{{ lengthLabelT }}\"\n            value=\"{{ currentLength }}\"\n            readonly\n          />\n        </mat-form-field>\n        <mat-form-field class=\"unit-field\">\n          <mat-select\n            [value]=\"lengthMeasureUnit\"\n            (selectionChange)=\"onChangeLengthUnit($event.value)\"\n          >\n            <mat-option *ngFor=\"let unit of allLengthUnits\" [value]=\"unit\">\n              {{ getLengthUnitEnum(unit) }}\n            </mat-option>\n          </mat-select>\n        </mat-form-field>\n      </div>\n      <div\n        *ngIf=\"labelFlag === labelType.Area || polygonCheck === 2\"\n        class=\"fields-container\"\n      >\n        <mat-form-field class=\"readOnly-Input\">\n          <mat-label>{{ 'igo.geo.draw.labelType.Area' | translate }}</mat-label>\n          <input\n            #input\n            matInput\n            placeholder=\"{{ 'igo.geo.draw.labelType.Area' | translate }}\"\n            value=\"{{ currentArea }}\"\n            readonly\n          />\n        </mat-form-field>\n        <mat-form-field class=\"unit-field\">\n          <mat-select\n            [value]=\"areaMeasureUnit\"\n            (selectionChange)=\"onChangeAreaUnit($event.value)\"\n          >\n            <mat-option *ngFor=\"let unit of allAreaUnits\" [value]=\"unit\">\n              {{ getAreaUnitEnum(unit) }}\n            </mat-option>\n          </mat-select>\n        </mat-form-field>\n      </div>\n    </div>\n  </div>\n\n  <div mat-dialog-actions>\n    <button mat-raised-button (click)=\"cancelDrawing()\">\n      {{ 'igo.geo.draw.cancel' | translate }}\n    </button>\n    <button mat-raised-button color=\"primary\" (click)=\"confirm()\">\n      {{ noLabelButton() }}\n    </button>\n  </div>\n</ng-container>\n\n<ng-container *ngIf=\"labelFlag === labelType.Custom\">\n  <div mat-dialog-content class=\"geometry-type-toggle\">\n    <div class=\"button-toggle-container\">\n      <mat-button-toggle-group\n        (change)=\"onLabelTypeChange($event.value)\"\n        [value]=\"customOrPredefined\"\n      >\n        <mat-button-toggle [value]=\"labelType.Custom\">\n          {{ 'igo.geo.draw.labelType.custom' | translate }}\n        </mat-button-toggle>\n        <mat-button-toggle [value]=\"labelType.Predefined\">\n          {{ 'igo.geo.draw.labelType.predefined' | translate }}\n        </mat-button-toggle>\n      </mat-button-toggle-group>\n    </div>\n    <p>\n      {{ 'igo.geo.draw.dialogInstruction' | translate }}\n    </p>\n    <mat-form-field class=\"input\">\n      <mat-label>{{ 'igo.geo.draw.dialogTitle' | translate }}</mat-label>\n      <input\n        #input\n        matInput\n        (select)=\"(true)\"\n        (input)=\"getLabelLength($event.target.value)\"\n        placeholder=\"{{ 'igo.geo.draw.dialogTitle' | translate }}\"\n        value=\"{{ currentLabel }}\"\n        cdkFocusInitial\n      />\n    </mat-form-field>\n  </div>\n\n  <div mat-dialog-actions>\n    <button mat-raised-button (click)=\"cancelDrawing()\">\n      {{ 'igo.geo.draw.cancel' | translate }}\n    </button>\n    <button mat-raised-button color=\"primary\" (click)=\"confirm(input.value)\">\n      {{ noLabelButton() }}\n    </button>\n  </div>\n</ng-container>\n", styles: [":host .mat-mdc-radio-button~.mat-radio-button{margin-left:12px}:host .readOnly-Input{width:200px!important}:host .button-toggle-container{margin-bottom:12px}:host .unit-field{margin-left:12px}:host .unit-field ::ng-deep .mat-mdc-form-field-infix{width:-moz-fit-content;width:fit-content}:host .unit-field ::ng-deep .mat-mdc-select-min-line{padding-right:24px}:host .mat-mdc-form-field{position:sticky!important}:host .coordinatesInputView{top:5em!important}:host .mat-mdc-dialog-actions{display:flex!important;justify-content:flex-end}:host .input{width:auto!important}:host .mat-button-toggle-group,:host .mat-button-toggle{width:100%}:host mat-checkbox{margin-right:10px}:host ::ng-deep mat-form-field .mat-mdc-form-field-subscript-wrapper{display:none}\n"], dependencies: [{ kind: "directive", type: i2$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i4$1.MatButton, selector: "    button[mat-button], button[mat-raised-button], button[mat-flat-button],    button[mat-stroked-button]  ", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "directive", type: i5$1.MatButtonToggleGroup, selector: "mat-button-toggle-group", inputs: ["appearance", "name", "vertical", "value", "multiple", "disabled"], outputs: ["valueChange", "change"], exportAs: ["matButtonToggleGroup"] }, { kind: "component", type: i5$1.MatButtonToggle, selector: "mat-button-toggle", inputs: ["disableRipple", "aria-label", "aria-labelledby", "id", "name", "value", "tabIndex", "appearance", "checked", "disabled"], outputs: ["change"], exportAs: ["matButtonToggle"] }, { kind: "component", type: i8.MatFormField, selector: "mat-form-field", inputs: ["hideRequiredMarker", "color", "floatLabel", "appearance", "subscriptSizing", "hintLabel"], exportAs: ["matFormField"] }, { kind: "directive", type: i8.MatLabel, selector: "mat-label" }, { kind: "directive", type: i9$3.MatInput, selector: "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", inputs: ["disabled", "id", "placeholder", "name", "required", "type", "errorStateMatcher", "aria-describedby", "value", "readonly"], exportAs: ["matInput"] }, { kind: "component", type: i15.MatSelect, selector: "mat-select", inputs: ["disabled", "disableRipple", "tabIndex", "panelWidth", "hideSingleSelectionIndicator"], exportAs: ["matSelect"] }, { kind: "component", type: i9.MatOption, selector: "mat-option", exportAs: ["matOption"] }, { kind: "directive", type: i1$2.MatDialogTitle, selector: "[mat-dialog-title], [matDialogTitle]", inputs: ["id"], exportAs: ["matDialogTitle"] }, { kind: "directive", type: i1$2.MatDialogContent, selector: "[mat-dialog-content], mat-dialog-content, [matDialogContent]" }, { kind: "directive", type: i1$2.MatDialogActions, selector: "[mat-dialog-actions], mat-dialog-actions, [matDialogActions]", inputs: ["align"] }, { kind: "directive", type: i8$2.MatRadioGroup, selector: "mat-radio-group", exportAs: ["matRadioGroup"] }, { kind: "component", type: i8$2.MatRadioButton, selector: "mat-radio-button", inputs: ["disableRipple", "tabIndex"], exportAs: ["matRadioButton"] }, { kind: "component", type: i11.MatCheckbox, selector: "mat-checkbox", inputs: ["disableRipple", "color", "tabIndex"], exportAs: ["matCheckbox"] }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DrawPopupComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-draw-popup-component', template: "<h2 mat-dialog-title>\n  {{ 'igo.geo.draw.popupTitle' | translate }}\n</h2>\n\n<ng-container *ngIf=\"labelFlag !== labelType.Custom\">\n  <div mat-dialog-content class=\"geometry-type-toggle\">\n    <div class=\"button-toggle-container\">\n      <mat-button-toggle-group\n        (change)=\"onLabelTypeChange($event.value)\"\n        [value]=\"customOrPredefined\"\n      >\n        <mat-button-toggle [value]=\"labelType.Custom\">\n          {{ 'igo.geo.draw.labelType.custom' | translate }}\n        </mat-button-toggle>\n        <mat-button-toggle [value]=\"labelType.Predefined\">\n          {{ 'igo.geo.draw.labelType.predefined' | translate }}\n        </mat-button-toggle>\n      </mat-button-toggle-group>\n    </div>\n    <div>\n      <p>\n        {{ 'igo.geo.draw.builtInInstructions' | translate }}\n      </p>\n      <mat-radio-group *ngIf=\"olGeometryType !== 'Polygon'\">\n        <mat-radio-button\n          *ngFor=\"let option of arrayBuiltInType\"\n          [value]=\"option.value\"\n          [disabled]=\"optionAvailable(option.value)\"\n          (change)=\"onLabelTypeChange($event.value)\"\n          [checked]=\"option.checked\"\n        >\n          {{ getProperLengthLabel(option.value) }}\n        </mat-radio-button>\n      </mat-radio-group>\n      <ng-container *ngIf=\"olGeometryType === 'Polygon'\">\n        <mat-checkbox\n          *ngFor=\"let option of arrayBuiltInType\"\n          class=\"mat-typography\"\n          [value]=\"option.value\"\n          [disabled]=\"optionAvailable(option.value)\"\n          (change)=\"onLabelTypeChange($event.source.value, $event.checked)\"\n          [checked]=\"option.checked\"\n        >\n          {{ getProperLengthLabel(option.value) }}\n        </mat-checkbox>\n      </ng-container>\n      <div *ngIf=\"labelFlag === labelType.Coordinates\" class=\"fields-container\">\n        <mat-form-field class=\"readOnly-Input\">\n          <mat-label>(Latitude, Longitude)</mat-label>\n          <input\n            #input\n            matInput\n            placeholder=\"(Latitude, Longitude)\"\n            value=\"{{ currentCoordinates }}\"\n            readonly\n          />\n        </mat-form-field>\n        <mat-form-field class=\"unit-field\">\n          <mat-select\n            [value]=\"coordinatesMeasureUnit\"\n            (selectionChange)=\"onChangeCoordinateUnit($event.value)\"\n          >\n            <mat-option *ngFor=\"let unit of allCoordinatesUnits\" [value]=\"unit\">\n              {{ unit }}\n            </mat-option>\n          </mat-select>\n        </mat-form-field>\n      </div>\n      <div\n        *ngIf=\"labelFlag === labelType.Length || polygonCheck === 2\"\n        class=\"fields-container\"\n      >\n        <mat-form-field class=\"readOnly-Input\">\n          <mat-label>{{ lengthLabelT }}</mat-label>\n          <input\n            #input\n            matInput\n            placeholder=\"{{ lengthLabelT }}\"\n            value=\"{{ currentLength }}\"\n            readonly\n          />\n        </mat-form-field>\n        <mat-form-field class=\"unit-field\">\n          <mat-select\n            [value]=\"lengthMeasureUnit\"\n            (selectionChange)=\"onChangeLengthUnit($event.value)\"\n          >\n            <mat-option *ngFor=\"let unit of allLengthUnits\" [value]=\"unit\">\n              {{ getLengthUnitEnum(unit) }}\n            </mat-option>\n          </mat-select>\n        </mat-form-field>\n      </div>\n      <div\n        *ngIf=\"labelFlag === labelType.Area || polygonCheck === 2\"\n        class=\"fields-container\"\n      >\n        <mat-form-field class=\"readOnly-Input\">\n          <mat-label>{{ 'igo.geo.draw.labelType.Area' | translate }}</mat-label>\n          <input\n            #input\n            matInput\n            placeholder=\"{{ 'igo.geo.draw.labelType.Area' | translate }}\"\n            value=\"{{ currentArea }}\"\n            readonly\n          />\n        </mat-form-field>\n        <mat-form-field class=\"unit-field\">\n          <mat-select\n            [value]=\"areaMeasureUnit\"\n            (selectionChange)=\"onChangeAreaUnit($event.value)\"\n          >\n            <mat-option *ngFor=\"let unit of allAreaUnits\" [value]=\"unit\">\n              {{ getAreaUnitEnum(unit) }}\n            </mat-option>\n          </mat-select>\n        </mat-form-field>\n      </div>\n    </div>\n  </div>\n\n  <div mat-dialog-actions>\n    <button mat-raised-button (click)=\"cancelDrawing()\">\n      {{ 'igo.geo.draw.cancel' | translate }}\n    </button>\n    <button mat-raised-button color=\"primary\" (click)=\"confirm()\">\n      {{ noLabelButton() }}\n    </button>\n  </div>\n</ng-container>\n\n<ng-container *ngIf=\"labelFlag === labelType.Custom\">\n  <div mat-dialog-content class=\"geometry-type-toggle\">\n    <div class=\"button-toggle-container\">\n      <mat-button-toggle-group\n        (change)=\"onLabelTypeChange($event.value)\"\n        [value]=\"customOrPredefined\"\n      >\n        <mat-button-toggle [value]=\"labelType.Custom\">\n          {{ 'igo.geo.draw.labelType.custom' | translate }}\n        </mat-button-toggle>\n        <mat-button-toggle [value]=\"labelType.Predefined\">\n          {{ 'igo.geo.draw.labelType.predefined' | translate }}\n        </mat-button-toggle>\n      </mat-button-toggle-group>\n    </div>\n    <p>\n      {{ 'igo.geo.draw.dialogInstruction' | translate }}\n    </p>\n    <mat-form-field class=\"input\">\n      <mat-label>{{ 'igo.geo.draw.dialogTitle' | translate }}</mat-label>\n      <input\n        #input\n        matInput\n        (select)=\"(true)\"\n        (input)=\"getLabelLength($event.target.value)\"\n        placeholder=\"{{ 'igo.geo.draw.dialogTitle' | translate }}\"\n        value=\"{{ currentLabel }}\"\n        cdkFocusInitial\n      />\n    </mat-form-field>\n  </div>\n\n  <div mat-dialog-actions>\n    <button mat-raised-button (click)=\"cancelDrawing()\">\n      {{ 'igo.geo.draw.cancel' | translate }}\n    </button>\n    <button mat-raised-button color=\"primary\" (click)=\"confirm(input.value)\">\n      {{ noLabelButton() }}\n    </button>\n  </div>\n</ng-container>\n", styles: [":host .mat-mdc-radio-button~.mat-radio-button{margin-left:12px}:host .readOnly-Input{width:200px!important}:host .button-toggle-container{margin-bottom:12px}:host .unit-field{margin-left:12px}:host .unit-field ::ng-deep .mat-mdc-form-field-infix{width:-moz-fit-content;width:fit-content}:host .unit-field ::ng-deep .mat-mdc-select-min-line{padding-right:24px}:host .mat-mdc-form-field{position:sticky!important}:host .coordinatesInputView{top:5em!important}:host .mat-mdc-dialog-actions{display:flex!important;justify-content:flex-end}:host .input{width:auto!important}:host .mat-button-toggle-group,:host .mat-button-toggle{width:100%}:host mat-checkbox{margin-right:10px}:host ::ng-deep mat-form-field .mat-mdc-form-field-subscript-wrapper{display:none}\n"] }]
        }], ctorParameters: function () { return [{ type: i2.LanguageService }, { type: i1$2.MatDialogRef }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [MAT_DIALOG_DATA]
                }] }]; }, propDecorators: { confirmFlag: [{
                type: Input
            }], labelFlag: [{
                type: Input
            }], coordinatesMeasureUnit: [{
                type: Input
            }], lengthMeasureUnit: [{
                type: Input
            }], areaMeasureUnit: [{
                type: Input
            }] } });

class DrawShorcutsComponent {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DrawShorcutsComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DrawShorcutsComponent, selector: "igo-draw-shorcuts", ngImport: i0, template: "<mat-dialog-content>\n  <div>\n    <span class=\"shortcut mat-typography\">\n      <mat-icon class=\"shortcut-icon\" svgIcon=\"keyboard-return\"></mat-icon\n      >{{ 'igo.geo.draw.finish' | translate }}</span\n    >\n  </div>\n  <div>\n    <span class=\"shortcut mat-typography\">\n      <mat-icon class=\"shortcut-icon\" svgIcon=\"backspace-outline\"></mat-icon\n      >{{ 'igo.geo.draw.undo' | translate }}</span\n    >\n  </div>\n  <div>\n    <span class=\"shortcut mat-typography\">\n      <mat-icon class=\"shortcut-icon\" svgIcon=\"keyboard-esc\"></mat-icon\n      >{{ 'igo.geo.draw.abort' | translate }}</span\n    >\n  </div>\n  <div>\n    <span class=\"shortcut mat-typography\">\n      <mat-icon class=\"shortcut-icon\" svgIcon=\"keyboard-space\"></mat-icon\n      >{{ 'igo.geo.draw.move' | translate }}</span\n    >\n  </div>\n</mat-dialog-content>\n<mat-dialog-actions class=\"shortcuts-close\">\n  <button mat-raised-button mat-dialog-close color=\"primary\">OK</button>\n</mat-dialog-actions>\n", styles: [".shortcut{display:flex;align-items:center}.shortcut-icon{margin-right:10px}.shortcuts-close{display:flex;justify-content:center}\n"], dependencies: [{ kind: "component", type: i4$1.MatButton, selector: "    button[mat-button], button[mat-raised-button], button[mat-flat-button],    button[mat-stroked-button]  ", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "directive", type: i1$2.MatDialogClose, selector: "[mat-dialog-close], [matDialogClose]", inputs: ["aria-label", "type", "mat-dialog-close", "matDialogClose"], exportAs: ["matDialogClose"] }, { kind: "directive", type: i1$2.MatDialogContent, selector: "[mat-dialog-content], mat-dialog-content, [matDialogContent]" }, { kind: "directive", type: i1$2.MatDialogActions, selector: "[mat-dialog-actions], mat-dialog-actions, [matDialogActions]", inputs: ["align"] }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DrawShorcutsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-draw-shorcuts', template: "<mat-dialog-content>\n  <div>\n    <span class=\"shortcut mat-typography\">\n      <mat-icon class=\"shortcut-icon\" svgIcon=\"keyboard-return\"></mat-icon\n      >{{ 'igo.geo.draw.finish' | translate }}</span\n    >\n  </div>\n  <div>\n    <span class=\"shortcut mat-typography\">\n      <mat-icon class=\"shortcut-icon\" svgIcon=\"backspace-outline\"></mat-icon\n      >{{ 'igo.geo.draw.undo' | translate }}</span\n    >\n  </div>\n  <div>\n    <span class=\"shortcut mat-typography\">\n      <mat-icon class=\"shortcut-icon\" svgIcon=\"keyboard-esc\"></mat-icon\n      >{{ 'igo.geo.draw.abort' | translate }}</span\n    >\n  </div>\n  <div>\n    <span class=\"shortcut mat-typography\">\n      <mat-icon class=\"shortcut-icon\" svgIcon=\"keyboard-space\"></mat-icon\n      >{{ 'igo.geo.draw.move' | translate }}</span\n    >\n  </div>\n</mat-dialog-content>\n<mat-dialog-actions class=\"shortcuts-close\">\n  <button mat-raised-button mat-dialog-close color=\"primary\">OK</button>\n</mat-dialog-actions>\n", styles: [".shortcut{display:flex;align-items:center}.shortcut-icon{margin-right:10px}.shortcuts-close{display:flex;justify-content:center}\n"] }]
        }] });

/**
 * Base search source class
 */
class SearchSource {
    storageService;
    /**
     * Search source ID
     * @internal
     */
    static id = '';
    /**
     * Search source type
     * @internal
     */
    static type = '';
    /**
     * Search source options
     * @internal
     */
    options;
    /**
     * Get search source's id
     * @returns Search source's id
     */
    getId() {
        throw new Error('You have to implement the method "getId".');
    }
    /**
     * Get search source's type
     * @returns Search source's type
     */
    getType() {
        throw new Error('You have to implement the method "getType".');
    }
    /**
     * Get search source's default options
     * @returns Search source default options
     */
    getDefaultOptions() {
        throw new Error('You have to implement the method "getDefaultOptions".');
    }
    /**
     * Search source's title
     */
    get title() {
        return this.options.title;
    }
    /**
     * Whether the search source is available
     */
    get available() {
        return this.options.available !== false;
    }
    /**
     * Whether the search source is enabled
     */
    set enabled(value) {
        this.options.enabled = value;
    }
    get enabled() {
        return this.available && this.options.enabled !== false;
    }
    get showInPointerSummary() {
        const showInPointerSummary = this.options.showInPointerSummary;
        return showInPointerSummary ? showInPointerSummary : false;
    }
    get showInSettings() {
        const showInSettings = this.options.showInSettings;
        return showInSettings === undefined ? true : showInSettings;
    }
    /**
     * Search url
     */
    get searchUrl() {
        return this.options.searchUrl;
    }
    /**
     * Search query params
     */
    get params() {
        return this.options.params;
    }
    /**
     * Search settings
     */
    get settings() {
        return this.options.settings === undefined ? [] : this.options.settings;
    }
    set featureStoresWithIndex(storesWithIndex) {
        this._featureStoresWithIndex = storesWithIndex;
    }
    get featureStoresWithIndex() {
        return this._featureStoresWithIndex;
    }
    _featureStoresWithIndex;
    setWorkspaces(workspaces) {
        if (workspaces.filter((fw) => fw.entityStore.searchDocument)
            .length >= 1) {
            this.options.available = true;
        }
        else {
            this.options.available = false;
        }
        const values = [];
        this.featureStoresWithIndex = workspaces
            .filter((fw) => fw.entityStore.searchDocument)
            .map((fw) => {
            values.push({
                title: fw.title,
                value: fw.title,
                enabled: true
            });
            return fw.entityStore;
        });
        const datasets = this.options.settings.find((s) => s.title === 'datasets');
        if (datasets) {
            datasets.values = values;
        }
        this.setParamFromSetting(datasets);
    }
    /**
     * Set params from selected settings
     */
    setParamFromSetting(setting, saveInStorage = true) {
        switch (setting.type) {
            case 'radiobutton':
                setting.values.forEach((conf) => {
                    if (conf.enabled) {
                        this.options.params = Object.assign(this.options.params || {}, {
                            [setting.name]: conf.value
                        });
                    }
                });
                break;
            case 'checkbox':
                let confValue = '';
                setting.values
                    .filter((s) => s.available !== false)
                    .forEach((conf) => {
                    if (conf.enabled) {
                        confValue += conf.value + ',';
                    }
                });
                confValue = confValue.slice(0, -1);
                this.options.params = Object.assign(this.options.params || {}, {
                    [setting.name]: confValue
                });
                break;
        }
        if (saveInStorage && this.storageService) {
            this.storageService.set(this.getId() + '.options', {
                params: this.options.params
            });
        }
    }
    /**
     * Search results display order
     */
    get displayOrder() {
        return this.options.order === undefined ? 99 : this.options.order;
    }
    constructor(options, storageService) {
        this.storageService = storageService;
        this.options = options;
        if (this.storageService) {
            const storageOptions = this.storageService.get(this.getId() + '.options');
            if (storageOptions) {
                this.options = ObjectUtils.mergeDeep(this.options, storageOptions);
            }
        }
        this.options = ObjectUtils.mergeDeep(this.getDefaultOptions(), this.options);
        // Set Default Params from Settings
        this.settings.forEach((setting) => {
            this.setParamFromSetting(setting, false);
        });
    }
    /**
     * Get hashtags valid
     * @param hashtag hashtag from query
     */
    getHashtagsValid(term, settingsName) {
        const hashtags = term.match(/(#[A-Za-zÀ-ÿ-+]+)/g);
        if (!hashtags) {
            return undefined;
        }
        const searchSourceSetting = this.getSettingsValues(settingsName);
        const hashtagsValid = [];
        hashtags.forEach((hashtag) => {
            searchSourceSetting.values.forEach((conf) => {
                const hashtagKey = hashtag.substring(1);
                if (typeof conf.value === 'string') {
                    const types = conf.value
                        .toLowerCase()
                        .normalize('NFD')
                        .replace(/[\u0300-\u036f]/g, '')
                        .split(',');
                    const index = types.indexOf(hashtagKey
                        .toLowerCase()
                        .normalize('NFD')
                        .replace(/[\u0300-\u036f]/g, ''));
                    if (index !== -1) {
                        hashtagsValid.push(types[index]);
                    }
                }
                if (conf.hashtags &&
                    conf.hashtags.indexOf(hashtagKey.toLowerCase()) !== -1) {
                    hashtagsValid.push(conf.value);
                }
            });
        });
        return hashtagsValid.filter((a, b) => hashtagsValid.indexOf(a) === b);
    }
    getSettingsValues(search) {
        return this.getDefaultOptions().settings.find((value) => {
            return value.name === search;
        });
    }
}

class FeatureDetailsComponent {
    http;
    cdRef;
    sanitizer;
    networkService;
    messageService;
    configService;
    state;
    unsubscribe$ = new Subject();
    ready = false;
    get source() {
        return this._source;
    }
    set source(value) {
        this._source = value;
        this.cdRef.detectChanges();
    }
    map;
    toolbox;
    get feature() {
        return this._feature;
    }
    set feature(value) {
        this._feature = value;
        this.cdRef.detectChanges();
        this.selectFeature.emit();
    }
    _feature;
    _source;
    routeEvent = new EventEmitter();
    selectFeature = new EventEmitter();
    htmlDisplayEvent = new EventEmitter();
    /**
     * @internal
     */
    get title() {
        return getEntityTitle(this.feature);
    }
    /**
     * @internal
     */
    get icon() {
        return getEntityIcon(this.feature) || 'link';
    }
    constructor(http, cdRef, sanitizer, networkService, messageService, configService) {
        this.http = http;
        this.cdRef = cdRef;
        this.sanitizer = sanitizer;
        this.networkService = networkService;
        this.messageService = messageService;
        this.configService = configService;
        this.networkService
            .currentState()
            .pipe(takeUntil(this.unsubscribe$))
            .subscribe((state) => {
            this.state = state;
        });
    }
    ngOnInit() {
        this.ready = true;
    }
    ngOnDestroy() {
        this.unsubscribe$.next();
        this.unsubscribe$.complete();
    }
    urlSanitizer(value) {
        return this.sanitizer.bypassSecurityTrustResourceUrl(value);
    }
    isHtmlDisplay() {
        if (this.feature &&
            this.isObject(this.feature.properties) &&
            this.feature.properties.target === 'iframe') {
            this.htmlDisplayEvent.emit(true);
            return true;
        }
        else {
            this.htmlDisplayEvent.emit(false);
            return false;
        }
    }
    htmlSanitizer(value) {
        if (!value.body) {
            return;
        }
        const regexBase = /<base href="[\w:\/\.]+">/;
        if (!regexBase.test(value.body)) {
            const url = new URL(value.url, window.location.origin);
            value.body = value.body.replace('<head>', `<head><base href="${url.origin}">`);
        }
        return this.sanitizer.bypassSecurityTrustHtml(value.body);
    }
    isObject(value) {
        return typeof value === 'object';
    }
    openSecureUrl(value) {
        let url;
        const regexDepot = new RegExp(this.configService?.getConfig('depot.url') + '.*?(?="|$)');
        if (regexDepot.test(value)) {
            url = value.match(regexDepot)[0];
            this.http
                .get(url, {
                responseType: 'blob'
            })
                .subscribe((docOrImage) => {
                const fileUrl = URL.createObjectURL(docOrImage);
                window.open(fileUrl, '_blank');
                this.cdRef.detectChanges();
            }, (error) => {
                this.messageService.error('igo.geo.targetHtmlUrlUnauthorized', 'igo.geo.targetHtmlUrlUnauthorizedTitle');
            });
        }
        else {
            let url = value;
            if (this.isEmbeddedLink(value)) {
                var div = document.createElement('div');
                div.innerHTML = value;
                url = div.children[0].getAttribute('href');
            }
            window.open(url, '_blank');
        }
    }
    isUrl(value) {
        if (typeof value === 'string') {
            const regex = /^https?:\/\//;
            return regex.test(value);
        }
    }
    isDoc(value) {
        if (typeof value === 'string') {
            if (this.isUrl(value)) {
                const regex = /(pdf|docx?|xlsx?)$/;
                return regex.test(value.toLowerCase());
            }
            else {
                return false;
            }
        }
    }
    isImg(value) {
        if (typeof value === 'string') {
            if (this.isUrl(value)) {
                const regex = /(jpe?g|png|gif)$/;
                return regex.test(value.toLowerCase());
            }
            else {
                return false;
            }
        }
    }
    isEmbeddedLink(value) {
        if (typeof value === 'string') {
            const matchRegex = /<a/g;
            const match = value.match(matchRegex) || [];
            const count = match.length;
            if (count === 1) {
                return true;
            }
            else {
                return false;
            }
        }
        return false;
    }
    getEmbeddedLinkText(value) {
        const regex = /(?:>).*?(?=<|$)/;
        let text = value.match(regex)[0];
        text = text.replace(/>/g, '');
        return text;
    }
    filterFeatureProperties(feature) {
        const allowedFieldsAndAlias = feature.meta ? feature.meta.alias : undefined;
        const properties = {};
        let offlineButtonState;
        if (this.map) {
            this.map.forcedOffline$
                .pipe(takeUntil(this.unsubscribe$))
                .subscribe((state) => {
                offlineButtonState = state;
            });
        }
        if (feature.properties &&
            feature.properties.Route &&
            this.toolbox &&
            !this.toolbox.getTool('directions')) {
            delete feature.properties.Route;
        }
        if (allowedFieldsAndAlias) {
            Object.keys(allowedFieldsAndAlias).forEach((field) => {
                properties[allowedFieldsAndAlias[field]] = feature.properties[field];
            });
            return properties;
        }
        else if (offlineButtonState !== undefined) {
            if (!offlineButtonState) {
                if (this.state.connection &&
                    feature.meta &&
                    feature.meta.excludeAttribute) {
                    const excludeAttribute = feature.meta.excludeAttribute;
                    excludeAttribute.forEach((attribute) => {
                        delete feature.properties[attribute];
                    });
                }
                else if (!this.state.connection &&
                    feature.meta &&
                    feature.meta.excludeAttributeOffline) {
                    const excludeAttributeOffline = feature.meta.excludeAttributeOffline;
                    excludeAttributeOffline.forEach((attribute) => {
                        delete feature.properties[attribute];
                    });
                }
            }
            else {
                if (feature.meta && feature.meta.excludeAttributeOffline) {
                    const excludeAttributeOffline = feature.meta.excludeAttributeOffline;
                    excludeAttributeOffline.forEach((attribute) => {
                        delete feature.properties[attribute];
                    });
                }
            }
        }
        else {
            if (this.state.connection &&
                feature.meta &&
                feature.meta.excludeAttribute) {
                const excludeAttribute = feature.meta.excludeAttribute;
                excludeAttribute.forEach((attribute) => {
                    delete feature.properties[attribute];
                });
            }
            else if (!this.state.connection &&
                feature.meta &&
                feature.meta.excludeAttributeOffline) {
                const excludeAttributeOffline = feature.meta.excludeAttributeOffline;
                excludeAttributeOffline.forEach((attribute) => {
                    delete feature.properties[attribute];
                });
            }
        }
        return feature.properties;
    }
    /**
     * Copy the url to a clipboard
     */
    copyTextToClipboard(value) {
        const successful = Clipboard.copy(value);
        if (successful) {
            this.messageService.success('igo.geo.query.link.message');
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FeatureDetailsComponent, deps: [{ token: i1.HttpClient }, { token: i0.ChangeDetectorRef }, { token: i2$4.DomSanitizer }, { token: i2.NetworkService }, { token: i2.MessageService }, { token: i2.ConfigService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: FeatureDetailsComponent, selector: "igo-feature-details", inputs: { source: "source", map: "map", toolbox: "toolbox", feature: "feature" }, outputs: { routeEvent: "routeEvent", selectFeature: "selectFeature", htmlDisplayEvent: "htmlDisplayEvent" }, ngImport: i0, template: "<table\n  class=\"igo-striped mat-typography\"\n  *ngIf=\"\n    ready &&\n    feature &&\n    isObject(feature.properties) &&\n    feature.properties.target !== 'iframe'\n  \"\n>\n  <tbody>\n    <tr *ngFor=\"let property of filterFeatureProperties(feature) | keyvalue\">\n      <td\n        *ngIf=\"feature.properties.target === '_blank' && property.key === 'url'\"\n      >\n        <mat-icon matListItemIcon svgIcon=\"{{ icon }}\"></mat-icon>\n      </td>\n\n      <td\n        *ngIf=\"feature.properties.target === '_blank' && property.key === 'url'\"\n      >\n        <a\n          href=\"{{ property.value }}\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          {{ 'igo.geo.targetHtmlUrl' | translate }} {{ title }}</a\n        >\n        <button\n          class=\"copyClipboard\"\n          mat-icon-button\n          (click)=\"copyTextToClipboard(property.value)\"\n        >\n          <mat-icon svgIcon=\"content-copy\"></mat-icon>\n        </button>\n      </td>\n\n      <td id=\"keyValue\" *ngIf=\"feature.properties.target === undefined\">\n        {{ property.key }}\n      </td>\n\n      <td\n        *ngIf=\"\n          feature.properties.target === undefined &&\n          !isObject(property.value) &&\n          !isUrl(property.value) &&\n          !isEmbeddedLink(property.value)\n        \"\n        [innerHTML]=\"property.value\"\n      ></td>\n\n      <td\n        *ngIf=\"\n          feature.properties.target === undefined &&\n          isEmbeddedLink(property.value)\n        \"\n      >\n        <u\n          [ngStyle]=\"{ cursor: 'pointer', color: 'blue' }\"\n          (click)=\"openSecureUrl(property.value)\"\n          >{{ getEmbeddedLinkText(property.value) }}</u\n        >\n      </td>\n\n      <td\n        *ngIf=\"\n          feature.properties.target === undefined &&\n          !isObject(property.value) &&\n          (isDoc(property.value) || isUrl(property.value)) &&\n          !isImg(property.value)\n        \"\n      >\n        <u\n          [ngStyle]=\"{ cursor: 'pointer', color: 'blue' }\"\n          (click)=\"openSecureUrl(property.value)\"\n          >{{ 'igo.geo.targetHtmlUrl' | translate }}</u\n        >\n        <button\n          class=\"copyClipboard\"\n          mat-icon-button\n          (click)=\"copyTextToClipboard(property.value)\"\n        >\n          <mat-icon svgIcon=\"content-copy\"></mat-icon>\n        </button>\n      </td>\n\n      <td\n        *ngIf=\"\n          feature.properties.target === undefined &&\n          !isObject(property.value) &&\n          isUrl(property.value) &&\n          isImg(property.value)\n        \"\n      >\n        <a\n          href=\"{{ property.value }}\"\n          target=\"_blank\"\n          (click)=\"openSecureUrl(property.value)\"\n          rel=\"noopener noreferrer\"\n        >\n          <img\n            igoImageError\n            src=\"{{ property.value | secureImage | async }}\"\n            width=\"225\"\n            height=\"auto\"\n          />\n        </a>\n      </td>\n\n      <td\n        *ngIf=\"\n          feature.properties.target === undefined && isObject(property.value)\n        \"\n        [innerHTML]=\"property.value | json\"\n      ></td>\n    </tr>\n  </tbody>\n</table>\n\n<iframe\n  *ngIf=\"isHtmlDisplay()\"\n  [srcdoc]=\"htmlSanitizer(feature.properties)\"\n  [src]=\"urlSanitizer(feature.properties.url)\"\n></iframe>\n", styles: ["table{width:100%}table td{padding:5px}#keyValue{width:30%}table ::ng-deep .routing{cursor:pointer}iframe{height:calc(100% - 4px);width:100%;border:0}.copyClipboard{border:none;background:transparent;cursor:pointer}\n"], dependencies: [{ kind: "directive", type: i2$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2$2.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "directive", type: i9$1.ImageErrorDirective, selector: "[igoImageError]", inputs: ["errorImageUrl", "hideError"] }, { kind: "pipe", type: i2$2.AsyncPipe, name: "async" }, { kind: "pipe", type: i2$2.JsonPipe, name: "json" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }, { kind: "pipe", type: i9$1.KeyValuePipe, name: "keyvalue" }, { kind: "pipe", type: i9$1.SecureImagePipe, name: "secureImage" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FeatureDetailsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-feature-details', changeDetection: ChangeDetectionStrategy.OnPush, template: "<table\n  class=\"igo-striped mat-typography\"\n  *ngIf=\"\n    ready &&\n    feature &&\n    isObject(feature.properties) &&\n    feature.properties.target !== 'iframe'\n  \"\n>\n  <tbody>\n    <tr *ngFor=\"let property of filterFeatureProperties(feature) | keyvalue\">\n      <td\n        *ngIf=\"feature.properties.target === '_blank' && property.key === 'url'\"\n      >\n        <mat-icon matListItemIcon svgIcon=\"{{ icon }}\"></mat-icon>\n      </td>\n\n      <td\n        *ngIf=\"feature.properties.target === '_blank' && property.key === 'url'\"\n      >\n        <a\n          href=\"{{ property.value }}\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          {{ 'igo.geo.targetHtmlUrl' | translate }} {{ title }}</a\n        >\n        <button\n          class=\"copyClipboard\"\n          mat-icon-button\n          (click)=\"copyTextToClipboard(property.value)\"\n        >\n          <mat-icon svgIcon=\"content-copy\"></mat-icon>\n        </button>\n      </td>\n\n      <td id=\"keyValue\" *ngIf=\"feature.properties.target === undefined\">\n        {{ property.key }}\n      </td>\n\n      <td\n        *ngIf=\"\n          feature.properties.target === undefined &&\n          !isObject(property.value) &&\n          !isUrl(property.value) &&\n          !isEmbeddedLink(property.value)\n        \"\n        [innerHTML]=\"property.value\"\n      ></td>\n\n      <td\n        *ngIf=\"\n          feature.properties.target === undefined &&\n          isEmbeddedLink(property.value)\n        \"\n      >\n        <u\n          [ngStyle]=\"{ cursor: 'pointer', color: 'blue' }\"\n          (click)=\"openSecureUrl(property.value)\"\n          >{{ getEmbeddedLinkText(property.value) }}</u\n        >\n      </td>\n\n      <td\n        *ngIf=\"\n          feature.properties.target === undefined &&\n          !isObject(property.value) &&\n          (isDoc(property.value) || isUrl(property.value)) &&\n          !isImg(property.value)\n        \"\n      >\n        <u\n          [ngStyle]=\"{ cursor: 'pointer', color: 'blue' }\"\n          (click)=\"openSecureUrl(property.value)\"\n          >{{ 'igo.geo.targetHtmlUrl' | translate }}</u\n        >\n        <button\n          class=\"copyClipboard\"\n          mat-icon-button\n          (click)=\"copyTextToClipboard(property.value)\"\n        >\n          <mat-icon svgIcon=\"content-copy\"></mat-icon>\n        </button>\n      </td>\n\n      <td\n        *ngIf=\"\n          feature.properties.target === undefined &&\n          !isObject(property.value) &&\n          isUrl(property.value) &&\n          isImg(property.value)\n        \"\n      >\n        <a\n          href=\"{{ property.value }}\"\n          target=\"_blank\"\n          (click)=\"openSecureUrl(property.value)\"\n          rel=\"noopener noreferrer\"\n        >\n          <img\n            igoImageError\n            src=\"{{ property.value | secureImage | async }}\"\n            width=\"225\"\n            height=\"auto\"\n          />\n        </a>\n      </td>\n\n      <td\n        *ngIf=\"\n          feature.properties.target === undefined && isObject(property.value)\n        \"\n        [innerHTML]=\"property.value | json\"\n      ></td>\n    </tr>\n  </tbody>\n</table>\n\n<iframe\n  *ngIf=\"isHtmlDisplay()\"\n  [srcdoc]=\"htmlSanitizer(feature.properties)\"\n  [src]=\"urlSanitizer(feature.properties.url)\"\n></iframe>\n", styles: ["table{width:100%}table td{padding:5px}#keyValue{width:30%}table ::ng-deep .routing{cursor:pointer}iframe{height:calc(100% - 4px);width:100%;border:0}.copyClipboard{border:none;background:transparent;cursor:pointer}\n"] }]
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: i0.ChangeDetectorRef }, { type: i2$4.DomSanitizer }, { type: i2.NetworkService }, { type: i2.MessageService }, { type: i2.ConfigService }]; }, propDecorators: { source: [{
                type: Input
            }], map: [{
                type: Input
            }], toolbox: [{
                type: Input
            }], feature: [{
                type: Input
            }], routeEvent: [{
                type: Output
            }], selectFeature: [{
                type: Output
            }], htmlDisplayEvent: [{
                type: Output
            }] } });

/**
 * A configurable form, optionnally bound to a feature.
 * This component creates an entity form and, on submit,
 * returns a feature made out of the submitted data. It also
 * does things like managing the feature visibility while it's being updated
 * as well as disabling the selection of another feature.
 */
class FeatureFormComponent {
    /**
     * Form
     */
    form;
    /**
     * Feature to update
     */
    set feature(value) {
        this.feature$.next(value);
    }
    get feature() {
        return this.feature$.value;
    }
    feature$ = new BehaviorSubject(undefined);
    /**
     * Event emitted when the form is submitted
     */
    submitForm = new EventEmitter();
    igoForm;
    constructor() { }
    /**
     * Transform the form data to a feature and emit an event
     * @param event Form submit event
     * @internal
     */
    onSubmit(data) {
        const feature = this.formDataToFeature(data);
        this.submitForm.emit(feature);
    }
    getData() {
        return this.formDataToFeature(this.igoForm.getData());
    }
    /**
     * Transform the form data to a feature
     * @param data Form data
     * @returns A feature
     */
    formDataToFeature(data) {
        const properties = {};
        const meta = {};
        if (this.feature === undefined) {
            meta.id = uuid();
        }
        else {
            Object.assign(properties, this.feature.properties);
            Object.assign(meta, this.feature.meta, {
                revision: getEntityRevision(this.feature) + 1
            });
        }
        const propertyPrefix = 'properties.';
        Object.entries(data).forEach((entry) => {
            const [key, value] = entry;
            if (key.startsWith(propertyPrefix)) {
                const property = key.substr(propertyPrefix.length);
                properties[property] = value;
            }
        });
        let geometry = data.geometry;
        if (geometry === undefined && this.feature !== undefined) {
            geometry = this.feature.geometry;
        }
        return {
            meta: meta,
            type: FEATURE,
            geometry,
            projection: 'EPSG:4326',
            properties
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FeatureFormComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: FeatureFormComponent, selector: "igo-feature-form", inputs: { form: "form", feature: "feature" }, outputs: { submitForm: "submitForm" }, viewQueries: [{ propertyName: "igoForm", first: true, predicate: ["igoForm"], descendants: true, static: true }], ngImport: i0, template: "<igo-form\n  #igoForm\n  [form]=\"form\"\n  [formData]=\"feature$ | async\"\n  (submitForm)=\"onSubmit($event)\"\n>\n  <ng-content></ng-content>\n\n  <ng-content select=\"[formButtons]\" formButtons></ng-content>\n</igo-form>\n", styles: [":host{display:block}igo-form{height:100%}\n"], dependencies: [{ kind: "component", type: i9$1.FormComponent, selector: "igo-form", inputs: ["form", "formData", "autocomplete"], outputs: ["submitForm"] }, { kind: "pipe", type: i2$2.AsyncPipe, name: "async" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FeatureFormComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-feature-form', changeDetection: ChangeDetectionStrategy.OnPush, template: "<igo-form\n  #igoForm\n  [form]=\"form\"\n  [formData]=\"feature$ | async\"\n  (submitForm)=\"onSubmit($event)\"\n>\n  <ng-content></ng-content>\n\n  <ng-content select=\"[formButtons]\" formButtons></ng-content>\n</igo-form>\n", styles: [":host{display:block}igo-form{height:100%}\n"] }]
        }], ctorParameters: function () { return []; }, propDecorators: { form: [{
                type: Input
            }], feature: [{
                type: Input
            }], submitForm: [{
                type: Output
            }], igoForm: [{
                type: ViewChild,
                args: ['igoForm', { static: true }]
            }] } });

/* eslint-disable */
// See this issue: https://github.com/Microsoft/TypeScript/issues/13965
// And the solution: https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
// for an explanation as to why the prototype is set manually
/* eslint-enable */
class GeometrySliceError extends Error {
}
class GeometrySliceMultiPolygonError extends GeometrySliceError {
    constructor() {
        super("Can't slice a MultiPolygon.");
        Object.setPrototypeOf(this, GeometrySliceMultiPolygonError.prototype);
    }
}
class GeometrySliceLineStringError extends GeometrySliceError {
    constructor() {
        super("Can't slice with a line that has more than 2 points.");
        Object.setPrototypeOf(this, GeometrySliceLineStringError.prototype);
    }
}
class GeometrySliceTooManyIntersectionError extends GeometrySliceError {
    constructor() {
        super('More than 2 intersections found between the target polygon and the slicing line.');
        Object.setPrototypeOf(this, GeometrySliceTooManyIntersectionError.prototype);
    }
}

/**
 * Create a default style for draw and modify interactions
 * @param color Style color (R, G, B)
 * @returns OL style
 */
function createDrawInteractionStyle(color) {
    color = color || [0, 153, 255];
    return new olStyle.Circle({
        stroke: new olStyle.Stroke({
            color: color.concat([1]),
            width: 2
        }),
        fill: new olStyle.Fill({
            color: color.concat([0.2])
        }),
        radius: 8
    });
}
/**
 * Create a default style for drawing a hole
 * @returns OL style
 */
function createDrawHoleInteractionStyle() {
    return new olStyle.Style({
        stroke: new olStyle.Stroke({
            color: [0, 153, 255, 1],
            width: 2
        })
    });
}
/**
 * Slice geometry into two parts
 * @param olGeometry OL geometry
 * @param olSlicer Slicing line
 * @returns New OL geometries
 */
function sliceOlGeometry(olGeometry, olSlicer) {
    if (olGeometry instanceof OlPolygon) {
        return sliceOlPolygon(olGeometry, olSlicer);
    }
    else if (olGeometry instanceof OlLineString) {
        return sliceOlLineString(olGeometry, olSlicer);
    }
    return [];
}
/**
 * Slice OL LineString into one or more lines
 * @param olLineString OL line string
 * @param olSlicer Slicing line
 * @returns New OL line strings
 */
function sliceOlLineString(olLineString, olSlicer) {
    return [];
}
/**
 * Slice OL Polygon into one or more polygons
 * @param olPolygon OL polygon
 * @param olSlicer Slicing line
 * @returns New OL polygons
 */
function sliceOlPolygon(olPolygon, olSlicer) {
    if (olPolygon.getLinearRingCount() > 1) {
        throw new GeometrySliceMultiPolygonError();
    }
    if (olSlicer.getCoordinates().length > 2) {
        throw new GeometrySliceLineStringError();
    }
    const olGeoJSON = new OlGeoJSON();
    const slicer = olGeoJSON.writeGeometryObject(olSlicer);
    const outerCoordinates = olPolygon.getLinearRing(0).getCoordinates();
    const parts = [[], []];
    let totalIntersectionCount = 0;
    for (let i = 0, ii = outerCoordinates.length - 1; i < ii; i++) {
        const segmentCoordinates = [outerCoordinates[i], outerCoordinates[i + 1]];
        const segment = lineString(segmentCoordinates);
        const intersections = lineIntersect(segment, slicer).features;
        const intersectionCount = intersections.length;
        totalIntersectionCount += intersectionCount;
        if (intersectionCount > 1 || totalIntersectionCount > 2) {
            throw new GeometrySliceTooManyIntersectionError();
        }
        parts[0].push(segmentCoordinates[0]);
        if (intersectionCount === 1) {
            const intersection = intersections[0].geometry.coordinates;
            parts[0].push(intersection);
            parts[1].push(intersection);
            parts.reverse();
        }
    }
    if (totalIntersectionCount <= 1) {
        return [];
    }
    parts[0].push(parts[0][0]);
    parts[1].push(parts[1][0]);
    return [new OlPolygon([parts[0]]), new OlPolygon([parts[1]])];
}
/**
 * Splice geometry into two parts
 * @param olGeometry OL geometry
 * @param olSlicer Slicing line
 * @returns New OL geometries
 */
function addLinearRingToOlPolygon(olPolygon, olLinearRing) {
    // TODO: make some validation and support updating an existing linear ring
    olPolygon.appendLinearRing(olLinearRing);
}
function getMousePositionFromOlGeometryEvent(olEvent) {
    const olGeometry = olEvent.target;
    if (olGeometry instanceof OlPolygon) {
        return olGeometry.getFlatCoordinates().slice(-4, -2);
    }
    const olGeometryCast = olGeometry;
    return olGeometryCast.getFlatCoordinates().slice(-2);
}

/**
 * Control to draw entities
 */
class DrawControl {
    options;
    /**
     * Draw start observable
     */
    start$ = new Subject();
    /**
     * Draw end observable
     */
    end$ = new Subject();
    /**
     * Draw changes observable (while drawing)
     */
    changes$ = new Subject();
    /**
     * Draw modify observable (modify drawn features)
     */
    modify$ = new Subject();
    /**
     * Draw select observable (modify drawn features)
     */
    select$ = new Subject();
    /**
     * Draw abort observable (abort drawn features)
     */
    abort$ = new Subject();
    /**
     * Freehand mode observable (defaults to false)
     */
    freehand$ = new BehaviorSubject(false);
    /**
     * Observables from predefined radius (defaults to false and undefined)
     */
    ispredefinedRadius$ = new BehaviorSubject(false);
    predefinedRadius$ = new BehaviorSubject(undefined);
    radiusDrawEnd$ = new BehaviorSubject(undefined);
    keyDown$$;
    olGeometryType;
    olInteractionStyle;
    olMap;
    olDrawingLayer;
    olDrawInteraction;
    olSelectInteraction;
    olModifyInteraction;
    onDrawStartKey;
    onDrawEndKey;
    onDrawAbortKey;
    onDrawKey;
    radius;
    mousePosition;
    /**
     * take the value of radius
     */
    get radiusVal() {
        return this.predefinedRadius$.getValue();
    }
    set radiusValData(radiusCercle) {
        this.predefinedRadius$.next(radiusCercle);
    }
    /**
     * Wheter the control is active
     */
    get active() {
        return this.olMap !== undefined;
    }
    /**
     * OL overlay source
     * @internal
     */
    get olDrawingLayerSource() {
        return this.olDrawingLayer.getSource();
    }
    constructor(options) {
        this.options = options;
        this.olDrawingLayer = options.drawingLayer
            ? options.drawingLayer
            : this.createOlInnerOverlayLayer();
        this.olGeometryType = this.options.geometryType;
        this.olInteractionStyle = this.options.interactionStyle;
    }
    /**
     * Add or remove this control to/from a map.
     * @param map OL Map
     */
    setOlMap(olMap, activateModifyAndSelect) {
        if (!olMap) {
            this.clearOlInnerOverlaySource();
            this.removeOlInnerOverlayLayer();
            this.removeOlInteractions();
            this.olMap = olMap;
            return;
        }
        this.olMap = olMap;
        this.addOlInnerOverlayLayer();
        this.addOlInteractions(activateModifyAndSelect);
    }
    /**
     * Return the drawing layer source
     */
    getSource() {
        return this.olDrawingLayerSource;
    }
    setOlInteractionStyle(style) {
        this.olInteractionStyle = style;
    }
    /**
     * Set the current geometry type
     * @param geometryType the geometry type
     */
    setGeometryType(geometryType) {
        this.olGeometryType = geometryType;
    }
    /**
     * Get the current geometry type
     */
    getGeometryType() {
        return this.olGeometryType;
    }
    /**
     * Create a drawing source if none is defined in the options
     */
    createOlInnerOverlayLayer() {
        return new OlVectorLayer({
            source: this.options.drawingLayerSource
                ? this.options.drawingLayerSource
                : new OlVectorSource(),
            style: this.options.drawingLayerStyle,
            zIndex: 500
        });
    }
    /**
     * Clear the drawing layer if it wasn't defined in the options
     */
    removeOlInnerOverlayLayer() {
        if (!this.options.drawingLayer && this.olMap) {
            this.olMap.removeLayer(this.olDrawingLayer);
        }
    }
    /**
     * Add the drawing layer if it wasn't defined in the options
     */
    addOlInnerOverlayLayer() {
        if (!this.options.drawingLayer) {
            this.olMap.addLayer(this.olDrawingLayer);
        }
    }
    /**
     * Clear the drawing layer source if it wasn't defined in the options
     */
    clearOlInnerOverlaySource() {
        if (!this.options.drawingLayer && !this.options.drawingLayerSource) {
            this.olDrawingLayerSource.clear(true);
        }
    }
    /**
     * Add interactions to the map an set up some listeners
     */
    addOlInteractions(activateModifyAndSelect) {
        // Create Draw interaction
        let olDrawInteraction;
        if (!this.freehand$.getValue()) {
            if (!this.ispredefinedRadius$.getValue()) {
                olDrawInteraction = new OlDraw({
                    type: this.olGeometryType,
                    source: this.getSource(),
                    stopClick: true,
                    style: this.olInteractionStyle,
                    maxPoints: this.options.maxPoints,
                    freehand: false,
                    freehandCondition: () => false
                });
            }
            else {
                olDrawInteraction = new OlDraw({
                    type: 'Point',
                    source: this.getSource(),
                    stopClick: true,
                    style: this.olInteractionStyle,
                    maxPoints: this.options.maxPoints,
                    freehand: false,
                    freehandCondition: () => false
                });
            }
        }
        else {
            if (this.olGeometryType === 'Point') {
                olDrawInteraction = new OlDraw({
                    type: 'Circle',
                    source: this.getSource(),
                    style: typeof this.olInteractionStyle === 'function'
                        ? undefined
                        : this.olInteractionStyle,
                    maxPoints: this.options.maxPoints,
                    freehand: true
                });
            }
            else {
                olDrawInteraction = new OlDraw({
                    type: this.olGeometryType,
                    source: this.getSource(),
                    style: this.olInteractionStyle,
                    maxPoints: this.options.maxPoints,
                    freehand: true
                });
            }
        }
        // Add Draw interaction to map and create listeners
        this.olMap.addInteraction(olDrawInteraction);
        this.olDrawInteraction = olDrawInteraction;
        this.onDrawStartKey = olDrawInteraction.on('drawstart', (event) => this.onDrawStart(event));
        this.onDrawEndKey = olDrawInteraction.on('drawend', (event) => this.onDrawEnd(event));
        this.onDrawAbortKey = olDrawInteraction.on('drawabort', (event) => this.abort$.next(event.feature.getGeometry()));
        if (activateModifyAndSelect) {
            // Create a Modify interaction, add it to map and create a listener
            const olModifyInteraction = new OlModify({
                source: this.getSource()
            });
            this.olMap.addInteraction(olModifyInteraction);
            this.olModifyInteraction = olModifyInteraction;
            // Create a select interaction and add it to map
            if (!this.olSelectInteraction) {
                const olSelectInteraction = new OlSelect({
                    condition: doubleClick,
                    style: undefined
                });
                this.olMap.addInteraction(olSelectInteraction);
                this.olSelectInteraction = olSelectInteraction;
                this.olSelectInteraction.on('select', (event) => this.onSelect(event));
            }
        }
    }
    /**
     * Remove interactions
     */
    removeOlInteractions() {
        this.unsubscribeKeyDown();
        unByKey([
            this.onDrawStartKey,
            this.onDrawEndKey,
            this.onDrawKey,
            this.onDrawAbortKey
        ]);
        if (this.olMap) {
            this.olMap.removeInteraction(this.olDrawInteraction);
            this.olMap.removeInteraction(this.olModifyInteraction);
        }
        this.olDrawInteraction = undefined;
        this.olModifyInteraction = undefined;
    }
    /**
     * When drawing starts, clear the overlay and start watching for changes
     * @param event Draw start event
     */
    onDrawStart(event) {
        const olGeometry = event.feature.getGeometry();
        this.start$.next(olGeometry);
        this.clearOlInnerOverlaySource();
        this.onDrawKey = olGeometry.on('change', (olGeometryEvent) => {
            this.mousePosition = getMousePositionFromOlGeometryEvent(olGeometryEvent);
            this.changes$.next(olGeometryEvent.target);
        });
        this.subscribeKeyDown();
    }
    /**
     * When drawing ends, update the drawing (feature) geometry observable and add
     * @param event Draw event (drawend)
     */
    onDrawEnd(event) {
        if (event.feature.getGeometry().getType() === 'Point') {
            this.radiusDrawEnd$.next(this.predefinedRadius$.getValue());
        }
        this.unsubscribeKeyDown();
        unByKey(this.onDrawKey);
        const olGeometry = event.feature.getGeometry();
        olGeometry.on('change', () => {
            this.modify$.next(olGeometry);
        });
        this.end$.next(olGeometry);
    }
    /**
     * When a feature is selected, update the selected feature observable
     * @param event Modify event (modifyend)
     */
    onSelect(event) {
        if (event.selected.length === 1) {
            this.select$.next(event.selected[0]);
        }
    }
    /**
     * Subscribe to key downs used as drawing interaction shorcuts
     */
    subscribeKeyDown() {
        this.unsubscribeKeyDown();
        this.keyDown$$ = fromEvent(document, 'keydown').subscribe((event) => {
            // On Escape or 'c' keydowns, abort the current drawing
            if (event.key === 'Escape') {
                this.olDrawInteraction.abortDrawing();
                return;
            }
            // On Backspace or 'u' keydowns, remove last vertex of current drawing
            if (event.key === 'Backspace') {
                this.olDrawInteraction.removeLastPoint();
            }
            // On Enter or 'f' keydowns, finish current drawing
            if (event.key === 'Enter') {
                this.olDrawInteraction.finishDrawing();
            }
            // On space bar key down, pan to the current mouse position
            if (event.key === ' ') {
                this.olMap.getView().animate({
                    center: this.mousePosition,
                    duration: 100
                });
                return;
            }
        });
    }
    /**
     * Unsubscribe to key down
     */
    unsubscribeKeyDown() {
        if (this.keyDown$$) {
            this.keyDown$$.unsubscribe();
            this.keyDown$$ = undefined;
        }
    }
}

var FontType;
(function (FontType) {
    FontType["Arial"] = "Arial";
    FontType["ArialBlack"] = "Arial Black";
    FontType["Verdana"] = "Verdana";
    FontType["Tahoma"] = "Tahoma";
    FontType["TrebuchetMS"] = "Trebuchet MS";
    FontType["Impact"] = "Impact";
    FontType["TimesNewRoman"] = "Times New Roman";
    FontType["Georgia"] = "Georgia";
    FontType["AmericanTypewriter"] = "American Typewriter";
    FontType["Courier"] = "Courier";
    FontType["LucidaConsole"] = "Lucida Console";
    FontType["BrushScriptMT"] = "Brush Script MT";
    FontType["ComicSansMS"] = "Comic Sans MS";
})(FontType || (FontType = {}));

class DrawStyleService {
    fillColor = 'rgba(255,255,255,0.4)';
    strokeColor = 'rgba(143,7,7,1)';
    strokeWidth = 1;
    labelsAreShown = true;
    icon;
    fontSize = '15';
    fontStyle = FontType.Arial.toString();
    offsetX = 0;
    offsetY = 0;
    constructor() { }
    getFillColor() {
        return this.fillColor;
    }
    setFillColor(fillColor) {
        this.fillColor = fillColor;
    }
    getStrokeColor() {
        return this.strokeColor;
    }
    setStrokeColor(strokeColor) {
        this.strokeColor = strokeColor;
    }
    getStrokeWidth() {
        return this.strokeWidth;
    }
    getLabelsAreShown() {
        return this.labelsAreShown;
    }
    toggleLabelsAreShown() {
        this.labelsAreShown = !this.labelsAreShown;
    }
    setIcon(icon) {
        this.icon = icon;
    }
    getIcon() {
        return this.icon;
    }
    // To edit the label of drawing
    getFontSize() {
        return this.fontSize;
    }
    setFontSize(fontSize) {
        this.fontSize = fontSize;
    }
    getFontStyle() {
        return this.fontStyle;
    }
    setFontStyle(fontStyle) {
        this.fontStyle = fontStyle;
    }
    getOffsetX() {
        return this.offsetX;
    }
    setOffsetX(offsetX) {
        this.offsetX = offsetX;
    }
    getOffsetY() {
        return this.offsetY;
    }
    setOffsetY(offsetY) {
        this.offsetY = offsetY;
    }
    createIndividualElementStyle(feature, resolution, labelsAreShown, fontSizeAndStyle, fillColor, strokeColor, offsetX, offsetY, proj, icon) {
        let style;
        let labelsAreOffset = false;
        const geom = feature.getGeometry();
        if (geom instanceof OlPoint) {
            labelsAreOffset = !labelsAreOffset;
        }
        const textToShow = labelsAreShown ? feature.get('draw') : '';
        feature.set('_mapTitle', textToShow);
        const textIgoStyleObject = {
            text: textToShow,
            stroke: {
                color: 'white',
                width: 0.75
            },
            fill: { color: 'black' },
            font: fontSizeAndStyle,
            overflow: true,
            offsetX: offsetX,
            offsetY: offsetY
        };
        let igoStyleObject;
        // if feature is a circle
        if (feature.get('rad')) {
            const coordinates = transform(feature.getGeometry().flatCoordinates, proj, 'EPSG:4326');
            const radius = feature.get('rad') /
                Math.cos((Math.PI / 180) * coordinates[1]) /
                resolution;
            igoStyleObject = {
                text: textIgoStyleObject,
                circle: {
                    radius,
                    stroke: {
                        color: strokeColor ? strokeColor : this.strokeColor,
                        width: this.strokeWidth
                    },
                    fill: {
                        color: fillColor
                    }
                }
            };
            feature.set('_style', igoStyleObject);
            style = new olStyle.Style({
                text: new olStyle.Text({
                    text: textToShow,
                    stroke: new olStyle.Stroke({
                        color: 'white',
                        width: 0.75
                    }),
                    fill: new olStyle.Fill({
                        color: 'black'
                    }),
                    font: fontSizeAndStyle,
                    overflow: true,
                    offsetX: offsetX,
                    offsetY: offsetY
                }),
                image: new olStyle.Circle({
                    radius,
                    stroke: new olStyle.Stroke({
                        color: strokeColor ? strokeColor : this.strokeColor,
                        width: this.strokeWidth
                    }),
                    fill: new olStyle.Fill({
                        color: fillColor
                    })
                })
            });
            return style;
            // if feature is an icon
        }
        else if (icon) {
            this.offsetY = -26;
            textIgoStyleObject.offsetY = this.offsetY;
            const igoStyleObject = {
                text: textIgoStyleObject,
                stroke: {
                    color: strokeColor,
                    width: this.strokeWidth
                },
                fill: {
                    color: fillColor
                },
                icon: {
                    src: icon
                }
            };
            feature.set('_style', igoStyleObject);
            style = new olStyle.Style({
                text: new olStyle.Text({
                    text: labelsAreShown ? feature.get('draw') : '',
                    stroke: new olStyle.Stroke({
                        color: 'white',
                        width: 0.75
                    }),
                    fill: new olStyle.Fill({
                        color: 'black'
                    }),
                    font: fontSizeAndStyle,
                    overflow: true,
                    offsetX: offsetX,
                    offsetY: offsetY
                }),
                stroke: new olStyle.Stroke({
                    color: strokeColor,
                    width: this.strokeWidth
                }),
                fill: new olStyle.Fill({
                    color: fillColor
                }),
                image: new olStyle.Icon({
                    src: icon
                })
            });
            return style;
            // if feature is a point, a linestring or a polygon
        }
        else {
            this.offsetY = labelsAreOffset ? -15 : 0;
            textIgoStyleObject.offsetY = this.offsetY;
            const igoStyleObject = {
                text: textIgoStyleObject,
                stroke: {
                    color: strokeColor,
                    width: this.strokeWidth
                },
                fill: {
                    color: fillColor
                },
                circle: {
                    radius: 5,
                    stroke: {
                        color: strokeColor,
                        width: this.strokeWidth
                    },
                    fill: {
                        color: fillColor
                    }
                }
            };
            feature.set('_style', igoStyleObject);
            style = new olStyle.Style({
                text: new olStyle.Text({
                    text: labelsAreShown ? feature.get('draw') : '',
                    stroke: new olStyle.Stroke({
                        color: 'white',
                        width: 0.75
                    }),
                    fill: new olStyle.Fill({
                        color: 'black'
                    }),
                    font: fontSizeAndStyle,
                    overflow: true,
                    offsetX: offsetX,
                    offsetY: offsetY
                }),
                stroke: new olStyle.Stroke({
                    color: strokeColor,
                    width: this.strokeWidth
                }),
                fill: new olStyle.Fill({
                    color: fillColor
                }),
                image: new olStyle.Circle({
                    radius: 5,
                    stroke: new olStyle.Stroke({
                        color: strokeColor,
                        width: this.strokeWidth
                    }),
                    fill: new olStyle.Fill({
                        color: fillColor
                    })
                })
            });
            return style;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DrawStyleService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DrawStyleService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DrawStyleService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return []; } });

class StyleModalDrawingComponent {
    dialogRef;
    formBuilder;
    drawStyleService;
    data;
    confirmFlag = false;
    form;
    styleModalData;
    linestringOnly;
    constructor(dialogRef, formBuilder, drawStyleService, data) {
        this.dialogRef = dialogRef;
        this.formBuilder = formBuilder;
        this.drawStyleService = drawStyleService;
        this.data = data;
    }
    ngOnInit() {
        this.linestringOnly = true;
        for (const feature of this.data.features) {
            if (feature.geometry.type !== 'LineString') {
                this.linestringOnly = false;
            }
        }
        this.buildStyleData();
        this.buildForm();
    }
    buildForm() {
        this.form = this.formBuilder.group({
            fill: [this.getFeatureFillColor()],
            stroke: [this.getFeatureStrokeColor()]
        });
    }
    buildStyleData() {
        this.styleModalData = {
            fillColor: this.data.features.length > 0
                ? this.data.features[0].properties.drawingStyle.fill
                : 'rgba(255,255,255,0.4)',
            strokeColor: this.data.features.length > 0
                ? this.data.features[0].properties.drawingStyle.stroke
                : 'rgba(143,7,7,1)',
            fontSize: this.data.features.length > 0
                ? this.data.features[0].properties.fontStyle
                    .split(' ')[0]
                    .replace('px', '')
                : '20',
            fontStyle: this.data.features.length > 0
                ? this.data.features[0].properties.fontStyle.substring(this.data.features[0].properties.fontStyle.indexOf(' ') + 1)
                : FontType.Arial,
            offsetX: this.data.features.length > 0
                ? this.data.features[0].properties.offsetX
                : this.drawStyleService.getOffsetX(),
            offsetY: this.data.features.length > 0
                ? this.data.features[0].properties.offsetY
                : this.drawStyleService.getOffsetY()
        };
    }
    get allFontStyles() {
        return Object.values(FontType);
    }
    getFeatureFontSize() {
        if (!this.styleModalData.fontSize) {
            return this.data.features.length > 0
                ? this.data.features[0].properties.fontStyle
                    .split(' ')[0]
                    .replace('px', '')
                : '20';
        }
        else {
            return this.styleModalData.fontSize;
        }
    }
    getFeatureFontStyle() {
        if (!this.styleModalData.fontStyle) {
            return this.data.features.length > 0
                ? this.data.features[0].properties.fontStyle.substring(this.data.features[0].properties.fontStyle.indexOf(' ') + 1)
                : FontType.Arial;
        }
        else {
            return this.styleModalData.fontStyle;
        }
    }
    getFeatureFillColor() {
        if (!this.styleModalData.fillColor) {
            return this.data.features.length > 0
                ? this.data.features[0].properties.drawingStyle.fill
                : 'rgba(255,255,255,0.4)';
        }
        else {
            return this.styleModalData.fillColor;
        }
    }
    getFeatureStrokeColor() {
        if (!this.styleModalData.strokeColor) {
            return this.data.features.length > 0
                ? this.data.features[0].properties.drawingStyle.stroke
                : 'rgba(143,7,7,1)';
        }
        else {
            return this.styleModalData.strokeColor;
        }
    }
    getFeatureOffsetX() {
        if (!this.styleModalData.offsetX) {
            return this.data.features.length > 0
                ? this.data.features[0].properties.offsetX
                : this.drawStyleService.getOffsetX();
        }
        else {
            return this.styleModalData.offsetX;
        }
    }
    getFeatureOffsetY() {
        if (!this.styleModalData.offsetY) {
            return this.data.features.length > 0
                ? this.data.features[0].properties.offsetY
                : this.drawStyleService.getOffsetY();
        }
        else {
            return this.styleModalData.offsetY;
        }
    }
    cancelDrawing() {
        this.dialogRef.close();
    }
    confirm() {
        this.confirmFlag = true;
        if (this.form.get('fill').value) {
            this.styleModalData.fillColor = this.form.get('fill').value;
        }
        if (this.form.get('stroke').value) {
            this.styleModalData.strokeColor = this.form.get('stroke').value;
        }
        this.dialogRef.close(this.styleModalData);
    }
    openPicker() {
        this.dialogRef.disableClose = true;
    }
    closePicker() {
        this.dialogRef.disableClose = false;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: StyleModalDrawingComponent, deps: [{ token: i1$2.MatDialogRef }, { token: i2$1.UntypedFormBuilder }, { token: DrawStyleService }, { token: MAT_DIALOG_DATA }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: StyleModalDrawingComponent, selector: "igo-style-modal-drawing", inputs: { confirmFlag: "confirmFlag" }, ngImport: i0, template: "<h2 mat-dialog-title>\n  {{ 'igo.geo.style.styleModal' | translate }}\n</h2>\n<div\n  class=\"edition-drawing\"\n  mat-dialog-content\n  [hidden]=\"data.features.length === 0\"\n>\n  <form class=\"igo-form\" [formGroup]=\"form\">\n    <div class=\"color-picker\">\n      <ng-container *ngIf=\"linestringOnly !== true\">\n        <span>\n          <mat-icon class=\"stroke-palette-icon\" svgIcon=\"square\"></mat-icon>\n          {{ 'igo.geo.style.fill' | translate }}\n        </span>\n\n        <igo-color-picker-form-field\n          formControlName=\"fill\"\n        ></igo-color-picker-form-field>\n      </ng-container>\n\n      <span>\n        <mat-icon class=\"stroke-palette-icon\" svgIcon=\"square-outline\">\n        </mat-icon>\n        {{ 'igo.geo.style.stroke' | translate }}\n      </span>\n\n      <igo-color-picker-form-field\n        formControlName=\"stroke\"\n      ></igo-color-picker-form-field>\n    </div>\n\n    <div class=\"igo-input-container\">\n      <mat-form-field class=\"igo-form-input-box\" subscriptSizing=\"dynamic\">\n        <mat-label>{{ 'igo.geo.style.fontSize' | translate }}</mat-label>\n        <input\n          matInput\n          #testFontSize\n          type=\"number\"\n          placeholder=\"10\"\n          min=\"10\"\n          onkeydown=\"return event.keyCode !== 69\"\n          [value]=\"getFeatureFontSize()\"\n          (input)=\"styleModalData.fontSize = $event.target.value\"\n        />\n        <span matTextSuffix>px</span>\n      </mat-form-field>\n      <mat-form-field class=\"igo-form-input-box\" subscriptSizing=\"dynamic\">\n        <mat-label>{{ 'igo.geo.style.fontStyle' | translate }}</mat-label>\n        <mat-select\n          #testFontStyle\n          [value]=\"getFeatureFontStyle()\"\n          (selectionChange)=\"styleModalData.fontStyle = $event.value\"\n        >\n          <mat-option\n            *ngFor=\"let fontSelect of allFontStyles\"\n            [value]=\"fontSelect\"\n          >\n            {{ fontSelect }}\n          </mat-option>\n        </mat-select>\n      </mat-form-field>\n      <mat-form-field class=\"igo-form-input-box\" subscriptSizing=\"dynamic\">\n        <mat-label>{{ 'igo.geo.style.offsetX' | translate }}</mat-label>\n        <input\n          matInput\n          #offsetXInput\n          type=\"number\"\n          onkeydown=\"return event.keyCode !== 69\"\n          [value]=\"getFeatureOffsetX()\"\n          (input)=\"styleModalData.offsetX = $event.target.value\"\n        />\n      </mat-form-field>\n      <mat-form-field class=\"igo-form-input-box\" subscriptSizing=\"dynamic\">\n        <mat-label>{{ 'igo.geo.style.offsetY' | translate }}</mat-label>\n        <input\n          matInput\n          #offsetYInput\n          type=\"number\"\n          onkeydown=\"return event.keyCode !== 69\"\n          [value]=\"getFeatureOffsetY()\"\n          (input)=\"styleModalData.offsetY = $event.target.value\"\n        />\n      </mat-form-field>\n    </div>\n  </form>\n</div>\n<div mat-dialog-actions>\n  <button mat-raised-button (click)=\"cancelDrawing()\">\n    {{ 'igo.geo.style.cancel' | translate }}\n  </button>\n  <button mat-raised-button color=\"primary\" (click)=\"confirm()\">OK</button>\n</div>\n", styles: [":host h2{margin:0 0 1px}:host form{padding-top:16px}:host .fill-field,:host .stroke-field{width:140px}:host .color-picker{display:grid;grid-template-columns:auto 1fr;align-items:center;grid-gap:16px;margin-bottom:16px}:host .color-picker span{display:flex;align-items:center}:host .color-picker span mat-icon{margin-right:8px}:host .box{width:25px;height:25px}:host .igo-input-container{display:grid;grid-template-columns:1fr 1fr;grid-gap:16px}:host .igo-form-input-box{width:150px}:host button{margin-right:5px}\n"], dependencies: [{ kind: "directive", type: i2$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2$1.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "component", type: i8.MatFormField, selector: "mat-form-field", inputs: ["hideRequiredMarker", "color", "floatLabel", "appearance", "subscriptSizing", "hintLabel"], exportAs: ["matFormField"] }, { kind: "directive", type: i8.MatLabel, selector: "mat-label" }, { kind: "directive", type: i8.MatSuffix, selector: "[matSuffix], [matIconSuffix], [matTextSuffix]", inputs: ["matTextSuffix"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i4$1.MatButton, selector: "    button[mat-button], button[mat-raised-button], button[mat-flat-button],    button[mat-stroked-button]  ", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "directive", type: i1$2.MatDialogTitle, selector: "[mat-dialog-title], [matDialogTitle]", inputs: ["id"], exportAs: ["matDialogTitle"] }, { kind: "directive", type: i1$2.MatDialogContent, selector: "[mat-dialog-content], mat-dialog-content, [matDialogContent]" }, { kind: "directive", type: i1$2.MatDialogActions, selector: "[mat-dialog-actions], mat-dialog-actions, [matDialogActions]", inputs: ["align"] }, { kind: "directive", type: i9$3.MatInput, selector: "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", inputs: ["disabled", "id", "placeholder", "name", "required", "type", "errorStateMatcher", "aria-describedby", "value", "readonly"], exportAs: ["matInput"] }, { kind: "component", type: i15.MatSelect, selector: "mat-select", inputs: ["disabled", "disableRipple", "tabIndex", "panelWidth", "hideSingleSelectionIndicator"], exportAs: ["matSelect"] }, { kind: "component", type: i9.MatOption, selector: "mat-option", exportAs: ["matOption"] }, { kind: "directive", type: i2$1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "directive", type: i2$1.FormControlName, selector: "[formControlName]", inputs: ["formControlName", "disabled", "ngModel"], outputs: ["ngModelChange"] }, { kind: "component", type: i9$1.ColorPickerFormFieldComponent, selector: "igo-color-picker-form-field", inputs: ["outputFormat"], outputs: ["colorChange"] }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: StyleModalDrawingComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-style-modal-drawing', template: "<h2 mat-dialog-title>\n  {{ 'igo.geo.style.styleModal' | translate }}\n</h2>\n<div\n  class=\"edition-drawing\"\n  mat-dialog-content\n  [hidden]=\"data.features.length === 0\"\n>\n  <form class=\"igo-form\" [formGroup]=\"form\">\n    <div class=\"color-picker\">\n      <ng-container *ngIf=\"linestringOnly !== true\">\n        <span>\n          <mat-icon class=\"stroke-palette-icon\" svgIcon=\"square\"></mat-icon>\n          {{ 'igo.geo.style.fill' | translate }}\n        </span>\n\n        <igo-color-picker-form-field\n          formControlName=\"fill\"\n        ></igo-color-picker-form-field>\n      </ng-container>\n\n      <span>\n        <mat-icon class=\"stroke-palette-icon\" svgIcon=\"square-outline\">\n        </mat-icon>\n        {{ 'igo.geo.style.stroke' | translate }}\n      </span>\n\n      <igo-color-picker-form-field\n        formControlName=\"stroke\"\n      ></igo-color-picker-form-field>\n    </div>\n\n    <div class=\"igo-input-container\">\n      <mat-form-field class=\"igo-form-input-box\" subscriptSizing=\"dynamic\">\n        <mat-label>{{ 'igo.geo.style.fontSize' | translate }}</mat-label>\n        <input\n          matInput\n          #testFontSize\n          type=\"number\"\n          placeholder=\"10\"\n          min=\"10\"\n          onkeydown=\"return event.keyCode !== 69\"\n          [value]=\"getFeatureFontSize()\"\n          (input)=\"styleModalData.fontSize = $event.target.value\"\n        />\n        <span matTextSuffix>px</span>\n      </mat-form-field>\n      <mat-form-field class=\"igo-form-input-box\" subscriptSizing=\"dynamic\">\n        <mat-label>{{ 'igo.geo.style.fontStyle' | translate }}</mat-label>\n        <mat-select\n          #testFontStyle\n          [value]=\"getFeatureFontStyle()\"\n          (selectionChange)=\"styleModalData.fontStyle = $event.value\"\n        >\n          <mat-option\n            *ngFor=\"let fontSelect of allFontStyles\"\n            [value]=\"fontSelect\"\n          >\n            {{ fontSelect }}\n          </mat-option>\n        </mat-select>\n      </mat-form-field>\n      <mat-form-field class=\"igo-form-input-box\" subscriptSizing=\"dynamic\">\n        <mat-label>{{ 'igo.geo.style.offsetX' | translate }}</mat-label>\n        <input\n          matInput\n          #offsetXInput\n          type=\"number\"\n          onkeydown=\"return event.keyCode !== 69\"\n          [value]=\"getFeatureOffsetX()\"\n          (input)=\"styleModalData.offsetX = $event.target.value\"\n        />\n      </mat-form-field>\n      <mat-form-field class=\"igo-form-input-box\" subscriptSizing=\"dynamic\">\n        <mat-label>{{ 'igo.geo.style.offsetY' | translate }}</mat-label>\n        <input\n          matInput\n          #offsetYInput\n          type=\"number\"\n          onkeydown=\"return event.keyCode !== 69\"\n          [value]=\"getFeatureOffsetY()\"\n          (input)=\"styleModalData.offsetY = $event.target.value\"\n        />\n      </mat-form-field>\n    </div>\n  </form>\n</div>\n<div mat-dialog-actions>\n  <button mat-raised-button (click)=\"cancelDrawing()\">\n    {{ 'igo.geo.style.cancel' | translate }}\n  </button>\n  <button mat-raised-button color=\"primary\" (click)=\"confirm()\">OK</button>\n</div>\n", styles: [":host h2{margin:0 0 1px}:host form{padding-top:16px}:host .fill-field,:host .stroke-field{width:140px}:host .color-picker{display:grid;grid-template-columns:auto 1fr;align-items:center;grid-gap:16px;margin-bottom:16px}:host .color-picker span{display:flex;align-items:center}:host .color-picker span mat-icon{margin-right:8px}:host .box{width:25px;height:25px}:host .igo-input-container{display:grid;grid-template-columns:1fr 1fr;grid-gap:16px}:host .igo-form-input-box{width:150px}:host button{margin-right:5px}\n"] }]
        }], ctorParameters: function () { return [{ type: i1$2.MatDialogRef }, { type: i2$1.UntypedFormBuilder }, { type: DrawStyleService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [MAT_DIALOG_DATA]
                }] }]; }, propDecorators: { confirmFlag: [{
                type: Input
            }] } });

class DrawIconService {
    config;
    icons;
    constructor(config) {
        this.config = config;
        this.getIconsList();
    }
    getIcons() {
        return this.icons;
    }
    getPath() {
        return this.config.getConfig('drawingTool.icons') || [];
    }
    getIconsList() {
        this.icons = this.getPath();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DrawIconService, deps: [{ token: i2.ConfigService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DrawIconService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DrawIconService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i2.ConfigService }]; } });

class DrawComponent {
    languageService;
    formBuilder;
    drawStyleService;
    dialog;
    drawIconService;
    /**
     * Table template
     * @internal
     */
    tableTemplate;
    geometryType = GeometryType; // Reference to the GeometryType enum
    map; // Map to draw on
    get stores() {
        return this._stores;
    }
    set stores(value) {
        this._stores = value;
    }
    _stores = [];
    get drawControls() {
        return this._drawControls;
    }
    set drawControls(value) {
        this._drawControls = value;
    }
    _drawControls = [];
    get activeDrawingLayer() {
        return this._activeDrawingLayer;
    }
    set activeDrawingLayer(value) {
        this._activeDrawingLayer = value;
    }
    _activeDrawingLayer;
    activeLayerChange = new EventEmitter();
    drawControlsEvent = new EventEmitter();
    layersIDEvent = new EventEmitter();
    fillColor;
    strokeColor;
    strokeWidth;
    fontSize;
    fontStyle;
    activeStore;
    layerCounterID = 0;
    draw$ = new BehaviorSubject({}); // Observable of draw
    activeDrawingLayerSource = new OlVectorSource();
    activeDrawControl;
    drawEnd$$;
    drawSelect$$;
    selectedFeatures$ = new BehaviorSubject([]);
    fillForm;
    strokeForm;
    drawControlIsDisabled = true;
    drawControlIsActive = false;
    labelsAreShown;
    freehandMode = false;
    subscriptions$$ = [];
    position = 'bottom';
    form;
    icons;
    icon;
    radiusFormControl = new UntypedFormControl(1000);
    measureUnit = MeasureLengthUnit.Meters;
    radiusFormControlChange$$ = new Subscription();
    predefinedRadius$ = new BehaviorSubject(undefined);
    radiusDrawEnd$ = new BehaviorSubject(undefined);
    /**
     * Available measure units for the measure type given
     * @internal
     */
    get measureUnits() {
        return [MeasureLengthUnit.Meters, MeasureLengthUnit.Kilometers];
    }
    numberOfDrawings;
    isCreatingNewLayer = false;
    currGeometryType = this.geometryType.Point;
    select;
    constructor(languageService, formBuilder, drawStyleService, dialog, drawIconService) {
        this.languageService = languageService;
        this.formBuilder = formBuilder;
        this.drawStyleService = drawStyleService;
        this.dialog = dialog;
        this.drawIconService = drawIconService;
        this.tableTemplate = {
            selection: true,
            selectMany: true,
            selectionCheckbox: true,
            sort: true,
            fixedHeader: true,
            tableHeight: 'auto',
            columns: [
                {
                    name: 'Drawing',
                    title: this.languageService.translate.instant('igo.geo.draw.labels'),
                    valueAccessor: (feature) => {
                        return feature.properties.draw;
                    }
                },
                {
                    name: 'Edition',
                    title: '',
                    sort: false,
                    valueAccessor: (feature) => {
                        return [
                            {
                                editMode: false,
                                icon: 'pencil',
                                color: 'primary',
                                click: () => {
                                    this.editLabelDrawing(feature);
                                },
                                style: 'mat-icon-button'
                            }
                        ];
                    },
                    renderer: EntityTableColumnRenderer.ButtonGroup
                }
            ]
        };
        this.buildForm();
        this.fillColor = this.drawStyleService.getFillColor();
        this.strokeColor = this.drawStyleService.getStrokeColor();
        this.strokeWidth = this.drawStyleService.getStrokeWidth();
        this.labelsAreShown = this.drawStyleService.getLabelsAreShown();
        this.icons = this.drawIconService.getIcons();
        this.icon = this.drawStyleService.getIcon();
        this.fontSize = this.drawStyleService.getFontSize();
        this.fontStyle = this.drawStyleService.getFontStyle();
    }
    // Initialize the store that will contain the entities and create the Draw control
    ngOnInit() {
        if (!this.stores.length) {
            this.activeStore = new FeatureStore([], {
                map: this.map
            });
            this.initStore();
            this.activeDrawControl = this.createDrawControl(this.fillColor, this.strokeColor, this.strokeWidth);
            this.activeDrawControl.setGeometryType(this.geometryType.Point);
            this.toggleDrawControl();
            this.stores.push(this.activeStore);
            this.drawControls.push([
                this.activeDrawingLayer.id,
                this.activeDrawControl
            ]);
            this.drawControlsEvent.emit(this.drawControls);
            this.layersIDEvent.emit(this.activeDrawingLayer.id);
            this.onLayerChange(this.activeDrawingLayer);
        }
        else {
            this.activeStore = this.stores.find((store) => store.layer.id === this.activeDrawingLayer.id);
            this.activeDrawControl = this.drawControls.find((dc) => dc[0] === this.activeDrawingLayer.id)[1];
            this.deactivateDrawControl();
            this.allLayers.forEach((layer) => {
                if (layer.id !== this.activeDrawingLayer.id) {
                    layer.opacity = 0;
                }
                let store = this.stores.find((s) => s.layer.id === layer.id);
                this.subscriptions$$.push(store.stateView
                    .manyBy$((record) => {
                    return record.state.selected === true;
                })
                    .pipe(first())
                    .subscribe((records) => {
                    records.forEach((record) => {
                        record.state.selected = false;
                    });
                }));
                this.subscriptions$$.push(store.stateView
                    .manyBy$((record) => {
                    return record.state.selected === true;
                })
                    .pipe(skip(1) // Skip initial emission
                )
                    .subscribe((records) => {
                    this.selectedFeatures$.next(records.map((record) => record.entity));
                }));
                this.subscriptions$$.push(store.count$.subscribe((cnt) => {
                    cnt >= 1
                        ? (this.activeStore.layer.options.showInLayerList = true)
                        : (this.activeStore.layer.options.showInLayerList = false);
                }));
            });
            this.onLayerChange(this.activeDrawingLayer);
        }
        this.radiusFormControlChange$$ =
            this.radiusFormControl.valueChanges.subscribe((value) => {
                if (this.activeDrawControl.ispredefinedRadius$.getValue()) {
                    this.changeRadius(value);
                }
            });
    }
    /**
     * Remove the drawing layer and the interactions
     * @internal
     */
    ngOnDestroy() {
        this.allLayers.forEach((layer) => (layer.opacity = 1));
        this.activeStore.state.updateAll({ selected: false });
        this.deactivateDrawControl();
        this.subscriptions$$.map((s) => s.unsubscribe());
        this.radiusFormControlChange$$.unsubscribe();
    }
    /**
     * Create a Draw Control
     * @param fillColor the fill color
     * @param strokeColor the stroke color
     * @param strokeWidth the stroke width
     * @returns a Draw Control
     */
    createDrawControl(fillColor, strokeColor, strokeWidth) {
        const activeDrawControl = new DrawControl({
            geometryType: undefined,
            drawingLayerSource: this.activeDrawingLayerSource,
            drawingLayerStyle: new olStyle.Style({}),
            interactionStyle: createInteractionStyle(fillColor, strokeColor, strokeWidth)
        });
        return activeDrawControl;
    }
    /**
     * Store initialization, including drawing layer creation
     */
    initStore(newTitle, isNewLayer) {
        this.createLayer(newTitle, isNewLayer);
        this.subscriptions$$.push(this.activeStore.stateView
            .manyBy$((record) => {
            return record.state.selected === true;
        })
            .pipe(skip(1) // Skip initial emission
        )
            .subscribe((records) => {
            this.selectedFeatures$.next(records.map((record) => record.entity));
        }));
        this.subscriptions$$.push(this.activeStore.count$.subscribe((cnt) => {
            cnt >= 1
                ? (this.activeStore.layer.options.showInLayerList = true)
                : (this.activeStore.layer.options.showInLayerList = false);
        }));
    }
    /**
     * Open the style modal dialog box
     */
    openStyleModalDialog() {
        setTimeout(() => {
            // open the dialog box used to style features
            const dialogRef = this.dialog.open(StyleModalDrawingComponent, {
                disableClose: false,
                data: {
                    features: this.selectedFeatures$.getValue(),
                    icons: this.icons,
                    icon: this.icon
                },
                autoFocus: false
            });
            // when dialog box is closed, get label and set it to geometry
            dialogRef.afterClosed().subscribe((data) => {
                // checks if the user clicked ok
                if (dialogRef.componentInstance.confirmFlag) {
                    this.onFontChange(this.labelsAreShown, data.fontSize, data.fontStyle);
                    this.onColorChange(this.labelsAreShown, this.icon ? true : false, data.fillColor, data.strokeColor);
                    this.onOffsetLabelChange(this.labelsAreShown, data.offsetX, data.offsetY);
                }
            });
        }, 250);
    }
    /**
     * Open a dialog box to enter label and do something
     * @param olGeometry geometry at draw end or selected geometry
     * @param drawEnd event fired at drawEnd?
     */
    openDrawDialog(olGeometry, isDrawEnd) {
        setTimeout(() => {
            // open the dialog box used to enter label
            const dialogRef = this.dialog.open(DrawPopupComponent, {
                disableClose: false,
                data: { olGeometry: olGeometry, map: this.map }
            });
            // when dialog box is closed, get label and set it to geometry
            dialogRef.afterClosed().subscribe((result) => {
                // checks if the user clicked ok
                if (dialogRef.componentInstance.confirmFlag) {
                    this.updateLabelOfOlGeometry(olGeometry, result.label);
                    this.updateLabelType(olGeometry, dialogRef.componentInstance.labelFlag);
                    this.updateMeasureUnit(olGeometry, result.measureUnit);
                    if (!(olGeometry instanceof OlFeature)) {
                        this.updateFontSizeAndStyle(olGeometry, '15', FontType.Arial);
                        this.updateFillAndStrokeColor(olGeometry, 'rgba(255,255,255,0.4)', 'rgba(143,7,7,1)');
                        this.updateOffset(olGeometry, 0, olGeometry instanceof OlPoint ? -15 : 0);
                    }
                    isDrawEnd
                        ? this.onDrawEnd(olGeometry)
                        : this.onSelectDraw(olGeometry, result.label, [
                            dialogRef.componentInstance.labelFlag,
                            result.measureUnit
                        ]);
                    this.updateHeightTable();
                }
                // deletes the feature
                else {
                    this.activeDrawingLayerSource
                        .getFeatures()
                        .forEach((drawingLayerFeature) => {
                        const geometry = drawingLayerFeature.getGeometry();
                        if (olGeometry === geometry) {
                            this.activeDrawingLayerSource.removeFeature(drawingLayerFeature);
                        }
                    });
                }
            });
        }, 250);
    }
    /**
     * Clear the draw source and track the geometry being draw
     * @param olGeometry Ol linestring or polygon
     */
    onDrawEnd(olGeometry, radius) {
        this.addFeatureToStore(olGeometry, radius);
        this.clearLabelsOfOlGeometry(olGeometry);
        this.activeStore.layer.ol.getSource().refresh();
    }
    onModifyDraw(olGeometry) {
        const entities = this.activeStore.all();
        entities.forEach((entity) => {
            const entityId = entity.properties.id;
            const olGeometryId = olGeometry.ol_uid;
            if (entityId === olGeometryId) {
                if (entity.properties.labelType === LabelType.Coordinates) {
                    let longLat = DDtoDMS([entity.properties.longitude, entity.properties.latitude], entity.properties.measureUnit);
                    this.updateLabelOfOlGeometry(olGeometry, '(' + longLat[1] + ', ' + longLat[0] + ')');
                }
                else if (entity.properties.labelType === LabelType.Length) {
                    if (olGeometry instanceof OlCircle) {
                        let circularPolygon = fromCircle(olGeometry, 10000);
                        const radius = metersToUnit(this.getRadius(circularPolygon), entity.properties.measureUnit);
                        const unit = MeasureLengthUnitAbbreviation[entity.properties.measureUnit];
                        const radiusLabel = 'R: ' + radius.toFixed(2).toString() + ' ' + unit;
                        this.updateLabelOfOlGeometry(olGeometry, radiusLabel);
                    }
                    else {
                        let olGeometryLength = measureOlGeometryLength(olGeometry, this.map.ol.getView().getProjection().getCode());
                        let measureUnit;
                        const temp = entity.properties
                            .measureUnit;
                        measureUnit =
                            MeasureLengthUnitAbbreviation[entity.properties.measureUnit];
                        olGeometryLength = metersToUnit(olGeometryLength, temp);
                        let lengthLabel = olGeometry instanceof OlPolygon
                            ? 'P: ' +
                                olGeometryLength.toFixed(2).toString() +
                                ' ' +
                                measureUnit
                            : olGeometryLength.toFixed(2).toString() + ' ' + measureUnit;
                        this.updateLabelOfOlGeometry(olGeometry, lengthLabel);
                    }
                }
                else if (entity.properties.labelType === LabelType.Area) {
                    if (olGeometry instanceof OlCircle) {
                        let circularPolygon = fromCircle(olGeometry, 10000);
                        let circleArea = measureOlGeometryArea(circularPolygon, this.map.ol.getView().getProjection().getCode());
                        const unit = MeasureAreaUnitAbbreviation[entity.properties.measureUnit];
                        const temp = entity.properties
                            .measureUnit;
                        circleArea = squareMetersToUnit(circleArea, temp);
                        const areaLabel = circleArea.toFixed(2).toString() + ' ' + unit;
                        this.updateLabelOfOlGeometry(olGeometry, areaLabel);
                    }
                    else {
                        let olGeometryArea = measureOlGeometryArea(olGeometry, this.map.ol.getView().getProjection().getCode());
                        let measureUnit;
                        const temp = entity.properties
                            .measureUnit;
                        measureUnit =
                            MeasureAreaUnitAbbreviation[entity.properties.measureUnit];
                        olGeometryArea = squareMetersToUnit(olGeometryArea, temp);
                        const lengthLabel = olGeometryArea.toFixed(2).toString() + ' ' + measureUnit;
                        this.updateLabelOfOlGeometry(olGeometry, lengthLabel);
                    }
                }
                else {
                    this.updateLabelOfOlGeometry(olGeometry, entity.properties.draw);
                }
                this.updateLabelType(olGeometry, entity.properties.labelType);
                this.updateMeasureUnit(olGeometry, entity.properties.measureUnit);
                this.updateFontSizeAndStyle(olGeometry, entity.properties.fontStyle.split(' ')[0].replace('px', ''), entity.properties.fontStyle.substring(entity.properties.fontStyle.indexOf(' ') + 1));
                this.updateFillAndStrokeColor(olGeometry, entity.properties.drawingStyle.fill, entity.properties.drawingStyle.stroke);
                this.updateOffset(olGeometry, entity.properties.offsetX, entity.properties.offsetY);
                this.replaceFeatureInStore(entity, olGeometry);
            }
        });
    }
    onSelectDraw(olFeature, label, labelTypeAndUnit) {
        const entities = this.activeStore.all();
        const olGeometry = olFeature.getGeometry();
        olGeometry.ol_uid = olFeature.get('id');
        const olGeometryCoordinates = JSON.stringify(olGeometry.getCoordinates()[0]);
        entities.forEach((entity) => {
            const entityCoordinates = JSON.stringify(entity.geometry.coordinates[0]);
            if (olGeometryCoordinates === entityCoordinates) {
                const fontSize = olFeature
                    .get('fontStyle')
                    .split(' ')[0]
                    .replace('px', '');
                const fontStyle = olFeature
                    .get('fontStyle')
                    .substring(olFeature.get('fontStyle').indexOf(' ') + 1);
                const fillColor = olFeature.get('drawingStyle').fill;
                const strokeColor = olFeature.get('drawingStyle').stroke;
                const offsetX = olFeature.get('offsetX');
                const offsetY = olFeature.get('offsetY');
                const rad = entity.properties.rad
                    ? entity.properties.rad
                    : undefined;
                this.updateLabelOfOlGeometry(olGeometry, label);
                this.updateFontSizeAndStyle(olGeometry, fontSize, fontStyle);
                this.updateFillAndStrokeColor(olGeometry, fillColor, strokeColor);
                this.updateOffset(olGeometry, offsetX, offsetY);
                this.updateLabelType(olGeometry, labelTypeAndUnit[0]);
                this.updateMeasureUnit(olGeometry, labelTypeAndUnit[1]);
                this.replaceFeatureInStore(entity, olGeometry, rad);
            }
        });
    }
    /**
     * Add a feature with draw label to the store. The loading stragegy of the store
     * will trigger and add the feature to the map.
     * @internal
     */
    addFeatureToStore(olGeometry, radius, feature) {
        let rad;
        let center4326;
        let point4326;
        let lon4326;
        let lat4326;
        const featureId = feature ? feature.properties.id : olGeometry.ol_uid;
        const projection = this.map.ol.getView().getProjection();
        const geometry = new OlGeoJSON().writeGeometryObject(olGeometry, {
            featureProjection: projection,
            dataProjection: projection
        });
        if (olGeometry instanceof OlCircle || radius) {
            if (radius) {
                rad = radius;
            }
            else {
                geometry.type = 'Point';
                geometry.coordinates = olGeometry.getCenter();
                const extent4326 = transform([
                    olGeometry.getFlatCoordinates()[2],
                    olGeometry.getFlatCoordinates()[3]
                ], projection, 'EPSG:4326');
                center4326 = transform([
                    olGeometry.getFlatCoordinates()[0],
                    olGeometry.getFlatCoordinates()[1]
                ], projection, 'EPSG:4326');
                lon4326 = center4326[0];
                lat4326 = center4326[1];
                rad = getDistance(center4326, extent4326);
                this.radiusFormControl.setValue(Math.round(rad));
            }
        }
        if (this.activeDrawControl.radiusDrawEnd$.getValue()) {
            rad = this.activeDrawControl.radiusDrawEnd$.getValue();
        }
        if (olGeometry instanceof OlPoint) {
            point4326 = transform(olGeometry.getFlatCoordinates(), projection, 'EPSG:4326');
            lon4326 = point4326[0];
            lat4326 = point4326[1];
        }
        this.activeStore.update({
            type: FEATURE,
            geometry,
            projection: projection.getCode(),
            properties: {
                id: featureId,
                draw: olGeometry.get('_label'),
                longitude: lon4326 ? lon4326 : null,
                latitude: lat4326 ? lat4326 : null,
                rad: rad ? rad : null,
                fontStyle: olGeometry.get('fontStyle_'),
                drawingStyle: {
                    fill: olGeometry.get('fillColor_'),
                    stroke: olGeometry.get('strokeColor_')
                },
                offsetX: olGeometry.get('offsetX_'),
                offsetY: olGeometry.get('offsetY_'),
                labelType: olGeometry.get('labelType_'),
                measureUnit: olGeometry.get('measureUnit_')
            },
            meta: {
                id: featureId
            }
        });
        this.activeStore.setLayerExtent();
        this.activeDrawControl.predefinedRadius$.next(undefined);
        this.activeDrawControl.radiusDrawEnd$.next(undefined);
    }
    buildForm() {
        this.form = this.formBuilder.group({
            fill: [''],
            stroke: ['']
        });
    }
    setupLayer(isNewLayer) {
        setTimeout(() => {
            const dialogRef = this.dialog.open(DrawLayerPopupComponent, {
                disableClose: false
            });
            dialogRef.afterClosed().subscribe((label) => {
                if (dialogRef.componentInstance.confirmFlag) {
                    this.activeStore.state.updateAll({ selected: false });
                    this.activeStore = new FeatureStore([], {
                        map: this.map
                    });
                    this.activeDrawingLayerSource = new OlVectorSource();
                    this.activeDrawingLayer.opacity = 0;
                    this.deactivateDrawControl();
                    this.initStore(label, isNewLayer);
                    this.activeDrawControl = this.createDrawControl(this.fillColor, this.strokeColor, this.strokeWidth);
                    this.activeDrawControl.setGeometryType(this.currGeometryType);
                    this.toggleDrawControl();
                    this.stores.push(this.activeStore);
                    this.drawControls.push([
                        this.activeDrawingLayer.id,
                        this.activeDrawControl
                    ]);
                    this.drawControlsEvent.emit(this.drawControls);
                    this.layersIDEvent.emit(this.activeDrawingLayer.id);
                    this.isCreatingNewLayer = false;
                    if (!this.labelsAreShown) {
                        this.onToggleLabels();
                    }
                    this.activeLayerChange.emit(this.activeDrawingLayer);
                }
                else {
                    this.select.value = this.activeDrawingLayer;
                    this.select.selectionChange.emit(this.activeDrawingLayer);
                }
            });
        }, 250);
    }
    // HTML user interactions
    /**
     * Called when the user double-clicks the selected drawing
     */
    editLabelDrawing(feature) {
        const olGeometryFeature = featureToOl(feature, this.map.ol.getView().getProjection().getCode());
        this.openDrawDialog(olGeometryFeature, false);
    }
    openShorcutsDialog() {
        this.dialog.open(DrawShorcutsComponent);
    }
    deleteDrawings() {
        this.activeStore.deleteMany(this.selectedFeatures$.value);
        this.selectedFeatures$.value.forEach((selectedFeature) => {
            this.activeDrawingLayerSource
                .getFeatures()
                .forEach((drawingLayerFeature) => {
                const geometry = drawingLayerFeature.getGeometry();
                if (selectedFeature.properties.id === geometry.ol_uid) {
                    this.activeDrawingLayerSource.removeFeature(drawingLayerFeature);
                }
            });
        });
        this.updateHeightTable();
        this.activeStore.setLayerExtent();
    }
    /**
     * Called when the user toggles the labels toggle
     */
    onToggleLabels() {
        this.drawStyleService.toggleLabelsAreShown();
        this.labelsAreShown = !this.labelsAreShown;
        this.icon
            ? this.elementStyle(this.labelsAreShown, true)
            : this.elementStyle(this.labelsAreShown, false);
        this.createDrawControl();
    }
    /**
     * Called when the user toggles the Draw control is toggled
     * @internal
     */
    onToggleDrawControl(toggleIsChecked) {
        toggleIsChecked ? this.toggleDrawControl() : this.deactivateDrawControl();
    }
    onToggleFreehandMode(event) {
        if (this.isCircle() && !event.checked) {
            this.activeDrawControl.ispredefinedRadius$.next(true);
            this.changeRadius(this.radiusFormControl.value);
        }
        else {
            this.activeDrawControl.setOlInteractionStyle(createInteractionStyle(this.fillColor, this.strokeColor, this.strokeWidth));
            this.activeDrawControl.ispredefinedRadius$.next(false);
        }
        this.freehandMode = event.checked;
        this.activeDrawControl.freehand$.next(event.checked);
        this.toggleDrawControl();
    }
    // User changes properties of a drawing element
    /**
     * Display the current layer with the current store and the current layerSource
     */
    onLayerChange(currLayer) {
        if (currLayer) {
            this.activeStore.state.updateAll({ selected: false });
            this.isCreatingNewLayer = false;
            this.activeDrawingLayer.opacity = 0;
            this.activeDrawingLayer = currLayer;
            this.activeDrawingLayer.opacity = 1;
            this.deactivateDrawControl();
            if (!this.labelsAreShown) {
                this.onToggleLabels();
            }
            this.activeStore = this.stores.find((store) => store.layer.id === this.activeDrawingLayer.id);
            this.activeDrawControl = this.drawControls.find((dc) => dc[0] === this.activeDrawingLayer.id)[1];
            this.activeDrawingLayerSource =
                this.activeDrawControl.olDrawingLayerSource;
            this.activeDrawControl.setGeometryType(this.currGeometryType);
            this.toggleDrawControl();
        }
        else {
            this.setupLayer(true);
        }
        this.activeLayerChange.emit(this.activeDrawingLayer);
    }
    createLayer(newTitle, isNewLayer) {
        for (const layer of this.allLayers) {
            let numberId = Number(layer.id.replace('igo-draw-layer', ''));
            this.layerCounterID = Math.max(numberId, this.layerCounterID);
        }
        this.activeDrawingLayer = new VectorLayer({
            isIgoInternalLayer: true,
            id: 'igo-draw-layer' + ++this.layerCounterID,
            title: isNewLayer
                ? newTitle
                : this.languageService.translate.instant('igo.geo.draw.drawing'),
            zIndex: 200,
            source: new FeatureDataSource(),
            style: (feature, resolution) => {
                return this.drawStyleService.createIndividualElementStyle(feature, resolution, this.labelsAreShown, feature.get('fontStyle'), feature.get('drawingStyle').fill, feature.get('drawingStyle').stroke, feature.get('offsetX'), feature.get('offsetY'), this.map.projection, this.icon);
            },
            showInLayerList: true,
            exportable: true,
            browsable: false,
            workspace: {
                enabled: false
            }
        });
        tryBindStoreLayer(this.activeStore, this.activeDrawingLayer);
        tryAddLoadingStrategy(this.activeStore, new FeatureStoreLoadingStrategy({
            motion: FeatureMotion.None
        }));
        tryAddSelectionStrategy(this.activeStore, new FeatureStoreSelectionStrategy({
            map: this.map,
            motion: FeatureMotion.None,
            many: true
        }));
        this.activeStore.layer.visible = true;
        this.activeStore.source.ol.on('removefeature', (event) => {
            const olGeometry = event.feature.getGeometry();
            this.clearLabelsOfOlGeometry(olGeometry);
        });
    }
    /**
     * Called when the user changes the color in a color picker
     * @param labelsAreShown wheter the labels are shown or not
     * @param isAnIcon wheter the feature is an icon or not
     * @param fillColor which is the filling color
     * @param strokeColor which is the stroke color
     */
    onColorChange(labelsAreShown, isAnIcon, fillColor, strokeColor) {
        if (this.selectedFeatures$.value.length > 0 && !isAnIcon) {
            this.selectedFeatures$.value.forEach((feature) => {
                let olFeature = featureToOl(feature, this.map.ol.getView().getProjection().getCode());
                this.updateFillAndStrokeColor(olFeature, fillColor, strokeColor);
                const entity = this.activeStore
                    .all()
                    .find((e) => e.meta.id === olFeature.getId());
                entity.properties.drawingStyle.fill = olFeature.get('fillColor_');
                entity.properties.drawingStyle.stroke = olFeature.get('strokeColor_');
                this.activeStore.update(entity);
            });
        }
        this.elementStyle(labelsAreShown, isAnIcon);
        this.createDrawControl();
    }
    /**
     * Called when the user changes the font size or/and style
     * @param labelsAreShown wheter the labels are shown or not
     * @param size the size of the font
     * @param style the style of the font
     */
    onFontChange(labelsAreShown, size, style) {
        if (this.selectedFeatures$.value.length > 0) {
            this.selectedFeatures$.value.forEach((feature) => {
                let olFeature = featureToOl(feature, this.map.ol.getView().getProjection().getCode());
                this.updateFontSizeAndStyle(olFeature, size, style);
                const entity = this.activeStore
                    .all()
                    .find((e) => e.meta.id === olFeature.getId());
                entity.properties.fontStyle = olFeature.get('fontStyle_');
                this.activeStore.update(entity);
                olFeature = this.activeStore.layer.ol
                    .getSource()
                    .getFeatures()
                    .find((f) => f.getId() === entity.meta.id);
                olFeature.setProperties({ fontStyle: entity.properties.fontStyle });
                olFeature.changed();
            });
            this.fontSize = size;
            this.fontStyle = style;
            this.drawStyleService.setFontSize(size);
            this.drawStyleService.setFontStyle(style);
            this.elementStyle(labelsAreShown);
        }
    }
    /**
     * Called when the user changes the value of the horizontal/vertical offset
     * @param labelsAreShown wheter the labels are shown or not
     * @param offsetX horizontal offset of the label
     * @param offsetY vertical offset of the label
     */
    onOffsetLabelChange(labelsAreShown, offsetX, offsetY) {
        if (this.selectedFeatures$.value.length > 0) {
            this.selectedFeatures$.value.forEach((feature) => {
                let olFeature = featureToOl(feature, this.map.ol.getView().getProjection().getCode());
                this.updateOffset(olFeature, offsetX, offsetY);
                const entity = this.activeStore
                    .all()
                    .find((e) => e.meta.id === olFeature.getId());
                entity.properties.offsetX = olFeature.get('offsetX_');
                entity.properties.offsetY = olFeature.get('offsetY_');
                this.activeStore.update(entity);
                olFeature = this.activeStore.layer.ol
                    .getSource()
                    .getFeatures()
                    .find((f) => f.getId() === entity.meta.id);
                olFeature.setProperties({
                    offsetX: entity.properties.offsetX,
                    offsetY: entity.properties.offsetY
                });
                olFeature.changed();
            });
            this.elementStyle(labelsAreShown);
        }
    }
    onIconChange(event) {
        this.icon = event;
        this.drawStyleService.setIcon(this.icon);
        this.elementStyle(true, this.icon);
    }
    /**
     * Called when the user selects a new geometry type
     * @param geometryType the geometry type selected by the user
     */
    onGeometryTypeChange(geometryType) {
        this.currGeometryType = geometryType;
        this.activeDrawControl.setGeometryType(geometryType);
        this.freehandMode
            ? this.onToggleFreehandMode({ checked: true })
            : this.onToggleFreehandMode({ checked: false });
        this.toggleDrawControl();
    }
    // Updates the properties of olFeature inputted
    /**
     * Update the label of a geometry when a label is entered in a dialog box
     * @param OlFeature the feature
     * @param label the label
     */
    updateLabelOfOlGeometry(OlFeature, label) {
        OlFeature.setProperties({
            _label: label
        }, true);
    }
    updateFontSizeAndStyle(olFeature, fontSize, fontStyle) {
        olFeature.setProperties({
            fontStyle_: `${fontSize}px ${fontStyle}`
        }, true);
    }
    updateFillAndStrokeColor(olFeature, fillColor, strokeColor) {
        olFeature.setProperties({
            fillColor_: fillColor,
            strokeColor_: strokeColor
        }, true);
    }
    updateOffset(olFeature, offsetX, offsetY) {
        olFeature.setProperties({
            offsetX_: offsetX,
            offsetY_: offsetY
        }, true);
    }
    updateLabelType(olFeature, typeOfLabel) {
        olFeature.setProperties({
            labelType_: typeOfLabel
        }, true);
    }
    updateMeasureUnit(olFeature, measureUnit) {
        olFeature.setProperties({
            measureUnit_: measureUnit
        }, true);
    }
    // Updates values of the selected element on the HTML view
    getFeatureFontSize() {
        return this.selectedFeatures$.value.length > 0
            ? this.selectedFeatures$.value[0].properties.fontStyle
                .split(' ')[0]
                .replace('px', '')
            : '15';
    }
    getFeatureFontStyle() {
        return this.selectedFeatures$.value.length > 0
            ? this.selectedFeatures$.value[0].properties.fontStyle.substring(this.selectedFeatures$.value[0].properties.fontStyle.indexOf(' ') + 1)
            : FontType.Arial;
    }
    getFeatureFillColor() {
        return this.selectedFeatures$.value.length > 0
            ? this.selectedFeatures$.value[0].properties.drawingStyle.fill
            : 'rgba(255,255,255,0.4)';
    }
    getFeatureStrokeColor() {
        return this.selectedFeatures$.value.length > 0
            ? this.selectedFeatures$.value[0].properties.drawingStyle.stroke
            : 'rgba(143,7,7,1)';
    }
    getFeatureOffsetX() {
        return this.selectedFeatures$.value.length > 0
            ? this.selectedFeatures$.value[0].properties.offsetX
            : this.drawStyleService.getOffsetX();
    }
    getFeatureOffsetY() {
        return this.selectedFeatures$.value.length > 0
            ? this.selectedFeatures$.value[0].properties.offsetY
            : '0';
    }
    get allFontStyles() {
        return Object.values(FontType);
    }
    get allLayers() {
        return this.map.layers.filter((layer) => String(layer.id).includes('igo-draw-layer'));
    }
    updateHeightTable() {
        // Check the amount of rows as a possible alternative
        this.numberOfDrawings = this.activeStore.count$.getValue();
        this.numberOfDrawings > 10
            ? (this.tableTemplate.tableHeight = '35vh')
            : (this.tableTemplate.tableHeight = 'auto');
    }
    updateActiveLayer() {
        let currLayer = this.allLayers.find((layer) => layer.title === this.activeDrawingLayer.title);
        return currLayer ? currLayer : this.allLayers[0];
    }
    // Helper methods
    /**
     * Activate the correct control
     */
    toggleDrawControl() {
        this.deactivateDrawControl();
        this.activateDrawControl();
    }
    /**
     * Clear the tooltips of an OL geometry
     * @param olGeometry OL geometry with tooltips
     */
    clearLabelsOfOlGeometry(olGeometry) {
        getTooltipsOfOlGeometry(olGeometry).forEach((olTooltip) => {
            if (olTooltip && olTooltip.getMap()) {
                this.map.ol.removeOverlay(olTooltip);
            }
        });
    }
    /**
     * Replace the feature in the store
     * @param entity the entity to replace
     * @param olGeometry the new geometry to insert in the store
     */
    replaceFeatureInStore(entity, olGeometry, radius) {
        this.activeStore.delete(entity);
        this.onDrawEnd(olGeometry, radius);
    }
    /**
     * Deactivate the active draw control
     */
    deactivateDrawControl() {
        if (!this.activeDrawControl) {
            return;
        }
        if (this.drawEnd$$) {
            this.drawEnd$$.unsubscribe();
        }
        this.activeDrawControl.setOlMap(undefined);
        this.drawControlIsActive = false;
    }
    /**
     * Activate a given control
     */
    activateDrawControl() {
        this.drawControlIsDisabled = false;
        this.drawControlIsActive = true;
        this.drawEnd$$ = this.activeDrawControl.end$.subscribe((olGeometry) => {
            this.openDrawDialog(olGeometry, true);
        });
        this.activeDrawControl.modify$.subscribe((olGeometry) => {
            this.onModifyDraw(olGeometry);
        });
        if (!this.drawSelect$$) {
            this.drawSelect$$ = this.activeDrawControl.select$.subscribe((olFeature) => {
                this.openDrawDialog(olFeature, false);
            });
        }
        this.activeDrawControl.setOlMap(this.map.ol, true);
    }
    /**
     * get the geometry of design
     *
     */
    isPoint() {
        return this.activeDrawControl.getGeometryType() === this.geometryType.Point;
    }
    isLineString() {
        return (this.activeDrawControl.getGeometryType() === this.geometryType.LineString);
    }
    isPolygon() {
        return (this.activeDrawControl.getGeometryType() === this.geometryType.Polygon);
    }
    isCircle() {
        return (this.activeDrawControl.getGeometryType() === this.geometryType.Circle);
    }
    /**
     * The fonction to predefine the radius of the user
     *
     */
    changeRadius(radius) {
        let radiusMeters;
        if (radius) {
            this.measureUnit === MeasureLengthUnit.Meters
                ? (radiusMeters = radius)
                : (radiusMeters = radius * 1000);
        }
        else {
            radiusMeters = undefined;
        }
        const pointStyle = (feature, resolution) => {
            const geom = feature.getGeometry();
            const coordinates = olproj.transform(geom.getCoordinates(), this.map.projection, 'EPSG:4326');
            const radius = radiusMeters / Math.cos((Math.PI / 180) * coordinates[1]) / resolution;
            this.activeDrawControl.predefinedRadius$.next(radiusMeters);
            return new olStyle.Style({
                image: new olStyle.Circle({
                    radius: radius,
                    stroke: new olStyle.Stroke({
                        width: 1,
                        color: 'rgba(143,7,7,1)'
                    }),
                    fill: new olStyle.Fill({
                        color: 'rgba(255,255,255,0.4)'
                    })
                })
            });
        };
        this.activeDrawControl.setOlInteractionStyle(pointStyle);
        this.toggleDrawControl();
    }
    onMeasureUnitChange(selectedMeasureUnit) {
        if (selectedMeasureUnit === this.measureUnit) {
            return;
        }
        else {
            this.measureUnit = selectedMeasureUnit;
            this.measureUnit === MeasureLengthUnit.Meters
                ? this.radiusFormControl.setValue(this.radiusFormControl.value * 1000)
                : this.radiusFormControl.setValue(this.radiusFormControl.value / 1000);
        }
    }
    /**
     * Recreates the style of the feature stored
     */
    elementStyle(labelsAreShown, isAnIcon) {
        if (isAnIcon) {
            this.activeStore.layer.ol.setStyle((feature, resolution) => {
                return this.drawStyleService.createIndividualElementStyle(feature, resolution, labelsAreShown, feature.get('fontStyle'), feature.get('drawingStyle').fill, feature.get('drawingStyle').stroke, feature.get('offsetX'), feature.get('offsetY'), this.map.projection, this.icon);
            });
        }
        else {
            this.activeStore.layer.ol.setStyle((feature, resolution) => {
                return this.drawStyleService.createIndividualElementStyle(feature, resolution, labelsAreShown, feature.get('fontStyle'), feature.get('drawingStyle').fill, feature.get('drawingStyle').stroke, feature.get('offsetX'), feature.get('offsetY'), this.map.projection);
            });
        }
    }
    getRadius(olGeometry) {
        const length = getLength(olGeometry);
        return Number(length / (2 * Math.PI));
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DrawComponent, deps: [{ token: i2.LanguageService }, { token: i2$1.UntypedFormBuilder }, { token: DrawStyleService }, { token: i1$2.MatDialog }, { token: DrawIconService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DrawComponent, selector: "igo-draw", inputs: { map: "map", stores: "stores", drawControls: "drawControls", activeDrawingLayer: "activeDrawingLayer" }, outputs: { activeLayerChange: "activeLayerChange", drawControlsEvent: "drawControlsEvent", layersIDEvent: "layersIDEvent", fillColor: "fillColor", strokeColor: "strokeColor", strokeWidth: "strokeWidth", fontSize: "fontSize", fontStyle: "fontStyle" }, viewQueries: [{ propertyName: "select", first: true, predicate: ["selectedLayer"], descendants: true }], ngImport: i0, template: "<div>\n  <div class=\"geometry-type-toggle mat-typography\">\n    <mat-button-toggle-group\n      (change)=\"onGeometryTypeChange($event.value)\"\n      [value]=\"geometryType.Point\"\n    >\n      <mat-button-toggle [value]=\"geometryType.Point\">\n        {{ 'igo.geo.draw.' + geometryType.Point | translate }}\n      </mat-button-toggle>\n\n      <mat-button-toggle [value]=\"geometryType.LineString\">\n        {{ 'igo.geo.draw.' + geometryType.LineString | translate }}\n      </mat-button-toggle>\n\n      <mat-button-toggle [value]=\"geometryType.Polygon\">\n        {{ 'igo.geo.draw.' + geometryType.Polygon | translate }}\n      </mat-button-toggle>\n\n      <mat-button-toggle [value]=\"geometryType.Circle\">\n        {{ 'igo.geo.draw.' + geometryType.Circle | translate }}\n      </mat-button-toggle>\n    </mat-button-toggle-group>\n  </div>\n\n  <div class=\"draw-options mat-typography\">\n    <mat-slide-toggle\n      [disabled]=\"drawControlIsDisabled\"\n      [checked]=\"drawControlIsActive\"\n      [labelPosition]=\"'before'\"\n      (change)=\"onToggleDrawControl($event.checked)\"\n    >\n      {{ 'igo.geo.draw.drawControl' | translate }}\n    </mat-slide-toggle>\n\n    <mat-slide-toggle\n      [checked]=\"labelsAreShown\"\n      [labelPosition]=\"'before'\"\n      (change)=\"onToggleLabels()\"\n    >\n      {{ 'igo.geo.draw.toggleMapTooltips' | translate }}\n    </mat-slide-toggle>\n\n    <mat-slide-toggle\n      *ngIf=\"!isPoint()\"\n      [checked]=\"freehandMode\"\n      [labelPosition]=\"'before'\"\n      (change)=\"onToggleFreehandMode($event)\"\n    >\n      {{ 'igo.geo.draw.freehandMode' | translate }}\n    </mat-slide-toggle>\n\n    <div class=\"radius-unit\" *ngIf=\"isCircle()\">\n      <mat-form-field class=\"radius\">\n        <input\n          matInput\n          type=\"number\"\n          min=\"0\"\n          placeholder=\"{{ 'igo.geo.spatialFilter.radius' | translate }}\"\n          [formControl]=\"radiusFormControl\"\n          [readonly]=\"this.freehandMode\"\n        />\n      </mat-form-field>\n\n      <mat-form-field class=\"unit-field\">\n        <mat-select\n          [value]=\"measureUnit\"\n          (selectionChange)=\"onMeasureUnitChange($event.value)\"\n        >\n          <mat-option\n            *ngFor=\"let measureUnit of measureUnits\"\n            [value]=\"measureUnit\"\n          >\n            {{ 'igo.geo.measure.' + measureUnit | translate }}\n          </mat-option>\n        </mat-select>\n      </mat-form-field>\n    </div>\n  </div>\n\n  <mat-divider></mat-divider>\n\n  <div class=\"layer-select-container\">\n    <mat-form-field class=\"layer-select\" subscriptSizing=\"dynamic\">\n      <mat-label>{{ 'igo.geo.draw.layer.title' | translate }}</mat-label>\n      <mat-select\n        #selectedLayer\n        (selectionChange)=\"onLayerChange(selectedLayer.value)\"\n        [value]=\"updateActiveLayer()\"\n      >\n        <mat-option *ngFor=\"let layer of allLayers\" [value]=\"layer\">\n          {{ layer.title }}\n        </mat-option>\n        <mat-option id=\"createNewLayer\">\n          {{ 'igo.geo.draw.layer.createNewLayer' | translate }}\n        </mat-option>\n      </mat-select>\n    </mat-form-field>\n    <button\n      *ngIf=\"activeDrawingLayer\"\n      mat-icon-button\n      [color]=\"activeDrawingLayer.visible ? 'primary' : 'default'\"\n      collapsibleButton\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"\n        activeDrawingLayer.visible\n          ? ('igo.geo.layer.hideLayer' | translate)\n          : ('igo.geo.layer.showLayer' | translate)\n      \"\n      (click)=\"activeDrawingLayer.visible = !activeDrawingLayer.visible\"\n    >\n      <mat-icon [svgIcon]=\"activeDrawingLayer.visible ? 'eye' : 'eye-off'\">\n      </mat-icon>\n    </button>\n  </div>\n  <mat-divider></mat-divider>\n  <div>\n    <button\n      *ngIf=\"activeStore.count$.getValue() > 0\"\n      class=\"deleteBtn\"\n      mat-icon-button\n      color=\"warn\"\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"'igo.geo.draw.delete' | translate\"\n      [disabled]=\"(selectedFeatures$ | async).length === 0\"\n      (click)=\"deleteDrawings()\"\n    >\n      <mat-icon svgIcon=\"delete\"></mat-icon>\n    </button>\n\n    <div>\n      <igo-entity-table\n        #table\n        class=\"table-compact\"\n        [store]=\"activeStore\"\n        [template]=\"tableTemplate\"\n      >\n      </igo-entity-table>\n    </div>\n  </div>\n\n  <div class=\"icon-options\">\n    <mat-form-field *ngIf=\"icons.length >= 1\">\n      <mat-label>{{ 'igo.geo.draw.icon' | translate }}</mat-label>\n      <mat-select>\n        <mat-select-trigger>\n          <div *ngIf=\"icon\" class=\"box\">\n            <img src=\"{{ icon }}\" />\n          </div>\n        </mat-select-trigger>\n        <mat-option value=\"\" (click)=\"onIconChange()\">{{\n          'igo.geo.draw.noIcon' | translate\n        }}</mat-option>\n        <mat-option\n          *ngFor=\"let icon_html of icons\"\n          [value]=\"icon_html\"\n          (click)=\"onIconChange(icon_html)\"\n        >\n          <div class=\"box\">\n            <img src=\"{{ icon_html }}\" />\n          </div>\n        </mat-option>\n      </mat-select>\n    </mat-form-field>\n  </div>\n\n  <div class=\"actions-container\">\n    <button\n      mat-icon-button\n      color=\"accent\"\n      disableRipple=\"true\"\n      (click)=\"openShorcutsDialog()\"\n    >\n      <mat-icon\n        class=\"shortcuts-icon\"\n        svgIcon=\"keyboard-outline\"\n        tooltip-position=\"below\"\n        matTooltipShowDelay=\"500\"\n        [matTooltip]=\"'igo.geo.draw.shortcuts' | translate\"\n      >\n      </mat-icon>\n    </button>\n\n    <button\n      *ngIf=\"selectedFeatures$.value.length\"\n      mat-raised-button\n      color=\"primary\"\n      (click)=\"openStyleModalDialog()\"\n      [matTooltip]=\"'igo.geo.style.styleModalTooltipSelected' | translate\"\n    >\n      {{ 'igo.geo.style.styleModal' | translate }}\n      <mat-icon\n        aria-hidden=\"false\"\n        iconPositionEnd\n        class=\"style-icon\"\n        svgIcon=\"palette\"\n        [matBadge]=\"selectedFeatures$.value.length\"\n        matBadgeColor=\"warn\"\n        matBadgeSize=\"medium\"\n      >\n      </mat-icon>\n    </button>\n  </div>\n</div>\n", styles: [":host .geometry-type-toggle{padding:10px;text-align:center}:host .geometry-type-toggle mat-button-toggle-group{width:100%}:host .geometry-type-toggle mat-button-toggle-group mat-button-toggle{width:25%}:host .draw-options mat-slide-toggle{width:100%;padding:10px}:host .draw-options mat-slide-toggle ::ng-deep .mdc-form-field{width:100%}:host .draw-options mat-slide-toggle ::ng-deep .mdc-label{margin-left:0;width:calc(100% - 60px)}:host .icon-options{margin:5px 5px 0}:host .deleteBtn{margin-left:16px}:host .edition-drawing{padding:10px 0}:host img{width:100%;height:100%}:host .deleteBtn{margin-left:12px}:host .storeTable{height:auto!important}:host .layer-select{flex:1;margin-right:8px}:host .input-button-container{padding:10px}:host .input-button-container mat-form-field{width:25%}:host .input-button-container button{left:8px;bottom:10px}:host .radius{flex:2}:host .unit-field{flex:1;margin-left:8px}:host .radius-unit{display:flex;width:100%;padding:4px 8px}:host ::ng-deep igo-entity-table td:last-child{text-align:right!important}:host ::ng-deep igo-entity-table td:last-child button{margin:0%!important}:host .layer-select-container{margin:16px 8px}:host .actions-container,:host .layer-select-container{display:flex;align-items:center}\n"], dependencies: [{ kind: "directive", type: i2$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i2$1.NumberValueAccessor, selector: "input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]" }, { kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$1.MinValidator, selector: "input[type=number][min][formControlName],input[type=number][min][formControl],input[type=number][min][ngModel]", inputs: ["min"] }, { kind: "directive", type: i2$1.FormControlDirective, selector: "[formControl]", inputs: ["formControl", "disabled", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { kind: "directive", type: i2$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i4$1.MatButton, selector: "    button[mat-button], button[mat-raised-button], button[mat-flat-button],    button[mat-stroked-button]  ", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "directive", type: i5$1.MatButtonToggleGroup, selector: "mat-button-toggle-group", inputs: ["appearance", "name", "vertical", "value", "multiple", "disabled"], outputs: ["valueChange", "change"], exportAs: ["matButtonToggleGroup"] }, { kind: "component", type: i5$1.MatButtonToggle, selector: "mat-button-toggle", inputs: ["disableRipple", "aria-label", "aria-labelledby", "id", "name", "value", "tabIndex", "appearance", "checked", "disabled"], outputs: ["change"], exportAs: ["matButtonToggle"] }, { kind: "component", type: i9$2.MatDivider, selector: "mat-divider", inputs: ["vertical", "inset"] }, { kind: "component", type: i8.MatFormField, selector: "mat-form-field", inputs: ["hideRequiredMarker", "color", "floatLabel", "appearance", "subscriptSizing", "hintLabel"], exportAs: ["matFormField"] }, { kind: "directive", type: i8.MatLabel, selector: "mat-label" }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "directive", type: i6.MatBadge, selector: "[matBadge]", inputs: ["matBadgeDisabled", "matBadgeColor", "matBadgeOverlap", "matBadgePosition", "matBadge", "matBadgeDescription", "matBadgeSize", "matBadgeHidden"] }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "directive", type: i9$3.MatInput, selector: "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", inputs: ["disabled", "id", "placeholder", "name", "required", "type", "errorStateMatcher", "aria-describedby", "value", "readonly"], exportAs: ["matInput"] }, { kind: "component", type: i15.MatSelect, selector: "mat-select", inputs: ["disabled", "disableRipple", "tabIndex", "panelWidth", "hideSingleSelectionIndicator"], exportAs: ["matSelect"] }, { kind: "directive", type: i15.MatSelectTrigger, selector: "mat-select-trigger" }, { kind: "component", type: i9.MatOption, selector: "mat-option", exportAs: ["matOption"] }, { kind: "component", type: i7.MatSlideToggle, selector: "mat-slide-toggle", inputs: ["disabled", "disableRipple", "color", "tabIndex"], exportAs: ["matSlideToggle"] }, { kind: "component", type: i9$1.EntityTableComponent, selector: "igo-entity-table", inputs: ["store", "paginator", "template", "scrollBehavior", "sortNullsFirst", "withPaginator", "paginatorOptions"], outputs: ["entityClick", "entitySelectChange", "entitySortChange"] }, { kind: "pipe", type: i2$2.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }], animations: [
            trigger('openClose', [
                state('open', style({
                    opacity: 1
                })),
                state('closed', style({
                    opacity: 0
                })),
                transition('open => closed', [animate('600ms ease')]),
                transition('closed => open', [animate('800ms ease')])
            ])
        ], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DrawComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-draw', animations: [
                        trigger('openClose', [
                            state('open', style({
                                opacity: 1
                            })),
                            state('closed', style({
                                opacity: 0
                            })),
                            transition('open => closed', [animate('600ms ease')]),
                            transition('closed => open', [animate('800ms ease')])
                        ])
                    ], changeDetection: ChangeDetectionStrategy.OnPush, template: "<div>\n  <div class=\"geometry-type-toggle mat-typography\">\n    <mat-button-toggle-group\n      (change)=\"onGeometryTypeChange($event.value)\"\n      [value]=\"geometryType.Point\"\n    >\n      <mat-button-toggle [value]=\"geometryType.Point\">\n        {{ 'igo.geo.draw.' + geometryType.Point | translate }}\n      </mat-button-toggle>\n\n      <mat-button-toggle [value]=\"geometryType.LineString\">\n        {{ 'igo.geo.draw.' + geometryType.LineString | translate }}\n      </mat-button-toggle>\n\n      <mat-button-toggle [value]=\"geometryType.Polygon\">\n        {{ 'igo.geo.draw.' + geometryType.Polygon | translate }}\n      </mat-button-toggle>\n\n      <mat-button-toggle [value]=\"geometryType.Circle\">\n        {{ 'igo.geo.draw.' + geometryType.Circle | translate }}\n      </mat-button-toggle>\n    </mat-button-toggle-group>\n  </div>\n\n  <div class=\"draw-options mat-typography\">\n    <mat-slide-toggle\n      [disabled]=\"drawControlIsDisabled\"\n      [checked]=\"drawControlIsActive\"\n      [labelPosition]=\"'before'\"\n      (change)=\"onToggleDrawControl($event.checked)\"\n    >\n      {{ 'igo.geo.draw.drawControl' | translate }}\n    </mat-slide-toggle>\n\n    <mat-slide-toggle\n      [checked]=\"labelsAreShown\"\n      [labelPosition]=\"'before'\"\n      (change)=\"onToggleLabels()\"\n    >\n      {{ 'igo.geo.draw.toggleMapTooltips' | translate }}\n    </mat-slide-toggle>\n\n    <mat-slide-toggle\n      *ngIf=\"!isPoint()\"\n      [checked]=\"freehandMode\"\n      [labelPosition]=\"'before'\"\n      (change)=\"onToggleFreehandMode($event)\"\n    >\n      {{ 'igo.geo.draw.freehandMode' | translate }}\n    </mat-slide-toggle>\n\n    <div class=\"radius-unit\" *ngIf=\"isCircle()\">\n      <mat-form-field class=\"radius\">\n        <input\n          matInput\n          type=\"number\"\n          min=\"0\"\n          placeholder=\"{{ 'igo.geo.spatialFilter.radius' | translate }}\"\n          [formControl]=\"radiusFormControl\"\n          [readonly]=\"this.freehandMode\"\n        />\n      </mat-form-field>\n\n      <mat-form-field class=\"unit-field\">\n        <mat-select\n          [value]=\"measureUnit\"\n          (selectionChange)=\"onMeasureUnitChange($event.value)\"\n        >\n          <mat-option\n            *ngFor=\"let measureUnit of measureUnits\"\n            [value]=\"measureUnit\"\n          >\n            {{ 'igo.geo.measure.' + measureUnit | translate }}\n          </mat-option>\n        </mat-select>\n      </mat-form-field>\n    </div>\n  </div>\n\n  <mat-divider></mat-divider>\n\n  <div class=\"layer-select-container\">\n    <mat-form-field class=\"layer-select\" subscriptSizing=\"dynamic\">\n      <mat-label>{{ 'igo.geo.draw.layer.title' | translate }}</mat-label>\n      <mat-select\n        #selectedLayer\n        (selectionChange)=\"onLayerChange(selectedLayer.value)\"\n        [value]=\"updateActiveLayer()\"\n      >\n        <mat-option *ngFor=\"let layer of allLayers\" [value]=\"layer\">\n          {{ layer.title }}\n        </mat-option>\n        <mat-option id=\"createNewLayer\">\n          {{ 'igo.geo.draw.layer.createNewLayer' | translate }}\n        </mat-option>\n      </mat-select>\n    </mat-form-field>\n    <button\n      *ngIf=\"activeDrawingLayer\"\n      mat-icon-button\n      [color]=\"activeDrawingLayer.visible ? 'primary' : 'default'\"\n      collapsibleButton\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"\n        activeDrawingLayer.visible\n          ? ('igo.geo.layer.hideLayer' | translate)\n          : ('igo.geo.layer.showLayer' | translate)\n      \"\n      (click)=\"activeDrawingLayer.visible = !activeDrawingLayer.visible\"\n    >\n      <mat-icon [svgIcon]=\"activeDrawingLayer.visible ? 'eye' : 'eye-off'\">\n      </mat-icon>\n    </button>\n  </div>\n  <mat-divider></mat-divider>\n  <div>\n    <button\n      *ngIf=\"activeStore.count$.getValue() > 0\"\n      class=\"deleteBtn\"\n      mat-icon-button\n      color=\"warn\"\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"'igo.geo.draw.delete' | translate\"\n      [disabled]=\"(selectedFeatures$ | async).length === 0\"\n      (click)=\"deleteDrawings()\"\n    >\n      <mat-icon svgIcon=\"delete\"></mat-icon>\n    </button>\n\n    <div>\n      <igo-entity-table\n        #table\n        class=\"table-compact\"\n        [store]=\"activeStore\"\n        [template]=\"tableTemplate\"\n      >\n      </igo-entity-table>\n    </div>\n  </div>\n\n  <div class=\"icon-options\">\n    <mat-form-field *ngIf=\"icons.length >= 1\">\n      <mat-label>{{ 'igo.geo.draw.icon' | translate }}</mat-label>\n      <mat-select>\n        <mat-select-trigger>\n          <div *ngIf=\"icon\" class=\"box\">\n            <img src=\"{{ icon }}\" />\n          </div>\n        </mat-select-trigger>\n        <mat-option value=\"\" (click)=\"onIconChange()\">{{\n          'igo.geo.draw.noIcon' | translate\n        }}</mat-option>\n        <mat-option\n          *ngFor=\"let icon_html of icons\"\n          [value]=\"icon_html\"\n          (click)=\"onIconChange(icon_html)\"\n        >\n          <div class=\"box\">\n            <img src=\"{{ icon_html }}\" />\n          </div>\n        </mat-option>\n      </mat-select>\n    </mat-form-field>\n  </div>\n\n  <div class=\"actions-container\">\n    <button\n      mat-icon-button\n      color=\"accent\"\n      disableRipple=\"true\"\n      (click)=\"openShorcutsDialog()\"\n    >\n      <mat-icon\n        class=\"shortcuts-icon\"\n        svgIcon=\"keyboard-outline\"\n        tooltip-position=\"below\"\n        matTooltipShowDelay=\"500\"\n        [matTooltip]=\"'igo.geo.draw.shortcuts' | translate\"\n      >\n      </mat-icon>\n    </button>\n\n    <button\n      *ngIf=\"selectedFeatures$.value.length\"\n      mat-raised-button\n      color=\"primary\"\n      (click)=\"openStyleModalDialog()\"\n      [matTooltip]=\"'igo.geo.style.styleModalTooltipSelected' | translate\"\n    >\n      {{ 'igo.geo.style.styleModal' | translate }}\n      <mat-icon\n        aria-hidden=\"false\"\n        iconPositionEnd\n        class=\"style-icon\"\n        svgIcon=\"palette\"\n        [matBadge]=\"selectedFeatures$.value.length\"\n        matBadgeColor=\"warn\"\n        matBadgeSize=\"medium\"\n      >\n      </mat-icon>\n    </button>\n  </div>\n</div>\n", styles: [":host .geometry-type-toggle{padding:10px;text-align:center}:host .geometry-type-toggle mat-button-toggle-group{width:100%}:host .geometry-type-toggle mat-button-toggle-group mat-button-toggle{width:25%}:host .draw-options mat-slide-toggle{width:100%;padding:10px}:host .draw-options mat-slide-toggle ::ng-deep .mdc-form-field{width:100%}:host .draw-options mat-slide-toggle ::ng-deep .mdc-label{margin-left:0;width:calc(100% - 60px)}:host .icon-options{margin:5px 5px 0}:host .deleteBtn{margin-left:16px}:host .edition-drawing{padding:10px 0}:host img{width:100%;height:100%}:host .deleteBtn{margin-left:12px}:host .storeTable{height:auto!important}:host .layer-select{flex:1;margin-right:8px}:host .input-button-container{padding:10px}:host .input-button-container mat-form-field{width:25%}:host .input-button-container button{left:8px;bottom:10px}:host .radius{flex:2}:host .unit-field{flex:1;margin-left:8px}:host .radius-unit{display:flex;width:100%;padding:4px 8px}:host ::ng-deep igo-entity-table td:last-child{text-align:right!important}:host ::ng-deep igo-entity-table td:last-child button{margin:0%!important}:host .layer-select-container{margin:16px 8px}:host .actions-container,:host .layer-select-container{display:flex;align-items:center}\n"] }]
        }], ctorParameters: function () { return [{ type: i2.LanguageService }, { type: i2$1.UntypedFormBuilder }, { type: DrawStyleService }, { type: i1$2.MatDialog }, { type: DrawIconService }]; }, propDecorators: { map: [{
                type: Input
            }], stores: [{
                type: Input
            }], drawControls: [{
                type: Input
            }], activeDrawingLayer: [{
                type: Input
            }], activeLayerChange: [{
                type: Output
            }], drawControlsEvent: [{
                type: Output
            }], layersIDEvent: [{
                type: Output
            }], fillColor: [{
                type: Output
            }], strokeColor: [{
                type: Output
            }], strokeWidth: [{
                type: Output
            }], fontSize: [{
                type: Output
            }], fontStyle: [{
                type: Output
            }], select: [{
                type: ViewChild,
                args: ['selectedLayer']
            }] } });

/**
 * @ignore
 */
class IgoDrawModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoDrawModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoDrawModule, declarations: [DrawComponent,
            DrawPopupComponent,
            DrawLayerPopupComponent,
            DrawShorcutsComponent], imports: [FormsModule,
            ReactiveFormsModule,
            CommonModule,
            MatButtonModule,
            MatButtonToggleModule,
            MatDividerModule,
            MatFormFieldModule,
            MatIconModule,
            MatBadgeModule,
            MatTooltipModule,
            MatFormFieldModule,
            MatInputModule,
            MatListModule,
            MatSelectModule,
            MatSlideToggleModule,
            MatDialogModule,
            IgoLanguageModule,
            IgoEntityTableModule,
            BrowserModule,
            BrowserAnimationsModule,
            MatRadioModule,
            MatCheckboxModule], exports: [DrawComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoDrawModule, imports: [FormsModule,
            ReactiveFormsModule,
            CommonModule,
            MatButtonModule,
            MatButtonToggleModule,
            MatDividerModule,
            MatFormFieldModule,
            MatIconModule,
            MatBadgeModule,
            MatTooltipModule,
            MatFormFieldModule,
            MatInputModule,
            MatListModule,
            MatSelectModule,
            MatSlideToggleModule,
            MatDialogModule,
            IgoLanguageModule,
            IgoEntityTableModule,
            BrowserModule,
            BrowserAnimationsModule,
            MatRadioModule,
            MatCheckboxModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoDrawModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        FormsModule,
                        ReactiveFormsModule,
                        CommonModule,
                        MatButtonModule,
                        MatButtonToggleModule,
                        MatDividerModule,
                        MatFormFieldModule,
                        MatIconModule,
                        MatBadgeModule,
                        MatTooltipModule,
                        MatFormFieldModule,
                        MatInputModule,
                        MatListModule,
                        MatSelectModule,
                        MatSlideToggleModule,
                        MatDialogModule,
                        IgoLanguageModule,
                        IgoEntityTableModule,
                        BrowserModule,
                        BrowserAnimationsModule,
                        MatRadioModule,
                        MatCheckboxModule
                    ],
                    declarations: [
                        DrawComponent,
                        DrawPopupComponent,
                        DrawLayerPopupComponent,
                        DrawShorcutsComponent
                    ],
                    exports: [DrawComponent]
                }]
        }] });

class IgoDrawingToolModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoDrawingToolModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoDrawingToolModule, exports: [IgoDrawModule] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoDrawingToolModule, imports: [IgoDrawModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoDrawingToolModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [],
                    declarations: [],
                    exports: [IgoDrawModule]
                }]
        }] });

class FeatureDetailsDirective {
    el;
    component;
    get feature() {
        return this.component.feature;
    }
    feature$ = new BehaviorSubject(undefined);
    routingEvent = new EventEmitter();
    setFeature() {
        this.feature$.next(this.feature);
    }
    constructor(component, el) {
        this.el = el;
        this.component = component;
    }
    ngOnInit() {
        this.feature$.subscribe(() => {
            if (this.feature.geometry) {
                this.bindClicking();
            }
        });
    }
    bindClicking() {
        setTimeout(() => {
            const routeElement = this.el.nativeElement.querySelector('span.routing');
            if (routeElement) {
                routeElement.addEventListener('click', () => {
                    this.routingEvent.emit();
                });
            }
        }, 1);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FeatureDetailsDirective, deps: [{ token: FeatureDetailsComponent, self: true }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: FeatureDetailsDirective, selector: "[igoFeatureDetailsDirective]", outputs: { routingEvent: "routingEvent" }, host: { listeners: { "selectFeature": "setFeature()" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FeatureDetailsDirective, decorators: [{
            type: Directive,
            args: [{
                    // This directive allow to view the route between the user coordinates and the feature
                    selector: '[igoFeatureDetailsDirective]'
                }]
        }], ctorParameters: function () { return [{ type: FeatureDetailsComponent, decorators: [{
                    type: Self
                }] }, { type: i0.ElementRef }]; }, propDecorators: { routingEvent: [{
                type: Output
            }], setFeature: [{
                type: HostListener,
                args: ['selectFeature']
            }] } });

/**
 * @ignore
 */
class IgoFeatureDetailsModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoFeatureDetailsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoFeatureDetailsModule, declarations: [FeatureDetailsComponent, FeatureDetailsDirective], imports: [CommonModule,
            MatIconModule,
            IgoLanguageModule,
            IgoKeyValueModule,
            IgoImageModule], exports: [FeatureDetailsComponent, FeatureDetailsDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoFeatureDetailsModule, imports: [CommonModule,
            MatIconModule,
            IgoLanguageModule,
            IgoKeyValueModule,
            IgoImageModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoFeatureDetailsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        MatIconModule,
                        IgoLanguageModule,
                        IgoKeyValueModule,
                        IgoImageModule
                    ],
                    exports: [FeatureDetailsComponent, FeatureDetailsDirective],
                    declarations: [FeatureDetailsComponent, FeatureDetailsDirective]
                }]
        }] });

/**
 * @ignore
 */
class IgoFeatureFormModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoFeatureFormModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoFeatureFormModule, declarations: [FeatureFormComponent], imports: [CommonModule, IgoFormModule], exports: [IgoFormModule, FeatureFormComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoFeatureFormModule, imports: [CommonModule, IgoFormModule, IgoFormModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoFeatureFormModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, IgoFormModule],
                    exports: [IgoFormModule, FeatureFormComponent],
                    declarations: [FeatureFormComponent]
                }]
        }] });

class IgoFeatureModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoFeatureModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoFeatureModule, imports: [CommonModule], exports: [IgoFeatureDetailsModule, IgoFeatureFormModule] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoFeatureModule, imports: [CommonModule, IgoFeatureDetailsModule, IgoFeatureFormModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoFeatureModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    exports: [IgoFeatureDetailsModule, IgoFeatureFormModule],
                    declarations: [],
                    providers: []
                }]
        }] });

/**
 * Control to modify geometries
 */
class ModifyControl {
    options;
    /**
     * Modify start observable
     */
    start$ = new Subject();
    /**
     * Modify end observable
     */
    end$ = new Subject();
    /**
     * Geometry changes observable
     */
    changes$ = new Subject();
    olMap;
    olOverlayLayer;
    olModifyInteraction;
    onModifyStartKey;
    onModifyEndKey;
    onModifyKey;
    olModifyInteractionIsActive = false;
    olTranslateInteraction;
    onTranslateStartKey;
    onTranslateEndKey;
    onTranslateKey;
    olTranslateInteractionIsActive = false;
    olDrawInteraction;
    onDrawStartKey;
    onDrawEndKey;
    onDrawKey;
    olDrawInteractionIsActive = false;
    mousePosition;
    keyDown$$;
    drawKeyUp$$;
    drawKeyDown$$;
    removedOlInteractions = [];
    olLinearRingsLayer;
    // This is the geometry to test against when drawing holes
    olOuterGeometry;
    /**
     * Wheter the control is active
     */
    get active() {
        return this.olMap !== undefined;
    }
    /**
     * OL overlay source
     * @internal
     */
    get olOverlaySource() {
        return this.olOverlayLayer.getSource();
    }
    /**
     * OL linear rings source
     * @internal
     */
    get olLinearRingsSource() {
        return this.olLinearRingsLayer.getSource();
    }
    /**
     * Whether a modify control should be available
     */
    modify = true;
    /**
     * Whether a translate control should be available
     */
    translate = true;
    constructor(options) {
        this.options = options;
        if (options.modify !== undefined) {
            this.modify = options.modify;
        }
        if (options.translate !== undefined) {
            this.translate = options.translate;
        }
        if (options.layer !== undefined) {
            this.olOverlayLayer = options.layer;
        }
        else {
            this.olOverlayLayer = this.createOlInnerOverlayLayer();
        }
        this.olLinearRingsLayer = this.createOlLinearRingsLayer();
    }
    /**
     * Add or remove this control to/from a map.
     * @param map OL Map
     */
    setOlMap(olMap) {
        if (olMap === undefined) {
            this.clearOlInnerOverlaySource();
            this.removeOlInnerOverlayLayer();
            this.removeOlModifyInteraction();
            this.removeOlTranslateInteraction();
            this.removeOlDrawInteraction();
            this.olMap = olMap;
            return;
        }
        this.olMap = olMap;
        this.addOlInnerOverlayLayer();
        // The order in which these interactions
        // are added is important
        if (this.modify === true) {
            this.addOlDrawInteraction();
        }
        if (this.translate === true) {
            this.addOlTranslateInteraction();
            this.activateTranslateInteraction();
        }
        if (this.modify === true) {
            this.addOlModifyInteraction();
            this.activateModifyInteraction();
        }
    }
    /**
     * Return the overlay source
     */
    getSource() {
        return this.olOverlaySource;
    }
    /**
     * Add an OL geometry to the overlay and start modifying it
     * @param olGeometry Ol Geometry
     */
    setOlGeometry(olGeometry) {
        const olFeature = new OlFeature({ geometry: olGeometry });
        this.olOverlaySource.clear();
        this.olOverlaySource.addFeature(olFeature);
    }
    /**
     * Create an overlay source if none is defined in the options
     */
    createOlInnerOverlayLayer() {
        return new OlVectorLayer({
            source: this.options.source ? this.options.source : new OlVectorSource(),
            style: this.options.layerStyle,
            zIndex: 500
        });
    }
    /**
     * Add the overlay layer if it wasn't defined in the options
     */
    addOlInnerOverlayLayer() {
        if (this.options.layer === undefined) {
            this.olMap.addLayer(this.olOverlayLayer);
        }
    }
    /**
     * Clear the overlay layer if it wasn't defined in the options
     */
    removeOlInnerOverlayLayer() {
        if (this.options.layer === undefined && this.olMap !== undefined) {
            this.olMap.removeLayer(this.olOverlayLayer);
        }
    }
    /**
     * Clear the overlay source if it wasn't defined in the options
     */
    clearOlInnerOverlaySource() {
        if (this.options.layer === undefined && this.options.source === undefined) {
            this.olOverlaySource.clear(true);
        }
    }
    createOlLinearRingsLayer() {
        return new OlVectorLayer({
            source: new OlVectorSource(),
            style: createDrawHoleInteractionStyle(),
            zIndex: 500
        });
    }
    /**
     * Add the linear rings layer
     */
    addOlLinearRingsLayer() {
        this.olMap.addLayer(this.olLinearRingsLayer);
    }
    /**
     * Clear the linear rings layer
     */
    removeOlLinearRingsLayer() {
        this.olMap.removeLayer(this.olLinearRingsLayer);
    }
    /**
     * Clear the linear rings source
     */
    clearOlLinearRingsSource() {
        this.olLinearRingsSource.clear(true);
    }
    /**
     * Add a modify interaction to the map an set up some listeners
     */
    addOlModifyInteraction() {
        const olModifyInteraction = new OlModify({
            source: this.olOverlaySource,
            style: this.options.drawStyle
        });
        this.olModifyInteraction = olModifyInteraction;
    }
    /**
     * Remove the modify interaction
     */
    removeOlModifyInteraction() {
        if (this.olModifyInteraction === undefined) {
            return;
        }
        this.deactivateModifyInteraction();
        this.olModifyInteraction = undefined;
    }
    activateModifyInteraction() {
        if (this.olModifyInteractionIsActive === true) {
            return;
        }
        this.olModifyInteractionIsActive = true;
        this.onModifyStartKey = this.olModifyInteraction.on('modifystart', (event) => this.onModifyStart(event));
        this.onModifyEndKey = this.olModifyInteraction.on('modifyend', (event) => this.onModifyEnd(event));
        this.olMap.addInteraction(this.olModifyInteraction);
    }
    deactivateModifyInteraction() {
        if (this.olModifyInteractionIsActive === false) {
            return;
        }
        this.olModifyInteractionIsActive = false;
        unByKey([this.onModifyStartKey, this.onModifyEndKey, this.onModifyKey]);
        if (this.olMap !== undefined) {
            this.olMap.removeInteraction(this.olModifyInteraction);
        }
    }
    /**
     * When modifying starts, clear the overlay and start watching for changes
     * @param event Modify start event
     */
    onModifyStart(event) {
        const olGeometry = event.features.item(0).getGeometry();
        this.start$.next(olGeometry);
        this.onModifyKey = olGeometry.on('change', (olGeometryEvent) => {
            this.mousePosition =
                getMousePositionFromOlGeometryEvent(olGeometryEvent);
            this.changes$.next(olGeometryEvent.target);
        });
        this.subscribeToKeyDown();
    }
    /**
     * When modifying ends, update the geometry observable and stop watching for changes
     * @param event Modify end event
     */
    onModifyEnd(event) {
        unByKey(this.onModifyKey);
        this.end$.next(event.features.item(0).getGeometry());
        this.unsubscribeToKeyDown();
    }
    /**
     * Subscribe to space key down to pan the map
     */
    subscribeToKeyDown() {
        this.keyDown$$ = fromEvent(document, 'keydown').subscribe((event) => {
            if (event.key === ' ') {
                // On space bar, pan to the current mouse position
                this.olMap.getView().animate({
                    center: this.mousePosition,
                    duration: 0
                });
                return;
            }
        });
    }
    /**
     * Unsubscribe to key down
     */
    unsubscribeToKeyDown() {
        if (this.keyDown$$ !== undefined) {
            this.keyDown$$.unsubscribe();
        }
    }
    /**
     * Add a translate interaction to the map an set up some listeners
     */
    addOlTranslateInteraction() {
        const olTranslateInteraction = new OlTranslate({
            layers: [this.olOverlayLayer]
        });
        this.olTranslateInteraction = olTranslateInteraction;
    }
    /**
     * Remove the translate interaction
     */
    removeOlTranslateInteraction() {
        if (this.olTranslateInteraction === undefined) {
            return;
        }
        this.deactivateTranslateInteraction();
        this.olTranslateInteraction = undefined;
    }
    activateTranslateInteraction() {
        if (this.olTranslateInteractionIsActive === true) {
            return;
        }
        this.olTranslateInteractionIsActive = true;
        this.onTranslateStartKey = this.olTranslateInteraction.on('translatestart', (event) => this.onTranslateStart(event));
        this.onTranslateEndKey = this.olTranslateInteraction.on('translateend', (event) => this.onTranslateEnd(event));
        this.olMap.addInteraction(this.olTranslateInteraction);
    }
    deactivateTranslateInteraction() {
        if (this.olTranslateInteractionIsActive === false) {
            return;
        }
        this.olTranslateInteractionIsActive = false;
        unByKey([
            this.onTranslateStartKey,
            this.onTranslateEndKey,
            this.onTranslateKey
        ]);
        if (this.olMap !== undefined) {
            this.olMap.removeInteraction(this.olTranslateInteraction);
        }
    }
    /**
     * When translation starts, clear the overlay and start watching for changes
     * @param event Translate start event
     */
    onTranslateStart(event) {
        const olGeometry = event.features.item(0).getGeometry();
        this.start$.next(olGeometry);
        this.onTranslateKey = olGeometry.on('change', (olGeometryEvent) => {
            // this.changes$.next(olGeometryEvent.target);
        });
    }
    /**
     * When translation ends, update the geometry observable and stop watchign for changes
     * @param event Translate end event
     */
    onTranslateEnd(event) {
        unByKey(this.onTranslateKey);
        this.end$.next(event.features.item(0).getGeometry());
    }
    /**
     * Add a draw interaction to the map an set up some listeners
     */
    addOlDrawInteraction() {
        const olDrawInteraction = new OlDraw({
            type: 'Polygon',
            source: this.olLinearRingsSource,
            stopClick: true,
            style: createDrawHoleInteractionStyle(),
            condition: (event) => {
                const olOuterGeometry = this.olOuterGeometry || this.getOlGeometry();
                const intersects = olOuterGeometry.intersectsCoordinate(event.coordinate);
                return intersects;
            }
        });
        this.olDrawInteraction = olDrawInteraction;
        this.subscribeToDrawKeyDown();
    }
    /**
     * Subscribe to CTRL key down to activate the draw control
     */
    subscribeToDrawKeyDown() {
        this.drawKeyDown$$ = fromEvent(document, 'keydown').subscribe((event) => {
            if (event.key !== 'Control') {
                return;
            }
            this.unsubscribeToDrawKeyDown();
            const olGeometry = this.getOlGeometry();
            if (!olGeometry || !(olGeometry instanceof OlPolygon)) {
                return;
            }
            this.subscribeToDrawKeyUp();
            this.deactivateModifyInteraction();
            this.deactivateTranslateInteraction();
            this.activateDrawInteraction();
        });
    }
    /**
     * Subscribe to CTRL key up to deactivate the draw control
     */
    subscribeToDrawKeyUp() {
        this.drawKeyUp$$ = fromEvent(document, 'keyup').subscribe((event) => {
            if (event.key !== 'Control') {
                return;
            }
            this.unsubscribeToDrawKeyUp();
            this.unsubscribeToKeyDown();
            this.deactivateDrawInteraction();
            this.activateModifyInteraction();
            if (this.translate === true) {
                this.activateTranslateInteraction();
            }
            this.subscribeToDrawKeyDown();
            this.olOuterGeometry = undefined;
            this.clearOlLinearRingsSource();
            this.end$.next(this.getOlGeometry());
        });
    }
    /**
     * Unsubscribe to draw key down
     */
    unsubscribeToDrawKeyDown() {
        if (this.drawKeyDown$$ !== undefined) {
            this.drawKeyDown$$.unsubscribe();
        }
    }
    /**
     * Unsubscribe to key up
     */
    unsubscribeToDrawKeyUp() {
        if (this.drawKeyUp$$ !== undefined) {
            this.drawKeyUp$$.unsubscribe();
        }
    }
    /**
     * Remove the draw interaction
     */
    removeOlDrawInteraction() {
        if (this.olDrawInteraction === undefined) {
            return;
        }
        this.unsubscribeToKeyDown();
        this.unsubscribeToDrawKeyUp();
        this.unsubscribeToDrawKeyDown();
        this.deactivateDrawInteraction();
        this.clearOlLinearRingsSource();
        this.olDrawInteraction = undefined;
    }
    /**
     * Activate the draw interaction
     */
    activateDrawInteraction() {
        if (this.olDrawInteractionIsActive === true) {
            return;
        }
        this.clearOlLinearRingsSource();
        this.addOlLinearRingsLayer();
        this.olMap.getInteractions().forEach((olInteraction) => {
            if (olInteraction instanceof OlDragBoxInteraction) {
                this.olMap.removeInteraction(olInteraction);
                this.removedOlInteractions.push(olInteraction);
            }
        });
        this.olDrawInteractionIsActive = true;
        this.onDrawStartKey = this.olDrawInteraction.on('drawstart', (event) => this.onDrawStart(event));
        this.onDrawEndKey = this.olDrawInteraction.on('drawend', (event) => this.onDrawEnd(event));
        this.olMap.addInteraction(this.olDrawInteraction);
    }
    /**
     * Deactivate the draw interaction
     */
    deactivateDrawInteraction() {
        if (this.olDrawInteractionIsActive === false) {
            return;
        }
        this.removeOlLinearRingsLayer();
        this.removedOlInteractions.forEach((olInteraction) => {
            this.olMap.addInteraction(olInteraction);
        });
        this.removedOlInteractions = [];
        this.olDrawInteractionIsActive = false;
        unByKey([this.onDrawStartKey, this.onDrawEndKey, this.onDrawKey]);
        if (this.olMap !== undefined) {
            this.olMap.removeInteraction(this.olDrawInteraction);
        }
    }
    /**
     * When draw start, add a new linerar ring to the geometry and start watching for changes
     * @param event Draw start event
     */
    onDrawStart(event) {
        const olGeometry = event.feature.getGeometry();
        this.olOuterGeometry = this.getOlGeometry().clone();
        const linearRingCoordinates = olGeometry.getLinearRing().getCoordinates();
        this.addLinearRingToOlGeometry(linearRingCoordinates);
        this.start$.next(this.getOlGeometry());
        this.onDrawKey = olGeometry.on('change', (olGeometryEvent) => {
            this.mousePosition = getMousePositionFromOlGeometryEvent(olGeometryEvent);
            const olGeometryTarget = olGeometryEvent.target;
            const _linearRingCoordinates = olGeometryTarget
                .getLinearRing(0)
                .getCoordinates();
            this.updateLinearRingOfOlGeometry(_linearRingCoordinates);
            this.changes$.next(this.getOlGeometry());
        });
        this.subscribeToKeyDown();
    }
    /**
     * When translation ends, update the geometry observable and stop watchign for changes
     * @param event Draw end event
     */
    onDrawEnd(event) {
        unByKey(this.onDrawKey);
        this.olOuterGeometry = undefined;
        const linearRingCoordinates = event.feature.getGeometry().getLinearRing().getCoordinates();
        this.updateLinearRingOfOlGeometry(linearRingCoordinates);
        this.clearOlLinearRingsSource();
        this.end$.next(this.getOlGeometry());
        this.unsubscribeToKeyDown();
    }
    /**
     * Add a linear ring to the geometry being modified
     * @param coordinates Linear ring coordinates
     */
    addLinearRingToOlGeometry(coordinates) {
        const olGeometry = this.getOlGeometry();
        const olLinearRing = new OlLinearRing(coordinates);
        addLinearRingToOlPolygon(olGeometry, olLinearRing);
    }
    /**
     * Update the last linear ring of the geometry being modified
     * @param coordinates Linear ring coordinates
     */
    updateLinearRingOfOlGeometry(coordinates) {
        const olGeometry = this.getOlGeometry();
        // Remove the last linear ring (the one we are updating)
        const olLinearRings = olGeometry.getLinearRings().slice(0, -1);
        const newCoordinates = olLinearRings.map((olLinearRing) => {
            return olLinearRing.getCoordinates();
        });
        newCoordinates.push(coordinates);
        olGeometry.setCoordinates(newCoordinates);
    }
    /**
     * Get the geometry being modified
     * @returns OL Geometry
     */
    getOlGeometry() {
        const olFeatures = this.olOverlaySource.getFeatures();
        return olFeatures.length > 0 ? olFeatures[0].getGeometry() : undefined;
    }
}

/**
 * Control to modify geometries
 */
class SliceControl {
    options;
    /**
     * Slice end observable
     */
    end$ = new Subject();
    /**
     * Slice error, if any
     */
    error$ = new Subject();
    olMap;
    olOverlayLayer;
    /**
     * Draw line control
     */
    drawLineControl;
    /**
     * Subscription to draw start
     */
    drawLineStart$$;
    /**
     * Subscription to draw end
     */
    drawLineEnd$$;
    /**
     * Wheter the control is active
     */
    get active() {
        return this.olMap !== undefined;
    }
    /**
     * OL overlay source
     * @internal
     */
    get olOverlaySource() {
        return this.olOverlayLayer.getSource();
    }
    constructor(options) {
        this.options = options;
        if (options.layer !== undefined) {
            this.olOverlayLayer = options.layer;
        }
        else {
            this.olOverlayLayer = this.createOlInnerOverlayLayer();
        }
    }
    /**
     * Add or remove this control to/from a map.
     * @param map OL Map
     */
    setOlMap(olMap) {
        if (olMap === undefined) {
            this.clearOlInnerOverlaySource();
            this.removeOlInnerOverlayLayer();
            this.removeDrawLineControl();
            this.olMap = olMap;
            return;
        }
        this.olMap = olMap;
        this.addOlInnerOverlayLayer();
        this.addDrawLineControl();
    }
    /**
     * Return the overlay source
     */
    getSource() {
        return this.olOverlaySource;
    }
    /**
     * Add an OL geometry to the overlay for slicing
     * @param olGeometry Ol Geometry
     */
    setOlGeometry(olGeometry) {
        const olFeature = new OlFeature({ geometry: olGeometry });
        this.olOverlaySource.clear(true);
        this.olOverlaySource.addFeature(olFeature);
    }
    /**
     * Create an overlay source if none is defined in the options
     */
    createOlInnerOverlayLayer() {
        return new OlVectorLayer({
            source: this.options.source ? this.options.source : new OlVectorSource(),
            style: this.options.layerStyle,
            zIndex: 500
        });
    }
    /**
     * Clear the overlay layer if it wasn't defined in the options
     */
    removeOlInnerOverlayLayer() {
        if (this.options.layer === undefined && this.olMap !== undefined) {
            this.olMap.removeLayer(this.olOverlayLayer);
        }
    }
    /**
     * Add the overlay layer if it wasn't defined in the options
     */
    addOlInnerOverlayLayer() {
        if (this.options.layer === undefined) {
            this.olMap.addLayer(this.olOverlayLayer);
        }
    }
    /**
     * Clear the overlay source if it wasn't defined in the options
     */
    clearOlInnerOverlaySource() {
        if (this.options.layer === undefined && this.options.source === undefined) {
            this.olOverlaySource.clear(true);
        }
    }
    /**
     * Create a draw line control and add it to the map
     */
    addDrawLineControl() {
        this.drawLineControl = new DrawControl({
            geometryType: 'LineString',
            interactionStyle: this.options.drawStyle,
            maxPoints: 2
        });
        this.drawLineStart$$ = this.drawLineControl.start$.subscribe((olLine) => this.onDrawLineStart(olLine));
        this.drawLineEnd$$ = this.drawLineControl.end$.subscribe((olLine) => this.onDrawLineEnd(olLine));
        this.drawLineControl.setOlMap(this.olMap);
    }
    /**
     * Remove draw line control
     */
    removeDrawLineControl() {
        if (this.drawLineControl === undefined) {
            return;
        }
        this.drawLineStart$$.unsubscribe();
        this.drawLineEnd$$.unsubscribe();
        this.drawLineControl.getSource().clear(true);
        this.drawLineControl.setOlMap(undefined);
    }
    /**
     * Clear the draw source and track the geometry being draw
     * @param olLine Ol linestring or polygon
     */
    onDrawLineStart(olLine) {
        this.drawLineControl.getSource().clear(true);
    }
    /**
     * Slice the first geometry encountered with the drawn line
     * @param olLine Ol linestring
     */
    onDrawLineEnd(olLine) {
        const olSlicedGeometries = [];
        const lineExtent = olLine.getExtent();
        const olFeaturesToRemove = [];
        try {
            this.olOverlaySource.forEachFeatureInExtent(lineExtent, (olFeature) => {
                const olGeometry = olFeature.getGeometry();
                const olParts = sliceOlGeometry(olGeometry, olLine);
                if (olParts.length > 0) {
                    olSlicedGeometries.push(...olParts);
                    olFeaturesToRemove.push(olFeature);
                }
            });
        }
        catch (e) {
            if (e instanceof GeometrySliceError) {
                this.error$.next(e);
                return;
            }
            else {
                throw e;
            }
        }
        this.drawLineControl.getSource().clear(true);
        this.olOverlaySource.addFeatures(olSlicedGeometries.map((olGeometry) => new OlFeature(olGeometry)));
        olFeaturesToRemove.forEach((olFeature) => {
            this.olOverlaySource.removeFeature(olFeature);
        });
        this.error$.next(undefined);
        this.end$.next(olSlicedGeometries);
    }
}

/**
 * This pipe returns a measure converted from meters (or square meters)
 * to the specified unit. It also keeps a certain number of decimals.
 */
class MeasureFormatPipe {
    /**
     * @ignore
     */
    transform(value, unit, unitAbbr = false, decimal = 1) {
        let out;
        if (Object.values(MeasureAreaUnit).indexOf(unit) >= 0) {
            out = squareMetersToUnit(value, unit);
        }
        else if (Object.values(MeasureLengthUnit).indexOf(unit) >= 0) {
            out = metersToUnit(value, unit);
        }
        return out
            ? formatMeasure(out, {
                decimal: 1,
                unit,
                unitAbbr,
                locale: 'fr'
            })
            : out;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: MeasureFormatPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
    static ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: MeasureFormatPipe, name: "measureFormat" });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: MeasureFormatPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'measureFormat'
                }]
        }] });

class MeasurerDialogComponent {
    dialogRef;
    data;
    measureAreaUnit = MeasureAreaUnit;
    measureLengthUnit = MeasureLengthUnit;
    constructor(dialogRef, data) {
        this.dialogRef = dialogRef;
        this.data = data;
    }
    onNoClick() {
        this.dialogRef.close();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: MeasurerDialogComponent, deps: [{ token: i1$2.MatDialogRef }, { token: MAT_DIALOG_DATA }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: MeasurerDialogComponent, selector: "igo-measurer-dialog", ngImport: i0, template: "<h3 mat-dialog-title>{{ 'igo.geo.measure.dialog.title' | translate }}</h3>\n<div mat-dialog-content>\n  <table *ngIf=\"data.length > 0\" class=\"mat-typography\">\n    <thead>\n      <tr>\n        <th colspan=\"2\">\n          {{ 'igo.geo.measure.dialog.length.title' | translate }}\n        </th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr>\n        <td>{{ data.length | measureFormat: measureLengthUnit.Meters }}</td>\n        <td>{{ 'igo.geo.measure.dialog.lengthInMeters' | translate }}</td>\n      </tr>\n      <tr>\n        <td>\n          {{ data.length | measureFormat: measureLengthUnit.Kilometers }}\n        </td>\n        <td>{{ 'igo.geo.measure.dialog.lengthInKilometers' | translate }}</td>\n      </tr>\n      <tr>\n        <td>{{ data.length | measureFormat: measureLengthUnit.Miles }}</td>\n        <td>{{ 'igo.geo.measure.dialog.lengthInMiles' | translate }}</td>\n      </tr>\n      <tr>\n        <td>{{ data.length | measureFormat: measureLengthUnit.Feet }}</td>\n        <td>{{ 'igo.geo.measure.dialog.lengthInFeet' | translate }}</td>\n      </tr>\n    </tbody>\n  </table>\n\n  <table *ngIf=\"data.area > 0\" class=\"mat-typography\">\n    <thead>\n      <tr>\n        <th colspan=\"2\">\n          {{ 'igo.geo.measure.dialog.area.title' | translate }}\n        </th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr>\n        <td>{{ data.area | measureFormat: measureAreaUnit.SquareMeters }}</td>\n        <td>{{ 'igo.geo.measure.dialog.areaInSquareMeters' | translate }}</td>\n      </tr>\n      <tr>\n        <td>\n          {{ data.area | measureFormat: measureAreaUnit.SquareKilometers }}\n        </td>\n        <td>\n          {{ 'igo.geo.measure.dialog.areaInSquareKilometers' | translate }}\n        </td>\n      </tr>\n      <tr>\n        <td>{{ data.area | measureFormat: measureAreaUnit.SquareMiles }}</td>\n        <td>{{ 'igo.geo.measure.dialog.areaInSquareMiles' | translate }}</td>\n      </tr>\n      <tr>\n        <td>{{ data.area | measureFormat: measureAreaUnit.Acres }}</td>\n        <td>{{ 'igo.geo.measure.dialog.areaInAcres' | translate }}</td>\n      </tr>\n      <tr>\n        <td>{{ data.area | measureFormat: measureAreaUnit.Hectares }}</td>\n        <td>{{ 'igo.geo.measure.dialog.areaInHectares' | translate }}</td>\n      </tr>\n      <tr>\n        <td>{{ 'igo.geo.measure.dialog.perimeterInMeters' | translate }}</td>\n        <td>{{ data.perimeter | measureFormat: measureLengthUnit.Meters }}</td>\n      </tr>\n    </tbody>\n  </table>\n</div>\n", styles: [":host{font-family:Roboto,Helvetica Neue,sans-serif}h3{text-align:center;margin:0}table{width:100%;padding:10px}table tbody tr td:last-child{padding-left:10px}\n"], dependencies: [{ kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1$2.MatDialogTitle, selector: "[mat-dialog-title], [matDialogTitle]", inputs: ["id"], exportAs: ["matDialogTitle"] }, { kind: "directive", type: i1$2.MatDialogContent, selector: "[mat-dialog-content], mat-dialog-content, [matDialogContent]" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }, { kind: "pipe", type: MeasureFormatPipe, name: "measureFormat" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: MeasurerDialogComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-measurer-dialog', template: "<h3 mat-dialog-title>{{ 'igo.geo.measure.dialog.title' | translate }}</h3>\n<div mat-dialog-content>\n  <table *ngIf=\"data.length > 0\" class=\"mat-typography\">\n    <thead>\n      <tr>\n        <th colspan=\"2\">\n          {{ 'igo.geo.measure.dialog.length.title' | translate }}\n        </th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr>\n        <td>{{ data.length | measureFormat: measureLengthUnit.Meters }}</td>\n        <td>{{ 'igo.geo.measure.dialog.lengthInMeters' | translate }}</td>\n      </tr>\n      <tr>\n        <td>\n          {{ data.length | measureFormat: measureLengthUnit.Kilometers }}\n        </td>\n        <td>{{ 'igo.geo.measure.dialog.lengthInKilometers' | translate }}</td>\n      </tr>\n      <tr>\n        <td>{{ data.length | measureFormat: measureLengthUnit.Miles }}</td>\n        <td>{{ 'igo.geo.measure.dialog.lengthInMiles' | translate }}</td>\n      </tr>\n      <tr>\n        <td>{{ data.length | measureFormat: measureLengthUnit.Feet }}</td>\n        <td>{{ 'igo.geo.measure.dialog.lengthInFeet' | translate }}</td>\n      </tr>\n    </tbody>\n  </table>\n\n  <table *ngIf=\"data.area > 0\" class=\"mat-typography\">\n    <thead>\n      <tr>\n        <th colspan=\"2\">\n          {{ 'igo.geo.measure.dialog.area.title' | translate }}\n        </th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr>\n        <td>{{ data.area | measureFormat: measureAreaUnit.SquareMeters }}</td>\n        <td>{{ 'igo.geo.measure.dialog.areaInSquareMeters' | translate }}</td>\n      </tr>\n      <tr>\n        <td>\n          {{ data.area | measureFormat: measureAreaUnit.SquareKilometers }}\n        </td>\n        <td>\n          {{ 'igo.geo.measure.dialog.areaInSquareKilometers' | translate }}\n        </td>\n      </tr>\n      <tr>\n        <td>{{ data.area | measureFormat: measureAreaUnit.SquareMiles }}</td>\n        <td>{{ 'igo.geo.measure.dialog.areaInSquareMiles' | translate }}</td>\n      </tr>\n      <tr>\n        <td>{{ data.area | measureFormat: measureAreaUnit.Acres }}</td>\n        <td>{{ 'igo.geo.measure.dialog.areaInAcres' | translate }}</td>\n      </tr>\n      <tr>\n        <td>{{ data.area | measureFormat: measureAreaUnit.Hectares }}</td>\n        <td>{{ 'igo.geo.measure.dialog.areaInHectares' | translate }}</td>\n      </tr>\n      <tr>\n        <td>{{ 'igo.geo.measure.dialog.perimeterInMeters' | translate }}</td>\n        <td>{{ data.perimeter | measureFormat: measureLengthUnit.Meters }}</td>\n      </tr>\n    </tbody>\n  </table>\n</div>\n", styles: [":host{font-family:Roboto,Helvetica Neue,sans-serif}h3{text-align:center;margin:0}table{width:100%;padding:10px}table tbody tr td:last-child{padding-left:10px}\n"] }]
        }], ctorParameters: function () { return [{ type: i1$2.MatDialogRef }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [MAT_DIALOG_DATA]
                }] }]; } });

/**
 * Measurer item
 */
class MeasurerItemComponent {
    /**
     * Measure observable
     * @internal
     */
    measure$ = new BehaviorSubject(undefined);
    /**
     * Subscription to the measure observable when the auto mode is on
     * @internal
     */
    measure$$;
    /**
     * Measure type
     */
    measureType;
    /**
     * Measure unit
     */
    measureUnit;
    /**
     * Measure
     */
    set measure(value) {
        this.measure$.next(value);
    }
    get measure() {
        return this.measure$.value;
    }
    /**
     * Whther measure units should be automatically determined
     */
    set auto(value) {
        this.toggleAutoUnit(value);
    }
    get auto() {
        return this._auto;
    }
    _auto = false;
    /**
     * Placeholder
     */
    placeholder;
    /**
     * Event emitted when the measure unit changes
     */
    measureUnitChange = new EventEmitter();
    /**
     * Available measure units for the measure type given
     * @internal
     */
    get measureUnits() {
        if (this.measureType === MeasureType.Area) {
            return Object.values(MeasureAreaUnit);
        }
        return Object.values(MeasureLengthUnit);
    }
    constructor() { }
    /**
     * Toggle the auto unit off
     * @internal
     */
    ngOnDestroy() {
        this.toggleAutoUnit(false);
    }
    /**
     * Set the measure unit
     * @internal
     */
    onMeasureUnitChange(unit) {
        this.measureUnit = unit;
        this.measureUnitChange.emit(unit);
    }
    toggleAutoUnit(toggle) {
        if (this.measure$$ !== undefined) {
            this.measure$$.unsubscribe();
        }
        if (toggle === true) {
            this.measure$$ = this.measure$.subscribe((measure) => {
                this.computeBestMeasureUnit(measure);
            });
        }
        this._auto = toggle;
    }
    computeBestMeasureUnit(measure) {
        let measureUnit = this.measureUnit;
        if (this.measureType === MeasureType.Area) {
            measureUnit = computeBestAreaUnit(measure);
        }
        else if (this.measureType === MeasureType.Length) {
            measureUnit = computeBestLengthUnit(measure);
        }
        if (measureUnit !== this.measureUnit) {
            this.onMeasureUnitChange(measureUnit);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: MeasurerItemComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: MeasurerItemComponent, selector: "igo-measurer-item", inputs: { measureType: "measureType", measureUnit: "measureUnit", measure: "measure", auto: "auto", placeholder: "placeholder" }, outputs: { measureUnitChange: "measureUnitChange" }, ngImport: i0, template: "<mat-form-field class=\"measure-field\" floatLabel=\"always\">\n  <mat-label>{{ placeholder }}</mat-label>\n  <input\n    matInput\n    [disabled]=\"true\"\n    [readonly]=\"true\"\n    [value]=\"(measure$ | async) || 0 | measureFormat: measureUnit\"\n  />\n</mat-form-field>\n<mat-form-field class=\"unit-field\">\n  <mat-select\n    [value]=\"measureUnit\"\n    [disabled]=\"auto\"\n    (selectionChange)=\"onMeasureUnitChange($event.value)\"\n  >\n    <mat-option *ngFor=\"let measureUnit of measureUnits\" [value]=\"measureUnit\">\n      {{ 'igo.geo.measure.' + measureUnit | translate }}\n    </mat-option>\n  </mat-select>\n</mat-form-field>\n", styles: [":host{display:flex;width:100%;padding:5px 10px}:host .measure-field{pointer-events:none;flex:2}:host .unit-field{margin-left:8px;flex:1}:host ::ng-deep mat-form-field .mat-mdc-form-field-subscript-wrapper{display:none}\n"], dependencies: [{ kind: "directive", type: i2$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "component", type: i8.MatFormField, selector: "mat-form-field", inputs: ["hideRequiredMarker", "color", "floatLabel", "appearance", "subscriptSizing", "hintLabel"], exportAs: ["matFormField"] }, { kind: "directive", type: i8.MatLabel, selector: "mat-label" }, { kind: "directive", type: i9$3.MatInput, selector: "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", inputs: ["disabled", "id", "placeholder", "name", "required", "type", "errorStateMatcher", "aria-describedby", "value", "readonly"], exportAs: ["matInput"] }, { kind: "component", type: i15.MatSelect, selector: "mat-select", inputs: ["disabled", "disableRipple", "tabIndex", "panelWidth", "hideSingleSelectionIndicator"], exportAs: ["matSelect"] }, { kind: "component", type: i9.MatOption, selector: "mat-option", exportAs: ["matOption"] }, { kind: "pipe", type: i2$2.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }, { kind: "pipe", type: MeasureFormatPipe, name: "measureFormat" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: MeasurerItemComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-measurer-item', changeDetection: ChangeDetectionStrategy.OnPush, template: "<mat-form-field class=\"measure-field\" floatLabel=\"always\">\n  <mat-label>{{ placeholder }}</mat-label>\n  <input\n    matInput\n    [disabled]=\"true\"\n    [readonly]=\"true\"\n    [value]=\"(measure$ | async) || 0 | measureFormat: measureUnit\"\n  />\n</mat-form-field>\n<mat-form-field class=\"unit-field\">\n  <mat-select\n    [value]=\"measureUnit\"\n    [disabled]=\"auto\"\n    (selectionChange)=\"onMeasureUnitChange($event.value)\"\n  >\n    <mat-option *ngFor=\"let measureUnit of measureUnits\" [value]=\"measureUnit\">\n      {{ 'igo.geo.measure.' + measureUnit | translate }}\n    </mat-option>\n  </mat-select>\n</mat-form-field>\n", styles: [":host{display:flex;width:100%;padding:5px 10px}:host .measure-field{pointer-events:none;flex:2}:host .unit-field{margin-left:8px;flex:1}:host ::ng-deep mat-form-field .mat-mdc-form-field-subscript-wrapper{display:none}\n"] }]
        }], ctorParameters: function () { return []; }, propDecorators: { measureType: [{
                type: Input
            }], measureUnit: [{
                type: Input
            }], measure: [{
                type: Input
            }], auto: [{
                type: Input
            }], placeholder: [{
                type: Input
            }], measureUnitChange: [{
                type: Output
            }] } });

/**
 * Tool to measure lengths and areas
 */
class MeasurerComponent {
    languageService;
    dialog;
    storageService;
    document;
    /**
     * Table template
     * @internal
     */
    tableTemplate;
    subscriptions$$ = [];
    /**
     * Reference to the MeasureType enum
     * @internal
     */
    measureType = MeasureType;
    /**
     * Reference to the AreaMeasureUnit enum
     * @internal
     */
    measureAreaUnit = MeasureAreaUnit;
    /**
     * Reference to the LengthMeasureUnit enum
     * @internal
     */
    measureLengthUnit = MeasureLengthUnit;
    /**
     * Whether measure units should be automatically determined
     * @internal
     */
    measureUnitsAuto = false;
    /**
     * Whether display of distances of areas
     * @internal
     */
    displayDistance = true;
    /**
     * Whether display of distances of lines
     * @internal
     */
    displayLines = true;
    /**
     * Whether display of areas
     * @internal
     */
    displayAreas = true;
    /**
     * Observable of line boolean
     * @internal
     */
    hasLine$ = new BehaviorSubject(false);
    /**
     * Observable of area boolean
     * @internal
     */
    hasArea$ = new BehaviorSubject(false);
    /**
     * Observable of area
     * @internal
     */
    measure$ = new BehaviorSubject({});
    /**
     * Observable of selected features
     * @internal
     */
    selectedFeatures$ = new BehaviorSubject([]);
    /**
     * OL draw source
     * @internal
     */
    showTooltips = true;
    /**
     * Whether draw control toggle is disabled or not
     * @internal
     */
    drawControlIsDisabled = true;
    /**
     * Draw line control
     */
    drawLineControl;
    /**
     * Draw polygon control
     */
    drawPolygonControl;
    /**
     * Modify control
     */
    modifyControl;
    /**
     * Active OL geometry
     */
    activeOlGeometry;
    /**
     * Active mlength unit
     */
    activeLengthUnit = MeasureLengthUnit.Meters;
    /**
     * Active area unit
     */
    activeAreaUnit = MeasureAreaUnit.SquareMeters;
    /**
     * Feature added listener key
     */
    onFeatureAddedKey;
    /**
     * Feature removed listener key
     */
    onFeatureRemovedKey;
    /**
     * Active draw control
     * @internal
     */
    activeDrawControl;
    /**
     * Subscription to draw start
     */
    drawStart$$;
    /**
     * Subscription to draw end
     */
    drawEnd$$;
    /**
     * Subscription to controls changes
     */
    drawChanges$$;
    /**
     * Subscription to modify start
     */
    modifyStart$$;
    /**
     * Subscription to modify end
     */
    modifyEnd$$;
    /**
     * Subscription to controls changes
     */
    modifyChanges$$;
    /**
     * Subscription to measures selection
     */
    selectedFeatures$$;
    /**
     * OL draw source
     */
    olDrawSource = new OlVectorSource();
    /**
     * The map to measure on
     */
    map;
    /**
     * The measures store
     */
    store;
    /**
     * Measure type
     * @internal
     */
    set activeMeasureType(value) {
        this.setActiveMeasureType(value);
    }
    get activeMeasureType() {
        return this._activeMeasureType;
    }
    _activeMeasureType;
    /**
     * The minimum length a segment must have to display a tooltip.
     * It also applies to area tooltips.
     */
    minSegmentLength = 10;
    table;
    /**
     * Wheter one of the draw control is active
     * @internal
     */
    get drawControlIsActive() {
        return this.activeDrawControl !== undefined;
    }
    get projection() {
        return this.map.ol.getView().getProjection().getCode();
    }
    constructor(languageService, dialog, storageService, document) {
        this.languageService = languageService;
        this.dialog = dialog;
        this.storageService = storageService;
        this.document = document;
        this.tableTemplate = {
            selection: true,
            selectMany: true,
            selectionCheckbox: true,
            sort: true,
            columns: [
                {
                    name: 'length',
                    title: this.languageService.translate.instant('igo.geo.measure.lengthHeader'),
                    valueAccessor: (localFeature) => {
                        const unit = this.activeLengthUnit;
                        const measure = metersToUnit(localFeature.properties.measure.length, unit);
                        return formatMeasure(measure, {
                            decimal: 1,
                            unit,
                            unitAbbr: false,
                            locale: 'fr'
                        });
                    }
                },
                {
                    name: 'area',
                    title: this.languageService.translate.instant('igo.geo.measure.areaHeader'),
                    valueAccessor: (localFeature) => {
                        const unit = this.activeAreaUnit;
                        const measure = squareMetersToUnit(localFeature.properties.measure.area, unit);
                        return measure
                            ? formatMeasure(measure, {
                                decimal: 1,
                                unit,
                                unitAbbr: false,
                                locale: 'fr'
                            })
                            : '';
                    }
                }
            ]
        };
    }
    /**
     * Add draw controls and activate one
     * @internal
     */
    ngOnInit() {
        this.getSavedUnits();
        this.initStore();
        this.createDrawLineControl();
        this.createDrawPolygonControl();
        this.createModifyControl();
        this.toggleDrawControl();
        this.updateTooltipsOfOlSource(this.store.source.ol);
        this.checkDistanceAreaToggle();
        this.setActiveMeasureType(MeasureType.Length);
    }
    /**
     * Clear the overlay layer and any interaction added by this component.
     * @internal
     */
    ngOnDestroy() {
        this.setActiveMeasureType(undefined);
        this.deactivateModifyControl();
        this.freezeStore();
        this.subscriptions$$.map((s) => s.unsubscribe());
    }
    /**
     * Set the measure type
     * @internal
     */
    onMeasureTypeChange(measureType) {
        this.activeMeasureType = measureType;
    }
    /**
     * Activate or deactivate the current draw control
     * @internal
     */
    onToggleDrawControl(toggle) {
        if (toggle === true) {
            this.toggleDrawControl();
        }
        else {
            this.deactivateDrawControl();
        }
    }
    /**
     * Activate or deactivate the current draw control
     * @internal
     */
    onToggleMeasureUnitsAuto(toggle) {
        this.measureUnitsAuto = toggle;
    }
    /**
     * Activate or deactivate the current display of distances of the areas
     * @internal
     */
    onToggleDisplayDistance(toggle) {
        this.displayDistance = toggle;
        this.onDisplayDistance();
        toggle
            ? this.storageService.set('distanceToggle', true, StorageScope.SESSION)
            : this.storageService.set('distanceToggle', false, StorageScope.SESSION);
    }
    /**
     * Activate or deactivate the current display of distances of the lines
     * @internal
     */
    onToggleDisplayLines(toggle) {
        this.displayLines = toggle;
        this.onDisplayLines();
        toggle
            ? this.storageService.set('linesToggle', true, StorageScope.SESSION)
            : this.storageService.set('linesToggle', false, StorageScope.SESSION);
    }
    /**
     * Activate or deactivate the current display of areas
     * @internal
     */
    onToggleDisplayAreas(toggle) {
        this.displayAreas = toggle;
        this.onDisplayAreas();
        toggle
            ? this.storageService.set('areasToggle', true, StorageScope.SESSION)
            : this.storageService.set('areasToggle', false, StorageScope.SESSION);
    }
    /**
     * Set display parametres in current values
     * @internal
     */
    checkDistanceAreaToggle() {
        if (this.storageService.get('distanceToggle') === false) {
            this.displayDistance = false;
        }
        if (this.storageService.get('linesToggle') === false) {
            this.displayLines = false;
        }
        if (this.storageService.get('areasToggle') === false) {
            this.displayAreas = false;
        }
    }
    /**
     * Activate or deactivate the current display of distances of areas
     * @internal
     */
    onDisplayDistance() {
        const elements = this.document.getElementsByClassName('igo-map-tooltip-measure-polygone-segments');
        if (this.displayDistance) {
            Array.from(elements).map((value) => value.classList.remove('igo-map-tooltip-hidden'));
        }
        else {
            Array.from(elements).map((value) => value.classList.add('igo-map-tooltip-hidden'));
        }
    }
    /**
     * Activate or deactivate the current display of distances of lines
     * @internal
     */
    onDisplayLines() {
        const elements = this.document.getElementsByClassName('igo-map-tooltip-measure-line-segments');
        if (this.displayLines) {
            Array.from(elements).map((value) => {
                value.classList.remove('igo-map-tooltip-hidden');
            });
        }
        else {
            Array.from(elements).map((value) => {
                value.classList.add('igo-map-tooltip-hidden');
            });
        }
    }
    /**
     * Activate or deactivate the current display of areas
     * @internal
     */
    onDisplayAreas() {
        const elements = this.document.getElementsByClassName('igo-map-tooltip-measure-area');
        if (this.displayAreas) {
            Array.from(elements).map((value) => value.classList.remove('igo-map-tooltip-hidden'));
        }
        else {
            Array.from(elements).map((value) => value.classList.add('igo-map-tooltip-hidden'));
        }
    }
    /**
     * Set the measure type
     * @internal
     */
    onLengthUnitChange(unit) {
        this.activeLengthUnit = unit;
        this.saveCurrentUnits();
        this.refreshTableAndTooltip();
    }
    /**
     * Set the measure type
     * @internal
     */
    onAreaUnitChange(unit) {
        this.activeAreaUnit = unit;
        this.saveCurrentUnits();
        this.refreshTableAndTooltip();
    }
    refreshTableAndTooltip() {
        this.store.stateView.clear();
        this.updateTooltipsOfOlSource(this.store.source.ol);
        if (this.activeOlGeometry !== undefined) {
            this.updateTooltipsOfOlGeometry(this.activeOlGeometry);
        }
    }
    onCalculateClick() {
        const features = this.selectedFeatures$.value;
        const area = features.reduce((sum, localFeature) => {
            return sum + localFeature.properties.measure.area || 0;
        }, 0);
        const length = features.reduce((sum, localFeature) => {
            if (localFeature.geometry.type === 'Polygon') {
                return sum;
            }
            return sum + localFeature.properties.measure.length || 0;
        }, 0);
        const perimeter = features.reduce((sum, localFeature) => {
            if (localFeature.geometry.type === 'LineString') {
                return sum;
            }
            return sum + localFeature.properties.measure.length || 0;
        }, 0);
        this.openDialog({
            area,
            length,
            perimeter
        });
    }
    onDeleteClick() {
        this.store.deleteMany(this.selectedFeatures$.value);
        this.selectedFeatures$.value.forEach((selectedFeature) => {
            this.olDrawSource.getFeatures().forEach((drawingLayerFeature) => {
                const geometry = drawingLayerFeature.getGeometry();
                if (selectedFeature.properties.id === geometry.ol_uid) {
                    this.olDrawSource.removeFeature(drawingLayerFeature);
                }
            });
        });
    }
    onModifyClick() {
        if (this.selectedFeatures$.value.length !== 1) {
            return;
        }
        if (this.modifyControl.active === true) {
            this.deactivateModifyControl();
            this.toggleDrawControl();
        }
        else {
            const localFeature = this.selectedFeatures$.value[0];
            const olFeatures = this.store.layer.ol.getSource().getFeatures();
            const olFeature = olFeatures.find((_olFeature) => {
                return _olFeature.get('id') === localFeature.properties.id;
            });
            if (olFeature !== undefined) {
                this.deactivateDrawControl();
                this.activateModifyControl();
                const olGeometry = olFeature.getGeometry();
                this.clearTooltipsOfOlGeometry(olGeometry);
                this.modifyControl.setOlGeometry(olGeometry);
            }
        }
    }
    openDialog(data) {
        this.dialog.open(MeasurerDialogComponent, { data });
    }
    /**
     * Initialize the measure store and set up some listeners
     * @internal
     */
    initStore() {
        const store = this.store;
        const layer = new VectorLayer({
            title: this.languageService.translate.instant('igo.geo.measure.layerTitle'),
            isIgoInternalLayer: true,
            id: `igo-measures-${uuid()}`,
            zIndex: 200,
            source: new FeatureDataSource(),
            style: createMeasureLayerStyle(),
            showInLayerList: true,
            exportable: true,
            browsable: false,
            workspace: { enabled: false }
        });
        tryBindStoreLayer(store, layer);
        store.layer.visible = true;
        layer.visible$.subscribe((visible) => {
            const elements = this.document.getElementsByClassName('igo-map-tooltip-measure');
            if (visible) {
                Array.from(elements).map((value) => value.classList.remove('igo-map-tooltip-measure-by-display'));
            }
            else {
                Array.from(elements).map((value) => value.classList.add('igo-map-tooltip-measure-by-display'));
            }
        });
        tryAddLoadingStrategy(store);
        tryAddSelectionStrategy(store, new FeatureStoreSelectionStrategy({
            map: this.map,
            many: true
        }));
        this.onFeatureAddedKey = store.source.ol.on('addfeature', (event) => {
            const localFeature = event.feature;
            const olGeometry = localFeature.getGeometry();
            this.updateMeasureOfOlGeometry(olGeometry, localFeature.get('measure'));
            this.onDisplayDistance();
            this.onDisplayLines();
            this.onDisplayAreas();
        });
        this.onFeatureRemovedKey = store.source.ol.on('removefeature', (event) => {
            const olGeometry = event.feature.getGeometry();
            this.clearTooltipsOfOlGeometry(olGeometry);
        });
        this.selectedFeatures$$ = store.stateView
            .manyBy$((record) => {
            return record.state.selected === true;
        })
            .pipe(skip(1) // Skip initial emission
        )
            .subscribe((records) => {
            if (this.modifyControl.active === true) {
                this.deactivateModifyControl();
            }
            this.selectedFeatures$.next(records.map((record) => record.entity));
        });
        this.subscriptions$$.push(this.store.entities$.subscribe((objectsExists) => {
            if (objectsExists.find((objectExist) => objectExist.geometry.type === 'Polygon')) {
                this.hasArea$.next(true);
            }
            else {
                this.hasArea$.next(false);
            }
            if (objectsExists.find((objectExist) => objectExist.geometry.type === 'LineString')) {
                this.hasLine$.next(true);
            }
            else {
                this.hasLine$.next(false);
            }
        }));
        this.subscriptions$$.push(this.store.count$.subscribe((cnt) => {
            cnt >= 1
                ? (this.store.layer.options.showInLayerList = true)
                : (this.store.layer.options.showInLayerList = false);
        }));
    }
    /**
     * Freeze any store, meaning the layer is removed, strategies are deactivated
     * and some listener removed
     * @internal
     */
    freezeStore() {
        const store = this.store;
        this.selectedFeatures$$.unsubscribe();
        unByKey(this.onFeatureAddedKey);
        unByKey(this.onFeatureRemovedKey);
        store.deactivateStrategyOfType(FeatureStoreLoadingStrategy);
        store.deactivateStrategyOfType(FeatureStoreSelectionStrategy);
    }
    /**
     * Create a draw line control
     */
    createDrawLineControl() {
        this.drawLineControl = new DrawControl({
            geometryType: 'LineString',
            drawingLayerSource: this.olDrawSource,
            interactionStyle: createMeasureInteractionStyle(),
            drawingLayerStyle: new OlStyle({})
        });
    }
    /**
     * Create a draw polygon control
     */
    createDrawPolygonControl() {
        this.drawPolygonControl = new DrawControl({
            geometryType: 'Polygon',
            drawingLayerSource: this.olDrawSource,
            interactionStyle: createMeasureInteractionStyle(),
            drawingLayerStyle: new OlStyle({})
        });
    }
    /**
     * Create a draw polygon control
     */
    createModifyControl() {
        this.modifyControl = new ModifyControl({
            source: this.olDrawSource,
            drawStyle: createMeasureInteractionStyle(),
            layerStyle: new OlStyle({})
        });
    }
    /**
     * Activate the right control
     */
    toggleDrawControl() {
        this.deactivateDrawControl();
        // this.deactivateModifyControl();
        if (this.activeMeasureType === MeasureType.Length) {
            this.activateDrawControl(this.drawLineControl);
        }
        else if (this.activeMeasureType === MeasureType.Area) {
            this.activateDrawControl(this.drawPolygonControl);
        }
    }
    /**
     * Activate a given control
     * @param drawControl Draw control
     */
    activateDrawControl(drawControl) {
        this.drawControlIsDisabled = false;
        this.activeDrawControl = drawControl;
        this.drawStart$$ = drawControl.start$.subscribe((olGeometry) => this.onDrawStart(olGeometry));
        this.drawEnd$$ = drawControl.end$.subscribe((olGeometry) => this.onDrawEnd(olGeometry));
        this.drawChanges$$ = drawControl.changes$.subscribe((olGeometry) => this.onDrawChanges(olGeometry));
        this.drawChanges$$ = drawControl.abort$.subscribe((olGeometry) => {
            this.clearTooltipsOfOlGeometry(olGeometry);
            this.clearMeasures();
        });
        drawControl.setOlMap(this.map.ol, false);
    }
    /**
     * Deactivate the active draw control
     */
    deactivateDrawControl() {
        if (this.activeDrawControl === undefined) {
            return;
        }
        this.olDrawSource.clear();
        if (this.drawStart$$ !== undefined) {
            this.drawStart$$.unsubscribe();
        }
        if (this.drawEnd$$ !== undefined) {
            this.drawEnd$$.unsubscribe();
        }
        if (this.drawChanges$$ !== undefined) {
            this.drawChanges$$.unsubscribe();
        }
        this.clearTooltipsOfOlSource(this.olDrawSource);
        if (this.activeOlGeometry !== undefined) {
            this.clearTooltipsOfOlGeometry(this.activeOlGeometry);
        }
        this.activeDrawControl.setOlMap(undefined);
        this.activeDrawControl = undefined;
        this.activeOlGeometry = undefined;
    }
    setActiveMeasureType(measureType) {
        this._activeMeasureType = measureType;
        this.clearMeasures();
        this.toggleDrawControl();
    }
    /**
     * Clear the draw source and track the geometry being drawn
     * @param olGeometry Ol linestring or polygon
     */
    onDrawStart(olGeometry) {
        this.activeOlGeometry = olGeometry;
    }
    /**
     * Clear the draw source and track the geometry being draw
     * @param olGeometry Ol linestring or polygon
     */
    onDrawEnd(olGeometry) {
        this.activeOlGeometry = undefined;
        this.finalizeMeasureOfOlGeometry(olGeometry);
        this.addFeatureToStore(olGeometry);
        this.clearTooltipsOfOlGeometry(olGeometry);
        this.olDrawSource.clear(true);
    }
    /**
     * Update measures observables and map tooltips
     * @param olGeometry Ol linestring or polygon
     */
    onDrawChanges(olGeometry) {
        const measure = measureOlGeometry(olGeometry, this.projection);
        this.updateMeasureOfOlGeometry(olGeometry, Object.assign({}, measure, {
            area: undefined // We don't want to display an area tooltip while drawing.
        }));
        this.measure$.next(measure);
    }
    /**
     * Activate a given control
     * @param modifyControl Modify control
     */
    activateModifyControl() {
        const selection = this.store.getStrategyOfType(FeatureStoreSelectionStrategy);
        selection.deactivate();
        selection.clear();
        this.modifyStart$$ = this.modifyControl.start$.subscribe((olGeometry) => this.onModifyStart(olGeometry));
        this.modifyEnd$$ = this.modifyControl.end$.subscribe((olGeometry) => this.onModifyEnd(olGeometry));
        this.modifyChanges$$ = this.modifyControl.changes$.subscribe((olGeometry) => this.onModifyChanges(olGeometry));
        this.modifyControl.setOlMap(this.map.ol);
    }
    /**
     * Deactivate the active modify control
     */
    deactivateModifyControl() {
        if (this.modifyStart$$ !== undefined) {
            this.modifyStart$$.unsubscribe();
        }
        if (this.modifyEnd$$ !== undefined) {
            this.modifyEnd$$.unsubscribe();
        }
        if (this.modifyChanges$$ !== undefined) {
            this.modifyChanges$$.unsubscribe();
        }
        if (this.activeOlGeometry !== undefined) {
            if (this.selectedFeatures$.value.length === 1) {
                const localFeature = this.selectedFeatures$.value[0];
                this.addFeatureToStore(this.activeOlGeometry, localFeature);
            }
            this.finalizeMeasureOfOlGeometry(this.activeOlGeometry);
        }
        this.olDrawSource.clear();
        this.store.activateStrategyOfType(FeatureStoreSelectionStrategy);
        this.activeOlGeometry = undefined;
        this.modifyControl.setOlMap(undefined);
    }
    /**
     * Clear the draw source and track the geometry being drawn
     * @param olGeometry Ol linestring or polygon
     */
    onModifyStart(olGeometry) {
        this.onDrawStart(olGeometry);
    }
    /**
     * Update measures observables and map tooltips
     * @param olGeometry Ol linestring or polygon
     */
    onModifyChanges(olGeometry) {
        this.onDrawChanges(olGeometry);
    }
    /**
     * Clear the draw source and track the geometry being draw
     * @param olGeometry Ol linestring or polygon
     */
    onModifyEnd(olGeometry) {
        this.finalizeMeasureOfOlGeometry(olGeometry);
    }
    finalizeMeasureOfOlGeometry(olGeometry) {
        const measure = measureOlGeometry(olGeometry, this.projection);
        this.updateMeasureOfOlGeometry(olGeometry, measure);
    }
    /**
     * Update measures observables
     * @param olGeometry Ol linestring or polygon
     * @param measure Measure
     */
    updateMeasureOfOlGeometry(olGeometry, measure) {
        olGeometry.setProperties({ _measure: measure }, true);
        this.updateTooltipsOfOlGeometry(olGeometry);
    }
    /**
     * Clear the measures observables
     */
    clearMeasures() {
        this.measure$.next({});
    }
    /**
     * Add a feature with measures to the store. The loading stragegy of the store
     * will trigger and add the feature to the map.
     * @internal
     */
    addFeatureToStore(olGeometry, localFeature) {
        const featureId = localFeature
            ? localFeature.properties.id
            : olGeometry.ol_uid;
        const projection = this.map.ol.getView().getProjection();
        const geometry = new OlGeoJSON().writeGeometryObject(olGeometry, {
            featureProjection: projection,
            dataProjection: projection
        });
        this.store.update({
            type: FEATURE,
            geometry,
            projection: projection.getCode(),
            properties: {
                id: featureId,
                measure: olGeometry.get('_measure')
            },
            meta: {
                id: featureId
            }
        });
    }
    /**
     * Update all the tooltips of an OL geometry
     * @param olGeometry OL Geometry
     * @param lengths Lengths of the OL geometry's segments
     * @param measureUnit Display tooltip measure in those units
     */
    updateTooltipsOfOlGeometry(olGeometry) {
        const measure = olGeometry.get('_measure');
        const lengths = measure.lengths;
        const area = measure.area;
        const olMidpointsTooltips = updateOlTooltipsAtMidpoints(olGeometry);
        if (lengths.length === olMidpointsTooltips.length) {
            for (let i = 0; i < olMidpointsTooltips.length; i++) {
                const length = lengths[i];
                if (length !== undefined) {
                    this.updateOlTooltip(olMidpointsTooltips[i], metersToUnit(length, this.activeLengthUnit), this.activeLengthUnit, MeasureType.Length);
                }
            }
        }
        if (area !== undefined) {
            this.updateOlTooltip(updateOlTooltipAtCenter(olGeometry), squareMetersToUnit(area, this.activeAreaUnit), this.activeAreaUnit, MeasureType.Area);
        }
    }
    /**
     * Show the map tooltips of a geoemtry
     */
    showTooltipsOfOlGeometry(olGeometry) {
        getTooltipsOfOlGeometry(olGeometry).forEach((olTooltip) => {
            if (this.shouldShowTooltip(olTooltip)) {
                this.map.ol.addOverlay(olTooltip);
            }
        });
    }
    /**
     * Clear the tooltips of an OL geometrys
     * @param olGeometry OL geometry with tooltips
     */
    clearTooltipsOfOlGeometry(olGeometry) {
        getTooltipsOfOlGeometry(olGeometry).forEach((olTooltip) => {
            if (olTooltip !== undefined && olTooltip.getMap() !== undefined) {
                this.map.ol.removeOverlay(olTooltip);
            }
        });
    }
    /**
     * Show the map tooltips of all the geometries of a source
     */
    updateTooltipsOfOlSource(olSource) {
        olSource.forEachFeature((olFeature) => {
            this.updateTooltipsOfOlGeometry(olFeature.getGeometry());
        });
    }
    /**
     * Show the map tooltips of all the geometries of a source
     */
    showTooltipsOfOlSource(olSource) {
        olSource.forEachFeature((olFeature) => {
            this.showTooltipsOfOlGeometry(olFeature.getGeometry());
        });
    }
    /**
     * Clear the map tooltips
     * @param olDrawSource OL vector source
     */
    clearTooltipsOfOlSource(olSource) {
        olSource.forEachFeature((olFeature) => {
            const olGeometry = olFeature.getGeometry();
            if (olGeometry !== undefined) {
                this.clearTooltipsOfOlGeometry(olFeature.getGeometry());
            }
        });
    }
    /**
     * Update an OL tooltip properties and inner HTML and add it to the map if possible
     * @param olTooltip OL tooltip
     * @param measure The measure valeu ti display
     * @param measureUnit Display tooltip measure in those units
     */
    updateOlTooltip(olTooltip, measure, unit, type) {
        olTooltip.setProperties({ _measure: measure, _unit: unit, _type: type }, true);
        olTooltip.getElement().innerHTML = this.computeTooltipInnerHTML(olTooltip);
        if (this.shouldShowTooltip(olTooltip)) {
            this.map.ol.addOverlay(olTooltip);
        }
    }
    /**
     * Compute a tooltip's content
     * @param olTooltip OL overlay
     * @returns Inner HTML
     */
    computeTooltipInnerHTML(olTooltip) {
        const properties = olTooltip.getProperties();
        return formatMeasure(properties._measure, {
            decimal: 1,
            unit: properties._unit,
            unitAbbr: true,
            locale: 'fr'
        }, this.languageService);
    }
    /**
     * Whether a tooltip should be showned based on the length
     * of the segment it is bound to.
     * @param olTooltip OL overlay
     * @returns True if the tooltip should be shown
     */
    shouldShowTooltip(olTooltip) {
        if (this.showTooltips === false) {
            return false;
        }
        const properties = olTooltip.getProperties();
        const measure = properties._measure;
        if (measure === undefined) {
            return false;
        }
        if (properties._unit === MeasureType.Length) {
            const minSegmentLength = metersToUnit(this.minSegmentLength, properties._unit) || 0;
            return measure > Math.max(minSegmentLength, 0);
        }
        return true;
    }
    saveCurrentUnits() {
        this.storageService.set('distanceUnit', this.activeLengthUnit, StorageScope.SESSION);
        this.storageService.set('areaUnit', this.activeAreaUnit, StorageScope.SESSION);
    }
    getSavedUnits() {
        const distanceUnit = this.storageService.get('distanceUnit');
        const areaUnit = this.storageService.get('areaUnit');
        this.activeLengthUnit = distanceUnit ? distanceUnit : this.activeLengthUnit;
        this.activeAreaUnit = areaUnit ? areaUnit : this.activeAreaUnit;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: MeasurerComponent, deps: [{ token: i2.LanguageService }, { token: i1$2.MatDialog }, { token: i2.StorageService }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: MeasurerComponent, selector: "igo-measurer", inputs: { map: "map", store: "store", activeMeasureType: "activeMeasureType", minSegmentLength: "minSegmentLength" }, viewQueries: [{ propertyName: "table", first: true, predicate: ["table"], descendants: true, static: true }], ngImport: i0, template: "<div>\n  <div class=\"measure-type-toggle mat-typography\">\n    <mat-button-toggle-group\n      [value]=\"activeMeasureType\"\n      (change)=\"onMeasureTypeChange($event.value)\"\n    >\n      <mat-button-toggle [value]=\"measureType.Length\">\n        {{ 'igo.geo.measure.' + measureType.Length | translate }}\n      </mat-button-toggle>\n      <mat-button-toggle [value]=\"measureType.Area\">\n        {{ 'igo.geo.measure.' + measureType.Area | translate }}\n      </mat-button-toggle>\n    </mat-button-toggle-group>\n  </div>\n\n  <div class=\"measure-options mat-typography\">\n    <mat-slide-toggle\n      [disabled]=\"drawControlIsDisabled\"\n      [checked]=\"drawControlIsActive\"\n      [labelPosition]=\"'before'\"\n      (change)=\"onToggleDrawControl($event.checked)\"\n    >\n      {{ 'igo.geo.measure.toggleActive' | translate }}\n    </mat-slide-toggle>\n\n    <mat-divider *ngIf=\"hasLine$ | async\"></mat-divider>\n\n    <mat-slide-toggle\n      *ngIf=\"hasLine$ | async\"\n      [checked]=\"displayLines\"\n      [labelPosition]=\"'before'\"\n      (change)=\"onToggleDisplayLines($event.checked)\"\n    >\n      {{ 'igo.geo.measure.toggleDisplayLines' | translate }}\n    </mat-slide-toggle>\n\n    <mat-divider *ngIf=\"(hasLine$ | async) || (hasArea$ | async)\"></mat-divider>\n\n    <mat-slide-toggle\n      *ngIf=\"hasArea$ | async\"\n      [checked]=\"displayDistance\"\n      [labelPosition]=\"'before'\"\n      (change)=\"onToggleDisplayDistance($event.checked)\"\n    >\n      {{ 'igo.geo.measure.toggleDisplayDistance' | translate }}\n    </mat-slide-toggle>\n\n    <mat-slide-toggle\n      *ngIf=\"hasArea$ | async\"\n      [checked]=\"displayAreas\"\n      [labelPosition]=\"'before'\"\n      (change)=\"onToggleDisplayAreas($event.checked)\"\n    >\n      {{ 'igo.geo.measure.toggleDisplayAreas' | translate }}\n    </mat-slide-toggle>\n\n    <mat-divider *ngIf=\"hasArea$ | async\"></mat-divider>\n\n    <mat-slide-toggle\n      [checked]=\"measureUnitsAuto\"\n      [labelPosition]=\"'before'\"\n      (change)=\"onToggleMeasureUnitsAuto($event.checked)\"\n    >\n      {{ 'igo.geo.measure.toggleAutoUnits' | translate }}\n    </mat-slide-toggle>\n  </div>\n\n  <ng-container *ngIf=\"measure$ | async as measure\">\n    <igo-measurer-item\n      *ngIf=\"\n        activeMeasureType === measureType.Length ||\n        activeMeasureType === measureType.Area\n      \"\n      [measureType]=\"measureType.Length\"\n      [measureUnit]=\"activeLengthUnit\"\n      [measure]=\"measure.length\"\n      [auto]=\"measureUnitsAuto\"\n      [placeholder]=\"\n        (activeMeasureType === measureType.Area\n          ? 'igo.geo.measure.perimeter'\n          : 'igo.geo.measure.length'\n        ) | translate\n      \"\n      (measureUnitChange)=\"onLengthUnitChange($event)\"\n    >\n    </igo-measurer-item>\n\n    <igo-measurer-item\n      *ngIf=\"activeMeasureType === measureType.Area\"\n      [measureType]=\"measureType.Area\"\n      [measureUnit]=\"activeAreaUnit\"\n      [measure]=\"measure.area\"\n      [auto]=\"measureUnitsAuto\"\n      [placeholder]=\"'igo.geo.measure.area' | translate\"\n      (measureUnitChange)=\"onAreaUnitChange($event)\"\n    >\n    </igo-measurer-item>\n  </ng-container>\n\n  <mat-divider *ngIf=\"(hasLine$ | async) || (hasArea$ | async)\"></mat-divider>\n\n  <div class=\"measure-store-buttons\">\n    <button\n      *ngIf=\"(hasLine$ | async) || (hasArea$ | async)\"\n      mat-icon-button\n      [matTooltip]=\"'igo.geo.measure.actionbar.calculate.tooltip' | translate\"\n      [disabled]=\"(selectedFeatures$ | async).length === 0\"\n      color=\"accent\"\n      (click)=\"onCalculateClick()\"\n    >\n      <mat-icon svgIcon=\"calculator\"></mat-icon>\n    </button>\n\n    <button\n      *ngIf=\"(hasLine$ | async) || (hasArea$ | async)\"\n      mat-icon-button\n      [matTooltip]=\"'igo.geo.measure.actionbar.delete.tooltip' | translate\"\n      [disabled]=\"(selectedFeatures$ | async).length === 0\"\n      color=\"warn\"\n      (click)=\"onDeleteClick()\"\n    >\n      <mat-icon svgIcon=\"delete\"></mat-icon>\n    </button>\n\n    <!--button\n      mat-icon-button\n      [matTooltip]=\"'igo.geo.measure.actionbar.modify.tooltip' | translate\"\n      [disabled]=\"(selectedFeatures$ | async).length !== 1\"\n      (click)=\"onModifyClick()\">\n      <mat-icon svgIcon=\"edit\"></mat-icon>\n    </button-->\n  </div>\n\n  <igo-entity-table\n    #table\n    class=\"table-compact\"\n    [store]=\"store\"\n    [template]=\"tableTemplate\"\n  >\n  </igo-entity-table>\n</div>\n", styles: [":host .measure-type-toggle{padding:10px;text-align:center}:host .measure-type-toggle mat-button-toggle-group{width:100%}:host .measure-type-toggle mat-button-toggle-group mat-button-toggle{width:50%}:host .measure-options mat-slide-toggle{width:100%;padding:10px}:host .measure-options mat-slide-toggle ::ng-deep .mdc-form-field{width:100%}:host .measure-options mat-slide-toggle ::ng-deep .mdc-label{margin-left:0;width:calc(100% - 60px)}:host .measure-store-buttons{margin-left:-2px}:host .measure-store-buttons button:first-of-type{margin-left:14px}:host .table-compact ::ng-deep .mat-mdc-header-cell.mat-column-selectionCheckbox{width:52px}:host .igo-map-tooltip{position:relative;border-radius:4px;padding:4px 8px;white-space:nowrap}::ng-deep .igo-map-tooltip-hidden,.igo-map-tooltip-measure-by-display{display:none}\n"], dependencies: [{ kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "directive", type: i5$1.MatButtonToggleGroup, selector: "mat-button-toggle-group", inputs: ["appearance", "name", "vertical", "value", "multiple", "disabled"], outputs: ["valueChange", "change"], exportAs: ["matButtonToggleGroup"] }, { kind: "component", type: i5$1.MatButtonToggle, selector: "mat-button-toggle", inputs: ["disableRipple", "aria-label", "aria-labelledby", "id", "name", "value", "tabIndex", "appearance", "checked", "disabled"], outputs: ["change"], exportAs: ["matButtonToggle"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "component", type: i7.MatSlideToggle, selector: "mat-slide-toggle", inputs: ["disabled", "disableRipple", "color", "tabIndex"], exportAs: ["matSlideToggle"] }, { kind: "component", type: i9$2.MatDivider, selector: "mat-divider", inputs: ["vertical", "inset"] }, { kind: "component", type: i9$1.EntityTableComponent, selector: "igo-entity-table", inputs: ["store", "paginator", "template", "scrollBehavior", "sortNullsFirst", "withPaginator", "paginatorOptions"], outputs: ["entityClick", "entitySelectChange", "entitySortChange"] }, { kind: "component", type: MeasurerItemComponent, selector: "igo-measurer-item", inputs: ["measureType", "measureUnit", "measure", "auto", "placeholder"], outputs: ["measureUnitChange"] }, { kind: "pipe", type: i2$2.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: MeasurerComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-measurer', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div>\n  <div class=\"measure-type-toggle mat-typography\">\n    <mat-button-toggle-group\n      [value]=\"activeMeasureType\"\n      (change)=\"onMeasureTypeChange($event.value)\"\n    >\n      <mat-button-toggle [value]=\"measureType.Length\">\n        {{ 'igo.geo.measure.' + measureType.Length | translate }}\n      </mat-button-toggle>\n      <mat-button-toggle [value]=\"measureType.Area\">\n        {{ 'igo.geo.measure.' + measureType.Area | translate }}\n      </mat-button-toggle>\n    </mat-button-toggle-group>\n  </div>\n\n  <div class=\"measure-options mat-typography\">\n    <mat-slide-toggle\n      [disabled]=\"drawControlIsDisabled\"\n      [checked]=\"drawControlIsActive\"\n      [labelPosition]=\"'before'\"\n      (change)=\"onToggleDrawControl($event.checked)\"\n    >\n      {{ 'igo.geo.measure.toggleActive' | translate }}\n    </mat-slide-toggle>\n\n    <mat-divider *ngIf=\"hasLine$ | async\"></mat-divider>\n\n    <mat-slide-toggle\n      *ngIf=\"hasLine$ | async\"\n      [checked]=\"displayLines\"\n      [labelPosition]=\"'before'\"\n      (change)=\"onToggleDisplayLines($event.checked)\"\n    >\n      {{ 'igo.geo.measure.toggleDisplayLines' | translate }}\n    </mat-slide-toggle>\n\n    <mat-divider *ngIf=\"(hasLine$ | async) || (hasArea$ | async)\"></mat-divider>\n\n    <mat-slide-toggle\n      *ngIf=\"hasArea$ | async\"\n      [checked]=\"displayDistance\"\n      [labelPosition]=\"'before'\"\n      (change)=\"onToggleDisplayDistance($event.checked)\"\n    >\n      {{ 'igo.geo.measure.toggleDisplayDistance' | translate }}\n    </mat-slide-toggle>\n\n    <mat-slide-toggle\n      *ngIf=\"hasArea$ | async\"\n      [checked]=\"displayAreas\"\n      [labelPosition]=\"'before'\"\n      (change)=\"onToggleDisplayAreas($event.checked)\"\n    >\n      {{ 'igo.geo.measure.toggleDisplayAreas' | translate }}\n    </mat-slide-toggle>\n\n    <mat-divider *ngIf=\"hasArea$ | async\"></mat-divider>\n\n    <mat-slide-toggle\n      [checked]=\"measureUnitsAuto\"\n      [labelPosition]=\"'before'\"\n      (change)=\"onToggleMeasureUnitsAuto($event.checked)\"\n    >\n      {{ 'igo.geo.measure.toggleAutoUnits' | translate }}\n    </mat-slide-toggle>\n  </div>\n\n  <ng-container *ngIf=\"measure$ | async as measure\">\n    <igo-measurer-item\n      *ngIf=\"\n        activeMeasureType === measureType.Length ||\n        activeMeasureType === measureType.Area\n      \"\n      [measureType]=\"measureType.Length\"\n      [measureUnit]=\"activeLengthUnit\"\n      [measure]=\"measure.length\"\n      [auto]=\"measureUnitsAuto\"\n      [placeholder]=\"\n        (activeMeasureType === measureType.Area\n          ? 'igo.geo.measure.perimeter'\n          : 'igo.geo.measure.length'\n        ) | translate\n      \"\n      (measureUnitChange)=\"onLengthUnitChange($event)\"\n    >\n    </igo-measurer-item>\n\n    <igo-measurer-item\n      *ngIf=\"activeMeasureType === measureType.Area\"\n      [measureType]=\"measureType.Area\"\n      [measureUnit]=\"activeAreaUnit\"\n      [measure]=\"measure.area\"\n      [auto]=\"measureUnitsAuto\"\n      [placeholder]=\"'igo.geo.measure.area' | translate\"\n      (measureUnitChange)=\"onAreaUnitChange($event)\"\n    >\n    </igo-measurer-item>\n  </ng-container>\n\n  <mat-divider *ngIf=\"(hasLine$ | async) || (hasArea$ | async)\"></mat-divider>\n\n  <div class=\"measure-store-buttons\">\n    <button\n      *ngIf=\"(hasLine$ | async) || (hasArea$ | async)\"\n      mat-icon-button\n      [matTooltip]=\"'igo.geo.measure.actionbar.calculate.tooltip' | translate\"\n      [disabled]=\"(selectedFeatures$ | async).length === 0\"\n      color=\"accent\"\n      (click)=\"onCalculateClick()\"\n    >\n      <mat-icon svgIcon=\"calculator\"></mat-icon>\n    </button>\n\n    <button\n      *ngIf=\"(hasLine$ | async) || (hasArea$ | async)\"\n      mat-icon-button\n      [matTooltip]=\"'igo.geo.measure.actionbar.delete.tooltip' | translate\"\n      [disabled]=\"(selectedFeatures$ | async).length === 0\"\n      color=\"warn\"\n      (click)=\"onDeleteClick()\"\n    >\n      <mat-icon svgIcon=\"delete\"></mat-icon>\n    </button>\n\n    <!--button\n      mat-icon-button\n      [matTooltip]=\"'igo.geo.measure.actionbar.modify.tooltip' | translate\"\n      [disabled]=\"(selectedFeatures$ | async).length !== 1\"\n      (click)=\"onModifyClick()\">\n      <mat-icon svgIcon=\"edit\"></mat-icon>\n    </button-->\n  </div>\n\n  <igo-entity-table\n    #table\n    class=\"table-compact\"\n    [store]=\"store\"\n    [template]=\"tableTemplate\"\n  >\n  </igo-entity-table>\n</div>\n", styles: [":host .measure-type-toggle{padding:10px;text-align:center}:host .measure-type-toggle mat-button-toggle-group{width:100%}:host .measure-type-toggle mat-button-toggle-group mat-button-toggle{width:50%}:host .measure-options mat-slide-toggle{width:100%;padding:10px}:host .measure-options mat-slide-toggle ::ng-deep .mdc-form-field{width:100%}:host .measure-options mat-slide-toggle ::ng-deep .mdc-label{margin-left:0;width:calc(100% - 60px)}:host .measure-store-buttons{margin-left:-2px}:host .measure-store-buttons button:first-of-type{margin-left:14px}:host .table-compact ::ng-deep .mat-mdc-header-cell.mat-column-selectionCheckbox{width:52px}:host .igo-map-tooltip{position:relative;border-radius:4px;padding:4px 8px;white-space:nowrap}::ng-deep .igo-map-tooltip-hidden,.igo-map-tooltip-measure-by-display{display:none}\n"] }]
        }], ctorParameters: function () { return [{ type: i2.LanguageService }, { type: i1$2.MatDialog }, { type: i2.StorageService }, { type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }]; }, propDecorators: { map: [{
                type: Input
            }], store: [{
                type: Input
            }], activeMeasureType: [{
                type: Input
            }], minSegmentLength: [{
                type: Input
            }], table: [{
                type: ViewChild,
                args: ['table', { static: true }]
            }] } });

/**
 * This input allows a user to draw a new geometry or to edit
 * an existing one on a map. A text input is also displayed in the
 * form with some instructions.
 * This is still WIP.
 */
class GeometryFormFieldInputComponent {
    cdRef;
    ngControl;
    olOverlayLayer;
    olGeoJSON = new OlGeoJSON();
    ready = false;
    drawControl;
    modifyControl;
    defaultDrawStyleRadius;
    olGeometryEnds$$;
    olGeometryChanges$$;
    olTooltip = this.createMeasureTooltip();
    /**
     * Active control
     * @internal
     */
    activeControl;
    /**
     * The map to draw the geometry on
     */
    map;
    /**
     * The geometry type
     */
    set geometryType(value) {
        this._geometryType = value;
        if (this.ready === false) {
            return;
        }
        this.deactivateControl();
        this.createDrawControl();
        this.drawControl.freehand$.next(this.freehandDrawIsActive);
        this.toggleControl();
    }
    get geometryType() {
        return this._geometryType;
    }
    _geometryType;
    /**
     * The drawGuide around the mouse pointer to help drawing
     */
    drawGuide = null;
    /**
     * Whether a measure tooltip should be displayed
     */
    measure = false;
    /**
     * Whether draw control should be active or not
     */
    get drawControlIsActive() {
        return this._drawControlIsActive;
    }
    set drawControlIsActive(value) {
        this._drawControlIsActive = value;
        if (this.ready === false) {
            return;
        }
        this.deactivateControl();
        if (!this._drawControlIsActive) {
            return;
        }
        else {
            this.toggleControl();
        }
    }
    _drawControlIsActive = true;
    /**
     * Whether freehand draw control should be active or not
     */
    get freehandDrawIsActive() {
        return this._freehandDrawIsActive;
    }
    set freehandDrawIsActive(value) {
        this._freehandDrawIsActive = value;
        this.deactivateControl();
        this.createDrawControl();
        this.createModifyControl();
        this.drawControl.freehand$.next(this.freehandDrawIsActive);
        if (this.ready === false) {
            return;
        }
        if (!this.drawControlIsActive) {
            return;
        }
        this.toggleControl();
    }
    _freehandDrawIsActive;
    /**
     * Whether freehand draw control should be active or not
     */
    get predefinedRadius() {
        return this._predefinedRadius;
    }
    set predefinedRadius(value) {
        this._predefinedRadius = value;
        this.drawControl.ispredefinedRadius$.next(value);
    }
    _predefinedRadius;
    /**
     * Control options
     */
    controlOptions = {};
    /**
     * Style for the draw control (applies while the geometry is being drawn)
     */
    set drawStyle(value) {
        if (value === undefined) {
            value = createDrawInteractionStyle();
        }
        this._drawStyle = value;
        const olGuideStyle = this.getGuideStyleFromDrawStyle(value);
        if (olGuideStyle !== undefined) {
            this.defaultDrawStyleRadius = olGuideStyle.getRadius();
        }
        else {
            this.defaultDrawStyleRadius = null;
        }
        if (this.ready === false) {
            return;
        }
        this.deactivateControl();
        this.createDrawControl();
        this.createModifyControl();
        this.drawControl.freehand$.next(this.freehandDrawIsActive);
        this.toggleControl();
    }
    get drawStyle() {
        return this._drawStyle;
    }
    _drawStyle;
    /**
     * Style for the overlay layer (applies once the geometry is added to the map)
     * If not specified, drawStyle applies
     */
    set overlayStyle(value) {
        this._overlayStyle = value;
    }
    get overlayStyle() {
        return this._overlayStyle;
    }
    _overlayStyle;
    /**
     * The geometry value (GeoJSON)
     * Implemented as part of ControlValueAccessor.
     */
    set value(value) {
        this._value = value;
        if (this.ready === false) {
            return;
        }
        if (value) {
            this.addGeoJSONToOverlay(value);
        }
        else {
            this.olOverlaySource.clear(true);
        }
        this.onChange(value);
        this.toggleControl();
        this.cdRef.detectChanges();
    }
    get value() {
        return this._value;
    }
    _value;
    /**
     * The vector source to add the geometry to
     * @internal
     */
    get olOverlaySource() {
        return this.olOverlayLayer.getSource();
    }
    set radius(value) {
        if (this.ready === false) {
            return;
        }
        if (this.modifyControl.getSource()) {
            this.modifyControl.getSource().refresh();
        }
        if (this.freehandDrawIsActive) {
            let olModify;
            setTimeout(() => {
                olModify = this.modifyControl.olModifyInteraction;
                if (olModify) {
                    if (olModify.features_) {
                        olModify.features_.clear();
                        this.addGeoJSONToOverlay(this.value);
                    }
                }
            }, 0);
        }
    }
    constructor(cdRef, ngControl) {
        this.cdRef = cdRef;
        this.ngControl = ngControl;
        if (this.ngControl !== undefined) {
            // Setting the value accessor directly (instead of using
            // the providers) to avoid running into a circular import.
            this.ngControl.valueAccessor = this;
        }
    }
    /**
     * Create an overlay layer, add the initial geometry to it (if any)
     * and toggle the right interaction.
     * @internal
     */
    ngOnInit() {
        if (this.drawStyle === undefined) {
            this.drawStyle = createDrawInteractionStyle();
        }
        if (this.overlayStyle === undefined) {
            this.overlayStyle = this.drawStyle;
        }
        this.addOlOverlayLayer();
        this.createDrawControl();
        this.createModifyControl();
        if (this.value) {
            this.addGeoJSONToOverlay(this.value);
        }
        this.toggleControl();
        this.ready = true;
    }
    /**
     * Clear the overlay layer and any interaction added by this component.
     * @internal
     */
    ngOnDestroy() {
        // This is mandatory when the form control is reused after
        // this component has been destroyed. It seems like the control
        // keeps a reference to this component even after it's destroyed
        // and it attempts to set it's value
        this.ready = false;
        this.deactivateControl();
        this.olOverlaySource.clear();
        this.map.ol.removeLayer(this.olOverlayLayer);
    }
    /**
     * Implemented as part of ControlValueAccessor.
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    onChange = () => { };
    /**
     * Implemented as part of ControlValueAccessor.
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    onTouched = () => { };
    /**
     * Implemented as part of ControlValueAccessor.
     */
    writeValue(value) {
        this.value = value;
    }
    /**
     * Add an overlay layer to the map
     */
    addOlOverlayLayer() {
        this.olOverlayLayer = new OlVectorLayer({
            source: new OlVectorSource(),
            zIndex: 500,
            style: null
        });
        this.map.ol.addLayer(this.olOverlayLayer);
    }
    /**
     * Create a draw control and subscribe to it's geometry
     */
    createDrawControl() {
        const controlOptions = Object.assign({}, this.controlOptions, {
            geometryType: this.geometryType || 'Point',
            drawingLayer: this.olOverlayLayer,
            interactionStyle: typeof this.drawStyle === 'function'
                ? this.drawStyle
                : (olFeature, resolution) => {
                    const style = this.drawStyle;
                    this.updateDrawStyleWithDrawGuide(style, resolution);
                    return style;
                }
        });
        this.drawControl = new DrawControl(controlOptions);
    }
    /**
     * Create a modify control and subscribe to it's geometry
     */
    createModifyControl() {
        const controlOptions = Object.assign({}, this.controlOptions, {
            layer: this.olOverlayLayer,
            drawStyle: typeof this.drawStyle === 'function'
                ? this.drawStyle
                : (olFeature, resolution) => {
                    const style = this.drawStyle;
                    this.updateDrawStyleWithDrawGuide(style, resolution);
                    return style;
                }
        });
        this.modifyControl = new ModifyControl(controlOptions);
    }
    /**
     * Toggle the proper control (draw or modify)
     */
    toggleControl() {
        let activate;
        if (!this.value && this.geometryType) {
            activate = this.drawControl;
        }
        else {
            activate = this.modifyControl;
        }
        // If the control that should be activated
        // is not the same as the current active control,
        // deactivate the current control and activate the new one
        // Otherwise, do nothing and keep the current control active
        if (activate !== this.activeControl) {
            this.deactivateControl();
            this.activateControl(activate);
        }
    }
    /**
     * Activate a given control
     * @param control Control
     */
    activateControl(control) {
        this.activeControl = control;
        this.olGeometryEnds$$ = control.end$.subscribe((olGeometry) => this.onOlGeometryEnds(olGeometry));
        if (this.measure === true && control === this.drawControl) {
            this.olGeometryChanges$$ = control.changes$.subscribe((olGeometry) => this.onOlGeometryChanges(olGeometry));
        }
        control.setOlMap(this.map.ol, false);
    }
    /**
     * Deactivate the active control
     */
    deactivateControl() {
        this.removeMeasureTooltip();
        if (this.activeControl !== undefined) {
            this.activeControl.setOlMap(undefined);
        }
        if (this.olGeometryEnds$$ !== undefined) {
            this.olGeometryEnds$$.unsubscribe();
        }
        if (this.olGeometryChanges$$ !== undefined) {
            this.olGeometryChanges$$.unsubscribe();
        }
        this.activeControl = undefined;
    }
    /**
     * Update measures observables and map tooltips
     * @param olGeometry Ol linestring or polygon
     */
    onOlGeometryEnds(olGeometry) {
        this.removeMeasureTooltip();
        this.setOlGeometry(olGeometry);
    }
    /**
     * Update measures observables and map tooltips
     * @param olGeometry Ol linestring or polygon
     */
    onOlGeometryChanges(olGeometry) {
        if (olGeometry.getType() !== 'Point') {
            this.updateMeasureTooltip(olGeometry);
        }
    }
    /**
     * When drawing ends, convert the output value to GeoJSON and keep it.
     * Restore the double click interaction.
     * @param olGeometry OL geometry
     */
    setOlGeometry(olGeometry) {
        let value;
        if (olGeometry === undefined) {
            return;
        }
        if (olGeometry.getType() === 'Circle') {
            // Because Circle doesn't exist as a GeoJSON object
            olGeometry = this.circleToPoint(olGeometry);
        }
        value = this.olGeoJSON.writeGeometryObject(olGeometry, {
            featureProjection: this.map.projection,
            dataProjection: 'EPSG:4326'
        });
        if (olGeometry.get('radius')) {
            value.radius = olGeometry.get('radius');
            olGeometry.set('radius', value.radius);
        }
        this.writeValue(value);
    }
    circleToPoint(olGeometry) {
        const center = olGeometry.getCenter();
        const coordinates = olproj.transform(center, this.map.projection, 'EPSG:4326');
        const radius = Math.round(olGeometry.getRadius() * Math.cos((Math.PI / 180) * coordinates[1]));
        // Convert it to a point object
        olGeometry = new OlPoint(center);
        olGeometry.set('radius', radius, true);
        return olGeometry;
    }
    /**
     * Add a GeoJSON geometry to the overlay
     * @param geometry GeoJSON geometry
     */
    addGeoJSONToOverlay(geometry) {
        const olGeometry = this.olGeoJSON.readGeometry(geometry, {
            dataProjection: 'EPSG:4326',
            featureProjection: this.map.projection
        });
        const olFeature = new OlFeature({
            geometry: olGeometry
        });
        olFeature.setStyle(this.overlayStyle);
        this.olOverlaySource.clear();
        this.olOverlaySource.addFeature(olFeature);
    }
    /**
     * Create the measure tooltip
     */
    createMeasureTooltip() {
        return new OlOverlay({
            element: document.createElement('div'),
            offset: [-30, -10],
            className: ['igo-map-tooltip', 'igo-map-tooltip-measure'].join(' '),
            stopEvent: false
        });
    }
    /**
     * Update the measure tooltip of an OL geometry
     * @param olGeometry OL Geometry
     */
    updateMeasureTooltip(olGeometry) {
        const measure = measureOlGeometry(olGeometry, this.map.projection);
        const lengths = measure.lengths;
        const lastIndex = olGeometry.getType() === 'Polygon'
            ? lengths.length - 2
            : lengths.length - 1;
        const lastLength = lengths[lastIndex];
        const olMidpoints = updateOlGeometryMidpoints(olGeometry);
        const olLastMidpoint = olMidpoints[lastIndex];
        if (olMidpoints.length === 0 || olLastMidpoint === undefined) {
            this.removeMeasureTooltip();
            return;
        }
        this.olTooltip.setPosition(olLastMidpoint.getFlatCoordinates());
        const innerHtml = formatMeasure(lastLength, {
            decimal: 1,
            unit: MeasureLengthUnit.Meters,
            unitAbbr: true,
            locale: 'fr'
        });
        this.olTooltip.getElement().innerHTML = innerHtml;
        if (this.olTooltip.getMap() === undefined) {
            this.map.ol.addOverlay(this.olTooltip);
        }
    }
    /**
     * Remove the measure tooltip from the map
     */
    removeMeasureTooltip() {
        if (this.olTooltip.getMap && this.olTooltip.getMap() !== undefined) {
            this.map.ol.removeOverlay(this.olTooltip);
            this.olTooltip.setMap(undefined);
        }
    }
    /**
     * Adjust the draw style with the specified draw guide distance, if possible
     * @param olStyle Draw style to update
     * @param resolution Resolution (to make the screen size of symbol fit the drawGuide value)
     */
    updateDrawStyleWithDrawGuide(olStyle, resolution) {
        const olGuideStyle = this.getGuideStyleFromDrawStyle(olStyle);
        if (olGuideStyle === undefined) {
            return;
        }
        const drawGuide = this.drawGuide;
        let radius;
        if (!drawGuide || drawGuide < 0) {
            radius = this.defaultDrawStyleRadius;
        }
        else {
            radius = drawGuide > 0 ? drawGuide / resolution : drawGuide;
        }
        olGuideStyle.setRadius(radius);
    }
    /**
     * Returns wether a given Open Layers style has a radius property that can be set (used to set draw guide)
     * @param olStyle The style on which to perform the check
     */
    getGuideStyleFromDrawStyle(olStyle) {
        let baseStyle;
        if (Array.isArray(olStyle)) {
            baseStyle = olStyle[0];
        }
        else {
            baseStyle = olStyle;
        }
        if (typeof baseStyle.getImage === 'function') {
            baseStyle = baseStyle.getImage();
        }
        let guideStyle;
        if (typeof baseStyle.setRadius === 'function') {
            guideStyle = baseStyle;
        }
        return guideStyle;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GeometryFormFieldInputComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i2$1.NgControl, optional: true, self: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: GeometryFormFieldInputComponent, selector: "igo-geometry-form-field-input", inputs: { map: "map", geometryType: "geometryType", drawGuide: "drawGuide", measure: "measure", drawControlIsActive: "drawControlIsActive", freehandDrawIsActive: "freehandDrawIsActive", predefinedRadius: "predefinedRadius", controlOptions: "controlOptions", drawStyle: "drawStyle", overlayStyle: "overlayStyle", value: "value", radius: "radius" }, ngImport: i0, template: "<ng-template></ng-template>\n", changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GeometryFormFieldInputComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-geometry-form-field-input', changeDetection: ChangeDetectionStrategy.OnPush, template: "<ng-template></ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i2$1.NgControl, decorators: [{
                    type: Optional
                }, {
                    type: Self
                }] }]; }, propDecorators: { map: [{
                type: Input
            }], geometryType: [{
                type: Input
            }], drawGuide: [{
                type: Input
            }], measure: [{
                type: Input
            }], drawControlIsActive: [{
                type: Input
            }], freehandDrawIsActive: [{
                type: Input
            }], predefinedRadius: [{
                type: Input
            }], controlOptions: [{
                type: Input
            }], drawStyle: [{
                type: Input
            }], overlayStyle: [{
                type: Input
            }], value: [{
                type: Input
            }], radius: [{
                type: Input
            }] } });

/**
 * This input allows a user to draw a new geometry or to edit
 * an existing one on a map.
 */
let GeometryFormFieldComponent = class GeometryFormFieldComponent {
    cdRef;
    value$ = new BehaviorSubject(undefined);
    value$$;
    set drawControlIsActive(value) {
        this._drawControlIsActive = value;
        this.cdRef.detectChanges();
    }
    get drawControlIsActive() {
        return this._drawControlIsActive;
    }
    _drawControlIsActive = true;
    set freehandDrawIsActive(value) {
        this._freehandDrawIsActive = value;
        this.cdRef.detectChanges();
    }
    get freehandDrawIsActive() {
        return this._freehandDrawIsActive;
    }
    _freehandDrawIsActive = false;
    /**
     * The field's form control
     */
    formControl;
    /**
     * The map to draw the geometry on
     */
    map;
    set geometryType(value) {
        this.geometryType$.next(value);
    }
    get geometryType() {
        return this.geometryType$.value;
    }
    geometryType$ = new BehaviorSubject(undefined);
    /**
     * Whether a geometry type toggle should be displayed
     */
    geometryTypeField = false;
    /**
     * Available geometry types
     */
    geometryTypes = ['Point', 'LineString', 'Polygon'];
    /**
     * Whether a draw guide field should be displayed
     */
    drawGuideField = false;
    /**
     * The drawGuide around the mouse pointer to help drawing
     */
    set drawGuide(value) {
        this.drawGuide$.next(value);
    }
    get drawGuide() {
        return this.drawGuide$.value;
    }
    drawGuide$ = new BehaviorSubject(0);
    /**
     * Draw guide placeholder
     */
    drawGuidePlaceholder = '';
    /**
     * Whether a measure tooltip should be displayed
     */
    measure = false;
    /**
     * Control options
     */
    controlOptions = {};
    /**
     * Style for the draw control (applies while the geometry is being drawn)
     */
    drawStyle;
    /**
     * Style for the overlay layer (applies once the geometry is added to the map)
     * If not specified, drawStyle applies
     */
    overlayStyle;
    constructor(cdRef) {
        this.cdRef = cdRef;
    }
    /**
     * Set up a value stream
     * @internal
     */
    ngOnInit() {
        this.value$.next(this.formControl.value ? this.formControl.value : undefined);
        this.value$$ = this.formControl.valueChanges.subscribe((value) => {
            this.value$.next(value ? value : undefined);
        });
    }
    /**
     * Unsubscribe to the value stream
     * @internal
     */
    ngOnDestroy() {
        this.value$$.unsubscribe();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GeometryFormFieldComponent, deps: [{ token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: GeometryFormFieldComponent, selector: "igo-geometry-form-field", inputs: { formControl: "formControl", map: "map", geometryType: "geometryType", geometryTypeField: "geometryTypeField", geometryTypes: "geometryTypes", drawGuideField: "drawGuideField", drawGuide: "drawGuide", drawGuidePlaceholder: "drawGuidePlaceholder", measure: "measure", controlOptions: "controlOptions", drawStyle: "drawStyle", overlayStyle: "overlayStyle" }, ngImport: i0, template: "<igo-geometry-form-field-input\n  [formControl]=\"formControl\"\n  [map]=\"map\"\n  [geometryType]=\"geometryType$ | async\"\n  [drawGuide]=\"drawGuide$ | async\"\n  [measure]=\"measure\"\n  [drawControlIsActive]=\"drawControlIsActive\"\n  [freehandDrawIsActive]=\"freehandDrawIsActive\"\n  [controlOptions]=\"controlOptions\"\n  [drawStyle]=\"drawStyle\"\n  [overlayStyle]=\"overlayStyle\"\n>\n</igo-geometry-form-field-input>\n\n<div *ngIf=\"geometryTypeField\" class=\"geometry-type-toggle\">\n  <mat-button-toggle-group\n    [disabled]=\"(value$ | async) !== undefined\"\n    [(ngModel)]=\"geometryType\"\n  >\n    <mat-button-toggle\n      value=\"Point\"\n      [disabled]=\"geometryTypes.indexOf('Point') < 0\"\n    >\n      {{ 'igo.geo.geometry.point' | translate }}\n    </mat-button-toggle>\n    <mat-button-toggle\n      value=\"LineString\"\n      [disabled]=\"geometryTypes.indexOf('LineString') < 0\"\n    >\n      {{ 'igo.geo.geometry.line' | translate }}\n    </mat-button-toggle>\n    <mat-button-toggle\n      value=\"Polygon\"\n      [disabled]=\"geometryTypes.indexOf('Polygon') < 0\"\n    >\n      {{ 'igo.geo.geometry.polygon' | translate }}\n    </mat-button-toggle>\n  </mat-button-toggle-group>\n</div>\n\n<mat-form-field *ngIf=\"drawGuideField\" class=\"draw-guide-field\">\n  <input\n    matInput\n    type=\"number\"\n    [placeholder]=\"drawGuidePlaceholder\"\n    [(ngModel)]=\"drawGuide\"\n  />\n  <mat-icon matPrefix [color]=\"'primary'\" svgIcon=\"adjust\"> </mat-icon>\n  <span matSuffix class=\"draw-guide-units\">{{\n    'igo.geo.measure.meters' | translate\n  }}</span>\n</mat-form-field>\n", styles: [":host{display:block;width:100%}.geometry-type-toggle,.draw-guide-field{width:100%}.geometry-type-toggle{padding:10px;text-align:center}.draw-guide-field mat-icon{margin:0 10px}.draw-guide-units{padding:10px}\n"], dependencies: [{ kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i2$1.NumberValueAccessor, selector: "input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]" }, { kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "directive", type: i2$1.FormControlDirective, selector: "[formControl]", inputs: ["formControl", "disabled", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i8.MatFormField, selector: "mat-form-field", inputs: ["hideRequiredMarker", "color", "floatLabel", "appearance", "subscriptSizing", "hintLabel"], exportAs: ["matFormField"] }, { kind: "directive", type: i8.MatPrefix, selector: "[matPrefix], [matIconPrefix], [matTextPrefix]", inputs: ["matTextPrefix"] }, { kind: "directive", type: i8.MatSuffix, selector: "[matSuffix], [matIconSuffix], [matTextSuffix]", inputs: ["matTextSuffix"] }, { kind: "directive", type: i9$3.MatInput, selector: "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", inputs: ["disabled", "id", "placeholder", "name", "required", "type", "errorStateMatcher", "aria-describedby", "value", "readonly"], exportAs: ["matInput"] }, { kind: "directive", type: i5$1.MatButtonToggleGroup, selector: "mat-button-toggle-group", inputs: ["appearance", "name", "vertical", "value", "multiple", "disabled"], outputs: ["valueChange", "change"], exportAs: ["matButtonToggleGroup"] }, { kind: "component", type: i5$1.MatButtonToggle, selector: "mat-button-toggle", inputs: ["disableRipple", "aria-label", "aria-labelledby", "id", "name", "value", "tabIndex", "appearance", "checked", "disabled"], outputs: ["change"], exportAs: ["matButtonToggle"] }, { kind: "component", type: GeometryFormFieldInputComponent, selector: "igo-geometry-form-field-input", inputs: ["map", "geometryType", "drawGuide", "measure", "drawControlIsActive", "freehandDrawIsActive", "predefinedRadius", "controlOptions", "drawStyle", "overlayStyle", "value", "radius"] }, { kind: "pipe", type: i2$2.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
};
GeometryFormFieldComponent = __decorate([
    IgoFormFieldComponent('geometry'),
    __metadata("design:paramtypes", [ChangeDetectorRef])
], GeometryFormFieldComponent);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GeometryFormFieldComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-geometry-form-field', changeDetection: ChangeDetectionStrategy.OnPush, template: "<igo-geometry-form-field-input\n  [formControl]=\"formControl\"\n  [map]=\"map\"\n  [geometryType]=\"geometryType$ | async\"\n  [drawGuide]=\"drawGuide$ | async\"\n  [measure]=\"measure\"\n  [drawControlIsActive]=\"drawControlIsActive\"\n  [freehandDrawIsActive]=\"freehandDrawIsActive\"\n  [controlOptions]=\"controlOptions\"\n  [drawStyle]=\"drawStyle\"\n  [overlayStyle]=\"overlayStyle\"\n>\n</igo-geometry-form-field-input>\n\n<div *ngIf=\"geometryTypeField\" class=\"geometry-type-toggle\">\n  <mat-button-toggle-group\n    [disabled]=\"(value$ | async) !== undefined\"\n    [(ngModel)]=\"geometryType\"\n  >\n    <mat-button-toggle\n      value=\"Point\"\n      [disabled]=\"geometryTypes.indexOf('Point') < 0\"\n    >\n      {{ 'igo.geo.geometry.point' | translate }}\n    </mat-button-toggle>\n    <mat-button-toggle\n      value=\"LineString\"\n      [disabled]=\"geometryTypes.indexOf('LineString') < 0\"\n    >\n      {{ 'igo.geo.geometry.line' | translate }}\n    </mat-button-toggle>\n    <mat-button-toggle\n      value=\"Polygon\"\n      [disabled]=\"geometryTypes.indexOf('Polygon') < 0\"\n    >\n      {{ 'igo.geo.geometry.polygon' | translate }}\n    </mat-button-toggle>\n  </mat-button-toggle-group>\n</div>\n\n<mat-form-field *ngIf=\"drawGuideField\" class=\"draw-guide-field\">\n  <input\n    matInput\n    type=\"number\"\n    [placeholder]=\"drawGuidePlaceholder\"\n    [(ngModel)]=\"drawGuide\"\n  />\n  <mat-icon matPrefix [color]=\"'primary'\" svgIcon=\"adjust\"> </mat-icon>\n  <span matSuffix class=\"draw-guide-units\">{{\n    'igo.geo.measure.meters' | translate\n  }}</span>\n</mat-form-field>\n", styles: [":host{display:block;width:100%}.geometry-type-toggle,.draw-guide-field{width:100%}.geometry-type-toggle{padding:10px;text-align:center}.draw-guide-field mat-icon{margin:0 10px}.draw-guide-units{padding:10px}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }]; }, propDecorators: { formControl: [{
                type: Input
            }], map: [{
                type: Input
            }], geometryType: [{
                type: Input
            }], geometryTypeField: [{
                type: Input
            }], geometryTypes: [{
                type: Input
            }], drawGuideField: [{
                type: Input
            }], drawGuide: [{
                type: Input
            }], drawGuidePlaceholder: [{
                type: Input
            }], measure: [{
                type: Input
            }], controlOptions: [{
                type: Input
            }], drawStyle: [{
                type: Input
            }], overlayStyle: [{
                type: Input
            }] } });

/**
 * @ignore
 */
class IgoGeometryFormFieldModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoGeometryFormFieldModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoGeometryFormFieldModule, declarations: [GeometryFormFieldComponent, GeometryFormFieldInputComponent], imports: [CommonModule,
            FormsModule,
            ReactiveFormsModule,
            MatIconModule,
            MatFormFieldModule,
            MatInputModule,
            MatButtonModule,
            MatButtonToggleModule,
            IgoLanguageModule], exports: [GeometryFormFieldComponent, GeometryFormFieldInputComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoGeometryFormFieldModule, imports: [CommonModule,
            FormsModule,
            ReactiveFormsModule,
            MatIconModule,
            MatFormFieldModule,
            MatInputModule,
            MatButtonModule,
            MatButtonToggleModule,
            IgoLanguageModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoGeometryFormFieldModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        FormsModule,
                        ReactiveFormsModule,
                        MatIconModule,
                        MatFormFieldModule,
                        MatInputModule,
                        MatButtonModule,
                        MatButtonToggleModule,
                        IgoLanguageModule
                    ],
                    exports: [GeometryFormFieldComponent, GeometryFormFieldInputComponent],
                    declarations: [GeometryFormFieldComponent, GeometryFormFieldInputComponent]
                }]
        }] });

class IgoGeometryModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoGeometryModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoGeometryModule, imports: [CommonModule, IgoGeometryFormFieldModule], exports: [IgoGeometryFormFieldModule] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoGeometryModule, imports: [CommonModule, IgoGeometryFormFieldModule, IgoGeometryFormFieldModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoGeometryModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, IgoGeometryFormFieldModule],
                    exports: [IgoGeometryFormFieldModule],
                    declarations: [],
                    providers: []
                }]
        }] });

class WktService {
    constructor() { }
    wktToFeature(wkt, wktProj, featureProj) {
        return new olWKT().readFeature(wkt, {
            dataProjection: wktProj,
            featureProjection: featureProj
        });
    }
    extentToWkt(epsgTO, extent, extentProj) {
        let currentExtent = olproj.transformExtent(extent, extentProj, epsgTO);
        currentExtent = this.roundCoordinateArray(currentExtent, epsgTO, 0);
        const wktPoly = `POLYGON((
      ${extent[0]} ${extent[1]},
      ${extent[0]} ${extent[3]},
      ${extent[2]} ${extent[3]},
      ${extent[2]} ${extent[1]},
      ${extent[0]} ${extent[1]}))`;
        const wktLine = `LINESTRING(
      ${extent[0]} ${extent[1]},
      ${extent[0]} ${extent[3]},
      ${extent[2]} ${extent[3]},
      ${extent[2]} ${extent[1]},
      ${extent[0]} ${extent[1]})`;
        const wktMultiPoints = `MULTIPOINT(
        ${extent[0]} ${extent[1]},
        ${extent[0]} ${extent[3]},
        ${extent[2]} ${extent[3]},
        ${extent[2]} ${extent[1]})`;
        return {
            wktPoly,
            wktLine,
            wktMultiPoints
        };
    }
    roundCoordinateArray(coordinateArray, projection, decimal = 0) {
        const lproj = olproj.get(projection);
        const units = lproj.getUnits();
        const olUnits = ['ft', 'm', 'us-ft'];
        if (olUnits.indexOf(units) !== -1) {
            coordinateArray = this.roundArray(coordinateArray, decimal);
        }
        return coordinateArray;
    }
    roundArray(array, decimal = 0) {
        let x = 0;
        while (x < array.length) {
            array[x] = array[x].toFixed(decimal);
            x++;
        }
        return array;
    }
    snrcToWkt(snrc, epsgTO) {
        snrc = snrc.toLowerCase();
        let wktPoly;
        const ew = {
            1: { from: -56, to: -64 },
            2: { from: -64, to: -72 },
            3: { from: -72, to: -80 },
            4: { from: -80, to: -88 },
            5: { from: -88, to: -96 },
            6: { from: -96, to: -104 },
            7: { from: -104, to: -112 },
            8: { from: -112, to: -120 },
            9: { from: -120, to: -128 },
            10: { from: -128, to: -136 }
        };
        const sn = {
            1: { from: 44, to: 48 },
            2: { from: 48, to: 52 },
            3: { from: 52, to: 56 },
            4: { from: 56, to: 60 },
            5: { from: 60, to: 64 },
            6: { from: 64, to: 68 },
            7: { from: 68, to: 72 },
            8: { from: 72, to: 76 },
            9: { from: 76, to: -128 }
        };
        const snrc250kIndex = [
            ['m', 'n', 'o', 'p'],
            ['l', 'k', 'j', 'i'],
            ['e', 'f', 'g', 'h'],
            ['d', 'c', 'b', 'a']
        ];
        const snrc50kIndex = [
            ['13', '14', '15', '16'],
            ['12', '11', '10', '09'],
            ['05', '06', '07', '08'],
            ['04', '03', '02', '01']
        ];
        const checkSNRC50k = /\d{2,3}[a-p][0,1][0-9]/gi;
        const checkSNRC250k = /\d{2,3}[a-p]/gi;
        const checkSNRC1m = /\d{2,3}/gi;
        let snrc1m = false;
        let snrc250k = false;
        let snrc50k = false;
        if (checkSNRC50k.test(snrc)) {
            snrc50k = true;
        }
        else {
            if (checkSNRC250k.test(snrc)) {
                snrc250k = true;
            }
            else {
                if (checkSNRC1m.test(snrc)) {
                    snrc1m = true;
                }
            }
        }
        if (snrc1m) {
            snrc += 'a01';
        }
        else if (snrc250k) {
            snrc += '01';
        }
        if (/\d{2,3}[a-p][0,1][0-9]/gi.test(snrc)) {
            const regex1m = /(?=[a-p])/gi;
            const ar1m = snrc.split(regex1m);
            const part1m = ar1m[0];
            const part250k = ar1m[1][0];
            const part50k = ar1m[1].split(part250k)[1];
            let separator = 1;
            if (part1m.length === 3) {
                separator = 2;
            }
            const partEW = part1m.substring(0, separator);
            const partSN = part1m.substring(separator);
            const unit1mEW = 8;
            const unit1mSN = 4;
            const unit250kEW = 2;
            const unit250kSN = 1;
            const unit50kEW = 0.5;
            const unit50kSN = 0.25;
            let index250kEW = 0;
            let index250kSN = 0;
            let index50kEW = 0;
            let index50kSN = 0;
            snrc250kIndex.forEach((element) => {
                if (element.indexOf(part250k) !== -1) {
                    index250kSN = snrc250kIndex.indexOf(element);
                    index250kEW = element.indexOf(part250k);
                }
            });
            snrc50kIndex.forEach((element) => {
                if (element.indexOf(part50k) !== -1) {
                    index50kSN = snrc50kIndex.indexOf(element);
                    index50kEW = element.indexOf(part50k);
                }
            });
            let increment250kEW = 0;
            let increment250kSN = 0;
            let increment50kEW = 0;
            let increment50kSN = 0;
            let unitPerTypeEW = unit1mEW;
            let unitPerTypeSN = unit1mSN;
            if (snrc250k) {
                increment250kEW = index250kEW * unit250kEW;
                increment250kSN = index250kSN * unit250kSN;
                increment50kEW = 0;
                increment50kSN = 0;
                unitPerTypeEW = unit250kEW;
                unitPerTypeSN = unit250kSN;
            }
            else if (snrc50k) {
                increment250kEW = index250kEW * unit250kEW;
                increment250kSN = index250kSN * unit250kSN;
                increment50kEW = index50kEW * unit50kEW;
                increment50kSN = index50kSN * unit50kSN;
                unitPerTypeEW = unit50kEW;
                unitPerTypeSN = unit50kSN;
            }
            const coord = {
                ul: [
                    ew[partEW].to + increment250kEW + increment50kEW,
                    sn[partSN].to - increment250kSN - increment50kSN
                ]
            };
            coord.lr = [coord.ul[0] + unitPerTypeEW, coord.ul[1] - unitPerTypeSN];
            coord.ur = [coord.ul[0], coord.ul[1] - unitPerTypeSN];
            coord.ll = [coord.ul[0] + unitPerTypeEW, coord.ul[1]];
            coord.ul = olproj.transform([coord.ul[0], coord.ul[1]], 'EPSG:4326', epsgTO);
            coord.lr = olproj.transform([coord.lr[0], coord.lr[1]], 'EPSG:4326', epsgTO);
            coord.ur = olproj.transform([coord.ur[0], coord.ur[1]], 'EPSG:4326', epsgTO);
            coord.ll = olproj.transform([coord.ll[0], coord.ll[1]], 'EPSG:4326', epsgTO);
            // Rounded coordinate to shorten url in get
            coord.ul = this.roundCoordinateArray(coord.ul, epsgTO, 0);
            coord.lr = this.roundCoordinateArray(coord.lr, epsgTO, 0);
            coord.ur = this.roundCoordinateArray(coord.ur, epsgTO, 0);
            coord.ll = this.roundCoordinateArray(coord.ll, epsgTO, 0);
            wktPoly =
                'POLYGON((' +
                    [
                        coord.ul.join(' '),
                        coord.ur.join(' '),
                        coord.lr.join(' '),
                        coord.ll.join(' '),
                        coord.ul.join(' ')
                    ].join(',') +
                    '))';
            const wktLine = 'LINESTRING(' +
                [
                    coord.ul.join(' '),
                    coord.ur.join(' '),
                    coord.lr.join(' '),
                    coord.ll.join(' '),
                    coord.ul.join(' ')
                ].join(',') +
                ')';
            const wktMultiPoints = 'MULTIPOINT(' +
                [
                    coord.ul.join(' '),
                    coord.ur.join(' '),
                    coord.lr.join(' '),
                    coord.ll.join(' ')
                ].join(',') +
                ')';
            return {
                wktPoly,
                wktLine,
                wktMultiPoints
            };
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: WktService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: WktService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: WktService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return []; } });

class OGCFilterTimeService {
    defaultStepMillisecond = 60000;
    constructor() { }
    step(datasource, currentFilter) {
        return datasource.options.stepDate
            ? datasource.options.stepDate
            : currentFilter.step;
    }
    stepMillisecond(dataSource, currentFilter) {
        const step = moment
            .duration(this.step(dataSource, currentFilter))
            .asMilliseconds();
        return step === 0 ? this.defaultStepMillisecond : step;
    }
    stepIsYearDuration(step) {
        const year = moment.duration(step);
        return (year.years() !== 0 &&
            year.months() === 0 &&
            year.weeks() === 0 &&
            year.days() === 0 &&
            year.hours() === 0 &&
            year.minutes() === 0);
    }
    stepIsMonthDuration(step) {
        const month = moment.duration(step);
        return (month.months() !== 0 &&
            month.weeks() === 0 &&
            month.days() === 0 &&
            month.hours() === 0 &&
            month.minutes() === 0);
    }
    stepIsWeekDuration(step) {
        const week = moment.duration(step);
        return (week.weeks() !== 0 &&
            week.days() === 7 &&
            week.hours() === 0 &&
            week.minutes() === 0);
    }
    stepIsDayDuration(step) {
        const day = moment.duration(step);
        return day.days() !== 0 && day.hours() === 0 && day.minutes() === 0;
    }
    stepIsHourDuration(step) {
        const hour = moment.duration(step);
        return hour.hours() !== 0 && hour.minutes() === 0;
    }
    stepIsMinuteDuration(step) {
        const minute = moment.duration(step);
        return minute.minutes() !== 0;
    }
    dateToNumber(date) {
        let newDate = new Date();
        if (date) {
            newDate = new Date(date);
        }
        return newDate.getTime();
    }
    addStep(value, stepMillisecond) {
        return moment(value).add(stepMillisecond, 'milliseconds').toDate();
    }
    subtractStep(value, stepMillisecond) {
        return moment(value).subtract(stepMillisecond, 'milliseconds').toDate();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OGCFilterTimeService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OGCFilterTimeService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OGCFilterTimeService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return []; } });

class OgcFilterTimeSliderComponent {
    ogcFilterTimeService;
    currentFilter;
    begin;
    max;
    datasource;
    changeProperty = new EventEmitter();
    slider;
    interval;
    sliderValue = 1;
    calculatedStep = 0;
    _defaultDisplayFormat = 'DD/MM/YYYY HH:mm A';
    _defaultSliderInterval = 2000;
    playIcon = 'play-circle';
    resetIcon = 'replay';
    get sliderInterval() {
        return this.currentFilter.sliderInterval === undefined
            ? this._defaultSliderInterval
            : this.currentFilter.sliderInterval;
    }
    get displayFormat() {
        if (this.currentFilter.sliderOptions?.displayFormat) {
            return this.currentFilter.sliderOptions.displayFormat;
        }
        if (this.currentFilter.displayFormat) {
            return this.currentFilter.displayFormat;
        }
        return this._defaultDisplayFormat;
    }
    get beginMillisecond() {
        return this.ogcFilterTimeService.dateToNumber(this.begin);
    }
    get maxMillisecond() {
        return this.ogcFilterTimeService.dateToNumber(this.max);
    }
    get stepMillisecond() {
        return this.ogcFilterTimeService.stepMillisecond(this.datasource, this.currentFilter);
    }
    constructor(ogcFilterTimeService) {
        this.ogcFilterTimeService = ogcFilterTimeService;
        this.sliderDisplayWith = this.sliderDisplayWith.bind(this);
    }
    ngOnInit() {
        this.calculateStep();
        this.handleSliderInput({ value: 1 });
    }
    sliderDisplayWith(value) {
        let dateTmp = new Date(this.beginMillisecond + (value - 1) * this.stepMillisecond);
        if (this.ogcFilterTimeService.stepIsYearDuration(this.ogcFilterTimeService.step(this.datasource, this.currentFilter))) {
            const toAdd = moment
                .duration(this.ogcFilterTimeService.step(this.datasource, this.currentFilter))
                .years();
            dateTmp = moment(this.beginMillisecond)
                .add((value - 1) * toAdd, 'year')
                .toDate();
        }
        else if (this.ogcFilterTimeService.stepIsMonthDuration(this.ogcFilterTimeService.step(this.datasource, this.currentFilter))) {
            const toAdd = moment
                .duration(this.ogcFilterTimeService.step(this.datasource, this.currentFilter))
                .months();
            dateTmp = moment(this.beginMillisecond)
                .add((value - 1) * toAdd, 'month')
                .toDate();
        }
        return moment(dateTmp).format(this.displayFormat);
    }
    playFilter(event) {
        if (this.interval) {
            this.stopFilter();
        }
        else {
            this.playIcon = 'pause-circle';
            this.interval = setInterval((that) => {
                if (this.slider.step < this.calculatedStep) {
                    const _increment = '_increment';
                    const _emitInputEvent = '_emitInputEvent';
                    this.slider[_increment](1);
                    this.slider[_emitInputEvent]();
                }
                else {
                    this.stopFilter();
                }
            }, this.sliderInterval, this);
        }
    }
    stopFilter() {
        if (this.interval) {
            clearInterval(this.interval);
        }
        this.interval = undefined;
        this.playIcon = 'play-circle';
    }
    resetFilter(event) {
        if (this.interval) {
            clearInterval(this.interval);
        }
        this.interval = undefined;
        this.playIcon = 'play-circle';
        this.slider.step = 1;
        const _increment = '_increment';
        const _emitInputEvent = '_emitInputEvent';
        this.slider[_emitInputEvent]();
    }
    handleSliderInput(matSliderChange) {
        if (matSliderChange) {
            if (this.ogcFilterTimeService.stepIsYearDuration(this.ogcFilterTimeService.step(this.datasource, this.currentFilter))) {
                const toAdd = moment
                    .duration(this.ogcFilterTimeService.step(this.datasource, this.currentFilter))
                    .years();
                const dateBeginTmp = moment(this.beginMillisecond)
                    .add((matSliderChange.value - 1) * toAdd, 'year')
                    .toDate();
                const dateEndTmp = moment(dateBeginTmp).add(toAdd, 'year').toDate();
                this.changeProperty.next({
                    value: moment(dateBeginTmp).toDate().toISOString(),
                    pos: 1,
                    refreshFilter: false
                });
                this.changeProperty.next({
                    value: moment(dateEndTmp).toDate().toISOString(),
                    pos: 2,
                    refreshFilter: true
                });
            }
            else if (this.ogcFilterTimeService.stepIsMonthDuration(this.ogcFilterTimeService.step(this.datasource, this.currentFilter))) {
                const toAdd = moment
                    .duration(this.ogcFilterTimeService.step(this.datasource, this.currentFilter))
                    .months();
                const dateBeginTmp = moment(this.beginMillisecond)
                    .add((matSliderChange.value - 1) * toAdd, 'month')
                    .toDate();
                const dateEndTmp = moment(dateBeginTmp).add(toAdd, 'month').toDate();
                this.changeProperty.next({
                    value: moment(dateBeginTmp).startOf('month').toDate().toISOString(),
                    pos: 1,
                    refreshFilter: false
                });
                this.changeProperty.next({
                    value: moment(dateEndTmp).toDate().toISOString(),
                    pos: 2,
                    refreshFilter: true
                });
            }
            else if (this.ogcFilterTimeService.stepIsDayDuration(this.ogcFilterTimeService.step(this.datasource, this.currentFilter)) ||
                this.ogcFilterTimeService.stepIsHourDuration(this.ogcFilterTimeService.step(this.datasource, this.currentFilter)) ||
                this.ogcFilterTimeService.stepIsMinuteDuration(this.ogcFilterTimeService.step(this.datasource, this.currentFilter))) {
                const dateTmp = new Date(this.beginMillisecond +
                    this.stepMillisecond * (matSliderChange.value - 1));
                this.changeProperty.next({
                    value: dateTmp.toISOString(),
                    pos: 1,
                    refreshFilter: false
                });
                this.changeProperty.next({
                    value: new Date(this.ogcFilterTimeService.addStep(dateTmp.toISOString(), this.stepMillisecond)).toISOString(),
                    pos: 2,
                    refreshFilter: true
                });
            }
        }
    }
    calculateStep() {
        for (let i = 1; this.maxMillisecond -
            (this.beginMillisecond + i * this.stepMillisecond) >=
            -1; i++) {
            this.calculatedStep = i;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OgcFilterTimeSliderComponent, deps: [{ token: OGCFilterTimeService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: OgcFilterTimeSliderComponent, selector: "igo-ogc-filter-time-slider", inputs: { currentFilter: "currentFilter", begin: "begin", max: "max", datasource: "datasource" }, outputs: { changeProperty: "changeProperty" }, viewQueries: [{ propertyName: "slider", first: true, predicate: MatSlider, descendants: true }], ngImport: i0, template: "<div class=\"slider-container\">\n  <mat-slider\n    id=\"time-slider\"\n    [step]=\"1\"\n    [min]=\"1\"\n    [max]=\"calculatedStep\"\n    [(ngModel)]=\"sliderValue\"\n    [displayWith]=\"sliderDisplayWith\"\n    thumbLabel\n    #ngSlider\n    ><input\n      matSliderThumb\n      (input)=\"\n        handleSliderInput({\n          source: ngSliderThumb,\n          parent: ngSlider,\n          value: ngSliderThumb.value\n        })\n      \"\n      #ngSliderThumb=\"matSliderThumb\"\n    />\n  </mat-slider>\n  <button mat-icon-button color=\"primary\" (click)=\"playFilter($event)\">\n    <mat-icon [svgIcon]=\"playIcon\"></mat-icon>\n  </button>\n  <button mat-icon-button color=\"primary\" (click)=\"resetFilter($event)\">\n    <mat-icon svgIcon=\"{{ resetIcon }}\"></mat-icon>\n  </button>\n</div>\n", styles: [":host ::ng-deep input{text-align:center!important;margin:auto 5px!important}:host .datetime-container{text-align:center}:host .slider-container{text-align:center}:host .datetime-input{display:inline-block;margin:5px 25px}:host .date-input{width:120px;margin-right:25px}:host .time-input{display:inherit;margin-right:25px}:host .hour-input,:host .minute-input{width:40px}:host .minute-input{margin-left:10px}\n"], dependencies: [{ kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "component", type: i8$1.MatSlider, selector: "mat-slider", inputs: ["color", "disableRipple", "disabled", "discrete", "showTickMarks", "min", "max", "step", "displayWith"], exportAs: ["matSlider"] }, { kind: "directive", type: i8$1.MatSliderThumb, selector: "input[matSliderThumb]", inputs: ["value"], outputs: ["valueChange", "dragStart", "dragEnd"], exportAs: ["matSliderThumb"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OgcFilterTimeSliderComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-ogc-filter-time-slider', template: "<div class=\"slider-container\">\n  <mat-slider\n    id=\"time-slider\"\n    [step]=\"1\"\n    [min]=\"1\"\n    [max]=\"calculatedStep\"\n    [(ngModel)]=\"sliderValue\"\n    [displayWith]=\"sliderDisplayWith\"\n    thumbLabel\n    #ngSlider\n    ><input\n      matSliderThumb\n      (input)=\"\n        handleSliderInput({\n          source: ngSliderThumb,\n          parent: ngSlider,\n          value: ngSliderThumb.value\n        })\n      \"\n      #ngSliderThumb=\"matSliderThumb\"\n    />\n  </mat-slider>\n  <button mat-icon-button color=\"primary\" (click)=\"playFilter($event)\">\n    <mat-icon [svgIcon]=\"playIcon\"></mat-icon>\n  </button>\n  <button mat-icon-button color=\"primary\" (click)=\"resetFilter($event)\">\n    <mat-icon svgIcon=\"{{ resetIcon }}\"></mat-icon>\n  </button>\n</div>\n", styles: [":host ::ng-deep input{text-align:center!important;margin:auto 5px!important}:host .datetime-container{text-align:center}:host .slider-container{text-align:center}:host .datetime-input{display:inline-block;margin:5px 25px}:host .date-input{width:120px;margin-right:25px}:host .time-input{display:inherit;margin-right:25px}:host .hour-input,:host .minute-input{width:40px}:host .minute-input{margin-left:10px}\n"] }]
        }], ctorParameters: function () { return [{ type: OGCFilterTimeService }]; }, propDecorators: { currentFilter: [{
                type: Input
            }], begin: [{
                type: Input
            }], max: [{
                type: Input
            }], datasource: [{
                type: Input
            }], changeProperty: [{
                type: Output
            }], slider: [{
                type: ViewChild,
                args: [MatSlider]
            }] } });

class OgcFilterTimeComponent {
    ogcFilterTimeService;
    datasource;
    currentFilter;
    changeProperty = new EventEmitter();
    beginHours;
    endHours;
    beginMinutes;
    endMinutes;
    beginHourFormControl = new UntypedFormControl();
    beginMinuteFormControl = new UntypedFormControl();
    endHourFormControl = new UntypedFormControl();
    endMinuteFormControl = new UntypedFormControl();
    _beginValue;
    _endValue;
    _defaultMin = '1900-01-01';
    _defaultMax = '2052-01-06';
    _defaultDisplayFormat = 'DD/MM/YYYY HH:mm A';
    _defaultSliderModeEnabled = true;
    ogcFilterOperator = OgcFilterOperator;
    sliderMode = false;
    defaultStepMillisecond = 60000;
    options;
    onlyYearBegin;
    onlyYearEnd;
    calendarTypeYear = false;
    resetIcon = 'replay';
    filterStateDisable;
    endDatepickerTime;
    beginDatepickerTime;
    beginTime;
    endTime;
    get step() {
        return this.datasource.options.stepDate
            ? this.datasource.options.stepDate
            : this.currentFilter.step;
    }
    get stepMilliseconds() {
        const step = moment.duration(this.step).asMilliseconds();
        return step === 0 ? this.defaultStepMillisecond : step;
    }
    set beginValue(begin) {
        this._beginValue = begin;
    }
    get beginValue() {
        return this._beginValue;
    }
    set endValue(end) {
        this._endValue = end;
    }
    get endValue() {
        return this._endValue;
    }
    get sliderInterval() {
        return this.currentFilter.sliderInterval === undefined
            ? 2000
            : this.currentFilter.sliderInterval;
    }
    get maxDate() {
        return this.datasource.options.maxDate
            ? this.datasource.options.maxDate
            : this._defaultMax;
    }
    get displayFormat() {
        return this.currentFilter.displayFormat
            ? this.currentFilter.displayFormat
            : this._defaultDisplayFormat;
    }
    filterBeginFunction;
    filterEndFunction;
    constructor(ogcFilterTimeService) {
        this.ogcFilterTimeService = ogcFilterTimeService;
    }
    ngOnInit() {
        if (this.currentFilter.sliderOptions) {
            this.currentFilter.sliderOptions.enabled =
                this.currentFilter.sliderOptions.enabled !== undefined
                    ? this.currentFilter.sliderOptions.enabled
                    : this._defaultSliderModeEnabled;
        }
        this.beginValue = this.parseFilter(this.handleMin());
        this.endValue = this.parseFilter(this.handleMax());
        this.onlyYearBegin = this.beginValue.getUTCFullYear();
        this.onlyYearEnd = this.endValue.getUTCFullYear();
        this.calendarTypeYear = this.isCalendarYearMode();
        this.setFilterStateDisable();
        this.updateHoursMinutesArray();
        // update value for now value
        this.updateValues();
        this.dateFilter(this.filterBeginFunction, 'begin');
        this.dateFilter(this.filterEndFunction, 'end');
    }
    parseFilter(filter) {
        if (!filter) {
            return new Date();
        }
        else if (isNaN(new Date(filter).getTime())) {
            if (filter.search('now') >= 0) {
                const interval = filter.match(/years|months|weeks|days|hours|seconds/);
                if (filter.match(/\+/)) {
                    const intervalInt = parseInt(filter.substring(filter.search('+') + 1, interval.index), 10);
                    return moment().add(intervalInt, interval[0]).toDate();
                }
                if (filter.match(/\-/)) {
                    const intervalInt = parseInt(filter.substring(filter.search('-') + 1, interval.index), 10);
                    return moment().subtract(intervalInt, interval[0]).toDate();
                }
                return new Date();
            }
            if (filter.search('today') >= 0) {
                const _now = moment().endOf('day').toDate();
                const interval = filter.match(/years|months|weeks|days|hours|seconds/);
                if (filter.match(/\+/)) {
                    const intervalInt = parseInt(filter.substring(filter.search('+') + 1, interval.index), 10);
                    return moment(_now).add(intervalInt, interval[0]).toDate();
                }
                if (filter.match(/\-/)) {
                    const intervalInt = parseInt(filter.substring(filter.search('-') + 1, interval.index), 10);
                    return moment(_now).subtract(intervalInt, interval[0]).toDate();
                }
                return _now;
            }
            return new Date();
        }
        if (this.currentFilter.calendarModeYear) {
            const date = this.getDateFromStringWithoutTime(filter);
            return date;
        }
        else {
            return filter ? new Date(filter) : new Date();
        }
    }
    changeTemporalProperty(value, position, refreshFilter = true) {
        if (!this.isValidDate(value)) {
            return;
        }
        let valueTmp = this.getDateTime(value, position);
        if (this.isCalendarYearMode()) {
            let dateStringFromYearNotime;
            if (position === 1) {
                this.beginValue = value;
                this.onlyYearBegin = this.beginValue.getFullYear();
                dateStringFromYearNotime = `${this.onlyYearBegin}-01-01`;
            }
            else {
                this.endValue = value;
                this.onlyYearEnd = this.endValue.getFullYear();
                dateStringFromYearNotime = `${this.onlyYearEnd}-01-01`;
            }
            // call service with string date without time
            this.changeProperty.next({
                value: dateStringFromYearNotime,
                pos: position,
                refreshFilter
            });
            return;
        }
        if (position === 2 && this.calendarType() === 'date' && !this.sliderMode) {
            /* Above month: see yearSelected or monthSelected */
            valueTmp = moment(valueTmp).endOf('day').toDate();
        }
        if (position === 1) {
            this.beginValue = valueTmp;
            if (this.restrictedToStep()) {
                this.changeTemporalProperty(this.ogcFilterTimeService.addStep(valueTmp, this.stepMilliseconds), 2, refreshFilter);
            }
        }
        else {
            this.endValue = valueTmp;
        }
        this.updateHoursMinutesArray();
        this.changeProperty.next({
            value: valueTmp.toISOString(),
            pos: position,
            refreshFilter
        });
    }
    handleDate(value) {
        if (!value || value === '') {
            return undefined;
        }
        if (typeof value === 'string' && this.currentFilter.calendarModeYear) {
            return this.getDateFromStringWithoutTime(value);
        }
        return new Date(value);
    }
    calendarType() {
        if (this.currentFilter.calendarModeYear) {
            return 'year';
        }
        if (this.stepMilliseconds < 86400000) {
            return 'datetime';
        }
        return 'date';
    }
    isCalendarYearMode() {
        if (this.calendarType() === 'year') {
            return true;
        }
        else {
            return false;
        }
    }
    yearOnlyInputChange(changeEvent, datePicker, property) {
        const year = changeEvent.target.value;
        const date = this.getDateFromStringWithoutTime(year);
        this.yearSelected(date, datePicker, property);
    }
    yearSelected(year, datePicker, property, refreshFilter = true) {
        if (this.ogcFilterTimeService.stepIsYearDuration(this.step)) {
            if (datePicker) {
                datePicker.close();
            }
            if (property === 'end') {
                // change value 01 jan to 31 dec same year
                year = moment(year).endOf('year').toDate();
            }
            else if (property === 'begin' &&
                this.restrictedToStep() &&
                !this.calendarTypeYear) {
                this.yearSelected(year, undefined, 'end');
            }
            this.changeTemporalProperty(year, property === 'begin' ? 1 : 2, refreshFilter);
        }
    }
    monthSelected(month, datePicker, property, refreshFilter = true) {
        if (this.ogcFilterTimeService.stepIsMonthDuration(this.step)) {
            if (datePicker) {
                datePicker.close();
            }
            if (property === 'end') {
                month = moment(month).endOf('month').toDate();
            }
            else if (property === 'begin' && this.restrictedToStep()) {
                this.monthSelected(month, undefined, 'end');
            }
            this.changeTemporalProperty(month, property === 'begin' ? 1 : 2, refreshFilter);
        }
    }
    calendarView() {
        const test = this.stepMilliseconds;
        const diff = Math.abs(this.parseFilter(this.currentFilter.end).getTime() -
            this.parseFilter(this.currentFilter.begin).getTime());
        if (this.ogcFilterTimeService.stepIsYearDuration(this.step)) {
            return 'multi-year';
        }
        else if (this.ogcFilterTimeService.stepIsMonthDuration(this.step)) {
            return 'year';
        }
        else if (test < 86400000 && diff < 86400000) {
            return 'clock';
        }
        else {
            return 'month';
        }
    }
    dateFilter(type, date) {
        const dateValue = new Date(date);
        const diff = dateValue.getTime() - new Date(this.handleMin()).getTime();
        if (this.ogcFilterTimeService.stepIsYearDuration(this.step)) {
            const monthDiff = moment(dateValue).diff(moment(this.handleMin()), 'years', true);
            if (type === 'end') {
                const dateValuePlus1 = moment(dateValue).add(1, 'd');
                const monthDiffPlus1 = moment(dateValuePlus1).diff(moment(this.handleMin()), 'years', true);
                this.filterEndFunction =
                    monthDiffPlus1 % moment.duration(this.step).asYears() === 0;
                return;
            }
            else if (type === 'begin') {
                this.filterBeginFunction =
                    monthDiff % moment.duration(this.step).asYears() === 0;
                return;
            }
        }
        else if (this.ogcFilterTimeService.stepIsMonthDuration(this.step)) {
            const monthDiff = moment(dateValue).diff(moment(this.handleMin()), 'months', true);
            if (type === 'end') {
                const dateValuePlus1 = moment(dateValue).add(1, 'd');
                const monthDiffPlus1 = moment(dateValuePlus1).diff(moment(this.handleMin()), 'months', true);
                this.filterEndFunction =
                    monthDiffPlus1 % moment.duration(this.step).asMonths() === 0;
                return;
            }
            else if (type === 'begin') {
                this.filterBeginFunction =
                    monthDiff % moment.duration(this.step).asMonths() === 0;
                return;
            }
        }
        else if (this.ogcFilterTimeService.stepIsWeekDuration(this.step)) {
            const weekDiff = moment(dateValue).diff(moment(this.handleMin()), 'weeks', true);
            if (type === 'end') {
                const dateValuePlus1 = moment(dateValue).add(1, 'd');
                const weekDiffPlus1 = moment(dateValuePlus1).diff(moment(this.handleMin()), 'weeks', true);
                this.filterEndFunction =
                    weekDiffPlus1 % moment.duration(this.step).asWeeks() === 0;
                return;
            }
            else if (type === 'begin') {
                this.filterBeginFunction =
                    weekDiff % moment.duration(this.step).asWeeks() === 0;
                return;
            }
        }
        else if (this.ogcFilterTimeService.stepIsDayDuration(this.step)) {
            const dayDiff = moment(dateValue).diff(moment(this.handleMin()), 'days', true);
            if (type === 'end') {
                const dateValuePlus1 = moment(dateValue).add(1, 'd');
                const dayDiffPlus1 = moment(dateValuePlus1).diff(moment(this.handleMin()), 'days', true);
                const _mod = dayDiffPlus1 % moment.duration(this.step).asDays();
                this.filterEndFunction =
                    (_mod < 0.0000001 && _mod > -0.0000001) || _mod === 0; // 1 millisecond = 1.1574074074074076e-8
                return;
            }
            else if (type === 'begin') {
                const _mod = (dayDiff % moment.duration(this.step).asDays()) + 1;
                this.filterBeginFunction =
                    (_mod < 0.0000001 && _mod > -0.0000001 && _mod !== 0) || _mod === 1; // 1 millisecond = 1.1574074074074076e-8
                return;
            }
        }
        else if (this.ogcFilterTimeService.stepIsHourDuration(this.step)) {
            if (type === 'end') {
                const hourDiff = moment(dateValue).diff(moment(this.handleMin()), 'hours', true);
                this.filterEndFunction =
                    hourDiff % moment.duration(this.step).asHours() === 0;
                return;
            }
            else if (type === 'begin') {
                const hourDiff = moment(dateValue).diff(moment(this.handleMin()), 'hours', true);
                this.filterBeginFunction =
                    hourDiff % moment.duration(this.step).asHours() === 0;
                return;
            }
        }
        else if (this.ogcFilterTimeService.stepIsMinuteDuration(this.step)) {
            if (type === 'end') {
                this.filterEndFunction = true;
                return;
            }
            else if (type === 'begin') {
                this.filterBeginFunction = true;
                return;
            }
        }
        this.filterEndFunction = diff % this.stepMilliseconds === 0;
        this.filterBeginFunction = diff % this.stepMilliseconds === 0;
        return;
    }
    getDateTime(date, pos) {
        const valuetmp = new Date(date);
        let valuetmp2;
        if (!this.sliderMode) {
            switch (pos) {
                case 1: {
                    if (this.currentFilter.calendarModeYear) {
                        valuetmp2 = valuetmp.setHours(0, 0);
                        break;
                    }
                    else {
                        valuetmp2 = valuetmp.setHours(this.beginHourFormControl.value, this.beginMinuteFormControl.value);
                        break;
                    }
                }
                case 2: {
                    if (this.currentFilter.calendarModeYear) {
                        valuetmp2 = valuetmp.setHours(0, 0);
                        break;
                    }
                    else {
                        valuetmp2 = valuetmp.setHours(this.endHourFormControl.value, this.endMinuteFormControl.value);
                        break;
                    }
                }
            }
        }
        return new Date(valuetmp2 ? valuetmp2 : valuetmp);
    }
    handleMinuteIncrement() {
        if (this.ogcFilterTimeService.stepIsMinuteDuration(this.step)) {
            if (this.stepMilliseconds < 3600000) {
                return this.stepMilliseconds / 1000 === 60
                    ? 1
                    : this.stepMilliseconds / 1000;
            }
            else {
                return (this.stepMilliseconds % 3600000) / 60;
            }
        }
        else if (this.ogcFilterTimeService.stepIsHourDuration(this.step)) {
            return 60;
        }
        return 1;
    }
    handleHourIncrement() {
        if (this.ogcFilterTimeService.stepIsHourDuration(this.step)) {
            return this.stepMilliseconds / 1000 / 60 / 60;
        }
        return 1;
    }
    fullBeginHoursArray(checkEndValue) {
        if (checkEndValue) {
            this.beginHours = Array.from({
                length: (this.endHourFormControl.value - 0) / this.handleHourIncrement() + 1
            }, (_, i) => 0 + i * this.handleHourIncrement());
        }
        else {
            this.beginHours = Array.from({ length: (23 - 0) / this.handleHourIncrement() + 1 }, (_, i) => 0 + i * this.handleHourIncrement());
        }
        this.beginHourFormControl.setValue(this.beginValue.getHours());
    }
    fullEndHoursArray(checkEndValue) {
        if (checkEndValue) {
            this.endHours = Array.from({
                length: (23 - this.beginHourFormControl.value) /
                    this.handleHourIncrement() +
                    1
            }, (_, i) => this.beginHourFormControl.value + i * this.handleHourIncrement());
        }
        else {
            this.endHours = Array.from({ length: (23 - 0) / this.handleHourIncrement() + 1 }, (_, i) => 0 + i * this.handleHourIncrement());
        }
        this.endHourFormControl.setValue(this.endValue.getHours());
    }
    fullBeginMinutesArray(checkEndValue) {
        if (checkEndValue) {
            this.beginMinutes = Array.from({
                length: (this.endMinuteFormControl.value - 0) /
                    this.handleMinuteIncrement() +
                    1
            }, (_, i) => 0 + i * this.handleMinuteIncrement());
        }
        else {
            this.beginMinutes = Array.from({ length: (59 - 0) / this.handleMinuteIncrement() + 1 }, (_, i) => 0 + i * this.handleMinuteIncrement());
        }
        this.beginMinuteFormControl.setValue(this.beginValue.getMinutes());
    }
    fullEndMinutesArray(checkEndValue) {
        if (checkEndValue) {
            this.endMinutes = Array.from({
                length: (59 - this.beginMinuteFormControl.value) /
                    this.handleMinuteIncrement() +
                    1
            }, (_, i) => this.beginMinuteFormControl.value + i * this.handleMinuteIncrement());
        }
        else {
            this.endMinutes = Array.from({ length: (59 - 0) / this.handleMinuteIncrement() + 1 }, (_, i) => 0 + i * this.handleMinuteIncrement());
        }
        this.endMinuteFormControl.setValue(this.endValue.getMinutes());
    }
    updateHoursMinutesArray() {
        const beginTmp = new Date(this.beginValue);
        const endTmp = new Date(this.endValue);
        if (beginTmp.setHours(0, 0) === endTmp.setHours(0, 0)) {
            this.fullBeginHoursArray(true);
            this.fullEndHoursArray(true);
            if (this.beginValue.getHours() === this.endValue.getHours()) {
                this.fullBeginMinutesArray(true);
                this.fullEndMinutesArray(true);
            }
        }
        else {
            this.fullBeginHoursArray();
            this.fullEndHoursArray();
            this.fullBeginMinutesArray();
            this.fullEndMinutesArray();
        }
    }
    updateValues() {
        this.changeTemporalProperty(this.beginValue, 1, false);
        this.changeTemporalProperty(this.endValue, 2, true);
    }
    restrictedToStep() {
        return this.currentFilter.restrictToStep
            ? this.currentFilter.restrictToStep
            : false;
    }
    handleMin() {
        return this.currentFilter.begin
            ? this.currentFilter.begin
            : this.datasource.options.minDate
                ? this.datasource.options.minDate
                : this._defaultMin;
    }
    handleMax() {
        return this.currentFilter.end
            ? this.currentFilter.end
            : this.datasource.options.maxDate
                ? this.datasource.options.maxDate
                : this._defaultMax;
    }
    changePropertyByPass(event) {
        this.changeProperty.next(event);
    }
    modeChange(event) {
        if (!event.checked) {
            this.updateValues();
        }
    }
    setFilterStateDisable() {
        if (this.currentFilter) {
            this.filterStateDisable = !this.currentFilter.active;
        }
        else {
            this.filterStateDisable = false;
        }
        if (this.calendarType() === 'datetime') {
            if (this.filterStateDisable === true) {
                this.beginHourFormControl.disable();
                this.beginMinuteFormControl.disable();
                this.endHourFormControl.disable();
                this.endMinuteFormControl.disable();
            }
            else {
                this.beginHourFormControl.enable();
                this.beginMinuteFormControl.enable();
                this.endHourFormControl.enable();
                this.endMinuteFormControl.enable();
            }
        }
    }
    getDateFromStringWithoutTime(stringDate) {
        // warning create date with no time make a date UTC with TZ and the date create maybe not the same year, month and day
        // exemple:
        // new Date('2022-01-01') -> Fri Dec 31 2021 19:00:00 GMT-0500 (heure normale de l’Est nord-américain)
        // to create same date as string, add time 00 in the creation
        // new Date('2022-01-01 00:00:00') -> Sat Jan 01 2022 00:00:00 GMT-0500 (heure normale de l’Est nord-américain)
        let year;
        let month = '01';
        let day = '01';
        if (stringDate.length === 10) {
            const dateItems = stringDate.split('-');
            if (dateItems.length !== 3) {
                throw new Error('Error in config date begin-end for ogcFilter: Date without time format need to be YYYY-MM-DD or YYYY');
            }
            else {
                year = dateItems[0];
                month = dateItems[1];
                day = dateItems[2];
            }
        }
        else if (stringDate.length === 4) {
            year = stringDate;
        }
        else {
            return new Date(stringDate);
        }
        return new Date(`${year}-${month}-${day} 00:00:00`);
    }
    resetFilter() {
        let filterOriginConfig = this.datasource.options.ogcFilters
            .filters;
        let minDefaultDate;
        let maxDefaultDate;
        let minDefaultISOString;
        let maxDefaultISOString;
        if (this.calendarTypeYear) {
            if (filterOriginConfig.end === 'today') {
                let todayDateStringNoTime = new Date().toLocaleDateString('en-CA'); // '2022-02-13'
                maxDefaultISOString = `${todayDateStringNoTime.substring(0, 4)}-01-01`;
            }
            else {
                maxDefaultISOString = `${filterOriginConfig.end.substring(0, 4)}-01-01`;
            }
            minDefaultISOString = `${filterOriginConfig.begin.substring(0, 4)}-01-01`;
            minDefaultDate = this.getDateFromStringWithoutTime(minDefaultISOString);
            maxDefaultDate = this.getDateFromStringWithoutTime(maxDefaultISOString);
        }
        else {
            minDefaultDate = this.parseFilter(filterOriginConfig.begin);
            maxDefaultDate = this.parseFilter(filterOriginConfig.end);
            minDefaultISOString = minDefaultDate.toISOString();
            maxDefaultISOString = maxDefaultDate.toISOString();
        }
        if (this.currentFilter.begin !== minDefaultISOString ||
            this.currentFilter.end !== maxDefaultISOString) {
            this.beginValue = minDefaultDate;
            this.endValue = maxDefaultDate;
            this.updateValues();
        }
    }
    toggleFilterState() {
        if (this.currentFilter.active === true) {
            this.currentFilter.active = false;
        }
        else {
            this.currentFilter.active = true;
        }
        this.setFilterStateDisable();
        this.updateValues();
    }
    isValidDate(date) {
        return date instanceof Date && !isNaN(date.getTime());
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OgcFilterTimeComponent, deps: [{ token: OGCFilterTimeService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: OgcFilterTimeComponent, selector: "igo-ogc-filter-time", inputs: { datasource: "datasource", currentFilter: "currentFilter" }, outputs: { changeProperty: "changeProperty" }, viewQueries: [{ propertyName: "endDatepickerTime", first: true, predicate: ["endDatepickerTime"], descendants: true }, { propertyName: "beginDatepickerTime", first: true, predicate: ["beginDatepickerTime"], descendants: true }, { propertyName: "beginTime", first: true, predicate: ["beginTime"], descendants: true }, { propertyName: "endTime", first: true, predicate: ["endTime"], descendants: true }], ngImport: i0, template: "<div class=\"datetime-container\">\n  <mat-slide-toggle\n    *ngIf=\"this.currentFilter.sliderOptions?.enabled\"\n    [(ngModel)]=\"sliderMode\"\n    (change)=\"modeChange($event)\"\n  >\n    {{ 'igo.geo.filter.sliderModeTitle' | translate }}\n  </mat-slide-toggle>\n\n  <div class=\"slider-container\" *ngIf=\"sliderMode\">\n    <igo-ogc-filter-time-slider\n      [begin]=\"beginValue\"\n      [max]=\"this.restrictedToStep() ? this.maxDate : this.endValue\"\n      [currentFilter]=\"currentFilter\"\n      [datasource]=\"datasource\"\n      (changeProperty)=\"changePropertyByPass($event)\"\n    >\n    </igo-ogc-filter-time-slider>\n  </div>\n\n  <div *ngIf=\"!sliderMode\">\n    <div class=\"year-input-container\" *ngIf=\"calendarTypeYear\">\n      <!-- to emulate a year-picker, 2 input: first input to show user just year and second input hiden and bind \n        with the datepicker  -->\n      <mat-form-field class=\"year-input\" subscriptSizing=\"dynamic\">\n        <mat-label>{{ 'igo.geo.timeFilter.startYear' | translate }}</mat-label>\n        <input\n          matInput\n          class=\"year-input-only-year\"\n          value=\"{{ onlyYearBegin }}\"\n          (change)=\"yearOnlyInputChange($event, beginDatepicker, 'begin')\"\n          [disabled]=\"filterStateDisable\"\n        />\n        <mat-datepicker-toggle\n          matSuffix\n          [for]=\"beginDatepicker\"\n          [disabled]=\"filterStateDisable\"\n        ></mat-datepicker-toggle>\n\n        <mat-datepicker\n          panelClass=\"datepicker-year\"\n          #beginDatepicker\n          [startView]=\"calendarView()\"\n          [startAt]=\"beginValue\"\n          (yearSelected)=\"yearSelected($event, beginDatepicker, 'begin')\"\n        >\n        </mat-datepicker>\n\n        <input\n          #beginYear\n          class=\"year-input-hide\"\n          matInput\n          [matDatepicker]=\"beginDatepicker\"\n          enabled=\"false\"\n          readonly=\"true\"\n          [value]=\"\n            beginValue ? beginValue : handleDate(datasource.options.minDate)\n          \"\n          [min]=\"handleDate(datasource.options.minDate)\"\n          [max]=\"\n            endValue && !restrictedToStep()\n              ? endValue\n              : handleDate(datasource.options.maxDate)\n          \"\n        />\n      </mat-form-field>\n\n      <mat-form-field class=\"year-input\" subscriptSizing=\"dynamic\">\n        <mat-label>{{ 'igo.geo.timeFilter.endYear' | translate }}</mat-label>\n        <input\n          matInput\n          class=\"year-input-only-year\"\n          value=\"{{ onlyYearEnd }}\"\n          (change)=\"yearOnlyInputChange($event, endDatepicker, 'end')\"\n          [disabled]=\"filterStateDisable\"\n        />\n        <mat-datepicker-toggle\n          matSuffix\n          [for]=\"endDatepicker\"\n          [disabled]=\"filterStateDisable\"\n        ></mat-datepicker-toggle>\n        <mat-datepicker\n          panelClass=\"datepicker-year\"\n          #endDatepicker\n          [startView]=\"calendarView()\"\n          [startAt]=\"endValue\"\n          (yearSelected)=\"yearSelected($event, endDatepicker, 'end')\"\n        >\n        </mat-datepicker>\n\n        <input\n          #endYear\n          class=\"year-input-hide\"\n          matInput\n          [matDatepicker]=\"endDatepicker\"\n          enabled=\"false\"\n          readonly=\"true\"\n          [value]=\"endValue ? endValue : handleDate(datasource.options.maxDate)\"\n          [min]=\"\n            beginValue ? beginValue : handleDate(datasource.options.minDate)\n          \"\n          [max]=\"handleDate(datasource.options.maxDate)\"\n        />\n      </mat-form-field>\n      <div class=\"actions-container\">\n        <button\n          class=\"reset-button\"\n          mat-icon-button\n          color=\"primary\"\n          (click)=\"resetFilter()\"\n          [matTooltip]=\"'igo.geo.filter.resetFilters' | translate\"\n          [disabled]=\"filterStateDisable\"\n        >\n          <mat-icon svgIcon=\"{{ resetIcon }}\"></mat-icon>\n        </button>\n        <mat-slide-toggle\n          class=\"toggle-filter-state\"\n          (change)=\"toggleFilterState()\"\n          [matTooltip]=\"'igo.geo.filter.toggleFilterState' | translate\"\n          tooltip-position=\"below\"\n          matTooltipShowDelay=\"500\"\n          [checked]=\"!filterStateDisable\"\n        >\n        </mat-slide-toggle>\n      </div>\n    </div>\n\n    <div class=\"datetime-input-container\" *ngIf=\"calendarType() !== 'year'\">\n      <div class=\"datetime-input\">\n        <mat-form-field class=\"date-input\" subscriptSizing=\"dynamic\">\n          <mat-datepicker-toggle\n            matSuffix\n            [for]=\"beginDatepicker\"\n            [disabled]=\"filterStateDisable\"\n          ></mat-datepicker-toggle>\n          <input\n            #begin\n            matInput\n            [matDatepicker]=\"beginDatepicker\"\n            [placeholder]=\"'igo.geo.timeFilter.startDate' | translate\"\n            [attr.disabled]=\"!currentFilter.active\"\n            (dateChange)=\"changeTemporalProperty(begin.value, 1)\"\n            [matDatepickerFilter]=\"filterBeginFunction\"\n            [value]=\"\n              beginValue ? beginValue : handleDate(datasource.options.minDate)\n            \"\n            [min]=\"handleDate(datasource.options.minDate)\"\n            [max]=\"\n              endValue && !restrictedToStep()\n                ? endValue\n                : handleDate(datasource.options.maxDate)\n            \"\n            [disabled]=\"filterStateDisable\"\n          />\n          <span class=\"filler\"></span>\n          <mat-datepicker\n            #beginDatepicker\n            [startView]=\"calendarView()\"\n            [startAt]=\"beginValue\"\n            (yearSelected)=\"yearSelected($event, beginDatepicker, 'begin')\"\n            (monthSelected)=\"monthSelected($event, beginDatepicker, 'begin')\"\n          >\n          </mat-datepicker>\n        </mat-form-field>\n\n        <div *ngIf=\"calendarType() === 'datetime'\" class=\"time-input\">\n          <mat-form-field class=\"hour-input\" subscriptSizing=\"dynamic\">\n            <mat-label>{{ 'igo.geo.timeFilter.hour' | translate }}</mat-label>\n            <mat-select\n              [formControl]=\"beginHourFormControl\"\n              [attr.disabled]=\"!currentFilter.active\"\n              (selectionChange)=\"changeTemporalProperty(begin.value, 1)\"\n            >\n              <mat-option *ngFor=\"let hour of beginHours\" [value]=\"hour\">{{\n                hour\n              }}</mat-option>\n            </mat-select>\n          </mat-form-field>\n          <mat-form-field class=\"minute-input\" subscriptSizing=\"dynamic\">\n            <mat-label>{{ 'igo.geo.timeFilter.minute' | translate }}</mat-label>\n            <mat-select\n              [formControl]=\"beginMinuteFormControl\"\n              [attr.disabled]=\"!currentFilter.active\"\n              (selectionChange)=\"changeTemporalProperty(begin.value, 1)\"\n            >\n              <mat-option\n                *ngFor=\"let minute of beginMinutes\"\n                [value]=\"minute\"\n                >{{ minute }}</mat-option\n              >\n            </mat-select>\n          </mat-form-field>\n        </div>\n      </div>\n\n      <div *ngIf=\"!restrictedToStep()\" class=\"datetime-input\">\n        <mat-form-field class=\"date-input\" subscriptSizing=\"dynamic\">\n          <mat-datepicker-toggle\n            matSuffix\n            [for]=\"endDatepicker\"\n            [disabled]=\"filterStateDisable\"\n          ></mat-datepicker-toggle>\n          <input\n            #end\n            matInput\n            [matDatepicker]=\"endDatepicker\"\n            [placeholder]=\"'igo.geo.timeFilter.endDate' | translate\"\n            [attr.disabled]=\"!currentFilter.active\"\n            (dateChange)=\"changeTemporalProperty(end.value, 2)\"\n            [matDatepickerFilter]=\"filterEndFunction\"\n            [value]=\"\n              endValue ? endValue : handleDate(datasource.options.maxDate)\n            \"\n            [min]=\"\n              beginValue ? beginValue : handleDate(datasource.options.minDate)\n            \"\n            [max]=\"handleDate(datasource.options.maxDate)\"\n            [disabled]=\"filterStateDisable\"\n          />\n          <span class=\"filler\"></span>\n          <mat-datepicker\n            #endDatepicker\n            [startView]=\"calendarView()\"\n            [startAt]=\"endValue\"\n            (yearSelected)=\"yearSelected($event, endDatepicker, 'end')\"\n            (monthSelected)=\"monthSelected($event, endDatepicker, 'end')\"\n          >\n          </mat-datepicker>\n        </mat-form-field>\n\n        <div *ngIf=\"calendarType() === 'datetime'\" class=\"time-input\">\n          <mat-form-field class=\"hour-input\" subscriptSizing=\"dynamic\">\n            <mat-label>{{ 'igo.geo.timeFilter.hour' | translate }}</mat-label>\n            <mat-select\n              [formControl]=\"endHourFormControl\"\n              [attr.disabled]=\"!currentFilter.active\"\n              (selectionChange)=\"changeTemporalProperty(end.value, 2)\"\n            >\n              <mat-option *ngFor=\"let hour of endHours\" [value]=\"hour\">{{\n                hour\n              }}</mat-option>\n            </mat-select>\n          </mat-form-field>\n          <mat-form-field class=\"minute-input\" subscriptSizing=\"dynamic\">\n            <mat-label>{{ 'igo.geo.timeFilter.minute' | translate }}</mat-label>\n            <mat-select\n              [formControl]=\"endMinuteFormControl\"\n              [attr.disabled]=\"!currentFilter.active\"\n              (selectionChange)=\"changeTemporalProperty(end.value, 2)\"\n            >\n              <mat-option *ngFor=\"let minute of endMinutes\" [value]=\"minute\">{{\n                minute\n              }}</mat-option>\n            </mat-select>\n          </mat-form-field>\n        </div>\n      </div>\n\n      <div class=\"actions-container\">\n        <button\n          class=\"reset-button\"\n          mat-icon-button\n          color=\"primary\"\n          (click)=\"resetFilter()\"\n          [matTooltip]=\"'igo.geo.filter.resetFilters' | translate\"\n          [disabled]=\"filterStateDisable\"\n        >\n          <mat-icon svgIcon=\"{{ resetIcon }}\"></mat-icon>\n        </button>\n        <mat-slide-toggle\n          class=\"toggle-filter-state\"\n          (change)=\"toggleFilterState()\"\n          tooltip-position=\"below\"\n          matTooltipShowDelay=\"500\"\n          [matTooltip]=\"'igo.geo.filter.toggleFilterState' | translate\"\n          [checked]=\"!filterStateDisable\"\n        >\n        </mat-slide-toggle>\n      </div>\n    </div>\n  </div>\n</div>\n", styles: [":host ::ng-deep input{text-align:center!important;margin:auto 5px!important}:host .slider-container{text-align:center}:host .datetime-input-container{display:flex;align-items:center;flex-wrap:wrap}:host .datetime-input-container>:not(:last-child){margin-right:8px}:host .datetime-input{display:block}:host .date-input{width:154px}:host .actions-container{display:flex;align-items:center}:host .time-input{margin-top:16px}:host .time-input>:not(:last-child){margin-right:8px}@media only screen and (orientation:portrait) and (max-width: 599px),only screen and (orientation:landscape) and (max-width: 959px){:host .time-input{margin-top:4px}}:host .hour-input,:host .minute-input{width:100px}:host .year-input-container{display:flex;width:100%}:host .year-input-container mat-form-field:not(:last-child){margin-right:4px}:host .year-input-hide{width:120px;margin-right:25px;display:none}:host .year-input-only-year{width:120px;margin-right:25px;text-align:left!important}:host ::ng-deep .datepicker-year ::ng-deep .mat-calendar-arrow{display:none}:host ::ng-deep .datepicker-year ::ng-deep .mat-calendar-period-button{pointer-events:none}:host ::ng-deep .datepicker-year ::ng-deep .mat-calendar-body-cell:not(.mat-calendar-body-disabled):hover{background-color:#0000001f;border-radius:999px}\n"], dependencies: [{ kind: "directive", type: i2$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "directive", type: i2$1.FormControlDirective, selector: "[formControl]", inputs: ["formControl", "disabled", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { kind: "component", type: i9.MatOption, selector: "mat-option", exportAs: ["matOption"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "component", type: i7.MatSlideToggle, selector: "mat-slide-toggle", inputs: ["disabled", "disableRipple", "color", "tabIndex"], exportAs: ["matSlideToggle"] }, { kind: "component", type: i8.MatFormField, selector: "mat-form-field", inputs: ["hideRequiredMarker", "color", "floatLabel", "appearance", "subscriptSizing", "hintLabel"], exportAs: ["matFormField"] }, { kind: "directive", type: i8.MatLabel, selector: "mat-label" }, { kind: "directive", type: i8.MatSuffix, selector: "[matSuffix], [matIconSuffix], [matTextSuffix]", inputs: ["matTextSuffix"] }, { kind: "directive", type: i9$3.MatInput, selector: "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", inputs: ["disabled", "id", "placeholder", "name", "required", "type", "errorStateMatcher", "aria-describedby", "value", "readonly"], exportAs: ["matInput"] }, { kind: "component", type: i15.MatSelect, selector: "mat-select", inputs: ["disabled", "disableRipple", "tabIndex", "panelWidth", "hideSingleSelectionIndicator"], exportAs: ["matSelect"] }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "component", type: i12.MatDatepicker, selector: "mat-datepicker", exportAs: ["matDatepicker"] }, { kind: "directive", type: i12.MatDatepickerInput, selector: "input[matDatepicker]", inputs: ["matDatepicker", "min", "max", "matDatepickerFilter"], exportAs: ["matDatepickerInput"] }, { kind: "component", type: i12.MatDatepickerToggle, selector: "mat-datepicker-toggle", inputs: ["for", "tabIndex", "aria-label", "disabled", "disableRipple"], exportAs: ["matDatepickerToggle"] }, { kind: "component", type: OgcFilterTimeSliderComponent, selector: "igo-ogc-filter-time-slider", inputs: ["currentFilter", "begin", "max", "datasource"], outputs: ["changeProperty"] }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OgcFilterTimeComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-ogc-filter-time', template: "<div class=\"datetime-container\">\n  <mat-slide-toggle\n    *ngIf=\"this.currentFilter.sliderOptions?.enabled\"\n    [(ngModel)]=\"sliderMode\"\n    (change)=\"modeChange($event)\"\n  >\n    {{ 'igo.geo.filter.sliderModeTitle' | translate }}\n  </mat-slide-toggle>\n\n  <div class=\"slider-container\" *ngIf=\"sliderMode\">\n    <igo-ogc-filter-time-slider\n      [begin]=\"beginValue\"\n      [max]=\"this.restrictedToStep() ? this.maxDate : this.endValue\"\n      [currentFilter]=\"currentFilter\"\n      [datasource]=\"datasource\"\n      (changeProperty)=\"changePropertyByPass($event)\"\n    >\n    </igo-ogc-filter-time-slider>\n  </div>\n\n  <div *ngIf=\"!sliderMode\">\n    <div class=\"year-input-container\" *ngIf=\"calendarTypeYear\">\n      <!-- to emulate a year-picker, 2 input: first input to show user just year and second input hiden and bind \n        with the datepicker  -->\n      <mat-form-field class=\"year-input\" subscriptSizing=\"dynamic\">\n        <mat-label>{{ 'igo.geo.timeFilter.startYear' | translate }}</mat-label>\n        <input\n          matInput\n          class=\"year-input-only-year\"\n          value=\"{{ onlyYearBegin }}\"\n          (change)=\"yearOnlyInputChange($event, beginDatepicker, 'begin')\"\n          [disabled]=\"filterStateDisable\"\n        />\n        <mat-datepicker-toggle\n          matSuffix\n          [for]=\"beginDatepicker\"\n          [disabled]=\"filterStateDisable\"\n        ></mat-datepicker-toggle>\n\n        <mat-datepicker\n          panelClass=\"datepicker-year\"\n          #beginDatepicker\n          [startView]=\"calendarView()\"\n          [startAt]=\"beginValue\"\n          (yearSelected)=\"yearSelected($event, beginDatepicker, 'begin')\"\n        >\n        </mat-datepicker>\n\n        <input\n          #beginYear\n          class=\"year-input-hide\"\n          matInput\n          [matDatepicker]=\"beginDatepicker\"\n          enabled=\"false\"\n          readonly=\"true\"\n          [value]=\"\n            beginValue ? beginValue : handleDate(datasource.options.minDate)\n          \"\n          [min]=\"handleDate(datasource.options.minDate)\"\n          [max]=\"\n            endValue && !restrictedToStep()\n              ? endValue\n              : handleDate(datasource.options.maxDate)\n          \"\n        />\n      </mat-form-field>\n\n      <mat-form-field class=\"year-input\" subscriptSizing=\"dynamic\">\n        <mat-label>{{ 'igo.geo.timeFilter.endYear' | translate }}</mat-label>\n        <input\n          matInput\n          class=\"year-input-only-year\"\n          value=\"{{ onlyYearEnd }}\"\n          (change)=\"yearOnlyInputChange($event, endDatepicker, 'end')\"\n          [disabled]=\"filterStateDisable\"\n        />\n        <mat-datepicker-toggle\n          matSuffix\n          [for]=\"endDatepicker\"\n          [disabled]=\"filterStateDisable\"\n        ></mat-datepicker-toggle>\n        <mat-datepicker\n          panelClass=\"datepicker-year\"\n          #endDatepicker\n          [startView]=\"calendarView()\"\n          [startAt]=\"endValue\"\n          (yearSelected)=\"yearSelected($event, endDatepicker, 'end')\"\n        >\n        </mat-datepicker>\n\n        <input\n          #endYear\n          class=\"year-input-hide\"\n          matInput\n          [matDatepicker]=\"endDatepicker\"\n          enabled=\"false\"\n          readonly=\"true\"\n          [value]=\"endValue ? endValue : handleDate(datasource.options.maxDate)\"\n          [min]=\"\n            beginValue ? beginValue : handleDate(datasource.options.minDate)\n          \"\n          [max]=\"handleDate(datasource.options.maxDate)\"\n        />\n      </mat-form-field>\n      <div class=\"actions-container\">\n        <button\n          class=\"reset-button\"\n          mat-icon-button\n          color=\"primary\"\n          (click)=\"resetFilter()\"\n          [matTooltip]=\"'igo.geo.filter.resetFilters' | translate\"\n          [disabled]=\"filterStateDisable\"\n        >\n          <mat-icon svgIcon=\"{{ resetIcon }}\"></mat-icon>\n        </button>\n        <mat-slide-toggle\n          class=\"toggle-filter-state\"\n          (change)=\"toggleFilterState()\"\n          [matTooltip]=\"'igo.geo.filter.toggleFilterState' | translate\"\n          tooltip-position=\"below\"\n          matTooltipShowDelay=\"500\"\n          [checked]=\"!filterStateDisable\"\n        >\n        </mat-slide-toggle>\n      </div>\n    </div>\n\n    <div class=\"datetime-input-container\" *ngIf=\"calendarType() !== 'year'\">\n      <div class=\"datetime-input\">\n        <mat-form-field class=\"date-input\" subscriptSizing=\"dynamic\">\n          <mat-datepicker-toggle\n            matSuffix\n            [for]=\"beginDatepicker\"\n            [disabled]=\"filterStateDisable\"\n          ></mat-datepicker-toggle>\n          <input\n            #begin\n            matInput\n            [matDatepicker]=\"beginDatepicker\"\n            [placeholder]=\"'igo.geo.timeFilter.startDate' | translate\"\n            [attr.disabled]=\"!currentFilter.active\"\n            (dateChange)=\"changeTemporalProperty(begin.value, 1)\"\n            [matDatepickerFilter]=\"filterBeginFunction\"\n            [value]=\"\n              beginValue ? beginValue : handleDate(datasource.options.minDate)\n            \"\n            [min]=\"handleDate(datasource.options.minDate)\"\n            [max]=\"\n              endValue && !restrictedToStep()\n                ? endValue\n                : handleDate(datasource.options.maxDate)\n            \"\n            [disabled]=\"filterStateDisable\"\n          />\n          <span class=\"filler\"></span>\n          <mat-datepicker\n            #beginDatepicker\n            [startView]=\"calendarView()\"\n            [startAt]=\"beginValue\"\n            (yearSelected)=\"yearSelected($event, beginDatepicker, 'begin')\"\n            (monthSelected)=\"monthSelected($event, beginDatepicker, 'begin')\"\n          >\n          </mat-datepicker>\n        </mat-form-field>\n\n        <div *ngIf=\"calendarType() === 'datetime'\" class=\"time-input\">\n          <mat-form-field class=\"hour-input\" subscriptSizing=\"dynamic\">\n            <mat-label>{{ 'igo.geo.timeFilter.hour' | translate }}</mat-label>\n            <mat-select\n              [formControl]=\"beginHourFormControl\"\n              [attr.disabled]=\"!currentFilter.active\"\n              (selectionChange)=\"changeTemporalProperty(begin.value, 1)\"\n            >\n              <mat-option *ngFor=\"let hour of beginHours\" [value]=\"hour\">{{\n                hour\n              }}</mat-option>\n            </mat-select>\n          </mat-form-field>\n          <mat-form-field class=\"minute-input\" subscriptSizing=\"dynamic\">\n            <mat-label>{{ 'igo.geo.timeFilter.minute' | translate }}</mat-label>\n            <mat-select\n              [formControl]=\"beginMinuteFormControl\"\n              [attr.disabled]=\"!currentFilter.active\"\n              (selectionChange)=\"changeTemporalProperty(begin.value, 1)\"\n            >\n              <mat-option\n                *ngFor=\"let minute of beginMinutes\"\n                [value]=\"minute\"\n                >{{ minute }}</mat-option\n              >\n            </mat-select>\n          </mat-form-field>\n        </div>\n      </div>\n\n      <div *ngIf=\"!restrictedToStep()\" class=\"datetime-input\">\n        <mat-form-field class=\"date-input\" subscriptSizing=\"dynamic\">\n          <mat-datepicker-toggle\n            matSuffix\n            [for]=\"endDatepicker\"\n            [disabled]=\"filterStateDisable\"\n          ></mat-datepicker-toggle>\n          <input\n            #end\n            matInput\n            [matDatepicker]=\"endDatepicker\"\n            [placeholder]=\"'igo.geo.timeFilter.endDate' | translate\"\n            [attr.disabled]=\"!currentFilter.active\"\n            (dateChange)=\"changeTemporalProperty(end.value, 2)\"\n            [matDatepickerFilter]=\"filterEndFunction\"\n            [value]=\"\n              endValue ? endValue : handleDate(datasource.options.maxDate)\n            \"\n            [min]=\"\n              beginValue ? beginValue : handleDate(datasource.options.minDate)\n            \"\n            [max]=\"handleDate(datasource.options.maxDate)\"\n            [disabled]=\"filterStateDisable\"\n          />\n          <span class=\"filler\"></span>\n          <mat-datepicker\n            #endDatepicker\n            [startView]=\"calendarView()\"\n            [startAt]=\"endValue\"\n            (yearSelected)=\"yearSelected($event, endDatepicker, 'end')\"\n            (monthSelected)=\"monthSelected($event, endDatepicker, 'end')\"\n          >\n          </mat-datepicker>\n        </mat-form-field>\n\n        <div *ngIf=\"calendarType() === 'datetime'\" class=\"time-input\">\n          <mat-form-field class=\"hour-input\" subscriptSizing=\"dynamic\">\n            <mat-label>{{ 'igo.geo.timeFilter.hour' | translate }}</mat-label>\n            <mat-select\n              [formControl]=\"endHourFormControl\"\n              [attr.disabled]=\"!currentFilter.active\"\n              (selectionChange)=\"changeTemporalProperty(end.value, 2)\"\n            >\n              <mat-option *ngFor=\"let hour of endHours\" [value]=\"hour\">{{\n                hour\n              }}</mat-option>\n            </mat-select>\n          </mat-form-field>\n          <mat-form-field class=\"minute-input\" subscriptSizing=\"dynamic\">\n            <mat-label>{{ 'igo.geo.timeFilter.minute' | translate }}</mat-label>\n            <mat-select\n              [formControl]=\"endMinuteFormControl\"\n              [attr.disabled]=\"!currentFilter.active\"\n              (selectionChange)=\"changeTemporalProperty(end.value, 2)\"\n            >\n              <mat-option *ngFor=\"let minute of endMinutes\" [value]=\"minute\">{{\n                minute\n              }}</mat-option>\n            </mat-select>\n          </mat-form-field>\n        </div>\n      </div>\n\n      <div class=\"actions-container\">\n        <button\n          class=\"reset-button\"\n          mat-icon-button\n          color=\"primary\"\n          (click)=\"resetFilter()\"\n          [matTooltip]=\"'igo.geo.filter.resetFilters' | translate\"\n          [disabled]=\"filterStateDisable\"\n        >\n          <mat-icon svgIcon=\"{{ resetIcon }}\"></mat-icon>\n        </button>\n        <mat-slide-toggle\n          class=\"toggle-filter-state\"\n          (change)=\"toggleFilterState()\"\n          tooltip-position=\"below\"\n          matTooltipShowDelay=\"500\"\n          [matTooltip]=\"'igo.geo.filter.toggleFilterState' | translate\"\n          [checked]=\"!filterStateDisable\"\n        >\n        </mat-slide-toggle>\n      </div>\n    </div>\n  </div>\n</div>\n", styles: [":host ::ng-deep input{text-align:center!important;margin:auto 5px!important}:host .slider-container{text-align:center}:host .datetime-input-container{display:flex;align-items:center;flex-wrap:wrap}:host .datetime-input-container>:not(:last-child){margin-right:8px}:host .datetime-input{display:block}:host .date-input{width:154px}:host .actions-container{display:flex;align-items:center}:host .time-input{margin-top:16px}:host .time-input>:not(:last-child){margin-right:8px}@media only screen and (orientation:portrait) and (max-width: 599px),only screen and (orientation:landscape) and (max-width: 959px){:host .time-input{margin-top:4px}}:host .hour-input,:host .minute-input{width:100px}:host .year-input-container{display:flex;width:100%}:host .year-input-container mat-form-field:not(:last-child){margin-right:4px}:host .year-input-hide{width:120px;margin-right:25px;display:none}:host .year-input-only-year{width:120px;margin-right:25px;text-align:left!important}:host ::ng-deep .datepicker-year ::ng-deep .mat-calendar-arrow{display:none}:host ::ng-deep .datepicker-year ::ng-deep .mat-calendar-period-button{pointer-events:none}:host ::ng-deep .datepicker-year ::ng-deep .mat-calendar-body-cell:not(.mat-calendar-body-disabled):hover{background-color:#0000001f;border-radius:999px}\n"] }]
        }], ctorParameters: function () { return [{ type: OGCFilterTimeService }]; }, propDecorators: { datasource: [{
                type: Input
            }], currentFilter: [{
                type: Input
            }], changeProperty: [{
                type: Output
            }], endDatepickerTime: [{
                type: ViewChild,
                args: ['endDatepickerTime']
            }], beginDatepickerTime: [{
                type: ViewChild,
                args: ['beginDatepickerTime']
            }], beginTime: [{
                type: ViewChild,
                args: ['beginTime']
            }], endTime: [{
                type: ViewChild,
                args: ['endTime']
            }] } });

class OgcFilterFormComponent {
    wktService;
    ogcFilterOperator = OgcFilterOperator;
    filteredValues$;
    filteredFields$;
    allOgcFilterOperators;
    ogcFilterOperators$ = new BehaviorSubject(undefined);
    igoSpatialSelectors;
    value = '';
    inputOperator;
    selectedField$ = new BehaviorSubject(undefined);
    fields$ = new BehaviorSubject([]);
    color = 'primary';
    disabled;
    currentFilterIsSpatial$ = new BehaviorSubject(false);
    defaultStepMillisecond = 6000;
    inputClearable;
    refreshFilters;
    datasource;
    map;
    currentFilter;
    set snrc(value) {
        const checkSNRC50k = /^\d{2}[a-l][0,1][0-9]$/gi;
        const checkSNRC250k = /^\d{2}[a-p]$/gi;
        const checkSNRC1m = /^\d{2}$/gi;
        if (checkSNRC1m.test(value) ||
            checkSNRC250k.test(value) ||
            checkSNRC50k.test(value)) {
            this._snrc = value;
            this.currentFilter.igoSNRC = value;
        }
    }
    get snrc() {
        return this._snrc;
    }
    _snrc = '';
    floatLabel;
    get activeFilters() {
        return this.datasource.options.ogcFilters.interfaceOgcFilters.filter((f) => f.active === true);
    }
    get allowedOperators() {
        return new OgcFilterWriter().computeAllowedOperators(this.fields$.value, this.currentFilter.propertyName, this.datasource.options.ogcFilters.allowedOperatorsType);
    }
    constructor(wktService) {
        this.wktService = wktService;
        // TODO: Filter permitted operator based on wfscapabilities
        // Need to work on regex on XML capabilities because
        // comaparison operator's name varies between WFS servers...
        // Ex: IsNull vs PropertyIsNull vs IsNil ...
        this.allOgcFilterOperators = new OgcFilterWriter().operators;
        this.ogcFilterOperators$.next(this.allOgcFilterOperators);
        this.igoSpatialSelectors = [
            {
                type: 'fixedExtent'
            },
            {
                type: 'snrc'
            }
        ];
        // TODO: selectFeature & drawFeature
    }
    ngOnInit() {
        if (this.datasource.options.sourceFields) {
            const sFields = this.datasource.options.sourceFields.filter((sf) => sf.excludeFromOgcFilters === undefined || !sf.excludeFromOgcFilters);
            sFields.map((sfs) => {
                if (sfs.values) {
                    sfs.values.sort();
                }
            });
            this.fields$.next(sFields);
        }
        this.updateFieldsList();
        this.selectedField$.next(this.fields$.value.find((f) => f.name === this.currentFilter.propertyName));
        this.updateValuesList();
        this.selectedField$.subscribe((f) => {
            this.ogcFilterOperators$.next(this.allowedOperators);
            if (Object.keys(this.allowedOperators).indexOf(this.currentFilter.operator) === -1) {
                this.currentFilter.operator = Object.keys(this.allowedOperators)[0];
                this.currentFilter.operator = Object.keys(this.allowedOperators)[0];
            }
            this.updateValuesList();
        });
        this.currentFilterIsSpatial();
    }
    updateFieldsList(value) {
        this.filteredFields$ =
            value && value.length > 0 ? of(this._filterFields(value)) : this.fields$;
        if (this.fields$.value.find((f) => f.name === value)) {
            this.changeField(value);
        }
    }
    updateValuesList(value, pos) {
        this.filteredValues$ =
            value && value.length > 0
                ? of(this._filterValues(value))
                : this.selectedField$.value
                    ? of(this.selectedField$.value.values)
                    : of([]);
        if (value && value.length >= 1) {
            this.changeProperty(value, pos);
        }
    }
    _filterFields(value) {
        const keywordRegex = new RegExp(value.normalize('NFD').replace(/[\u0300-\u036f]/g, ''), 'gi');
        return this.fields$.value.filter((val) => keywordRegex.test(val.alias.normalize('NFD').replace(/[\u0300-\u036f]/g, '')));
    }
    _filterValues(value) {
        const keywordRegex = new RegExp(value
            .toString()
            .normalize('NFD')
            .replace(/[\u0300-\u036f]/g, ''), 'gi');
        return this.selectedField$.value?.values?.filter((val) => val &&
            keywordRegex.test(val
                .toString()
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '')));
    }
    clearSelectedField() {
        this.currentFilter.propertyName = '';
        this.selectedField$.next(undefined);
        this.clearProperty();
    }
    isClearable(pos) {
        const detectedProperty = this.detectProperty(pos);
        if (detectedProperty) {
            return this.currentFilter[detectedProperty];
        }
    }
    clearProperty(pos) {
        // this.autoCompleteInputValues.closePanel();
        const detectedProperty = this.detectProperty(pos);
        if (detectedProperty) {
            return (this.currentFilter[detectedProperty] = '');
        }
    }
    toggleFilterState(event) {
        this.datasource.options.ogcFilters.interfaceOgcFilters.find((f) => f.filterid === this.currentFilter.filterid).active = event.checked;
        this.refreshFilters();
    }
    deleteFilter() {
        const ogcFilters = this.datasource.options.ogcFilters;
        ogcFilters.interfaceOgcFilters = ogcFilters.interfaceOgcFilters.filter((f) => f.filterid !== this.currentFilter.filterid);
        this.refreshFilters();
    }
    changeLogical(logical) {
        this.currentFilter.parentLogical = logical;
        this.refreshFilters();
    }
    changeOperator(operator) {
        this.currentFilter.operator = operator;
        this.currentFilterIsSpatial();
        if (this.currentFilterIsSpatial$.value &&
            this.currentFilter.wkt_geometry.length === 0) {
            this.changeSpatialSelector(this.currentFilter.igoSpatialSelector);
        }
        else {
            this.refreshFilters();
        }
    }
    changeField(field) {
        this.currentFilter.propertyName = field;
        this.selectedField$.next(this.fields$.value.find((f) => f.name === this.currentFilter.propertyName));
        this.refreshFilters();
    }
    // Issue with mapserver 7.2 and Postgis layers. Fixed in 7.4
    // Due to this issue, the checkbox is hide.
    changeCaseSensitive(matchCase) {
        this.currentFilter.matchCase = matchCase.checked;
        this.refreshFilters();
    }
    changeProperty(value, pos, refreshFilter = true) {
        const detectedProperty = this.detectProperty(pos);
        if (detectedProperty) {
            this.datasource.options.ogcFilters.interfaceOgcFilters.find((f) => f.filterid === this.currentFilter.filterid)[detectedProperty] = value;
            if (refreshFilter) {
                this.refreshFilters();
            }
        }
    }
    changeNumericProperty(value, pos) {
        this.changeProperty(parseFloat(value), pos);
    }
    changeSpatialSelector(value) {
        this.currentFilter.igoSpatialSelector = value;
        if (value === 'fixedExtent') {
            this.changeMapExtentGeometry(false);
        }
        this.currentFilterIsSpatial();
        this.refreshFilters();
    }
    changeSNRC(value) {
        this.snrc = value;
        this.changeSNRCGeometry();
    }
    changeSNRCGeometry() {
        const interfaceOgcFilter = this.datasource.options.ogcFilters.interfaceOgcFilters.find((f) => f.filterid === this.currentFilter.filterid);
        if (!interfaceOgcFilter) {
            return;
        }
        if (this.snrc && this.currentFilter.igoSpatialSelector === 'snrc') {
            this.currentFilter.wkt_geometry = this.wktService.snrcToWkt(this.snrc, this.map.projection).wktPoly;
        }
        this.refreshFilters();
    }
    changeMapExtentGeometry(refresh = true) {
        const interfaceOgcFilter = this.datasource.options.ogcFilters.interfaceOgcFilters.find((f) => f.filterid === this.currentFilter.filterid);
        if (!interfaceOgcFilter) {
            return;
        }
        if (this.currentFilter.igoSpatialSelector === 'fixedExtent') {
            this.currentFilter.wkt_geometry = this.wktService.extentToWkt(this.map.projection, this.map.viewController.getExtent(), this.map.projection).wktPoly;
        }
        if (refresh) {
            this.refreshFilters();
        }
    }
    detectProperty(pos) {
        switch (this.currentFilter.operator) {
            case OgcFilterOperator.PropertyIsNotEqualTo:
            case OgcFilterOperator.PropertyIsEqualTo:
            case OgcFilterOperator.PropertyIsGreaterThan:
            case OgcFilterOperator.PropertyIsGreaterThanOrEqualTo:
            case OgcFilterOperator.PropertyIsLessThan:
            case OgcFilterOperator.PropertyIsLessThanOrEqualTo:
                return 'expression';
            case OgcFilterOperator.PropertyIsLike:
                return 'pattern';
            case OgcFilterOperator.PropertyIsBetween:
                return pos && pos === 1
                    ? 'lowerBoundary'
                    : pos && pos === 2
                        ? 'upperBoundary'
                        : undefined;
            case OgcFilterOperator.During:
                return pos && pos === 1
                    ? 'begin'
                    : pos && pos === 2
                        ? 'end'
                        : undefined;
            default:
                return;
        }
    }
    currentFilterIsSpatial() {
        let isSpatial = false;
        if (this.currentFilter) {
            isSpatial =
                [
                    OgcFilterOperator.Contains,
                    OgcFilterOperator.Intersects,
                    OgcFilterOperator.Within
                ].indexOf(this.currentFilter.operator) !== -1;
        }
        this.currentFilterIsSpatial$.next(isSpatial);
    }
    isTemporalOperator() {
        return (this.currentFilter.operator.toLowerCase() ===
            this.ogcFilterOperator.During.toLowerCase());
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OgcFilterFormComponent, deps: [{ token: WktService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: OgcFilterFormComponent, selector: "igo-ogc-filter-form", inputs: { refreshFilters: "refreshFilters", datasource: "datasource", map: "map", currentFilter: "currentFilter", floatLabel: "floatLabel" }, ngImport: i0, template: "<div class=\"ogc-filter-form-container\">\n  <mat-checkbox\n    tooltip-position=\"below\"\n    matTooltipShowDelay=\"500\"\n    [matTooltip]=\"'igo.geo.filter.toggleFilterState' | translate\"\n    (click)=\"$event.stopPropagation()\"\n    (change)=\"toggleFilterState($event)\"\n    [checked]=\"currentFilter.active\"\n  >\n  </mat-checkbox>\n\n  <mat-form-field\n    [ngClass]=\"{\n      logical:\n        activeFilters.indexOf(currentFilter) !== 0 &&\n        currentFilter.active === true,\n      logicalHidden:\n        activeFilters.indexOf(currentFilter) === 0 ||\n        currentFilter.active !== true\n    }\"\n  >\n    <mat-select\n      [disabled]=\"!currentFilter.active\"\n      [value]=\"currentFilter.parentLogical\"\n      tooltip-position=\"above\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"\n        currentFilter.parentLogical\n          ? ('igo.geo.operators.tooltip.' + currentFilter.parentLogical\n            | translate)\n          : ''\n      \"\n      (selectionChange)=\"changeLogical($event.value)\"\n    >\n      <mat-option\n        [value]=\"ogcFilterOperator.And\"\n        tooltip-position=\"above\"\n        matTooltipShowDelay=\"500\"\n        [matTooltip]=\"'igo.geo.operators.tooltip.And' | translate\"\n      >\n        {{ 'igo.geo.operators.And' | translate }}\n      </mat-option>\n      <mat-option\n        [value]=\"ogcFilterOperator.Or\"\n        tooltip-position=\"above\"\n        matTooltipShowDelay=\"500\"\n        [matTooltip]=\"'igo.geo.operators.tooltip.Or' | translate\"\n      >\n        {{ 'igo.geo.operators.Or' | translate }}\n      </mat-option>\n    </mat-select>\n  </mat-form-field>\n\n  <mat-form-field\n    class=\"field\"\n    *ngIf=\"\n      (currentFilterIsSpatial$ | async) === false &&\n      (fields$ | async) &&\n      (fields$ | async).length > 0 &&\n      (fields$ | async)[0].name !== ''\n    \"\n    (mouseenter)=\"inputClearable = 'selectField'\"\n    (mouseleave)=\"inputClearable = undefined\"\n    [floatLabel]=\"floatLabel\"\n  >\n    <input\n      matInput\n      [placeholder]=\"'igo.geo.sourceFields.selectField' | translate\"\n      [disabled]=\"!currentFilter.active\"\n      [matAutocomplete]=\"autoCompleteField\"\n      [value]=\"(selectedField$ | async) ? (selectedField$ | async).alias : ''\"\n      tooltip-position=\"above\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"\n        (selectedField$ | async)\n          ? (selectedField$ | async).alias\n          : ('igo.geo.sourceFields.selectField' | translate)\n      \"\n      (input)=\"updateFieldsList($event.target.value)\"\n    />\n    <mat-autocomplete\n      #autoCompleteField=\"matAutocomplete\"\n      (optionSelected)=\"changeField($event.option.id)\"\n    >\n      <mat-option\n        *ngFor=\"let field of filteredFields$ | async\"\n        matTooltipShowDelay=\"500\"\n        [value]=\"field.alias\"\n        [id]=\"field.name\"\n        [matTooltip]=\"field.alias\"\n      >\n        {{ field.alias }}\n      </mat-option>\n    </mat-autocomplete>\n    <button\n      *ngIf=\"\n        currentFilter.propertyName &&\n        inputClearable === 'selectField' &&\n        currentFilter.active\n      \"\n      matSuffix\n      mat-icon-button\n      aria-label=\"Clear\"\n      [disabled]=\"!currentFilter.active\"\n      (click)=\"clearSelectedField()\"\n    >\n      <mat-icon svgIcon=\"close\"></mat-icon>\n    </button>\n  </mat-form-field>\n\n  <mat-form-field\n    [ngClass]=\"{\n      operator: (currentFilterIsSpatial$ | async) === false,\n      dualInput: (currentFilterIsSpatial$ | async)\n    }\"\n    [floatLabel]=\"floatLabel\"\n  >\n    <mat-select\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"\n        currentFilter.operator\n          ? ('igo.geo.operators.tooltip.' + currentFilter.operator | translate)\n          : ('igo.geo.filter.selectOperator' | translate)\n      \"\n      [disabled]=\"!currentFilter.active\"\n      [value]=\"currentFilter.operator\"\n      (selectionChange)=\"changeOperator($event.value)\"\n    >\n      <mat-option\n        *ngFor=\"let operator of ogcFilterOperators$ | async | keyvalue\"\n        tooltip-position=\"above\"\n        matTooltipShowDelay=\"500\"\n        [value]=\"operator.key\"\n        [matTooltip]=\"'igo.geo.operators.tooltip.' + operator.key | translate\"\n      >\n        {{ 'igo.geo.operators.' + operator.key | translate }}\n      </mat-option>\n    </mat-select>\n  </mat-form-field>\n\n  <mat-form-field\n    class=\"spatialSelector\"\n    *ngIf=\"currentFilterIsSpatial$ | async\"\n  >\n    <mat-select\n      [disabled]=\"!currentFilter.active\"\n      [value]=\"currentFilter.igoSpatialSelector\"\n      (selectionChange)=\"changeSpatialSelector($event.value)\"\n    >\n      <mat-option\n        *ngFor=\"let igoSpatialSelector of igoSpatialSelectors\"\n        [value]=\"igoSpatialSelector.type\"\n      >\n        {{ 'igo.geo.spatialSelector.' + igoSpatialSelector.type | translate }}\n      </mat-option>\n    </mat-select>\n  </mat-form-field>\n\n  <mat-form-field\n    class=\"singleInput\"\n    *ngIf=\"['expression', 'pattern'].indexOf(detectProperty()) !== -1\"\n    (mouseenter)=\"inputClearable = 'selectProperty'\"\n    (mouseleave)=\"inputClearable = undefined\"\n    [floatLabel]=\"floatLabel\"\n  >\n    <input\n      matInput\n      [placeholder]=\"'igo.geo.filter.placeholder' | translate\"\n      [disabled]=\"!currentFilter.active\"\n      [matAutocomplete]=\"autoCompleteValues\"\n      [value]=\"\n        detectProperty() === 'expression'\n          ? currentFilter.expression\n          : currentFilter.pattern\n      \"\n      tooltip-position=\"above\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"\n        detectProperty() === 'expression'\n          ? currentFilter.expression || ''\n          : currentFilter.pattern || ''\n      \"\n      (input)=\"updateValuesList($event.target.value)\"\n    />\n    <mat-autocomplete\n      #autoCompleteValues=\"matAutocomplete\"\n      (optionSelected)=\"changeProperty($event.option.value)\"\n    >\n      <mat-option\n        *ngFor=\"let value of filteredValues$ | async\"\n        matTooltipShowDelay=\"500\"\n        [value]=\"value\"\n        [matTooltip]=\"value\"\n      >\n        {{ value }}\n      </mat-option>\n    </mat-autocomplete>\n    <button\n      *ngIf=\"\n        isClearable() &&\n        inputClearable === 'selectProperty' &&\n        currentFilter.active\n      \"\n      matSuffix\n      mat-icon-button\n      aria-label=\"Clear\"\n      [disabled]=\"!currentFilter.active\"\n      (click)=\"clearProperty()\"\n    >\n      <mat-icon svgIcon=\"close\"></mat-icon>\n    </button>\n  </mat-form-field>\n\n  <div class=\"igo-layer-button-group\">\n    <button\n      mat-icon-button\n      collapsibleButton\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"'igo.geo.filter.removeFilter' | translate\"\n      color=\"warn\"\n      (click)=\"deleteFilter()\"\n    >\n      <mat-icon svgIcon=\"delete\"></mat-icon>\n    </button>\n  </div>\n\n  <mat-form-field\n    class=\"snrc\"\n    *ngIf=\"\n      (currentFilterIsSpatial$ | async) &&\n      currentFilter.igoSpatialSelector === 'snrc'\n    \"\n    (mouseenter)=\"inputClearable = 'selectSNRC'\"\n    (mouseleave)=\"inputClearable = undefined\"\n    [floatLabel]=\"floatLabel\"\n  >\n    <input\n      matInput\n      [placeholder]=\"'igo.geo.filter.placeholderSnrc' | translate\"\n      [value]=\"currentFilter.igoSNRC\"\n      tooltip-position=\"above\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"currentFilter.igoSNRC ? currentFilter.igoSNRC : ''\"\n      (input)=\"changeSNRC($event.target.value)\"\n    />\n    <button\n      *ngIf=\"currentFilter.igoSNRC\"\n      matSuffix\n      mat-icon-button\n      aria-label=\"Clear\"\n      [disabled]=\"\n        !currentFilter.active &&\n        inputClearable === 'selectSNRC' &&\n        currentFilter.active\n      \"\n      (click)=\"currentFilter.igoSNRC = ''\"\n    >\n      <mat-icon svgIcon=\"close\"></mat-icon>\n    </button>\n  </mat-form-field>\n\n  <ng-container\n    *ngIf=\"\n      (currentFilterIsSpatial$ | async) &&\n      currentFilter.igoSpatialSelector === 'fixedExtent'\n    \"\n  >\n    <button\n      [disabled]=\"!currentFilter.active\"\n      *ngIf=\"currentFilter.igoSpatialSelector === 'fixedExtent'\"\n      matSuffix\n      mat-icon-button\n      [disabled]=\"!currentFilter.active\"\n      (click)=\"changeMapExtentGeometry()\"\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"'igo.geo.spatialSelector.btnSetExtent' | translate\"\n    >\n      <mat-icon svgIcon=\"arrow-expand-all\"></mat-icon>\n    </button>\n  </ng-container>\n</div>\n\n<div class=\"ogc-filter-form-container\">\n  <mat-form-field\n    class=\"dualInput\"\n    *ngIf=\"\n      !isTemporalOperator() &&\n      ['lowerBoundary', 'begin'].indexOf(detectProperty(1)) !== -1\n    \"\n    (mouseenter)=\"inputClearable = 'selectProperty1'\"\n    (mouseleave)=\"inputClearable = undefined\"\n    [floatLabel]=\"floatLabel\"\n  >\n    <input\n      matInput\n      [placeholder]=\"'igo.geo.filter.placeholder' | translate\"\n      [disabled]=\"!currentFilter.active\"\n      [matAutocomplete]=\"autoDualValueOperator1\"\n      type=\"number\"\n      [value]=\"\n        detectProperty(1) === 'lowerBoundary'\n          ? currentFilter.lowerBoundary\n          : currentFilter.begin\n      \"\n      (input)=\"updateValuesList($event.target.value, 1)\"\n    />\n    <mat-autocomplete\n      #autoDualValueOperator1=\"matAutocomplete\"\n      (optionSelected)=\"changeNumericProperty($event.option.value, 1)\"\n    >\n      <mat-option\n        *ngFor=\"let value of filteredValues$ | async\"\n        matTooltipShowDelay=\"500\"\n        [value]=\"value\"\n        [matTooltip]=\"value\"\n      >\n        {{ value }}\n      </mat-option>\n    </mat-autocomplete>\n    <button\n      *ngIf=\"\n        isClearable(1) &&\n        inputClearable === 'selectProperty1' &&\n        currentFilter.active\n      \"\n      matSuffix\n      mat-icon-button\n      aria-label=\"Clear\"\n      [disabled]=\"!currentFilter.active\"\n      (click)=\"clearProperty(1)\"\n    >\n      <mat-icon svgIcon=\"close\"></mat-icon>\n    </button>\n  </mat-form-field>\n\n  <mat-form-field\n    class=\"dualInput\"\n    *ngIf=\"\n      !isTemporalOperator() &&\n      ['upperBoundary', 'end'].indexOf(detectProperty(2)) !== -1\n    \"\n    (mouseenter)=\"inputClearable = 'selectProperty2'\"\n    (mouseleave)=\"inputClearable = undefined\"\n    [floatLabel]=\"floatLabel\"\n  >\n    <input\n      matInput\n      [placeholder]=\"'igo.geo.filter.placeholder' | translate\"\n      [disabled]=\"!currentFilter.active\"\n      [matAutocomplete]=\"autoDualValueOperator2\"\n      type=\"number\"\n      [value]=\"\n        detectProperty(2) === 'upperBoundary'\n          ? currentFilter.upperBoundary\n          : currentFilter.end\n      \"\n      (input)=\"updateValuesList($event.target.value, 2)\"\n    />\n    <mat-autocomplete\n      #autoDualValueOperator2=\"matAutocomplete\"\n      (optionSelected)=\"changeNumericProperty($event.option.value, 2)\"\n    >\n      <mat-option\n        *ngFor=\"let value of filteredValues$ | async\"\n        matTooltipShowDelay=\"500\"\n        [value]=\"value\"\n        [matTooltip]=\"value\"\n      >\n        {{ value }}\n      </mat-option>\n    </mat-autocomplete>\n    <button\n      *ngIf=\"\n        isClearable(2) &&\n        inputClearable === 'selectProperty2' &&\n        currentFilter.active\n      \"\n      matSuffix\n      mat-icon-button\n      aria-label=\"Clear\"\n      [disabled]=\"!currentFilter.active\"\n      (click)=\"clearProperty(2)\"\n    >\n      <mat-icon svgIcon=\"close\"></mat-icon>\n    </button>\n  </mat-form-field>\n</div>\n\n<igo-ogc-filter-time\n  *ngIf=\"isTemporalOperator()\"\n  [(datasource)]=\"datasource\"\n  [(currentFilter)]=\"currentFilter\"\n  (changeProperty)=\"changeProperty($event.value, $event.pos)\"\n>\n</igo-ogc-filter-time>\n", styles: [":host{width:100%;padding:5px 10px}:host ::ng-deep .mat-mdc-form-field .mat-icon svg{width:1em;height:1em;color:#d3d3d3}:host .ogc-filter-form-container{display:flex}:host .mat-mdc-form-field{width:100%}:host .mat-mdc-select-arrow{visibility:hidden}:host .mat-mdc-slide-toggle{margin-top:10px}:host .logical{flex-flow:column nowrap;width:100%;max-width:60px;margin-right:5px}:host .logicalHidden{width:0px;visibility:hidden;max-width:0px}:host ::ng-deep .logical .mat-mdc-select-arrow{visibility:hidden}:host ::ng-deep .logicalHidden .mat-mdc-select-arrow{visibility:hidden}:host .field{width:150px;margin-right:5px}:host ::ng-deep .field .mat-mdc-select-arrow{visibility:hidden}:host .operator{width:150px;margin-right:5px;text-align:center}:host ::ng-deep .operator .mat-mdc-select-arrow{visibility:hidden}:host .spatialSelector{width:110px;margin-right:5px}:host ::ng-deep .spatialSelector .mat-mdc-select-arrow{visibility:hidden}:host .singleInput{width:150px;margin-right:5px}@media only screen and (orientation:portrait) and (max-width: 599px),only screen and (orientation:landscape) and (max-width: 959px){:host .singleInput{width:27%}}:host .snrc{width:110px;margin-right:5px}:host ::ng-deep .singleInput .mat-mdc-select-arrow{visibility:hidden}:host .dualInput{width:150px;margin-right:5px}:host ::ng-deep .dualInput .mat-mdc-select-arrow{visibility:hidden}:host .igo-layer-button-group{display:flex;padding-top:5px}:host .container{display:flex}\n"], dependencies: [{ kind: "directive", type: i2$2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i6$2.MatAutocomplete, selector: "mat-autocomplete", inputs: ["disableRipple", "hideSingleSelectionIndicator"], exportAs: ["matAutocomplete"] }, { kind: "component", type: i9.MatOption, selector: "mat-option", exportAs: ["matOption"] }, { kind: "directive", type: i6$2.MatAutocompleteTrigger, selector: "input[matAutocomplete], textarea[matAutocomplete]", exportAs: ["matAutocompleteTrigger"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "component", type: i11.MatCheckbox, selector: "mat-checkbox", inputs: ["disableRipple", "color", "tabIndex"], exportAs: ["matCheckbox"] }, { kind: "component", type: i8.MatFormField, selector: "mat-form-field", inputs: ["hideRequiredMarker", "color", "floatLabel", "appearance", "subscriptSizing", "hintLabel"], exportAs: ["matFormField"] }, { kind: "directive", type: i8.MatSuffix, selector: "[matSuffix], [matIconSuffix], [matTextSuffix]", inputs: ["matTextSuffix"] }, { kind: "directive", type: i9$3.MatInput, selector: "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", inputs: ["disabled", "id", "placeholder", "name", "required", "type", "errorStateMatcher", "aria-describedby", "value", "readonly"], exportAs: ["matInput"] }, { kind: "component", type: i15.MatSelect, selector: "mat-select", inputs: ["disabled", "disableRipple", "tabIndex", "panelWidth", "hideSingleSelectionIndicator"], exportAs: ["matSelect"] }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "component", type: OgcFilterTimeComponent, selector: "igo-ogc-filter-time", inputs: ["datasource", "currentFilter"], outputs: ["changeProperty"] }, { kind: "pipe", type: i2$2.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }, { kind: "pipe", type: i9$1.KeyValuePipe, name: "keyvalue" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OgcFilterFormComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-ogc-filter-form', template: "<div class=\"ogc-filter-form-container\">\n  <mat-checkbox\n    tooltip-position=\"below\"\n    matTooltipShowDelay=\"500\"\n    [matTooltip]=\"'igo.geo.filter.toggleFilterState' | translate\"\n    (click)=\"$event.stopPropagation()\"\n    (change)=\"toggleFilterState($event)\"\n    [checked]=\"currentFilter.active\"\n  >\n  </mat-checkbox>\n\n  <mat-form-field\n    [ngClass]=\"{\n      logical:\n        activeFilters.indexOf(currentFilter) !== 0 &&\n        currentFilter.active === true,\n      logicalHidden:\n        activeFilters.indexOf(currentFilter) === 0 ||\n        currentFilter.active !== true\n    }\"\n  >\n    <mat-select\n      [disabled]=\"!currentFilter.active\"\n      [value]=\"currentFilter.parentLogical\"\n      tooltip-position=\"above\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"\n        currentFilter.parentLogical\n          ? ('igo.geo.operators.tooltip.' + currentFilter.parentLogical\n            | translate)\n          : ''\n      \"\n      (selectionChange)=\"changeLogical($event.value)\"\n    >\n      <mat-option\n        [value]=\"ogcFilterOperator.And\"\n        tooltip-position=\"above\"\n        matTooltipShowDelay=\"500\"\n        [matTooltip]=\"'igo.geo.operators.tooltip.And' | translate\"\n      >\n        {{ 'igo.geo.operators.And' | translate }}\n      </mat-option>\n      <mat-option\n        [value]=\"ogcFilterOperator.Or\"\n        tooltip-position=\"above\"\n        matTooltipShowDelay=\"500\"\n        [matTooltip]=\"'igo.geo.operators.tooltip.Or' | translate\"\n      >\n        {{ 'igo.geo.operators.Or' | translate }}\n      </mat-option>\n    </mat-select>\n  </mat-form-field>\n\n  <mat-form-field\n    class=\"field\"\n    *ngIf=\"\n      (currentFilterIsSpatial$ | async) === false &&\n      (fields$ | async) &&\n      (fields$ | async).length > 0 &&\n      (fields$ | async)[0].name !== ''\n    \"\n    (mouseenter)=\"inputClearable = 'selectField'\"\n    (mouseleave)=\"inputClearable = undefined\"\n    [floatLabel]=\"floatLabel\"\n  >\n    <input\n      matInput\n      [placeholder]=\"'igo.geo.sourceFields.selectField' | translate\"\n      [disabled]=\"!currentFilter.active\"\n      [matAutocomplete]=\"autoCompleteField\"\n      [value]=\"(selectedField$ | async) ? (selectedField$ | async).alias : ''\"\n      tooltip-position=\"above\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"\n        (selectedField$ | async)\n          ? (selectedField$ | async).alias\n          : ('igo.geo.sourceFields.selectField' | translate)\n      \"\n      (input)=\"updateFieldsList($event.target.value)\"\n    />\n    <mat-autocomplete\n      #autoCompleteField=\"matAutocomplete\"\n      (optionSelected)=\"changeField($event.option.id)\"\n    >\n      <mat-option\n        *ngFor=\"let field of filteredFields$ | async\"\n        matTooltipShowDelay=\"500\"\n        [value]=\"field.alias\"\n        [id]=\"field.name\"\n        [matTooltip]=\"field.alias\"\n      >\n        {{ field.alias }}\n      </mat-option>\n    </mat-autocomplete>\n    <button\n      *ngIf=\"\n        currentFilter.propertyName &&\n        inputClearable === 'selectField' &&\n        currentFilter.active\n      \"\n      matSuffix\n      mat-icon-button\n      aria-label=\"Clear\"\n      [disabled]=\"!currentFilter.active\"\n      (click)=\"clearSelectedField()\"\n    >\n      <mat-icon svgIcon=\"close\"></mat-icon>\n    </button>\n  </mat-form-field>\n\n  <mat-form-field\n    [ngClass]=\"{\n      operator: (currentFilterIsSpatial$ | async) === false,\n      dualInput: (currentFilterIsSpatial$ | async)\n    }\"\n    [floatLabel]=\"floatLabel\"\n  >\n    <mat-select\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"\n        currentFilter.operator\n          ? ('igo.geo.operators.tooltip.' + currentFilter.operator | translate)\n          : ('igo.geo.filter.selectOperator' | translate)\n      \"\n      [disabled]=\"!currentFilter.active\"\n      [value]=\"currentFilter.operator\"\n      (selectionChange)=\"changeOperator($event.value)\"\n    >\n      <mat-option\n        *ngFor=\"let operator of ogcFilterOperators$ | async | keyvalue\"\n        tooltip-position=\"above\"\n        matTooltipShowDelay=\"500\"\n        [value]=\"operator.key\"\n        [matTooltip]=\"'igo.geo.operators.tooltip.' + operator.key | translate\"\n      >\n        {{ 'igo.geo.operators.' + operator.key | translate }}\n      </mat-option>\n    </mat-select>\n  </mat-form-field>\n\n  <mat-form-field\n    class=\"spatialSelector\"\n    *ngIf=\"currentFilterIsSpatial$ | async\"\n  >\n    <mat-select\n      [disabled]=\"!currentFilter.active\"\n      [value]=\"currentFilter.igoSpatialSelector\"\n      (selectionChange)=\"changeSpatialSelector($event.value)\"\n    >\n      <mat-option\n        *ngFor=\"let igoSpatialSelector of igoSpatialSelectors\"\n        [value]=\"igoSpatialSelector.type\"\n      >\n        {{ 'igo.geo.spatialSelector.' + igoSpatialSelector.type | translate }}\n      </mat-option>\n    </mat-select>\n  </mat-form-field>\n\n  <mat-form-field\n    class=\"singleInput\"\n    *ngIf=\"['expression', 'pattern'].indexOf(detectProperty()) !== -1\"\n    (mouseenter)=\"inputClearable = 'selectProperty'\"\n    (mouseleave)=\"inputClearable = undefined\"\n    [floatLabel]=\"floatLabel\"\n  >\n    <input\n      matInput\n      [placeholder]=\"'igo.geo.filter.placeholder' | translate\"\n      [disabled]=\"!currentFilter.active\"\n      [matAutocomplete]=\"autoCompleteValues\"\n      [value]=\"\n        detectProperty() === 'expression'\n          ? currentFilter.expression\n          : currentFilter.pattern\n      \"\n      tooltip-position=\"above\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"\n        detectProperty() === 'expression'\n          ? currentFilter.expression || ''\n          : currentFilter.pattern || ''\n      \"\n      (input)=\"updateValuesList($event.target.value)\"\n    />\n    <mat-autocomplete\n      #autoCompleteValues=\"matAutocomplete\"\n      (optionSelected)=\"changeProperty($event.option.value)\"\n    >\n      <mat-option\n        *ngFor=\"let value of filteredValues$ | async\"\n        matTooltipShowDelay=\"500\"\n        [value]=\"value\"\n        [matTooltip]=\"value\"\n      >\n        {{ value }}\n      </mat-option>\n    </mat-autocomplete>\n    <button\n      *ngIf=\"\n        isClearable() &&\n        inputClearable === 'selectProperty' &&\n        currentFilter.active\n      \"\n      matSuffix\n      mat-icon-button\n      aria-label=\"Clear\"\n      [disabled]=\"!currentFilter.active\"\n      (click)=\"clearProperty()\"\n    >\n      <mat-icon svgIcon=\"close\"></mat-icon>\n    </button>\n  </mat-form-field>\n\n  <div class=\"igo-layer-button-group\">\n    <button\n      mat-icon-button\n      collapsibleButton\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"'igo.geo.filter.removeFilter' | translate\"\n      color=\"warn\"\n      (click)=\"deleteFilter()\"\n    >\n      <mat-icon svgIcon=\"delete\"></mat-icon>\n    </button>\n  </div>\n\n  <mat-form-field\n    class=\"snrc\"\n    *ngIf=\"\n      (currentFilterIsSpatial$ | async) &&\n      currentFilter.igoSpatialSelector === 'snrc'\n    \"\n    (mouseenter)=\"inputClearable = 'selectSNRC'\"\n    (mouseleave)=\"inputClearable = undefined\"\n    [floatLabel]=\"floatLabel\"\n  >\n    <input\n      matInput\n      [placeholder]=\"'igo.geo.filter.placeholderSnrc' | translate\"\n      [value]=\"currentFilter.igoSNRC\"\n      tooltip-position=\"above\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"currentFilter.igoSNRC ? currentFilter.igoSNRC : ''\"\n      (input)=\"changeSNRC($event.target.value)\"\n    />\n    <button\n      *ngIf=\"currentFilter.igoSNRC\"\n      matSuffix\n      mat-icon-button\n      aria-label=\"Clear\"\n      [disabled]=\"\n        !currentFilter.active &&\n        inputClearable === 'selectSNRC' &&\n        currentFilter.active\n      \"\n      (click)=\"currentFilter.igoSNRC = ''\"\n    >\n      <mat-icon svgIcon=\"close\"></mat-icon>\n    </button>\n  </mat-form-field>\n\n  <ng-container\n    *ngIf=\"\n      (currentFilterIsSpatial$ | async) &&\n      currentFilter.igoSpatialSelector === 'fixedExtent'\n    \"\n  >\n    <button\n      [disabled]=\"!currentFilter.active\"\n      *ngIf=\"currentFilter.igoSpatialSelector === 'fixedExtent'\"\n      matSuffix\n      mat-icon-button\n      [disabled]=\"!currentFilter.active\"\n      (click)=\"changeMapExtentGeometry()\"\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"'igo.geo.spatialSelector.btnSetExtent' | translate\"\n    >\n      <mat-icon svgIcon=\"arrow-expand-all\"></mat-icon>\n    </button>\n  </ng-container>\n</div>\n\n<div class=\"ogc-filter-form-container\">\n  <mat-form-field\n    class=\"dualInput\"\n    *ngIf=\"\n      !isTemporalOperator() &&\n      ['lowerBoundary', 'begin'].indexOf(detectProperty(1)) !== -1\n    \"\n    (mouseenter)=\"inputClearable = 'selectProperty1'\"\n    (mouseleave)=\"inputClearable = undefined\"\n    [floatLabel]=\"floatLabel\"\n  >\n    <input\n      matInput\n      [placeholder]=\"'igo.geo.filter.placeholder' | translate\"\n      [disabled]=\"!currentFilter.active\"\n      [matAutocomplete]=\"autoDualValueOperator1\"\n      type=\"number\"\n      [value]=\"\n        detectProperty(1) === 'lowerBoundary'\n          ? currentFilter.lowerBoundary\n          : currentFilter.begin\n      \"\n      (input)=\"updateValuesList($event.target.value, 1)\"\n    />\n    <mat-autocomplete\n      #autoDualValueOperator1=\"matAutocomplete\"\n      (optionSelected)=\"changeNumericProperty($event.option.value, 1)\"\n    >\n      <mat-option\n        *ngFor=\"let value of filteredValues$ | async\"\n        matTooltipShowDelay=\"500\"\n        [value]=\"value\"\n        [matTooltip]=\"value\"\n      >\n        {{ value }}\n      </mat-option>\n    </mat-autocomplete>\n    <button\n      *ngIf=\"\n        isClearable(1) &&\n        inputClearable === 'selectProperty1' &&\n        currentFilter.active\n      \"\n      matSuffix\n      mat-icon-button\n      aria-label=\"Clear\"\n      [disabled]=\"!currentFilter.active\"\n      (click)=\"clearProperty(1)\"\n    >\n      <mat-icon svgIcon=\"close\"></mat-icon>\n    </button>\n  </mat-form-field>\n\n  <mat-form-field\n    class=\"dualInput\"\n    *ngIf=\"\n      !isTemporalOperator() &&\n      ['upperBoundary', 'end'].indexOf(detectProperty(2)) !== -1\n    \"\n    (mouseenter)=\"inputClearable = 'selectProperty2'\"\n    (mouseleave)=\"inputClearable = undefined\"\n    [floatLabel]=\"floatLabel\"\n  >\n    <input\n      matInput\n      [placeholder]=\"'igo.geo.filter.placeholder' | translate\"\n      [disabled]=\"!currentFilter.active\"\n      [matAutocomplete]=\"autoDualValueOperator2\"\n      type=\"number\"\n      [value]=\"\n        detectProperty(2) === 'upperBoundary'\n          ? currentFilter.upperBoundary\n          : currentFilter.end\n      \"\n      (input)=\"updateValuesList($event.target.value, 2)\"\n    />\n    <mat-autocomplete\n      #autoDualValueOperator2=\"matAutocomplete\"\n      (optionSelected)=\"changeNumericProperty($event.option.value, 2)\"\n    >\n      <mat-option\n        *ngFor=\"let value of filteredValues$ | async\"\n        matTooltipShowDelay=\"500\"\n        [value]=\"value\"\n        [matTooltip]=\"value\"\n      >\n        {{ value }}\n      </mat-option>\n    </mat-autocomplete>\n    <button\n      *ngIf=\"\n        isClearable(2) &&\n        inputClearable === 'selectProperty2' &&\n        currentFilter.active\n      \"\n      matSuffix\n      mat-icon-button\n      aria-label=\"Clear\"\n      [disabled]=\"!currentFilter.active\"\n      (click)=\"clearProperty(2)\"\n    >\n      <mat-icon svgIcon=\"close\"></mat-icon>\n    </button>\n  </mat-form-field>\n</div>\n\n<igo-ogc-filter-time\n  *ngIf=\"isTemporalOperator()\"\n  [(datasource)]=\"datasource\"\n  [(currentFilter)]=\"currentFilter\"\n  (changeProperty)=\"changeProperty($event.value, $event.pos)\"\n>\n</igo-ogc-filter-time>\n", styles: [":host{width:100%;padding:5px 10px}:host ::ng-deep .mat-mdc-form-field .mat-icon svg{width:1em;height:1em;color:#d3d3d3}:host .ogc-filter-form-container{display:flex}:host .mat-mdc-form-field{width:100%}:host .mat-mdc-select-arrow{visibility:hidden}:host .mat-mdc-slide-toggle{margin-top:10px}:host .logical{flex-flow:column nowrap;width:100%;max-width:60px;margin-right:5px}:host .logicalHidden{width:0px;visibility:hidden;max-width:0px}:host ::ng-deep .logical .mat-mdc-select-arrow{visibility:hidden}:host ::ng-deep .logicalHidden .mat-mdc-select-arrow{visibility:hidden}:host .field{width:150px;margin-right:5px}:host ::ng-deep .field .mat-mdc-select-arrow{visibility:hidden}:host .operator{width:150px;margin-right:5px;text-align:center}:host ::ng-deep .operator .mat-mdc-select-arrow{visibility:hidden}:host .spatialSelector{width:110px;margin-right:5px}:host ::ng-deep .spatialSelector .mat-mdc-select-arrow{visibility:hidden}:host .singleInput{width:150px;margin-right:5px}@media only screen and (orientation:portrait) and (max-width: 599px),only screen and (orientation:landscape) and (max-width: 959px){:host .singleInput{width:27%}}:host .snrc{width:110px;margin-right:5px}:host ::ng-deep .singleInput .mat-mdc-select-arrow{visibility:hidden}:host .dualInput{width:150px;margin-right:5px}:host ::ng-deep .dualInput .mat-mdc-select-arrow{visibility:hidden}:host .igo-layer-button-group{display:flex;padding-top:5px}:host .container{display:flex}\n"] }]
        }], ctorParameters: function () { return [{ type: WktService }]; }, propDecorators: { refreshFilters: [{
                type: Input
            }], datasource: [{
                type: Input
            }], map: [{
                type: Input
            }], currentFilter: [{
                type: Input
            }], floatLabel: [{
                type: Input
            }] } });

class OgcFilterSelectionComponent {
    ogcFilterService;
    formBuilder;
    domService;
    configService;
    cdRef;
    sel;
    refreshFilters;
    datasource;
    map;
    checkboxesIndex = 5;
    radioButtonsIndex = 5;
    baseIndex = 5;
    get currentFilter() {
        return this._currentFilter;
    }
    set currentFilter(value) {
        this._currentFilter = value;
        if (this._currentFilter?.sliderOptions) {
            this._currentFilter.sliderOptions.enabled = false; // remove slider toggle (animation temporelle)
        }
    }
    _currentFilter;
    ogcFilterOperator = OgcFilterOperator;
    form;
    ogcFilterWriter;
    color = 'primary';
    selectAllSelected = false;
    selectEnabled$ = new BehaviorSubject(undefined);
    selectEnableds$ = new BehaviorSubject([]);
    autocompleteEnabled$ = new BehaviorSubject(undefined);
    filteredOgcAutocomplete = {};
    applyFiltersTimeout;
    get ogcFiltersSelectors() {
        const ogcSelector = [];
        if (this.datasource?.options?.ogcFilters?.pushButtons) {
            ogcSelector.push(this.datasource?.options?.ogcFilters?.pushButtons);
        }
        if (this.datasource?.options?.ogcFilters?.checkboxes) {
            ogcSelector.push(this.datasource?.options?.ogcFilters?.checkboxes);
        }
        if (this.datasource?.options?.ogcFilters?.radioButtons) {
            ogcSelector.push(this.datasource?.options?.ogcFilters?.radioButtons);
        }
        if (this.datasource?.options?.ogcFilters?.select) {
            ogcSelector.push(this.datasource?.options?.ogcFilters?.select);
        }
        if (this.datasource?.options?.ogcFilters?.autocomplete) {
            ogcSelector.push(this.datasource?.options?.ogcFilters?.autocomplete);
        }
        ogcSelector.sort((a, b) => {
            if (a.order < b.order) {
                return -1;
            }
            if (a.order > b.order) {
                return 1;
            }
            return 0;
        });
        return ogcSelector;
    }
    get currentPushButtonsGroup() {
        return this.form.get('pushButtonsGroup').value;
    }
    set currentPushButtonsGroup(value) {
        this.form.patchValue({ pushButtonsGroup: value });
    }
    get currentCheckboxesGroup() {
        return this.form.get('checkboxesGroup').value;
    }
    set currentCheckboxesGroup(value) {
        this.form.patchValue({ checkboxesGroup: value });
    }
    get currentRadioButtonsGroup() {
        return this.form.get('radioButtonsGroup').value;
    }
    set currentRadioButtonsGroup(value) {
        this.form.patchValue({ radioButtonsGroup: value });
    }
    get currentSelectGroup() {
        return this.form.get('selectGroup').value;
    }
    set currentSelectGroup(value) {
        this.form.patchValue({ selectGroup: value });
        this.cdRef.detectChanges();
    }
    get currentAutocompleteGroup() {
        return this.form.get('autocompleteGroup').value;
    }
    set currentAutocompleteGroup(value) {
        this.form.patchValue({ autocompleteGroup: value });
        this.cdRef.detectChanges();
    }
    get selectEnabled() {
        return this.selectEnabled$.value;
    }
    set selectEnabled(value) {
        this.selectEnabled$.next(value);
        clearTimeout(this.applyFiltersTimeout);
        this.currentSelectGroup.computedSelectors.forEach((compSelect) => {
            compSelect.selectors?.forEach((selector) => {
                value === selector
                    ? (selector.enabled = true)
                    : (selector.enabled = false);
            });
        });
        this.applyFiltersTimeout = setTimeout(() => {
            this.applyFilters();
        }, 750);
    }
    get selectEnableds() {
        return this.selectEnableds$.value;
    }
    set selectEnableds(value) {
        this.selectEnableds$.next(value);
        clearTimeout(this.applyFiltersTimeout);
        this.currentSelectGroup.computedSelectors.forEach((compSelect) => {
            compSelect.selectors?.forEach((selector) => {
                value.includes(selector)
                    ? (selector.enabled = true)
                    : (selector.enabled = false);
            });
        });
        this.applyFiltersTimeout = setTimeout(() => {
            this.applyFilters();
        }, 750);
    }
    get autocompleteEnabled() {
        return this.autocompleteEnabled$.value;
    }
    set autocompleteEnabled(value) {
        this.autocompleteEnabled$.next(value);
        clearTimeout(this.applyFiltersTimeout);
        this.currentAutocompleteGroup.computedSelectors.forEach((compSelect) => {
            compSelect.selectors?.forEach((selector) => {
                value === selector.title
                    ? (selector.enabled = true)
                    : (selector.enabled = false);
            });
        });
        this.applyFiltersTimeout = setTimeout(() => {
            this.applyFilters();
        }, 750);
    }
    constructor(ogcFilterService, formBuilder, domService, configService, cdRef) {
        this.ogcFilterService = ogcFilterService;
        this.formBuilder = formBuilder;
        this.domService = domService;
        this.configService = configService;
        this.cdRef = cdRef;
        this.ogcFilterWriter = new OgcFilterWriter();
        this.buildForm();
    }
    buildForm() {
        this.form = this.formBuilder.group({
            pushButtons: ['', [Validators.required]],
            radioButtons: ['', [Validators.required]],
            pushButtonsGroup: ['', [Validators.required]],
            checkboxesGroup: ['', [Validators.required]],
            radioButtonsGroup: ['', [Validators.required]],
            selectGroup: ['', [Validators.required]],
            select: ['', [Validators.required]],
            selectMulti: ['', [Validators.required]],
            autocompleteGroup: ['', [Validators.required]],
            autocomplete: ['', [Validators.required]]
        });
    }
    getPushButtonsGroups() {
        if (this.datasource?.options?.ogcFilters?.pushButtons) {
            return this.datasource.options.ogcFilters.pushButtons.groups;
        }
    }
    getCheckboxesGroups() {
        if (this.datasource?.options?.ogcFilters?.checkboxes) {
            return this.datasource.options.ogcFilters.checkboxes.groups;
        }
    }
    getRadioButtonsGroups() {
        if (this.datasource?.options?.ogcFilters?.radioButtons) {
            return this.datasource.options.ogcFilters.radioButtons.groups;
        }
    }
    getSelectGroups() {
        if (this.datasource?.options?.ogcFilters?.select) {
            return this.datasource.options.ogcFilters.select.groups;
        }
    }
    getAutocompleteGroups() {
        if (this.datasource?.options?.ogcFilters?.autocomplete) {
            return this.datasource.options.ogcFilters.autocomplete.groups;
        }
    }
    async ngOnInit() {
        if (this.datasource.options.ogcFilters) {
            if (this.datasource.options.ogcFilters.pushButtons) {
                this.currentPushButtonsGroup =
                    this.datasource.options.ogcFilters.pushButtons.groups.find((group) => group.enabled) || this.datasource.options.ogcFilters.pushButtons.groups[0];
            }
            if (this.datasource.options.ogcFilters.checkboxes) {
                this.currentCheckboxesGroup =
                    this.datasource.options.ogcFilters.checkboxes.groups.find((group) => group.enabled) || this.datasource.options.ogcFilters.checkboxes.groups[0];
            }
            if (this.datasource.options.ogcFilters.radioButtons) {
                this.currentRadioButtonsGroup =
                    this.datasource.options.ogcFilters.radioButtons.groups.find((group) => group.enabled) || this.datasource.options.ogcFilters.radioButtons.groups[0];
            }
            if (this.datasource.options.ogcFilters.select) {
                this.currentSelectGroup =
                    this.datasource.options.ogcFilters.select.groups.find((group) => group.enabled) || this.datasource.options.ogcFilters.select.groups[0];
                this.getSelectEnabled();
                await this.getSelectDomValues();
            }
            if (this.datasource.options.ogcFilters.autocomplete) {
                this.currentAutocompleteGroup =
                    this.datasource.options.ogcFilters.autocomplete.groups.find((group) => group.enabled) || this.datasource.options.ogcFilters.autocomplete.groups[0];
                this.getAutocompleteEnabled();
                await this.getAutocompleteDomValues();
            }
            this.applyFilters();
        }
        this.form
            .get('pushButtonsGroup')
            .valueChanges.pipe(debounceTime(750))
            .subscribe(() => {
            this.onPushButtonsChangeGroup();
            this.applyFilters();
        });
        this.form
            .get('checkboxesGroup')
            .valueChanges.pipe(debounceTime(750))
            .subscribe(() => {
            this.onCheckboxesChangeGroup();
            this.applyFilters();
        });
        this.form
            .get('radioButtonsGroup')
            .valueChanges.pipe(debounceTime(750))
            .subscribe(() => {
            this.onRadioButtonsChangeGroup();
            this.applyFilters();
        });
        this.form
            .get('selectGroup')
            .valueChanges.pipe(debounceTime(750))
            .subscribe(() => {
            this.onSelectChangeGroup();
            this.applyFilters();
        });
        this.form
            .get('autocompleteGroup')
            .valueChanges.pipe(debounceTime(750))
            .subscribe(() => {
            this.onAutocompleteChangeGroup();
            this.applyFilters();
        });
        this.form
            .get('pushButtons')
            .valueChanges.pipe(debounceTime(750))
            .subscribe(() => {
            this.applyFilters();
        });
        this.form
            .get('radioButtons')
            .valueChanges.pipe(debounceTime(750))
            .subscribe(() => {
            this.applyFilters();
        });
    }
    getSelectEnabled() {
        const enableds = [];
        let enabled;
        this.currentSelectGroup.computedSelectors.forEach((compSelect) => {
            if (compSelect.multiple) {
                compSelect.selectors?.forEach((selector) => {
                    if (selector.enabled) {
                        enableds.push(selector);
                    }
                });
                this.selectEnableds = enableds;
                this.form.controls['selectMulti'].setValue(enableds);
            }
            else {
                compSelect.selectors?.forEach((selector) => {
                    if (selector.enabled) {
                        enabled = selector;
                    }
                });
                this.form.controls['select'].reset(enabled);
                this.selectEnabled$.subscribe((value) => {
                    if (this.form.controls['select'].value !== value) {
                        this.form.controls['select'].setValue(value);
                    }
                });
                this.selectEnabled = enabled;
            }
        });
    }
    getAutocompleteEnabled() {
        let enabled;
        this.currentAutocompleteGroup.computedSelectors.forEach((compSelect) => {
            compSelect.selectors?.forEach((selector) => {
                if (selector.enabled) {
                    const dom = {
                        id: selector.filters.expression,
                        value: selector.title
                    };
                    enabled = selector.title;
                    this.form.controls['autocomplete'].setValue(dom);
                }
            });
            this.autocompleteEnabled = enabled;
        });
    }
    getToolTip(selector) {
        let toolTip;
        if (selector.tooltip) {
            if (Array.isArray(selector.tooltip)) {
                toolTip = selector.tooltip.join('\n');
            }
            else {
                toolTip = selector.tooltip;
            }
        }
        return toolTip || '';
    }
    async getSelectDomValues() {
        for (const bundle of this.datasource.options.ogcFilters.select.bundles) {
            if (bundle.domSelectors) {
                let domValues;
                for (const domSelector of bundle.domSelectors) {
                    let filterDOM;
                    for (const domOptions of this.configService.getConfig('dom')) {
                        if (domSelector.id === domOptions.id ||
                            domSelector.name === domOptions.name) {
                            filterDOM = {
                                id: domOptions.id,
                                url: domOptions.url,
                                name: domOptions.name,
                                values: domOptions.values
                            };
                        }
                    }
                    filterDOM.url
                        ? (domValues = (await this.domService.getDom(filterDOM)))
                        : (domValues = filterDOM.values);
                    if (domValues) {
                        let newBundle = bundle;
                        newBundle.selectors = [];
                        let selector;
                        for (const value of domValues) {
                            if (bundle.multiple) {
                                let enabled;
                                this.selectEnableds?.find((sel) => sel.title === value.value)
                                    ? (enabled = true)
                                    : (enabled = false);
                                selector = {
                                    title: value.value,
                                    enabled,
                                    filters: {
                                        operator: domSelector.operator,
                                        propertyName: domSelector.propertyName,
                                        expression: value.id
                                    }
                                };
                            }
                            else {
                                selector = {
                                    title: value.value,
                                    enabled: this.selectEnabled?.title === value.value ? true : false,
                                    filters: {
                                        operator: domSelector.operator,
                                        propertyName: domSelector.propertyName,
                                        expression: value.id
                                    }
                                };
                            }
                            newBundle.selectors.push(selector);
                        }
                        this.getSelectGroups()
                            .find((group) => group.ids.includes(newBundle.id))
                            .computedSelectors.find((comp) => comp.title === newBundle.title).selectors = newBundle.selectors;
                    }
                }
                this.getSelectEnabled();
            }
        }
    }
    async getAutocompleteDomValues() {
        for (const bundle of this.datasource.options.ogcFilters.autocomplete
            .bundles) {
            if (bundle.domSelectors) {
                let domValues;
                for (const domSelector of bundle.domSelectors) {
                    let filterDOM;
                    for (const domOptions of this.configService.getConfig('dom')) {
                        if (domSelector.id === domOptions.id ||
                            domSelector.name === domOptions.name) {
                            filterDOM = {
                                id: domOptions.id,
                                url: domOptions.url,
                                name: domOptions.name,
                                values: domOptions.values
                            };
                        }
                    }
                    filterDOM.url
                        ? (domValues = (await this.domService.getDom(filterDOM)))
                        : (domValues = filterDOM.values);
                    if (domValues) {
                        let newBundle = bundle;
                        newBundle.selectors = [];
                        let selector;
                        for (const value of domValues) {
                            selector = {
                                title: value.value,
                                enabled: this.autocompleteEnabled &&
                                    this.autocompleteEnabled === value.value
                                    ? true
                                    : false,
                                filters: {
                                    operator: domSelector.operator,
                                    propertyName: domSelector.propertyName,
                                    expression: value.id
                                }
                            };
                            newBundle.selectors.push(selector);
                        }
                        this.getAutocompleteGroups()
                            .find((group) => group.ids.includes(newBundle.id))
                            .computedSelectors.find((comp) => comp.title === newBundle.title).selectors = newBundle.selectors;
                    }
                }
                this.filteredOgcAutocomplete[bundle.id] = new Observable();
                this.cdRef.detectChanges();
                this.filteredOgcAutocomplete[bundle.id] = this.form.controls['autocomplete'].valueChanges.pipe(map((value) => {
                    if (value.length) {
                        return domValues?.filter((option) => {
                            const filterNormalized = value
                                ? value
                                    .toLowerCase()
                                    .normalize('NFD')
                                    .replace(/[\u0300-\u036f]/g, '')
                                : '';
                            const featureNameNormalized = option.value
                                .toLowerCase()
                                .normalize('NFD')
                                .replace(/[\u0300-\u036f]/g, '');
                            return featureNameNormalized.includes(filterNormalized);
                        });
                    }
                }));
            }
        }
    }
    // getButtonStyle(pb: OgcPushButton): {} {
    //   let styles;
    //   if (pb.color) {
    //     styles = {
    //       'background-color': pb.enabled ? `rgba(${pb.color})` : `rgba(255,255,255,0)`
    //     };
    //   } else {
    //     styles = {
    //       'background-color': pb.enabled ? 'accent': `rgba(255,255,255,0)`,
    //       'color': pb.enabled ? `rgba(0,0,0,0.9)` : `rgba(33,33,33,0.38)`
    //     }
    //   }
    //   return styles;
    // }
    getButtonColor(pushButton) {
        let styles;
        if (pushButton.color && pushButton.enabled) {
            styles = {
                'background-color': `rgba(${pushButton.color})`
            };
        }
        return styles;
    }
    bundleIsVertical(bundle) {
        return bundle.vertical ? bundle.vertical : false;
    }
    onPushButtonsChangeGroup() {
        this.getPushButtonsGroups().map((group) => (group.enabled = false));
        this.getPushButtonsGroups().find((group) => group === this.currentPushButtonsGroup).enabled = true;
    }
    onCheckboxesChangeGroup() {
        this.getCheckboxesGroups().map((group) => (group.enabled = false));
        this.getCheckboxesGroups().find((group) => group === this.currentCheckboxesGroup).enabled = true;
    }
    onRadioButtonsChangeGroup() {
        this.getRadioButtonsGroups().map((group) => (group.enabled = false));
        this.getRadioButtonsGroups().find((group) => group === this.currentRadioButtonsGroup).enabled = true;
    }
    onSelectChangeGroup() {
        this.getSelectGroups().map((group) => (group.enabled = false));
        this.getSelectGroups().find((group) => group === this.currentSelectGroup).enabled = true;
    }
    onAutocompleteChangeGroup() {
        this.getAutocompleteGroups().map((group) => (group.enabled = false));
        this.getAutocompleteGroups().find((group) => group === this.currentAutocompleteGroup).enabled = true;
    }
    onSelectionChange(currentOgcSelection, selectorType) {
        clearTimeout(this.applyFiltersTimeout);
        if (selectorType === 'radioButton') {
            this.emptyRadioButtons();
        }
        if (currentOgcSelection) {
            currentOgcSelection.enabled = !currentOgcSelection.enabled;
        }
        this.applyFiltersTimeout = setTimeout(() => {
            this.applyFilters();
        }, 750);
    }
    emptyRadioButtons() {
        this.currentRadioButtonsGroup.computedSelectors.forEach((compSelect) => {
            compSelect.selectors.map((selector) => (selector.enabled = false));
            this.applyFiltersTimeout = setTimeout(() => {
                this.applyFilters();
            }, 750);
        });
    }
    emptySelect() {
        this.selectEnabled = undefined;
    }
    emptyAutocomplete() {
        this.autocompleteEnabled = undefined;
        this.form.controls['autocomplete'].setValue('');
        this.form.controls['autocomplete'].markAsUntouched();
    }
    toggleAllSelection() {
        if (this.selectAllSelected) {
            const enableds = [];
            this.currentSelectGroup.computedSelectors.forEach((compSelect) => {
                compSelect.selectors?.forEach((selector) => {
                    enableds.push(selector);
                });
            });
            this.sel.options.forEach((item) => item.select());
            this.selectEnableds = enableds;
        }
        else {
            this.sel.options.forEach((item) => item.deselect());
            this.selectEnableds = [];
        }
    }
    selectOptionClick(value, bundle, event) {
        if (bundle.multiple) {
            const enableds = this.selectEnableds;
            let newStatus = true;
            this.sel.options.forEach((item) => {
                if (!item.selected) {
                    newStatus = false;
                }
            });
            this.selectAllSelected = newStatus;
            if (event.isUserInput) {
                if (enableds.length) {
                    for (const enabled of enableds) {
                        if (enabled.title === value.title) {
                            if (enabled.enabled && value.enabled) {
                                enableds.splice(enableds.indexOf(enabled), 1);
                                this.selectEnableds = enableds;
                                break;
                            }
                        }
                        else if (enableds.indexOf(enabled) === enableds.length - 1) {
                            enableds.push(value);
                            this.selectEnableds = enableds;
                            break;
                        }
                    }
                }
                else {
                    enableds.push(value);
                    this.selectEnableds = enableds;
                }
            }
        }
        else {
            this.selectEnabled = value;
        }
    }
    autocompleteOptionClick(value) {
        this.autocompleteEnabled = value.value;
    }
    displayFn(dom) {
        return dom ? dom.value : undefined;
    }
    applyFilters() {
        let filterQueryString = '';
        const conditions = [];
        const currentGroups = [
            this.currentPushButtonsGroup,
            this.currentCheckboxesGroup,
            this.currentRadioButtonsGroup,
            this.currentSelectGroup,
            this.currentAutocompleteGroup
        ];
        for (const currentGroup of currentGroups) {
            if (currentGroup.computedSelectors) {
                currentGroup.computedSelectors.map((selectorBundle) => {
                    const bundleCondition = [];
                    selectorBundle.selectors
                        ?.filter((ogcSelector) => ogcSelector.enabled === true)
                        .forEach((enabledSelector) => bundleCondition.push(enabledSelector.filters));
                    if (bundleCondition.length >= 1) {
                        if (bundleCondition.length === 1) {
                            conditions.push(bundleCondition[0]);
                        }
                        else {
                            conditions.push({
                                logical: selectorBundle.logical,
                                filters: bundleCondition
                            });
                        }
                    }
                });
            }
        }
        if (this.isTemporalOperator() && this._currentFilter.active) {
            conditions.push(this.datasource.options.ogcFilters.interfaceOgcFilters[0]);
        }
        if (conditions.length >= 1) {
            filterQueryString = this.ogcFilterWriter.buildFilter(conditions.length === 1
                ? conditions[0]
                : { logical: 'And', filters: conditions });
        }
        if (this.datasource.options.type === 'wms') {
            this.ogcFilterService.filterByOgc(this.datasource, filterQueryString);
        }
        if (this.datasource.options.type === 'wfs') {
            // TODO: Check how to prevent wfs to refresh when filter icon is pushed...
            this.datasource.ol.refresh();
        }
        this.datasource.setOgcFilters(this.datasource.options.ogcFilters, true);
    }
    isMoreResults(bundle, type) {
        let selectorsLength = 0;
        for (const selectors of bundle.selectors) {
            selectorsLength++;
        }
        const index = type === 'radio' ? this.radioButtonsIndex : this.checkboxesIndex;
        return selectorsLength > index;
    }
    displayMoreResults(type) {
        type === 'radio'
            ? (this.radioButtonsIndex += 5)
            : (this.checkboxesIndex += 5);
        return;
    }
    isLessResults(bundle, type) {
        let selectorsLength = 0;
        for (const selectors of bundle.selectors) {
            selectorsLength++;
        }
        const index = type === 'radio' ? this.radioButtonsIndex : this.checkboxesIndex;
        return this.baseIndex !== index && selectorsLength > this.baseIndex;
    }
    displayLessResults(type) {
        type === 'radio'
            ? (this.radioButtonsIndex = this.baseIndex)
            : (this.checkboxesIndex = this.baseIndex);
        return;
    }
    isTemporalOperator() {
        return (this.currentFilter?.operator?.toLowerCase() ===
            this.ogcFilterOperator.During.toLowerCase());
    }
    changeProperty(value, pos, refreshFilter = true) {
        const detectedProperty = this.detectProperty(pos);
        if (detectedProperty) {
            this.datasource.options.ogcFilters.interfaceOgcFilters.find((filter) => filter.filterid === this.currentFilter.filterid)[detectedProperty] = value;
            if (refreshFilter) {
                this.applyFilters();
            }
        }
    }
    detectProperty(pos) {
        switch (this.currentFilter.operator) {
            case OgcFilterOperator.PropertyIsNotEqualTo:
            case OgcFilterOperator.PropertyIsEqualTo:
            case OgcFilterOperator.PropertyIsGreaterThan:
            case OgcFilterOperator.PropertyIsGreaterThanOrEqualTo:
            case OgcFilterOperator.PropertyIsLessThan:
            case OgcFilterOperator.PropertyIsLessThanOrEqualTo:
                return 'expression';
            case OgcFilterOperator.PropertyIsLike:
                return 'pattern';
            case OgcFilterOperator.PropertyIsBetween:
                return pos && pos === 1
                    ? 'lowerBoundary'
                    : pos && pos === 2
                        ? 'upperBoundary'
                        : undefined;
            case OgcFilterOperator.During:
                return pos && pos === 1
                    ? 'begin'
                    : pos && pos === 2
                        ? 'end'
                        : undefined;
            default:
                return;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OgcFilterSelectionComponent, deps: [{ token: OGCFilterService }, { token: i2$1.UntypedFormBuilder }, { token: i9$1.DOMService }, { token: i2.ConfigService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: OgcFilterSelectionComponent, selector: "igo-ogc-filter-selection", inputs: { refreshFilters: "refreshFilters", datasource: "datasource", map: "map", checkboxesIndex: "checkboxesIndex", radioButtonsIndex: "radioButtonsIndex", baseIndex: "baseIndex", currentFilter: "currentFilter" }, providers: [DOMService], viewQueries: [{ propertyName: "sel", first: true, predicate: ["selection"], descendants: true }], ngImport: i0, template: "<form [formGroup]=\"form\">\n  <div *ngFor=\"let selector of ogcFiltersSelectors\">\n    <div\n      class=\"pushButtonGroups\"\n      *ngIf=\"selector.selectorType === 'pushButton'\"\n    >\n      <mat-divider></mat-divider>\n      <div class=\"groupsSelector\" *ngIf=\"getPushButtonsGroups().length > 1\">\n        <mat-form-field>\n          <mat-select\n            formControlName=\"pushButtonsGroup\"\n            [matTooltip]=\"'igo.geo.layer.legend.selectStyle' | translate\"\n            tooltip-position=\"below\"\n            matTooltipShowDelay=\"500\"\n            [(value)]=\"currentPushButtonsGroup\"\n          >\n            <mat-option\n              *ngFor=\"let selectorGroup of getPushButtonsGroups()\"\n              [value]=\"selectorGroup\"\n              >{{ selectorGroup.title }}\n            </mat-option>\n          </mat-select>\n        </mat-form-field>\n      </div>\n      <ng-container\n        *ngFor=\"let bundle of currentPushButtonsGroup.computedSelectors\"\n      >\n        <h3>{{ bundle.title }}</h3>\n        <mat-button-toggle-group\n          formControlName=\"pushButtons\"\n          class=\"mat-typography\"\n          appearance=\"legacy\"\n          vertical=\"{{ bundleIsVertical(bundle) }}\"\n          multiple=\"true\"\n        >\n          <mat-button-toggle\n            *ngFor=\"let ogcPushButton of bundle.selectors\"\n            [matTooltip]=\"getToolTip(ogcPushButton)\"\n            tooltip-position=\"below\"\n            matTooltipShowDelay=\"500\"\n            matTooltipClass=\"material-tooltip\"\n            [ngStyle]=\"getButtonColor(ogcPushButton)\"\n            [checked]=\"ogcPushButton.enabled\"\n            (change)=\"onSelectionChange(ogcPushButton, selector.selectorType)\"\n            [value]=\"ogcPushButton\"\n            >{{ ogcPushButton.title }}\n          </mat-button-toggle>\n        </mat-button-toggle-group>\n      </ng-container>\n    </div>\n\n    <div class=\"checkboxGroups\" *ngIf=\"selector.selectorType === 'checkbox'\">\n      <mat-divider></mat-divider>\n      <div class=\"groupsSelector\" *ngIf=\"getCheckboxesGroups().length > 1\">\n        <mat-form-field>\n          <mat-select\n            formControlName=\"checkboxesGroup\"\n            [matTooltip]=\"'igo.geo.layer.legend.selectStyle' | translate\"\n            tooltip-position=\"below\"\n            matTooltipShowDelay=\"500\"\n            [(value)]=\"currentCheckboxesGroup\"\n          >\n            <mat-option\n              *ngFor=\"let selectorGroup of getCheckboxesGroups()\"\n              [value]=\"selectorGroup\"\n              >{{ selectorGroup.title }}\n            </mat-option>\n          </mat-select>\n        </mat-form-field>\n      </div>\n      <ng-container\n        *ngFor=\"let bundle of currentCheckboxesGroup.computedSelectors\"\n      >\n        <h3>{{ bundle.title }}</h3>\n        <div class=\"checkboxes mat-typography\">\n          <mat-checkbox\n            *ngFor=\"let ogcCheckbox of bundle.selectors\"\n            [matTooltip]=\"getToolTip(ogcCheckbox)\"\n            tooltip-position=\"below\"\n            matTooltipShowDelay=\"500\"\n            matTooltipClass=\"material-tooltip\"\n            [checked]=\"ogcCheckbox.enabled\"\n            (change)=\"onSelectionChange(ogcCheckbox, selector.selectorType)\"\n            [value]=\"ogcCheckbox\"\n            >{{ ogcCheckbox.title }}\n          </mat-checkbox>\n        </div>\n        <p\n          *ngIf=\"\n            isLessResults(bundle, 'checkbox') ||\n            isMoreResults(bundle, 'checkbox')\n          \"\n        >\n          <u\n            *ngIf=\"isLessResults(bundle, 'checkbox')\"\n            class=\"lessResults mat-typography\"\n            (click)=\"displayLessResults('checkbox')\"\n            >{{ 'igo.geo.filter.displayLessResults' | translate }}\n          </u>\n          <u\n            *ngIf=\"isMoreResults(bundle, 'checkbox')\"\n            class=\"moreResults mat-typography\"\n            (click)=\"displayMoreResults('checkbox')\"\n            >{{ 'igo.geo.filter.displayMoreResults' | translate }}\n          </u>\n        </p>\n      </ng-container>\n    </div>\n\n    <div\n      class=\"radioButtonGroups\"\n      *ngIf=\"selector.selectorType === 'radioButton'\"\n    >\n      <mat-divider></mat-divider>\n      <div class=\"groupsSelector\" *ngIf=\"getRadioButtonsGroups().length > 1\">\n        <mat-form-field>\n          <mat-select\n            formControlName=\"radioButtonsGroup\"\n            [matTooltip]=\"'igo.geo.layer.legend.selectStyle' | translate\"\n            tooltip-position=\"below\"\n            matTooltipShowDelay=\"500\"\n            [(value)]=\"currentRadioButtonsGroup\"\n          >\n            <mat-option\n              *ngFor=\"let selectorGroup of getRadioButtonsGroups()\"\n              [value]=\"selectorGroup\"\n              >{{ selectorGroup.title }}\n            </mat-option>\n          </mat-select>\n        </mat-form-field>\n      </div>\n      <ng-container\n        *ngFor=\"let bundle of currentRadioButtonsGroup.computedSelectors\"\n      >\n        <h3>{{ bundle.title }}</h3>\n        <mat-radio-group formControlName=\"radioButtons\" class=\"mat-typography\">\n          <mat-radio-button\n            *ngIf=\"bundle.unfiltered\"\n            [matTooltip]=\"'igo.geo.filter.resetFilters' | translate\"\n            tooltip-position=\"below\"\n            matTooltipShowDelay=\"500\"\n            matTooltipClass=\"material-tooltip\"\n            (change)=\"emptyRadioButtons()\"\n            >{{ 'igo.geo.filter.resetFilters' | translate }}\n          </mat-radio-button>\n          <mat-radio-button\n            *ngFor=\"let ogcRadioButton of bundle.selectors\"\n            [matTooltip]=\"getToolTip(ogcRadioButton)\"\n            tooltip-position=\"below\"\n            matTooltipShowDelay=\"500\"\n            matTooltipClass=\"material-tooltip\"\n            [checked]=\"ogcRadioButton.enabled\"\n            (change)=\"onSelectionChange(ogcRadioButton, selector.selectorType)\"\n            [value]=\"ogcRadioButton\"\n            >{{ ogcRadioButton.title }}\n          </mat-radio-button>\n          <p\n            *ngIf=\"\n              isLessResults(bundle, 'radio') || isMoreResults(bundle, 'radio')\n            \"\n          >\n            <u\n              *ngIf=\"isLessResults(bundle, 'radio')\"\n              class=\"lessResults mat-typography\"\n              (click)=\"displayLessResults('radio')\"\n              >{{ 'igo.geo.filter.displayLessResults' | translate }}\n            </u>\n            <u\n              *ngIf=\"isMoreResults(bundle, 'radio')\"\n              class=\"moreResults mat-typography\"\n              (click)=\"displayMoreResults('radio')\"\n              >{{ 'igo.geo.filter.displayMoreResults' | translate }}\n            </u>\n          </p>\n        </mat-radio-group>\n      </ng-container>\n    </div>\n\n    <div class=\"selectGroups\" *ngIf=\"selector.selectorType === 'select'\">\n      <mat-divider></mat-divider>\n      <div class=\"groupsSelector\" *ngIf=\"getSelectGroups().length > 1\">\n        <mat-form-field>\n          <mat-select\n            formControlName=\"selectGroup\"\n            [matTooltip]=\"'igo.geo.layer.legend.selectStyle' | translate\"\n            tooltip-position=\"below\"\n            matTooltipShowDelay=\"500\"\n            [(value)]=\"currentSelectGroup\"\n          >\n            <mat-option\n              *ngFor=\"let selectorGroup of getSelectGroups()\"\n              [value]=\"selectorGroup\"\n              >{{ selectorGroup.title }}\n            </mat-option>\n          </mat-select>\n        </mat-form-field>\n      </div>\n      <ng-container *ngFor=\"let bundle of currentSelectGroup.computedSelectors\">\n        <h3>{{ bundle.title }}</h3>\n        <div class=\"groupsSelector\">\n          <mat-button\n            *ngIf=\"bundle.unfiltered && !bundle.multiple\"\n            mat-icon-button\n            color=\"warn\"\n            [matTooltip]=\"'igo.geo.filter.resetFilters' | translate\"\n            tooltip-position=\"below\"\n            matTooltipShowDelay=\"500\"\n            matTooltipClass=\"material-tooltip\"\n            (click)=\"emptySelect()\"\n          >\n            <mat-icon svgIcon=\"filter-remove\"></mat-icon>\n          </mat-button>\n          <mat-form-field\n            [style.width.%]=\"bundle.width ? bundle.width : undefined\"\n          >\n            <div *ngIf=\"bundle.multiple; else notMulti\">\n              <mat-select\n                #selection\n                [multiple]=\"bundle.multiple\"\n                [placeholder]=\"bundle.title\"\n                formControlName=\"selectMulti\"\n              >\n                <div class=\"checkboxes mat-typography\">\n                  <mat-checkbox\n                    *ngIf=\"bundle.multiple\"\n                    [(ngModel)]=\"selectAllSelected\"\n                    [ngModelOptions]=\"{ standalone: true }\"\n                    (change)=\"toggleAllSelection()\"\n                    >Tous\n                  </mat-checkbox>\n                </div>\n                <mat-option\n                  *ngFor=\"let ogcSelect of bundle.selectors\"\n                  [matTooltip]=\"getToolTip(ogcSelect)\"\n                  tooltip-position=\"below\"\n                  matTooltipDelay=\"500\"\n                  matTooltipClass=\"material-tooltip\"\n                  (onSelectionChange)=\"\n                    selectOptionClick($event.source.value, bundle, $event)\n                  \"\n                  [value]=\"ogcSelect\"\n                  >{{ ogcSelect.title }}\n                </mat-option>\n              </mat-select>\n            </div>\n            <ng-template #notMulti>\n              <mat-select [placeholder]=\"bundle.title\" formControlName=\"select\">\n                <mat-option\n                  *ngFor=\"let ogcSelect of bundle.selectors\"\n                  [matTooltip]=\"getToolTip(ogcSelect)\"\n                  tooltip-position=\"below\"\n                  matTooltipDelay=\"500\"\n                  matTooltipClass=\"material-tooltip\"\n                  [value]=\"ogcSelect\"\n                  (onSelectionChange)=\"\n                    selectOptionClick($event.source.value, bundle)\n                  \"\n                  >{{ ogcSelect.title }}\n                </mat-option>\n              </mat-select>\n            </ng-template>\n          </mat-form-field>\n        </div>\n      </ng-container>\n    </div>\n\n    <div\n      class=\"autocompleteGroups\"\n      *ngIf=\"selector.selectorType === 'autocomplete'\"\n    >\n      <mat-divider></mat-divider>\n      <div class=\"groupsSelector\" *ngIf=\"getAutocompleteGroups().length > 1\">\n        <mat-form-field>\n          <mat-select\n            formControlName=\"autocompleteGroup\"\n            [matTooltip]=\"'igo.geo.layer.legend.selectStyle' | translate\"\n            tooltip-position=\"below\"\n            matTooltipShowDelay=\"500\"\n            [(value)]=\"currentAutocompleteGroup\"\n          >\n            <mat-option\n              *ngFor=\"let autocompleteGroup of getAutocompleteGroups()\"\n              [value]=\"autocompleteGroup\"\n              >{{ autocompleteGroup.title }}\n            </mat-option>\n          </mat-select>\n        </mat-form-field>\n      </div>\n      <ng-container\n        *ngFor=\"let bundle of currentAutocompleteGroup.computedSelectors\"\n      >\n        <h3>{{ bundle.title }}</h3>\n        <div class=\"groupsSelector\">\n          <mat-button\n            *ngIf=\"bundle.unfiltered\"\n            mat-icon-button\n            color=\"warn\"\n            [matTooltip]=\"'igo.geo.filter.resetFilters' | translate\"\n            tooltip-position=\"below\"\n            matTooltipShowDelay=\"500\"\n            matTooltipClass=\"material-tooltip\"\n            (click)=\"emptyAutocomplete()\"\n          >\n            <mat-icon svgIcon=\"filter-remove\"></mat-icon>\n          </mat-button>\n          <mat-form-field\n            *ngIf=\"filteredOgcAutocomplete[bundle.id]\"\n            [style.width.%]=\"bundle.width ? bundle.width : undefined\"\n          >\n            <input\n              matInput\n              type=\"text\"\n              formControlName=\"autocomplete\"\n              #autocomplete\n              class=\"autocomplete\"\n              [matAutocomplete]=\"auto\"\n              [placeholder]=\"bundle.title\"\n            />\n            <mat-autocomplete\n              #auto=\"matAutocomplete\"\n              #autocomplete\n              (optionSelected)=\"autocompleteOptionClick($event.option.value)\"\n              [displayWith]=\"displayFn\"\n            >\n              <mat-option\n                *ngFor=\"\n                  let ogcAutocomplete of filteredOgcAutocomplete[bundle.id]\n                    | async\n                \"\n                [value]=\"ogcAutocomplete\"\n              >\n                {{ ogcAutocomplete.value }}\n              </mat-option>\n            </mat-autocomplete>\n          </mat-form-field>\n        </div>\n      </ng-container>\n    </div>\n  </div>\n</form>\n\n<div *ngIf=\"isTemporalOperator()\">\n  <mat-divider></mat-divider>\n  <h3 *ngIf=\"!currentFilter.title\">\n    {{ 'igo.geo.filter.reportingDate' | translate }}\n  </h3>\n  <h3 *ngIf=\"currentFilter.title\">{{ currentFilter.title }}</h3>\n  <igo-ogc-filter-time\n    [(datasource)]=\"datasource\"\n    [(currentFilter)]=\"currentFilter\"\n    (changeProperty)=\"changeProperty($event.value, $event.pos)\"\n  >\n  </igo-ogc-filter-time>\n</div>\n", styles: [":host .mat-button-toggle-group{margin:5px;flex-wrap:wrap;box-shadow:none!important;width:95%}:host .checkboxes{flex-wrap:wrap;box-shadow:none}:host .groupsSelector{text-align:center}:host mat-button-toggle{display:inline-flex;border:1.5px solid black;border-radius:5px;margin:5px;white-space:normal;min-height:40px;height:auto;width:142px}:host mat-button-toggle ::ng-deep .mat-button-toggle-label-content{line-height:unset;font-size:small;display:block}@media only screen and (orientation:portrait) and (max-width: 599px),only screen and (orientation:landscape) and (max-width: 959px){:host mat-button-toggle{width:45%}}:host ::ng-deep .material-tooltip{white-space:pre-wrap}:host mat-checkbox,:host mat-radio-button{margin:7px;width:95%;display:inline-flex;font-size:larger}:host mat-checkbox ::ng-deep label,:host mat-radio-button ::ng-deep label{white-space:normal}:host mat-checkbox{vertical-align:middle}:host mat-button{padding-right:10px;cursor:pointer}:host h3{margin:7px;text-align:left}:host u{cursor:pointer;color:#00f;margin:5px}:host p{margin:unset}\n"], dependencies: [{ kind: "directive", type: i2$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2$2.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: i2$1.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { kind: "directive", type: i2$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i2$1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "directive", type: i2$1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "directive", type: i2$1.FormControlName, selector: "[formControlName]", inputs: ["formControlName", "disabled", "ngModel"], outputs: ["ngModelChange"] }, { kind: "component", type: i6$2.MatAutocomplete, selector: "mat-autocomplete", inputs: ["disableRipple", "hideSingleSelectionIndicator"], exportAs: ["matAutocomplete"] }, { kind: "component", type: i9.MatOption, selector: "mat-option", exportAs: ["matOption"] }, { kind: "directive", type: i6$2.MatAutocompleteTrigger, selector: "input[matAutocomplete], textarea[matAutocomplete]", exportAs: ["matAutocompleteTrigger"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "directive", type: i8$2.MatRadioGroup, selector: "mat-radio-group", exportAs: ["matRadioGroup"] }, { kind: "component", type: i8$2.MatRadioButton, selector: "mat-radio-button", inputs: ["disableRipple", "tabIndex"], exportAs: ["matRadioButton"] }, { kind: "directive", type: i5$1.MatButtonToggleGroup, selector: "mat-button-toggle-group", inputs: ["appearance", "name", "vertical", "value", "multiple", "disabled"], outputs: ["valueChange", "change"], exportAs: ["matButtonToggleGroup"] }, { kind: "component", type: i5$1.MatButtonToggle, selector: "mat-button-toggle", inputs: ["disableRipple", "aria-label", "aria-labelledby", "id", "name", "value", "tabIndex", "appearance", "checked", "disabled"], outputs: ["change"], exportAs: ["matButtonToggle"] }, { kind: "component", type: i11.MatCheckbox, selector: "mat-checkbox", inputs: ["disableRipple", "color", "tabIndex"], exportAs: ["matCheckbox"] }, { kind: "component", type: i8.MatFormField, selector: "mat-form-field", inputs: ["hideRequiredMarker", "color", "floatLabel", "appearance", "subscriptSizing", "hintLabel"], exportAs: ["matFormField"] }, { kind: "directive", type: i9$3.MatInput, selector: "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", inputs: ["disabled", "id", "placeholder", "name", "required", "type", "errorStateMatcher", "aria-describedby", "value", "readonly"], exportAs: ["matInput"] }, { kind: "component", type: i15.MatSelect, selector: "mat-select", inputs: ["disabled", "disableRipple", "tabIndex", "panelWidth", "hideSingleSelectionIndicator"], exportAs: ["matSelect"] }, { kind: "component", type: i9$2.MatDivider, selector: "mat-divider", inputs: ["vertical", "inset"] }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "component", type: OgcFilterTimeComponent, selector: "igo-ogc-filter-time", inputs: ["datasource", "currentFilter"], outputs: ["changeProperty"] }, { kind: "pipe", type: i2$2.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OgcFilterSelectionComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-ogc-filter-selection', providers: [DOMService], template: "<form [formGroup]=\"form\">\n  <div *ngFor=\"let selector of ogcFiltersSelectors\">\n    <div\n      class=\"pushButtonGroups\"\n      *ngIf=\"selector.selectorType === 'pushButton'\"\n    >\n      <mat-divider></mat-divider>\n      <div class=\"groupsSelector\" *ngIf=\"getPushButtonsGroups().length > 1\">\n        <mat-form-field>\n          <mat-select\n            formControlName=\"pushButtonsGroup\"\n            [matTooltip]=\"'igo.geo.layer.legend.selectStyle' | translate\"\n            tooltip-position=\"below\"\n            matTooltipShowDelay=\"500\"\n            [(value)]=\"currentPushButtonsGroup\"\n          >\n            <mat-option\n              *ngFor=\"let selectorGroup of getPushButtonsGroups()\"\n              [value]=\"selectorGroup\"\n              >{{ selectorGroup.title }}\n            </mat-option>\n          </mat-select>\n        </mat-form-field>\n      </div>\n      <ng-container\n        *ngFor=\"let bundle of currentPushButtonsGroup.computedSelectors\"\n      >\n        <h3>{{ bundle.title }}</h3>\n        <mat-button-toggle-group\n          formControlName=\"pushButtons\"\n          class=\"mat-typography\"\n          appearance=\"legacy\"\n          vertical=\"{{ bundleIsVertical(bundle) }}\"\n          multiple=\"true\"\n        >\n          <mat-button-toggle\n            *ngFor=\"let ogcPushButton of bundle.selectors\"\n            [matTooltip]=\"getToolTip(ogcPushButton)\"\n            tooltip-position=\"below\"\n            matTooltipShowDelay=\"500\"\n            matTooltipClass=\"material-tooltip\"\n            [ngStyle]=\"getButtonColor(ogcPushButton)\"\n            [checked]=\"ogcPushButton.enabled\"\n            (change)=\"onSelectionChange(ogcPushButton, selector.selectorType)\"\n            [value]=\"ogcPushButton\"\n            >{{ ogcPushButton.title }}\n          </mat-button-toggle>\n        </mat-button-toggle-group>\n      </ng-container>\n    </div>\n\n    <div class=\"checkboxGroups\" *ngIf=\"selector.selectorType === 'checkbox'\">\n      <mat-divider></mat-divider>\n      <div class=\"groupsSelector\" *ngIf=\"getCheckboxesGroups().length > 1\">\n        <mat-form-field>\n          <mat-select\n            formControlName=\"checkboxesGroup\"\n            [matTooltip]=\"'igo.geo.layer.legend.selectStyle' | translate\"\n            tooltip-position=\"below\"\n            matTooltipShowDelay=\"500\"\n            [(value)]=\"currentCheckboxesGroup\"\n          >\n            <mat-option\n              *ngFor=\"let selectorGroup of getCheckboxesGroups()\"\n              [value]=\"selectorGroup\"\n              >{{ selectorGroup.title }}\n            </mat-option>\n          </mat-select>\n        </mat-form-field>\n      </div>\n      <ng-container\n        *ngFor=\"let bundle of currentCheckboxesGroup.computedSelectors\"\n      >\n        <h3>{{ bundle.title }}</h3>\n        <div class=\"checkboxes mat-typography\">\n          <mat-checkbox\n            *ngFor=\"let ogcCheckbox of bundle.selectors\"\n            [matTooltip]=\"getToolTip(ogcCheckbox)\"\n            tooltip-position=\"below\"\n            matTooltipShowDelay=\"500\"\n            matTooltipClass=\"material-tooltip\"\n            [checked]=\"ogcCheckbox.enabled\"\n            (change)=\"onSelectionChange(ogcCheckbox, selector.selectorType)\"\n            [value]=\"ogcCheckbox\"\n            >{{ ogcCheckbox.title }}\n          </mat-checkbox>\n        </div>\n        <p\n          *ngIf=\"\n            isLessResults(bundle, 'checkbox') ||\n            isMoreResults(bundle, 'checkbox')\n          \"\n        >\n          <u\n            *ngIf=\"isLessResults(bundle, 'checkbox')\"\n            class=\"lessResults mat-typography\"\n            (click)=\"displayLessResults('checkbox')\"\n            >{{ 'igo.geo.filter.displayLessResults' | translate }}\n          </u>\n          <u\n            *ngIf=\"isMoreResults(bundle, 'checkbox')\"\n            class=\"moreResults mat-typography\"\n            (click)=\"displayMoreResults('checkbox')\"\n            >{{ 'igo.geo.filter.displayMoreResults' | translate }}\n          </u>\n        </p>\n      </ng-container>\n    </div>\n\n    <div\n      class=\"radioButtonGroups\"\n      *ngIf=\"selector.selectorType === 'radioButton'\"\n    >\n      <mat-divider></mat-divider>\n      <div class=\"groupsSelector\" *ngIf=\"getRadioButtonsGroups().length > 1\">\n        <mat-form-field>\n          <mat-select\n            formControlName=\"radioButtonsGroup\"\n            [matTooltip]=\"'igo.geo.layer.legend.selectStyle' | translate\"\n            tooltip-position=\"below\"\n            matTooltipShowDelay=\"500\"\n            [(value)]=\"currentRadioButtonsGroup\"\n          >\n            <mat-option\n              *ngFor=\"let selectorGroup of getRadioButtonsGroups()\"\n              [value]=\"selectorGroup\"\n              >{{ selectorGroup.title }}\n            </mat-option>\n          </mat-select>\n        </mat-form-field>\n      </div>\n      <ng-container\n        *ngFor=\"let bundle of currentRadioButtonsGroup.computedSelectors\"\n      >\n        <h3>{{ bundle.title }}</h3>\n        <mat-radio-group formControlName=\"radioButtons\" class=\"mat-typography\">\n          <mat-radio-button\n            *ngIf=\"bundle.unfiltered\"\n            [matTooltip]=\"'igo.geo.filter.resetFilters' | translate\"\n            tooltip-position=\"below\"\n            matTooltipShowDelay=\"500\"\n            matTooltipClass=\"material-tooltip\"\n            (change)=\"emptyRadioButtons()\"\n            >{{ 'igo.geo.filter.resetFilters' | translate }}\n          </mat-radio-button>\n          <mat-radio-button\n            *ngFor=\"let ogcRadioButton of bundle.selectors\"\n            [matTooltip]=\"getToolTip(ogcRadioButton)\"\n            tooltip-position=\"below\"\n            matTooltipShowDelay=\"500\"\n            matTooltipClass=\"material-tooltip\"\n            [checked]=\"ogcRadioButton.enabled\"\n            (change)=\"onSelectionChange(ogcRadioButton, selector.selectorType)\"\n            [value]=\"ogcRadioButton\"\n            >{{ ogcRadioButton.title }}\n          </mat-radio-button>\n          <p\n            *ngIf=\"\n              isLessResults(bundle, 'radio') || isMoreResults(bundle, 'radio')\n            \"\n          >\n            <u\n              *ngIf=\"isLessResults(bundle, 'radio')\"\n              class=\"lessResults mat-typography\"\n              (click)=\"displayLessResults('radio')\"\n              >{{ 'igo.geo.filter.displayLessResults' | translate }}\n            </u>\n            <u\n              *ngIf=\"isMoreResults(bundle, 'radio')\"\n              class=\"moreResults mat-typography\"\n              (click)=\"displayMoreResults('radio')\"\n              >{{ 'igo.geo.filter.displayMoreResults' | translate }}\n            </u>\n          </p>\n        </mat-radio-group>\n      </ng-container>\n    </div>\n\n    <div class=\"selectGroups\" *ngIf=\"selector.selectorType === 'select'\">\n      <mat-divider></mat-divider>\n      <div class=\"groupsSelector\" *ngIf=\"getSelectGroups().length > 1\">\n        <mat-form-field>\n          <mat-select\n            formControlName=\"selectGroup\"\n            [matTooltip]=\"'igo.geo.layer.legend.selectStyle' | translate\"\n            tooltip-position=\"below\"\n            matTooltipShowDelay=\"500\"\n            [(value)]=\"currentSelectGroup\"\n          >\n            <mat-option\n              *ngFor=\"let selectorGroup of getSelectGroups()\"\n              [value]=\"selectorGroup\"\n              >{{ selectorGroup.title }}\n            </mat-option>\n          </mat-select>\n        </mat-form-field>\n      </div>\n      <ng-container *ngFor=\"let bundle of currentSelectGroup.computedSelectors\">\n        <h3>{{ bundle.title }}</h3>\n        <div class=\"groupsSelector\">\n          <mat-button\n            *ngIf=\"bundle.unfiltered && !bundle.multiple\"\n            mat-icon-button\n            color=\"warn\"\n            [matTooltip]=\"'igo.geo.filter.resetFilters' | translate\"\n            tooltip-position=\"below\"\n            matTooltipShowDelay=\"500\"\n            matTooltipClass=\"material-tooltip\"\n            (click)=\"emptySelect()\"\n          >\n            <mat-icon svgIcon=\"filter-remove\"></mat-icon>\n          </mat-button>\n          <mat-form-field\n            [style.width.%]=\"bundle.width ? bundle.width : undefined\"\n          >\n            <div *ngIf=\"bundle.multiple; else notMulti\">\n              <mat-select\n                #selection\n                [multiple]=\"bundle.multiple\"\n                [placeholder]=\"bundle.title\"\n                formControlName=\"selectMulti\"\n              >\n                <div class=\"checkboxes mat-typography\">\n                  <mat-checkbox\n                    *ngIf=\"bundle.multiple\"\n                    [(ngModel)]=\"selectAllSelected\"\n                    [ngModelOptions]=\"{ standalone: true }\"\n                    (change)=\"toggleAllSelection()\"\n                    >Tous\n                  </mat-checkbox>\n                </div>\n                <mat-option\n                  *ngFor=\"let ogcSelect of bundle.selectors\"\n                  [matTooltip]=\"getToolTip(ogcSelect)\"\n                  tooltip-position=\"below\"\n                  matTooltipDelay=\"500\"\n                  matTooltipClass=\"material-tooltip\"\n                  (onSelectionChange)=\"\n                    selectOptionClick($event.source.value, bundle, $event)\n                  \"\n                  [value]=\"ogcSelect\"\n                  >{{ ogcSelect.title }}\n                </mat-option>\n              </mat-select>\n            </div>\n            <ng-template #notMulti>\n              <mat-select [placeholder]=\"bundle.title\" formControlName=\"select\">\n                <mat-option\n                  *ngFor=\"let ogcSelect of bundle.selectors\"\n                  [matTooltip]=\"getToolTip(ogcSelect)\"\n                  tooltip-position=\"below\"\n                  matTooltipDelay=\"500\"\n                  matTooltipClass=\"material-tooltip\"\n                  [value]=\"ogcSelect\"\n                  (onSelectionChange)=\"\n                    selectOptionClick($event.source.value, bundle)\n                  \"\n                  >{{ ogcSelect.title }}\n                </mat-option>\n              </mat-select>\n            </ng-template>\n          </mat-form-field>\n        </div>\n      </ng-container>\n    </div>\n\n    <div\n      class=\"autocompleteGroups\"\n      *ngIf=\"selector.selectorType === 'autocomplete'\"\n    >\n      <mat-divider></mat-divider>\n      <div class=\"groupsSelector\" *ngIf=\"getAutocompleteGroups().length > 1\">\n        <mat-form-field>\n          <mat-select\n            formControlName=\"autocompleteGroup\"\n            [matTooltip]=\"'igo.geo.layer.legend.selectStyle' | translate\"\n            tooltip-position=\"below\"\n            matTooltipShowDelay=\"500\"\n            [(value)]=\"currentAutocompleteGroup\"\n          >\n            <mat-option\n              *ngFor=\"let autocompleteGroup of getAutocompleteGroups()\"\n              [value]=\"autocompleteGroup\"\n              >{{ autocompleteGroup.title }}\n            </mat-option>\n          </mat-select>\n        </mat-form-field>\n      </div>\n      <ng-container\n        *ngFor=\"let bundle of currentAutocompleteGroup.computedSelectors\"\n      >\n        <h3>{{ bundle.title }}</h3>\n        <div class=\"groupsSelector\">\n          <mat-button\n            *ngIf=\"bundle.unfiltered\"\n            mat-icon-button\n            color=\"warn\"\n            [matTooltip]=\"'igo.geo.filter.resetFilters' | translate\"\n            tooltip-position=\"below\"\n            matTooltipShowDelay=\"500\"\n            matTooltipClass=\"material-tooltip\"\n            (click)=\"emptyAutocomplete()\"\n          >\n            <mat-icon svgIcon=\"filter-remove\"></mat-icon>\n          </mat-button>\n          <mat-form-field\n            *ngIf=\"filteredOgcAutocomplete[bundle.id]\"\n            [style.width.%]=\"bundle.width ? bundle.width : undefined\"\n          >\n            <input\n              matInput\n              type=\"text\"\n              formControlName=\"autocomplete\"\n              #autocomplete\n              class=\"autocomplete\"\n              [matAutocomplete]=\"auto\"\n              [placeholder]=\"bundle.title\"\n            />\n            <mat-autocomplete\n              #auto=\"matAutocomplete\"\n              #autocomplete\n              (optionSelected)=\"autocompleteOptionClick($event.option.value)\"\n              [displayWith]=\"displayFn\"\n            >\n              <mat-option\n                *ngFor=\"\n                  let ogcAutocomplete of filteredOgcAutocomplete[bundle.id]\n                    | async\n                \"\n                [value]=\"ogcAutocomplete\"\n              >\n                {{ ogcAutocomplete.value }}\n              </mat-option>\n            </mat-autocomplete>\n          </mat-form-field>\n        </div>\n      </ng-container>\n    </div>\n  </div>\n</form>\n\n<div *ngIf=\"isTemporalOperator()\">\n  <mat-divider></mat-divider>\n  <h3 *ngIf=\"!currentFilter.title\">\n    {{ 'igo.geo.filter.reportingDate' | translate }}\n  </h3>\n  <h3 *ngIf=\"currentFilter.title\">{{ currentFilter.title }}</h3>\n  <igo-ogc-filter-time\n    [(datasource)]=\"datasource\"\n    [(currentFilter)]=\"currentFilter\"\n    (changeProperty)=\"changeProperty($event.value, $event.pos)\"\n  >\n  </igo-ogc-filter-time>\n</div>\n", styles: [":host .mat-button-toggle-group{margin:5px;flex-wrap:wrap;box-shadow:none!important;width:95%}:host .checkboxes{flex-wrap:wrap;box-shadow:none}:host .groupsSelector{text-align:center}:host mat-button-toggle{display:inline-flex;border:1.5px solid black;border-radius:5px;margin:5px;white-space:normal;min-height:40px;height:auto;width:142px}:host mat-button-toggle ::ng-deep .mat-button-toggle-label-content{line-height:unset;font-size:small;display:block}@media only screen and (orientation:portrait) and (max-width: 599px),only screen and (orientation:landscape) and (max-width: 959px){:host mat-button-toggle{width:45%}}:host ::ng-deep .material-tooltip{white-space:pre-wrap}:host mat-checkbox,:host mat-radio-button{margin:7px;width:95%;display:inline-flex;font-size:larger}:host mat-checkbox ::ng-deep label,:host mat-radio-button ::ng-deep label{white-space:normal}:host mat-checkbox{vertical-align:middle}:host mat-button{padding-right:10px;cursor:pointer}:host h3{margin:7px;text-align:left}:host u{cursor:pointer;color:#00f;margin:5px}:host p{margin:unset}\n"] }]
        }], ctorParameters: function () { return [{ type: OGCFilterService }, { type: i2$1.UntypedFormBuilder }, { type: i9$1.DOMService }, { type: i2.ConfigService }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { sel: [{
                type: ViewChild,
                args: ['selection']
            }], refreshFilters: [{
                type: Input
            }], datasource: [{
                type: Input
            }], map: [{
                type: Input
            }], checkboxesIndex: [{
                type: Input
            }], radioButtonsIndex: [{
                type: Input
            }], baseIndex: [{
                type: Input
            }], currentFilter: [{
                type: Input
            }] } });

class OgcFilterableFormComponent {
    datasource;
    map;
    refreshFilters;
    get refreshFunc() {
        return this.refreshFilters;
    }
    get advancedOgcFilters() {
        if (this.datasource.options.ogcFilters) {
            return this.datasource.options.ogcFilters.advancedOgcFilters;
        }
        return;
    }
    get currentFilter() {
        return this.datasource.options.ogcFilters.interfaceOgcFilters
            ? this.datasource.options.ogcFilters.interfaceOgcFilters[0]
            : undefined;
    }
    color = 'primary';
    constructor() { }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OgcFilterableFormComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: OgcFilterableFormComponent, selector: "igo-ogc-filterable-form", inputs: { datasource: "datasource", map: "map", refreshFilters: "refreshFilters" }, providers: [
            {
                provide: MAT_SELECT_CONFIG,
                useValue: { overlayPanelClass: 'igo-overlay-panel-width' }
            },
            {
                provide: MAT_AUTOCOMPLETE_DEFAULT_OPTIONS,
                useValue: { overlayPanelClass: 'igo-overlay-panel-width' }
            }
        ], ngImport: i0, template: "<igo-ogc-filter-selection\n  *ngIf=\"!advancedOgcFilters\"\n  igoListItem\n  [refreshFilters]=\"refreshFunc\"\n  [datasource]=\"datasource\"\n  [map]=\"map\"\n  [currentFilter]=\"currentFilter\"\n>\n</igo-ogc-filter-selection>\n\n<ng-template\n  *ngIf=\"advancedOgcFilters && datasource.options.ogcFilters.editable\"\n  ngFor\n  let-currentFilter\n  [ngForOf]=\"datasource.options.ogcFilters.interfaceOgcFilters\"\n>\n  <igo-ogc-filter-form\n    [currentFilter]=\"currentFilter\"\n    [refreshFilters]=\"refreshFunc\"\n    [datasource]=\"datasource\"\n    [map]=\"map\"\n  >\n  </igo-ogc-filter-form>\n</ng-template>\n", styles: ["::ng-deep .igo-overlay-panel-width{min-width:-moz-fit-content;min-width:fit-content}\n"], dependencies: [{ kind: "directive", type: i2$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i9$1.ListItemDirective, selector: "[igoListItem]", inputs: ["color", "focused", "selected", "disabled"], outputs: ["beforeSelect", "beforeFocus", "beforeUnselect", "beforeUnfocus", "beforeDisable", "beforeEnable", "focus", "unfocus", "select", "unselect", "disable", "enable"] }, { kind: "component", type: OgcFilterFormComponent, selector: "igo-ogc-filter-form", inputs: ["refreshFilters", "datasource", "map", "currentFilter", "floatLabel"] }, { kind: "component", type: OgcFilterSelectionComponent, selector: "igo-ogc-filter-selection", inputs: ["refreshFilters", "datasource", "map", "checkboxesIndex", "radioButtonsIndex", "baseIndex", "currentFilter"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OgcFilterableFormComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-ogc-filterable-form', providers: [
                        {
                            provide: MAT_SELECT_CONFIG,
                            useValue: { overlayPanelClass: 'igo-overlay-panel-width' }
                        },
                        {
                            provide: MAT_AUTOCOMPLETE_DEFAULT_OPTIONS,
                            useValue: { overlayPanelClass: 'igo-overlay-panel-width' }
                        }
                    ], template: "<igo-ogc-filter-selection\n  *ngIf=\"!advancedOgcFilters\"\n  igoListItem\n  [refreshFilters]=\"refreshFunc\"\n  [datasource]=\"datasource\"\n  [map]=\"map\"\n  [currentFilter]=\"currentFilter\"\n>\n</igo-ogc-filter-selection>\n\n<ng-template\n  *ngIf=\"advancedOgcFilters && datasource.options.ogcFilters.editable\"\n  ngFor\n  let-currentFilter\n  [ngForOf]=\"datasource.options.ogcFilters.interfaceOgcFilters\"\n>\n  <igo-ogc-filter-form\n    [currentFilter]=\"currentFilter\"\n    [refreshFilters]=\"refreshFunc\"\n    [datasource]=\"datasource\"\n    [map]=\"map\"\n  >\n  </igo-ogc-filter-form>\n</ng-template>\n", styles: ["::ng-deep .igo-overlay-panel-width{min-width:-moz-fit-content;min-width:fit-content}\n"] }]
        }], ctorParameters: function () { return []; }, propDecorators: { datasource: [{
                type: Input
            }], map: [{
                type: Input
            }], refreshFilters: [{
                type: Input
            }] } });

class OgcFilterableItemComponent {
    ogcFilterService;
    color = 'primary';
    lastRunOgcFilter;
    defaultLogicalParent = OgcFilterOperator.And;
    hasActiveSpatialFilter = false;
    filtersAreEditable = true;
    filtersCollapsed = true;
    hasSelector = false;
    showLegend$ = new BehaviorSubject(false);
    inResolutionRange$ = new BehaviorSubject(true);
    resolution$$;
    ogcFilterWriter;
    layer;
    map;
    header = true;
    get refreshFunc() {
        return this.refreshFilters.bind(this);
    }
    get datasource() {
        return this.layer.dataSource;
    }
    constructor(ogcFilterService) {
        this.ogcFilterService = ogcFilterService;
        this.ogcFilterWriter = new OgcFilterWriter();
    }
    ngOnInit() {
        if (this.layer.visible) {
            this.filtersCollapsed = false;
        }
        const ogcFilters = this.datasource.options.ogcFilters;
        if ((ogcFilters.pushButtons && ogcFilters.pushButtons.bundles.length > 0) ||
            (ogcFilters.checkboxes && ogcFilters.checkboxes.bundles.length > 0) ||
            (ogcFilters.radioButtons && ogcFilters.radioButtons.bundles.length > 0) ||
            (ogcFilters.select && ogcFilters.select.bundles.length > 0) ||
            (ogcFilters.autocomplete && ogcFilters.autocomplete.bundles.length > 0)) {
            if (ogcFilters.advancedOgcFilters === undefined) {
                ogcFilters.advancedOgcFilters = false;
            }
            this.hasSelector = true;
        }
        switch (this.datasource.options.type) {
            case 'wms':
                this.ogcFilterService.setOgcWMSFiltersOptions(this.datasource);
                break;
            case 'wfs':
                this.ogcFilterService.setOgcWFSFiltersOptions(this.datasource);
                break;
            default:
                break;
        }
        if (ogcFilters) {
            if (ogcFilters.interfaceOgcFilters) {
                this.lastRunOgcFilter = JSON.parse(JSON.stringify(ogcFilters.interfaceOgcFilters));
                if (ogcFilters.interfaceOgcFilters.filter((f) => f.wkt_geometry).length >=
                    1) {
                    this.hasActiveSpatialFilter = true;
                }
            }
            this.filtersAreEditable = ogcFilters.editable
                ? ogcFilters.editable
                : false;
        }
        const resolution$ = this.layer.map.viewController.resolution$;
        this.resolution$$ = resolution$.subscribe(() => {
            this.inResolutionRange$.next(this.layer.isInResolutionsRange);
        });
    }
    ngOnDestroy() {
        this.resolution$$.unsubscribe();
    }
    addFilterToSequence() {
        this.filtersCollapsed = false;
        const interfaceOgcFilters = this.datasource.options.ogcFilters.interfaceOgcFilters;
        const arr = interfaceOgcFilters || [];
        const lastLevel = arr.length === 0 ? 0 : arr[arr.length - 1].level;
        let firstFieldName = '';
        const includedFields = this.datasource.options.sourceFields.filter((f) => !f.excludeFromOgcFilters);
        if (includedFields.length > 0) {
            firstFieldName =
                includedFields[0].name === undefined ? '' : includedFields[0].name;
        }
        let fieldNameGeometry;
        const datasourceOptions = this.datasource
            .options;
        if (datasourceOptions.fieldNameGeometry) {
            fieldNameGeometry = datasourceOptions.fieldNameGeometry;
        }
        else if (this.datasource.options.paramsWFS &&
            this.datasource.options.paramsWFS.fieldNameGeometry) {
            fieldNameGeometry = this.datasource.options.paramsWFS
                .fieldNameGeometry;
        }
        const allowedOperators = this.ogcFilterWriter.computeAllowedOperators(this.datasource.options.sourceFields, firstFieldName, this.datasource.options.ogcFilters.allowedOperatorsType);
        const firstOperatorName = Object.keys(allowedOperators)[0];
        arr.push(this.ogcFilterWriter.addInterfaceFilter({
            propertyName: firstFieldName,
            operator: firstOperatorName,
            active: true,
            igoSpatialSelector: 'fixedExtent',
            srsName: this.map.projection
        }, fieldNameGeometry, lastLevel, this.defaultLogicalParent));
        this.datasource.options.ogcFilters.interfaceOgcFilters = arr;
    }
    refreshFilters(force) {
        if (force === true) {
            this.lastRunOgcFilter = undefined;
        }
        const ogcFilters = this.datasource.options.ogcFilters;
        const activeFilters = ogcFilters.interfaceOgcFilters
            ? ogcFilters.interfaceOgcFilters.filter((f) => f.active === true)
            : [];
        if (activeFilters.length === 0) {
            ogcFilters.filters = undefined;
            ogcFilters.filtered = false;
        }
        if (activeFilters.length > 1) {
            activeFilters[0].parentLogical = activeFilters[1].parentLogical;
        }
        if (activeFilters.filter((af) => ['Contains', 'Intersects', 'Within'].indexOf(af.operator) !== -1).length === 0) {
            this.hasActiveSpatialFilter = false;
        }
        else {
            this.hasActiveSpatialFilter = true;
        }
        if (!(JSON.stringify(this.lastRunOgcFilter) === JSON.stringify(activeFilters))) {
            if (this.layer.dataSource.options.type === 'wfs') {
                const ogcDataSource = this.layer.dataSource;
                const ogcLayer = ogcDataSource.options.ogcFilters;
                ogcLayer.filters =
                    this.ogcFilterWriter.rebuiltIgoOgcFilterObjectFromSequence(activeFilters);
                this.layer.dataSource.ol.refresh();
            }
            else if (this.layer.dataSource.options.type === 'wms' &&
                ogcFilters.enabled) {
                let rebuildFilter = '';
                if (activeFilters.length >= 1) {
                    const ogcDataSource = this.layer.dataSource;
                    const ogcLayer = ogcDataSource.options.ogcFilters;
                    ogcLayer.filters =
                        this.ogcFilterWriter.rebuiltIgoOgcFilterObjectFromSequence(activeFilters);
                    rebuildFilter = this.ogcFilterWriter.buildFilter(ogcLayer.filters, undefined, undefined, this.layer.dataSource.options.fieldNameGeometry, ogcDataSource.options);
                }
                this.ogcFilterService.filterByOgc(this.datasource, rebuildFilter);
                this.datasource.options.ogcFilters.filtered =
                    activeFilters.length === 0 ? false : true;
            }
            this.lastRunOgcFilter = JSON.parse(JSON.stringify(activeFilters));
        }
        else {
            // identical filter. Nothing triggered
        }
        this.layer.dataSource.setOgcFilters(ogcFilters, true);
    }
    setVisible() {
        this.layer.visible = true;
    }
    isAdvancedOgcFilters() {
        return this.datasource.options.ogcFilters.advancedOgcFilters;
    }
    addFilterDisabled() {
        return (!this.datasource.options.sourceFields ||
            this.datasource.options.sourceFields.length === 0);
    }
    changeOgcFiltersAdvancedOgcFilters(value) {
        this.datasource.options.ogcFilters.advancedOgcFilters = value;
    }
    changeOgcFilterType(isAdvancedOgcFilters) {
        this.changeOgcFiltersAdvancedOgcFilters(isAdvancedOgcFilters.checked);
        if (isAdvancedOgcFilters.checked) {
            this.refreshFilters(true);
        }
    }
    toggleLegend(collapsed) {
        this.layer.legendCollapsed = collapsed;
        this.showLegend$.next(!collapsed);
    }
    toggleLegendOnClick() {
        if (!this.filtersCollapsed) {
            this.toggleLegend(this.showLegend$.value);
        }
    }
    toggleFiltersCollapsed() {
        this.filtersCollapsed = !this.filtersCollapsed;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OgcFilterableItemComponent, deps: [{ token: OGCFilterService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: OgcFilterableItemComponent, selector: "igo-ogc-filterable-item", inputs: { layer: "layer", map: "map", header: "header" }, ngImport: i0, template: "<div [ngClass]=\"{ 'separate-item': header === true }\">\n  <mat-list-item>\n    <mat-icon\n      *ngIf=\"header\"\n      class=\"igo-chevron\"\n      matListItemIcon\n      igoCollapse\n      [target]=\"ogcFilters\"\n      [collapsed]=\"filtersCollapsed\"\n      (click)=\"toggleFiltersCollapsed()\"\n      svgIcon=\"chevron-up\"\n    >\n    </mat-icon>\n    <span\n      *ngIf=\"header\"\n      matListItemTitle\n      [ngStyle]=\"{ cursor: filtersCollapsed ? 'default' : 'pointer' }\"\n      [matTooltip]=\"layer.title\"\n      matTooltipShowDelay=\"500\"\n      (click)=\"toggleLegendOnClick()\"\n    >\n      {{ layer.title }}\n    </span>\n    <div matListItemMeta>\n      <button\n        *ngIf=\"isAdvancedOgcFilters() && filtersAreEditable\"\n        [disabled]=\"addFilterDisabled()\"\n        mat-icon-button\n        tooltip-position=\"below\"\n        matTooltipShowDelay=\"500\"\n        [matTooltip]=\"'igo.geo.filter.addFilter' | translate\"\n        [color]=\"color\"\n        (click)=\"addFilterToSequence()\"\n      >\n        <mat-icon svgIcon=\"plus\"></mat-icon>\n      </button>\n      <button\n        *ngIf=\"header\"\n        mat-icon-button\n        [color]=\"layer.visible ? 'primary' : 'default'\"\n        collapsibleButton\n        tooltip-position=\"below\"\n        matTooltipShowDelay=\"500\"\n        [matTooltip]=\"\n          layer.visible\n            ? ('igo.geo.layer.hideLayer' | translate)\n            : ('igo.geo.layer.showLayer' | translate)\n        \"\n        (click)=\"layer.visible = !layer.visible\"\n      >\n        <mat-icon\n          [ngClass]=\"{ disabled: (inResolutionRange$ | async) === false }\"\n          [svgIcon]=\"layer.visible ? 'eye' : 'eye-off'\"\n        >\n        </mat-icon>\n      </button>\n    </div>\n  </mat-list-item>\n\n  <div #ogcFilters>\n    <div *ngIf=\"header\" #legend class=\"igo-layer-legend-container\">\n      <igo-layer-legend *ngIf=\"showLegend$ | async\" [layer]=\"layer\">\n      </igo-layer-legend>\n    </div>\n    <igo-ogc-filterable-form\n      [datasource]=\"datasource\"\n      [map]=\"map\"\n      [refreshFilters]=\"refreshFunc\"\n    >\n    </igo-ogc-filterable-form>\n\n    <section\n      *ngIf=\"hasSelector && filtersAreEditable\"\n      class=\"mat-typography advancedOgcFilters\"\n    >\n      <mat-divider></mat-divider>\n      <mat-checkbox\n        (change)=\"changeOgcFilterType($event)\"\n        [(ngModel)]=\"datasource.options.ogcFilters.advancedOgcFilters\"\n      >\n        {{ 'igo.geo.filter.advancedOgcFilters' | translate }}\n      </mat-checkbox>\n    </section>\n  </div>\n</div>\n", styles: [":host{overflow:hidden}:host .advancedOgcFilters{text-align:center;width:100%;display:inline-block}:host .mat-mdc-list-item{height:auto}:host .igo-layer-legend-container{padding-left:1.125em;width:calc(100% - 18px)}:host mat-icon.disabled{color:#00000061}:host .separate-item{border-bottom:4px solid darkgrey}:host ::ng-deep .mdc-list-item__start,:host ::ng-deep .mdc-list-item__end,:host ::ng-deep .mdc-list-item__content{pointer-events:auto}\n"], dependencies: [{ kind: "directive", type: i2$2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2$2.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "component", type: i11.MatCheckbox, selector: "mat-checkbox", inputs: ["disableRipple", "color", "tabIndex"], exportAs: ["matCheckbox"] }, { kind: "component", type: i5.MatListItem, selector: "mat-list-item, a[mat-list-item], button[mat-list-item]", inputs: ["activated"], exportAs: ["matListItem"] }, { kind: "directive", type: i5.MatListItemIcon, selector: "[matListItemIcon]" }, { kind: "component", type: i9$2.MatDivider, selector: "mat-divider", inputs: ["vertical", "inset"] }, { kind: "directive", type: i5.MatListItemTitle, selector: "[matListItemTitle]" }, { kind: "directive", type: i5.MatListItemMeta, selector: "[matListItemMeta]" }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "component", type: LayerLegendComponent, selector: "igo-layer-legend", inputs: ["updateLegendOnResolutionChange", "layer"] }, { kind: "directive", type: i9$1.CollapseDirective, selector: "[igoCollapse]", inputs: ["target", "collapsed"], outputs: ["toggle"] }, { kind: "component", type: OgcFilterableFormComponent, selector: "igo-ogc-filterable-form", inputs: ["datasource", "map", "refreshFilters"] }, { kind: "pipe", type: i2$2.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OgcFilterableItemComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-ogc-filterable-item', template: "<div [ngClass]=\"{ 'separate-item': header === true }\">\n  <mat-list-item>\n    <mat-icon\n      *ngIf=\"header\"\n      class=\"igo-chevron\"\n      matListItemIcon\n      igoCollapse\n      [target]=\"ogcFilters\"\n      [collapsed]=\"filtersCollapsed\"\n      (click)=\"toggleFiltersCollapsed()\"\n      svgIcon=\"chevron-up\"\n    >\n    </mat-icon>\n    <span\n      *ngIf=\"header\"\n      matListItemTitle\n      [ngStyle]=\"{ cursor: filtersCollapsed ? 'default' : 'pointer' }\"\n      [matTooltip]=\"layer.title\"\n      matTooltipShowDelay=\"500\"\n      (click)=\"toggleLegendOnClick()\"\n    >\n      {{ layer.title }}\n    </span>\n    <div matListItemMeta>\n      <button\n        *ngIf=\"isAdvancedOgcFilters() && filtersAreEditable\"\n        [disabled]=\"addFilterDisabled()\"\n        mat-icon-button\n        tooltip-position=\"below\"\n        matTooltipShowDelay=\"500\"\n        [matTooltip]=\"'igo.geo.filter.addFilter' | translate\"\n        [color]=\"color\"\n        (click)=\"addFilterToSequence()\"\n      >\n        <mat-icon svgIcon=\"plus\"></mat-icon>\n      </button>\n      <button\n        *ngIf=\"header\"\n        mat-icon-button\n        [color]=\"layer.visible ? 'primary' : 'default'\"\n        collapsibleButton\n        tooltip-position=\"below\"\n        matTooltipShowDelay=\"500\"\n        [matTooltip]=\"\n          layer.visible\n            ? ('igo.geo.layer.hideLayer' | translate)\n            : ('igo.geo.layer.showLayer' | translate)\n        \"\n        (click)=\"layer.visible = !layer.visible\"\n      >\n        <mat-icon\n          [ngClass]=\"{ disabled: (inResolutionRange$ | async) === false }\"\n          [svgIcon]=\"layer.visible ? 'eye' : 'eye-off'\"\n        >\n        </mat-icon>\n      </button>\n    </div>\n  </mat-list-item>\n\n  <div #ogcFilters>\n    <div *ngIf=\"header\" #legend class=\"igo-layer-legend-container\">\n      <igo-layer-legend *ngIf=\"showLegend$ | async\" [layer]=\"layer\">\n      </igo-layer-legend>\n    </div>\n    <igo-ogc-filterable-form\n      [datasource]=\"datasource\"\n      [map]=\"map\"\n      [refreshFilters]=\"refreshFunc\"\n    >\n    </igo-ogc-filterable-form>\n\n    <section\n      *ngIf=\"hasSelector && filtersAreEditable\"\n      class=\"mat-typography advancedOgcFilters\"\n    >\n      <mat-divider></mat-divider>\n      <mat-checkbox\n        (change)=\"changeOgcFilterType($event)\"\n        [(ngModel)]=\"datasource.options.ogcFilters.advancedOgcFilters\"\n      >\n        {{ 'igo.geo.filter.advancedOgcFilters' | translate }}\n      </mat-checkbox>\n    </section>\n  </div>\n</div>\n", styles: [":host{overflow:hidden}:host .advancedOgcFilters{text-align:center;width:100%;display:inline-block}:host .mat-mdc-list-item{height:auto}:host .igo-layer-legend-container{padding-left:1.125em;width:calc(100% - 18px)}:host mat-icon.disabled{color:#00000061}:host .separate-item{border-bottom:4px solid darkgrey}:host ::ng-deep .mdc-list-item__start,:host ::ng-deep .mdc-list-item__end,:host ::ng-deep .mdc-list-item__content{pointer-events:auto}\n"] }]
        }], ctorParameters: function () { return [{ type: OGCFilterService }]; }, propDecorators: { layer: [{
                type: Input
            }], map: [{
                type: Input
            }], header: [{
                type: Input
            }] } });

class OgcFilterButtonComponent {
    options;
    get badge() {
        const filter = this.options.ogcFilters;
        let cnt = 0;
        if (filter && !filter.advancedOgcFilters) {
            if (filter.pushButtons) {
                const pushButtons = filter.pushButtons;
                const currentPushButtonGroup = pushButtons.groups.find((gr) => gr.enabled);
                let cntPushButtons = 0;
                if (currentPushButtonGroup) {
                    currentPushButtonGroup.computedSelectors?.map((cb) => (cntPushButtons += cb.selectors?.filter((button) => button.enabled).length));
                }
                cnt += cntPushButtons;
            }
            if (filter.checkboxes) {
                const checkboxes = filter.checkboxes;
                const currentCheckboxGroup = checkboxes.groups.find((gr) => gr.enabled);
                let cntCheckboxes = 0;
                if (currentCheckboxGroup) {
                    currentCheckboxGroup.computedSelectors?.map((cb) => (cntCheckboxes += cb.selectors?.filter((checkbox) => checkbox.enabled).length));
                }
                cnt += cntCheckboxes;
            }
            if (filter.radioButtons) {
                const radioButtons = filter.radioButtons;
                const currentRadioButtonsGroup = radioButtons.groups.find((gr) => gr.enabled);
                let cntRadioButtons = 0;
                if (currentRadioButtonsGroup) {
                    currentRadioButtonsGroup.computedSelectors?.map((cb) => (cntRadioButtons += cb.selectors?.filter((radio) => radio.enabled).length));
                }
                cnt += cntRadioButtons;
            }
            if (filter.select) {
                const select = filter.select;
                const currentSelectGroup = select.groups.find((gr) => gr.enabled);
                let cntSelect = 0;
                if (currentSelectGroup) {
                    currentSelectGroup.computedSelectors?.map((cb) => (cntSelect += cb.selectors?.filter((multi) => multi.enabled).length));
                }
                cnt += cntSelect;
            }
            if (filter.autocomplete) {
                const autocomplete = filter.autocomplete;
                const currentAutocompleteGroup = autocomplete.groups.find((gr) => gr.enabled);
                let cntAutocomplete = 0;
                if (currentAutocompleteGroup) {
                    currentAutocompleteGroup.computedSelectors?.map((cb) => (cntAutocomplete += cb.selectors?.filter((autocomplete) => autocomplete.enabled).length));
                }
                cnt += cntAutocomplete;
            }
        }
        else if (filter && filter.filters && !filter.filters.filters) {
            return 1;
        }
        else if (filter && filter.filters && filter.filters.filters) {
            return filter.filters.filters.length;
        }
        if (filter.filters &&
            filter.filters.operator === 'During' &&
            filter.filters.active &&
            filter.interfaceOgcFilters &&
            filter.interfaceOgcFilters[0].active) {
            const filterActiveValue = filter.interfaceOgcFilters[0];
            if (filter.filters.calendarModeYear) {
                // year mode check just year
                if (filterActiveValue.begin.substring(0, 4) !==
                    this.options.minDate.substring(0, 4) ||
                    filterActiveValue.end.substring(0, 4) !==
                        this.options.maxDate.substring(0, 4)) {
                    cnt += 1;
                }
            }
            else if (filterActiveValue.begin !== this.options.minDate ||
                filterActiveValue.end !== this.options.maxDate) {
                cnt += 1;
            }
        }
        return cnt > 0 ? cnt : undefined;
    }
    get layer() {
        return this._layer;
    }
    set layer(value) {
        this._layer = value;
        if (value) {
            this.options = this.layer.dataSource
                .options;
        }
    }
    _layer;
    map;
    color = 'primary';
    header;
    ogcFilterCollapse = false;
    constructor() { }
    ngOnInit() {
        this.options = this.layer.dataSource
            .options;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OgcFilterButtonComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: OgcFilterButtonComponent, selector: "igo-ogc-filter-button", inputs: { layer: "layer", map: "map", color: "color", header: "header" }, ngImport: i0, template: "<button\n  *ngIf=\"\n    header &&\n    options.ogcFilters &&\n    options.ogcFilters.enabled &&\n    (options.ogcFilters.pushButtons ||\n      options.ogcFilters.checkboxes ||\n      options.ogcFilters.radioButtons ||\n      options.ogcFilters.select ||\n      options.ogcFilters.autocomplete ||\n      options.ogcFilters.editable)\n  \"\n  mat-icon-button\n  collapsibleButton\n  tooltip-position=\"below\"\n  matTooltipShowDelay=\"500\"\n  [matTooltip]=\"'igo.geo.filter.filterBy' | translate\"\n  [color]=\"color\"\n>\n  <mat-icon\n    aria-hidden=\"false\"\n    [matBadge]=\"badge\"\n    matBadgeColor=\"warn\"\n    matBadgeSize=\"medium\"\n    svgIcon=\"filter\"\n  ></mat-icon>\n</button>\n\n<div\n  #ogcFilter\n  class=\"igo-layer-actions-container\"\n  *ngIf=\"\n    options.ogcFilters &&\n    options.ogcFilters.enabled &&\n    (options.ogcFilters.pushButtons ||\n      options.ogcFilters.checkboxes ||\n      options.ogcFilters.radioButtons ||\n      options.ogcFilters.select ||\n      options.ogcFilters.autocomplete ||\n      options.ogcFilters.editable)\n  \"\n>\n  <igo-ogc-filterable-item\n    *ngIf=\"ogcFilterCollapse && options.ogcFilters.enabled\"\n    igoListItem\n    [header]=\"false\"\n    [map]=\"layer.map\"\n    [layer]=\"layer\"\n  >\n  </igo-ogc-filterable-item>\n</div>\n", styles: [""], dependencies: [{ kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "directive", type: i9$1.ListItemDirective, selector: "[igoListItem]", inputs: ["color", "focused", "selected", "disabled"], outputs: ["beforeSelect", "beforeFocus", "beforeUnselect", "beforeUnfocus", "beforeDisable", "beforeEnable", "focus", "unfocus", "select", "unselect", "disable", "enable"] }, { kind: "directive", type: i6.MatBadge, selector: "[matBadge]", inputs: ["matBadgeDisabled", "matBadgeColor", "matBadgeOverlap", "matBadgePosition", "matBadge", "matBadgeDescription", "matBadgeSize", "matBadgeHidden"] }, { kind: "component", type: OgcFilterableItemComponent, selector: "igo-ogc-filterable-item", inputs: ["layer", "map", "header"] }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OgcFilterButtonComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-ogc-filter-button', changeDetection: ChangeDetectionStrategy.OnPush, template: "<button\n  *ngIf=\"\n    header &&\n    options.ogcFilters &&\n    options.ogcFilters.enabled &&\n    (options.ogcFilters.pushButtons ||\n      options.ogcFilters.checkboxes ||\n      options.ogcFilters.radioButtons ||\n      options.ogcFilters.select ||\n      options.ogcFilters.autocomplete ||\n      options.ogcFilters.editable)\n  \"\n  mat-icon-button\n  collapsibleButton\n  tooltip-position=\"below\"\n  matTooltipShowDelay=\"500\"\n  [matTooltip]=\"'igo.geo.filter.filterBy' | translate\"\n  [color]=\"color\"\n>\n  <mat-icon\n    aria-hidden=\"false\"\n    [matBadge]=\"badge\"\n    matBadgeColor=\"warn\"\n    matBadgeSize=\"medium\"\n    svgIcon=\"filter\"\n  ></mat-icon>\n</button>\n\n<div\n  #ogcFilter\n  class=\"igo-layer-actions-container\"\n  *ngIf=\"\n    options.ogcFilters &&\n    options.ogcFilters.enabled &&\n    (options.ogcFilters.pushButtons ||\n      options.ogcFilters.checkboxes ||\n      options.ogcFilters.radioButtons ||\n      options.ogcFilters.select ||\n      options.ogcFilters.autocomplete ||\n      options.ogcFilters.editable)\n  \"\n>\n  <igo-ogc-filterable-item\n    *ngIf=\"ogcFilterCollapse && options.ogcFilters.enabled\"\n    igoListItem\n    [header]=\"false\"\n    [map]=\"layer.map\"\n    [layer]=\"layer\"\n  >\n  </igo-ogc-filterable-item>\n</div>\n" }]
        }], ctorParameters: function () { return []; }, propDecorators: { layer: [{
                type: Input
            }], map: [{
                type: Input
            }], color: [{
                type: Input
            }], header: [{
                type: Input
            }] } });

class OgcFilterableListComponent {
    layers;
    map;
    constructor() { }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OgcFilterableListComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: OgcFilterableListComponent, selector: "igo-ogc-filterable-list", inputs: { layers: "layers", map: "map" }, ngImport: i0, template: "<igo-list [navigation]=\"false\" [selection]=\"false\">\n  <div\n    id=\"no-layer-message\"\n    *ngIf=\"(layers | filterableDataSource: 'ogc').length === 0\"\n  >\n    {{ 'igo.geo.filter.noFilterableLayer' | translate }}\n  </div>\n  <ng-template ngFor let-layer [ngForOf]=\"layers | filterableDataSource: 'ogc'\">\n    <igo-ogc-filterable-item\n      igoListItem\n      [header]=\"true\"\n      [layer]=\"layer\"\n      [map]=\"layer.map\"\n    ></igo-ogc-filterable-item>\n  </ng-template>\n</igo-list>\n", styles: ["#no-layer-message{padding:7%;text-align:center;font-size:medium;font-weight:700}\n"], dependencies: [{ kind: "directive", type: i2$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i9$1.ListItemDirective, selector: "[igoListItem]", inputs: ["color", "focused", "selected", "disabled"], outputs: ["beforeSelect", "beforeFocus", "beforeUnselect", "beforeUnfocus", "beforeDisable", "beforeEnable", "focus", "unfocus", "select", "unselect", "disable", "enable"] }, { kind: "component", type: i9$1.ListComponent, selector: "igo-list", inputs: ["navigation", "selection"] }, { kind: "component", type: OgcFilterableItemComponent, selector: "igo-ogc-filterable-item", inputs: ["layer", "map", "header"] }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }, { kind: "pipe", type: FilterableDataSourcePipe, name: "filterableDataSource" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OgcFilterableListComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-ogc-filterable-list', changeDetection: ChangeDetectionStrategy.OnPush, template: "<igo-list [navigation]=\"false\" [selection]=\"false\">\n  <div\n    id=\"no-layer-message\"\n    *ngIf=\"(layers | filterableDataSource: 'ogc').length === 0\"\n  >\n    {{ 'igo.geo.filter.noFilterableLayer' | translate }}\n  </div>\n  <ng-template ngFor let-layer [ngForOf]=\"layers | filterableDataSource: 'ogc'\">\n    <igo-ogc-filterable-item\n      igoListItem\n      [header]=\"true\"\n      [layer]=\"layer\"\n      [map]=\"layer.map\"\n    ></igo-ogc-filterable-item>\n  </ng-template>\n</igo-list>\n", styles: ["#no-layer-message{padding:7%;text-align:center;font-size:medium;font-weight:700}\n"] }]
        }], ctorParameters: function () { return []; }, propDecorators: { layers: [{
                type: Input
            }], map: [{
                type: Input
            }] } });

class OgcFilterableListBindingDirective {
    mapService;
    component;
    layers$$;
    constructor(component, mapService) {
        this.mapService = mapService;
        this.component = component;
    }
    ngOnInit() {
        // Override input layers
        this.component.layers = [];
        this.layers$$ = this.mapService.getMap().layers$.subscribe((layers) => {
            this.component.layers = layers.filter((layer) => layer.showInLayerList);
        });
    }
    ngOnDestroy() {
        this.layers$$.unsubscribe();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OgcFilterableListBindingDirective, deps: [{ token: OgcFilterableListComponent, self: true }, { token: MapService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: OgcFilterableListBindingDirective, selector: "[igoOgcFilterableListBinding]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OgcFilterableListBindingDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igoOgcFilterableListBinding]'
                }]
        }], ctorParameters: function () { return [{ type: OgcFilterableListComponent, decorators: [{
                    type: Self
                }] }, { type: MapService }]; } });

class OptionsApiService extends OptionsService {
    http;
    urlApi;
    provideContextUri;
    constructor(http, options = {}) {
        super();
        this.http = http;
        this.urlApi = options.url || this.urlApi;
        this.provideContextUri =
            options.provideContextUri || this.provideContextUri;
    }
    getWMSOptions(baseOptions, detailedContextUri) {
        if (!this.urlApi) {
            return of({});
        }
        let params = new HttpParams({
            fromObject: {
                type: baseOptions.type,
                url: baseOptions.url,
                layers: baseOptions.params.LAYERS
            }
        });
        if (detailedContextUri && this.provideContextUri) {
            params = params.append('context', detailedContextUri);
        }
        const request = this.http.get(this.urlApi, {
            params
        });
        return request.pipe(map((res) => {
            if (!res || !res.sourceOptions) {
                return {};
            }
            if (res.layerOptions) {
                res.sourceOptions._layerOptionsFromSource = res.layerOptions;
            }
            return res.sourceOptions;
        }));
    }
    getArcgisRestOptions(baseOptions, detailedContextUri) {
        if (!this.urlApi) {
            return of({});
        }
        let params = new HttpParams({
            fromObject: {
                type: baseOptions.type,
                url: baseOptions.url,
                layers: baseOptions.layer
            }
        });
        if (detailedContextUri && this.provideContextUri) {
            params = params.append('context', detailedContextUri);
        }
        const request = this.http.get(this.urlApi, {
            params
        });
        return request.pipe(map((res) => {
            if (!res || !res.sourceOptions) {
                return {};
            }
            if (res.layerOptions) {
                res.sourceOptions._layerOptionsFromSource = res.layerOptions;
            }
            return res.sourceOptions;
        }));
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OptionsApiService, deps: [{ token: i1.HttpClient }, { token: 'options' }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OptionsApiService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OptionsApiService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['options']
                }] }]; } });

function optionsApiFactory(http, configService) {
    return new OptionsApiService(http, configService.getConfig('optionsApi'));
}
function provideOptionsApi() {
    return {
        provide: OptionsService,
        useFactory: optionsApiFactory,
        deps: [HttpClient, ConfigService]
    };
}

/**
 * Spatial-Filter-Item (search parameters)
 */
class SpatialFilterItemComponent {
    cdRef;
    spatialFilterService;
    messageService;
    languageService;
    map;
    get type() {
        return this._type;
    }
    set type(type) {
        this._type = type;
        const index = this.geometryTypes.findIndex((geom) => geom === this.type);
        this.geometryType = this.geometryTypes[index];
        this.formControl.reset();
        this.radius = undefined;
        this.drawGuide$.next(null);
        this.drawStyle$.next(undefined);
        // Necessary to keep reference to the geometry form field input
        if (this.type === SpatialFilterType.Predefined) {
            const geojson = {
                type: 'Point',
                coordinates: ''
            };
            this.formControl.setValue(geojson);
        }
        // Necessary to apply the right style when geometry type is Point
        if (this.type === SpatialFilterType.Point) {
            this.radius = 1000; // Base radius
            this.radiusFormControl.setValue(this.radius);
            this.PointStyle = (feature, resolution) => {
                const geom = feature.getGeometry();
                const coordinates = olproj.transform(geom.getCoordinates(), this.map.projection, 'EPSG:4326');
                return new olStyle.Style({
                    image: new olStyle.Circle({
                        radius: this.radius /
                            Math.cos((Math.PI / 180) * coordinates[1]) /
                            resolution,
                        stroke: new olStyle.Stroke({
                            width: 2,
                            color: 'rgba(0, 153, 255)'
                        }),
                        fill: new olStyle.Fill({
                            color: 'rgba(0, 153, 255, 0.2)'
                        })
                    })
                });
            };
            this.overlayStyle = this.PointStyle;
            this.drawStyle$.next(this.overlayStyle);
        }
        else {
            // If geometry types is Polygon
            this.radius = undefined;
            this.PolyStyle = () => {
                return new olStyle.Style({
                    stroke: new olStyle.Stroke({
                        width: 2,
                        color: 'rgba(0, 153, 255)'
                    }),
                    fill: new olStyle.Fill({
                        color: 'rgba(0, 153, 255, 0.2)'
                    })
                });
            };
            const color = [0, 153, 255];
            const drawStyle = () => {
                return new olStyle.Style({
                    image: new olStyle.Circle({
                        radius: 8,
                        stroke: new olStyle.Stroke({
                            width: 2,
                            color: 'rgba(0, 153, 255)'
                        }),
                        fill: new olStyle.Fill({
                            color: 'rgba(0, 153, 255, 0.2)'
                        })
                    }),
                    stroke: new olStyle.Stroke({
                        color: color.concat([1]),
                        width: 2
                    }),
                    fill: new olStyle.Fill({
                        color: color.concat([0.2])
                    })
                });
            };
            this.overlayStyle = this.PolyStyle;
            this.drawStyle$.next(drawStyle);
        }
        this.overlayStyle$.next(this.overlayStyle);
    }
    _type;
    queryType;
    zone;
    loading;
    get store() {
        return this._store;
    }
    set store(store) {
        this._store = store;
        this._store.entities$.subscribe(() => {
            this.cdRef.detectChanges();
        });
    }
    _store;
    /**
     * Available measure units for the measure type given
     * @internal
     */
    get measureUnits() {
        return [MeasureLengthUnit.Meters, MeasureLengthUnit.Kilometers];
    }
    layers = [];
    allLayers = [];
    get thematicLength() {
        return this._thematicLength;
    }
    set thematicLength(value) {
        this._thematicLength = value;
    }
    _thematicLength;
    toggleSearch = new EventEmitter();
    itemTypeChange = new EventEmitter();
    thematicChange = new EventEmitter();
    drawZoneEvent = new EventEmitter();
    bufferEvent = new EventEmitter();
    zoneWithBufferChange = new EventEmitter();
    measureUnitChange = new EventEmitter();
    radiusEvent = new EventEmitter();
    freehandControl = new EventEmitter();
    predefinedRadius = new EventEmitter();
    clearButtonEvent = new EventEmitter();
    clearSearchEvent = new EventEmitter();
    export = new EventEmitter();
    openWorkspace = new EventEmitter();
    entityChange = new EventEmitter();
    itemType = [
        SpatialFilterItemType.Address,
        SpatialFilterItemType.Thematics
    ];
    selectedItemType = SpatialFilterItemType.Address;
    selectedSourceAddress;
    treeControl = new NestedTreeControl((node) => node.children);
    // For thematics and results tables
    displayedColumns = ['name', 'select'];
    childrens = [];
    groups = [];
    thematics = [];
    dataSource = new MatTreeNestedDataSource();
    selectedThematics = new SelectionModel(true, []);
    // For geometry form field input
    value$ = new BehaviorSubject(undefined);
    drawGuide$ = new BehaviorSubject(null);
    overlayStyle$ = new BehaviorSubject(undefined);
    drawStyle$ = new BehaviorSubject(undefined);
    value$$;
    radiusChanges$$;
    bufferChanges$$;
    formControl = new UntypedFormControl();
    geometryType;
    geometryTypeField = false;
    geometryTypes = ['Point', 'Polygon'];
    drawGuideField = false;
    drawGuide = null;
    drawGuidePlaceholder = '';
    measure = false;
    drawControlIsActive = true;
    freehandDrawIsActive = false;
    drawStyle;
    drawZone;
    overlayStyle;
    PointStyle;
    PolyStyle;
    radius;
    buffer = 0;
    radiusFormControl = new UntypedFormControl();
    bufferFormControl = new UntypedFormControl();
    measureUnit = MeasureLengthUnit.Meters;
    zoneWithBuffer;
    listIsVisible = true;
    tableTemplate;
    constructor(cdRef, spatialFilterService, messageService, languageService) {
        this.cdRef = cdRef;
        this.spatialFilterService = spatialFilterService;
        this.messageService = messageService;
        this.languageService = languageService;
    }
    ngOnInit() {
        this.spatialFilterService
            .loadThematicsList()
            .subscribe((items) => {
            for (const item of items) {
                this.childrens.push(item);
                this.childrens.sort((a, b) => {
                    return a.name.localeCompare(b.name);
                });
            }
            this.groups.push(this.languageService.translate.instant('igo.geo.terrapi.limites'));
            const limits = {
                name: this.groups[0],
                children: []
            };
            this.thematics.push(limits);
            this.childrens.forEach((child) => {
                if (child.group && this.groups.indexOf(child.group) === -1) {
                    this.groups.push(child.group);
                    const thematic = {
                        name: child.group,
                        children: []
                    };
                    this.thematics.push(thematic);
                }
                if (!child.group) {
                    if (child.name ===
                        this.languageService.translate.instant('igo.geo.terrapi.AdmRegion') ||
                        child.name ===
                            this.languageService.translate.instant('igo.geo.terrapi.Mun') ||
                        child.name ===
                            this.languageService.translate.instant('igo.geo.terrapi.Arrond') ||
                        child.name ===
                            this.languageService.translate.instant('igo.geo.terrapi.CircFed') ||
                        child.name ===
                            this.languageService.translate.instant('igo.geo.terrapi.CircProv') ||
                        child.name ===
                            this.languageService.translate.instant('igo.geo.terrapi.DirReg') ||
                        child.name ===
                            this.languageService.translate.instant('igo.geo.terrapi.MRC') ||
                        child.name ===
                            this.languageService.translate.instant('igo.geo.terrapi.RegTour')) {
                        child.group = limits.name;
                    }
                    else if (child.name ===
                        this.languageService.translate.instant('igo.geo.terrapi.routes')) {
                        child.group = this.languageService.translate.instant('igo.geo.spatialFilter.group.transport');
                    }
                    else {
                        const thematic = {
                            name: child.name,
                            children: [],
                            source: child.source
                        };
                        this.thematics.push(thematic);
                    }
                }
                this.thematics.sort((a, b) => {
                    return a.name.localeCompare(b.name);
                });
            });
            this.thematics.forEach((thematic) => {
                for (const child of this.childrens) {
                    if (child.group === thematic.name) {
                        thematic.children.push(child);
                    }
                }
            });
        });
        this.dataSource.data = this.thematics;
        this.drawGuide$.next(null);
        this.value$.next(this.formControl.value ? this.formControl.value : undefined);
        this.value$$ = this.formControl.valueChanges.subscribe((value) => {
            if (value) {
                this.value$.next(value);
                this.drawZone = this.formControl.value;
                if (this.buffer !== 0) {
                    this.drawZoneEvent.emit(this.drawZone);
                    this.bufferFormControl.setValue(this.buffer);
                }
            }
            else {
                this.value$.next(undefined);
                this.drawZone = undefined;
            }
        });
        this.value$.subscribe(() => {
            this.getRadius();
            this.cdRef.detectChanges();
        });
        this.radiusChanges$$ = this.radiusFormControl.valueChanges.subscribe(() => {
            this.getRadius();
            this.cdRef.detectChanges();
        });
        this.bufferChanges$$ = this.bufferFormControl.valueChanges
            .pipe(debounceTime(500))
            .subscribe((value) => {
            if (this.measureUnit === MeasureLengthUnit.Meters &&
                value > 0 &&
                value <= 100000) {
                this.buffer = value;
                this.bufferEvent.emit(value);
                this.spatialFilterService
                    .loadBufferGeometry(this.drawZone, SpatialFilterType.Polygon, value)
                    .subscribe((featureGeom) => {
                    this.zoneWithBuffer = featureGeom;
                    this.zoneWithBufferChange.emit(this.zoneWithBuffer);
                });
            }
            else if (this.measureUnit === MeasureLengthUnit.Kilometers &&
                value > 0 &&
                value <= 100) {
                this.buffer = value;
                this.bufferEvent.emit(value);
                this.spatialFilterService
                    .loadBufferGeometry(this.drawZone, SpatialFilterType.Polygon, value * 1000)
                    .subscribe((featureGeom) => {
                    this.zoneWithBuffer = featureGeom;
                    this.zoneWithBufferChange.emit(this.zoneWithBuffer);
                });
            }
            else if (value === 0) {
                this.buffer = value;
                this.bufferEvent.emit(value);
                this.drawZoneEvent.emit(this.drawZone);
            }
            else if (value < 0 ||
                (this.measureUnit === MeasureLengthUnit.Meters && value > 100000) ||
                (this.measureUnit === MeasureLengthUnit.Kilometers && value > 100)) {
                this.bufferFormControl.setValue(0);
                this.buffer = 0;
                this.messageService.alert('igo.geo.spatialFilter.bufferAlert', 'igo.geo.spatialFilter.warning');
            }
        });
        const selectedRecordStrategy = new EntityStoreFilterSelectionStrategy({});
        const selectionStrategy = new FeatureStoreSelectionStrategy({
            layer: new VectorLayer({
                zIndex: 300,
                source: new FeatureDataSource(),
                style: undefined,
                showInLayerList: false,
                exportable: false,
                browsable: false
            }),
            map: this.map,
            hitTolerance: 15,
            motion: FeatureMotion.Default,
            many: true,
            dragBox: true
        });
        this.store.addStrategy(selectionStrategy, true);
        this.store.addStrategy(selectedRecordStrategy, false);
    }
    /**
     * Unsubscribe to the value stream
     * @internal
     */
    ngOnDestroy() {
        this.value$$.unsubscribe();
        this.radiusChanges$$.unsubscribe();
        this.bufferChanges$$.unsubscribe();
        this.cdRef.detach();
        if (this.radiusChanges$$) {
            this.radiusChanges$$.unsubscribe();
        }
        if (this.value$$) {
            this.value$$.unsubscribe();
        }
    }
    onItemTypeChange(event) {
        this.selectedItemType = event.value;
        this.itemTypeChange.emit(this.selectedItemType);
    }
    /**
     * Set the measure unit
     * @internal
     */
    onMeasureUnitChange(unit) {
        if (unit === this.measureUnit) {
            return;
        }
        else {
            this.measureUnit = unit;
            this.measureUnitChange.emit(this.measureUnit);
            if (this.isPolygon()) {
                this.measureUnit === MeasureLengthUnit.Meters
                    ? this.bufferFormControl.setValue(this.bufferFormControl.value * 1000)
                    : this.bufferFormControl.setValue(this.bufferFormControl.value / 1000);
            }
            else if (this.isPoint()) {
                this.measureUnit === MeasureLengthUnit.Meters
                    ? this.radiusFormControl.setValue(this.radiusFormControl.value * 1000)
                    : this.radiusFormControl.setValue(this.radiusFormControl.value / 1000);
            }
        }
    }
    isPredefined() {
        return this.type === SpatialFilterType.Predefined;
    }
    isPolygon() {
        return this.type === SpatialFilterType.Polygon;
    }
    isPoint() {
        return this.type === SpatialFilterType.Point;
    }
    hasChild(_, node) {
        if (node.children) {
            return node.children.length;
        }
        return false;
    }
    onToggleClick(node) {
        this.treeControl.isExpanded(node)
            ? this.treeControl.collapse(node)
            : this.treeControl.expand(node);
    }
    isAllSelected(node) {
        let numSelected;
        let numNodes = 0;
        if (!node) {
            numSelected = this.selectedThematics.selected.length;
            this.thematics.forEach((thematic) => {
                if (this.groups.indexOf(thematic.name) === -1) {
                    numNodes++;
                }
            });
            this.childrens.forEach((children) => {
                if (!this.thematics.find((thematic) => thematic.source === children.source)) {
                    numNodes++;
                }
            });
        }
        else {
            numSelected = node.children.length;
            node.children.forEach((children) => {
                if (this.selectedThematics.selected.find((thematic) => thematic === children)) {
                    numNodes++;
                }
            });
        }
        if (numNodes >= 1) {
            return numSelected === numNodes;
        }
        else {
            return false;
        }
    }
    hasChildrenSelected(node) {
        let bool = false;
        node.children.forEach((child) => {
            if (this.selectedThematics.selected.find((thematic) => thematic.source === child.source)) {
                bool = true;
            }
        });
        return bool;
    }
    /**
     * Apply header checkbox
     */
    masterToggle() {
        this.isAllSelected() ? this.selectedThematics.clear() : this.selectAll();
        const selectedThematicsName = [];
        for (const thematic of this.selectedThematics.selected) {
            selectedThematicsName.push(thematic);
        }
        if (this.isAllSelected()) {
            this.thematics.forEach((thematic) => {
                if (this.hasChild(0, thematic)) {
                    this.treeControl.expand(thematic);
                }
            });
        }
        else {
            this.thematics.forEach((thematic) => {
                if (this.hasChild(0, thematic)) {
                    this.treeControl.collapse(thematic);
                }
            });
        }
        this.thematicChange.emit(selectedThematicsName);
    }
    selectAll(node) {
        if (!node) {
            this.thematics.forEach((thematic) => {
                if (this.groups.indexOf(thematic.name) === -1) {
                    this.selectedThematics.select(thematic);
                }
            });
            this.childrens.forEach((children) => {
                if (!this.selectedThematics.selected.find((thematic) => thematic.source === children.source)) {
                    this.selectedThematics.select(children);
                }
            });
        }
        else {
            if (this.hasChild(0, node)) {
                node.children.forEach((children) => this.selectedThematics.select(children));
            }
        }
    }
    childrensToggle(node) {
        this.isAllSelected(node)
            ? node.children.forEach((child) => this.selectedThematics.deselect(child))
            : this.selectAll(node);
        const selectedThematicsName = [];
        for (const thematic of this.selectedThematics.selected) {
            selectedThematicsName.push(thematic);
        }
        this.treeControl.expand(node);
        this.thematicChange.emit(selectedThematicsName);
    }
    /**
     * Apply changes to the thematics selected tree and emit event
     */
    onToggleChange(nodeSelected) {
        let selected = false;
        if (this.selectedThematics.selected.find((thematic) => thematic.source === nodeSelected.source) !== undefined) {
            selected = true;
        }
        this.childrens.forEach((children) => {
            if (children === nodeSelected && selected === false) {
                this.selectedThematics.select(children);
            }
            if (children === nodeSelected && selected === true) {
                this.selectedThematics.deselect(children);
            }
        });
        this.thematics.forEach((thematic) => {
            if (thematic === nodeSelected && selected === false) {
                this.selectedThematics.select(thematic);
            }
            if (thematic === nodeSelected && selected === true) {
                this.selectedThematics.deselect(thematic);
            }
        });
        const selectedThematicsName = [];
        for (const thematic of this.selectedThematics.selected) {
            selectedThematicsName.push(thematic);
        }
        this.thematicChange.emit(selectedThematicsName);
    }
    onDrawControlChange() {
        this.drawControlIsActive = !this.drawControlIsActive;
    }
    onfreehandControlChange() {
        this.freehandDrawIsActive = !this.freehandDrawIsActive;
        this.freehandControl.emit(this.freehandDrawIsActive);
        if (this.isPoint()) {
            this.predefinedRadius.emit(!this.freehandDrawIsActive);
            if (this.freehandDrawIsActive) {
                this.overlayStyle$.next(undefined);
                this.drawStyle$.next(undefined);
            }
        }
        else {
            this.predefinedRadius.emit(false);
        }
    }
    /**
     * Launch search button
     */
    toggleSearchButton() {
        if (!this.isPredefined()) {
            if (this.buffer > 0) {
                this.zoneWithBuffer.meta = {
                    id: undefined,
                    title: 'Zone'
                };
                this.zoneWithBuffer.properties = {
                    nom: 'Zone',
                    type: this.type
                };
                this.drawZoneEvent.emit(this.zoneWithBuffer);
            }
            else {
                this.drawZone.meta = {
                    id: undefined,
                    title: 'Zone'
                };
                this.drawZone.properties = {
                    nom: 'Zone',
                    type: this.type
                };
                this.drawZoneEvent.emit(this.drawZone);
            }
        }
        if (this.isPoint()) {
            this.radiusEvent.emit(this.radius);
        }
        else if (this.isPolygon()) {
            this.bufferEvent.emit(this.buffer);
        }
        this.toggleSearch.emit();
        this.store.entities$.pipe(debounceTime(500)).subscribe((value) => {
            if (value.length && this.layers.length === this.thematicLength + 1) {
                this.openWorkspace.emit();
                this.createTableTemplate();
            }
        });
    }
    /**
     * Launch clear button (clear store and map layers)
     */
    clearButton() {
        this.loading = true;
        if (this.store) {
            this.store.clear();
        }
        if (this.isPoint() || this.isPolygon()) {
            this.drawZone = undefined;
            this.formControl.reset();
        }
        this.bufferFormControl.setValue(0);
        this.buffer = 0;
        this.bufferEvent.emit(0);
        this.clearButtonEvent.emit();
        this.loading = false;
        this.tableTemplate = undefined;
    }
    clearDrawZone() {
        this.formControl.reset();
        this.bufferFormControl.setValue(0);
        this.buffer = 0;
    }
    /**
     * Launch clear search (clear field if type is predefined)
     */
    clearSearch() {
        this.selectedThematics.clear();
        this.bufferFormControl.setValue(0);
        this.buffer = 0;
        this.bufferEvent.emit(0);
        this.thematicChange.emit([]);
        this.clearSearchEvent.emit();
    }
    /**
     * Verify conditions of incomplete fields or busy service
     */
    disableSearchButton() {
        if (this.type === SpatialFilterType.Predefined) {
            if (this.selectedItemType === SpatialFilterItemType.Address) {
                if (this.queryType !== undefined && this.zone !== undefined) {
                    return this.loading;
                }
            }
            if (this.selectedItemType === SpatialFilterItemType.Thematics) {
                if (this.queryType !== undefined &&
                    this.zone !== undefined &&
                    this.selectedThematics.selected.length > 0) {
                    return this.loading;
                }
            }
        }
        if (this.type === SpatialFilterType.Polygon ||
            this.type === SpatialFilterType.Point) {
            if (this.selectedItemType === SpatialFilterItemType.Address &&
                this.formControl.value !== null) {
                return this.loading;
            }
            if (this.selectedItemType === SpatialFilterItemType.Thematics) {
                if (this.selectedThematics.selected.length > 0 &&
                    this.formControl.value !== null) {
                    return this.loading;
                }
            }
        }
        return true;
    }
    disabledClearSearch() {
        let disable = true;
        this.selectedItemType === SpatialFilterItemType.Address
            ? (disable = this.queryType === undefined)
            : (disable =
                this.queryType === undefined &&
                    this.selectedThematics.selected.length === 0);
        return disable;
    }
    /**
     * Manage radius value at user change
     */
    getRadius() {
        let formValue;
        if (this.formControl.value !== null) {
            this.measureUnit === MeasureLengthUnit.Meters
                ? (formValue = this.formControl.value.radius)
                : (formValue = this.formControl.value.radius / 1000);
        }
        else {
            formValue = undefined;
        }
        if (this.type === SpatialFilterType.Point) {
            if (!this.freehandDrawIsActive) {
                if (this.radiusFormControl.value < 0 ||
                    (this.measureUnit === MeasureLengthUnit.Meters &&
                        this.radiusFormControl.value >= 100000) ||
                    (this.measureUnit === MeasureLengthUnit.Kilometers &&
                        this.radiusFormControl.value >= 100)) {
                    this.messageService.alert('igo.geo.spatialFilter.radiusAlert', 'igo.geo.spatialFilter.warning');
                    this.radius = 1000;
                    this.measureUnit === MeasureLengthUnit.Meters
                        ? this.radiusFormControl.setValue(this.radius)
                        : this.radiusFormControl.setValue(this.radius / 1000);
                    this.drawGuide$.next(this.radius);
                    return;
                }
            }
            else {
                if (formValue) {
                    if (formValue >= 100000) {
                        this.messageService.alert('igo.geo.spatialFilter.radiusAlert', 'igo.geo.spatialFilter.warning');
                        this.formControl.reset();
                        return;
                    }
                    if (formValue !== this.radiusFormControl.value) {
                        this.radiusFormControl.setValue(formValue);
                        return;
                    }
                }
            }
            if (this.measureUnit === MeasureLengthUnit.Meters) {
                this.radius = this.radiusFormControl.value;
                this.drawGuide$.next(this.radius);
            }
            else {
                this.radius = this.radiusFormControl.value * 1000;
                this.drawGuide$.next(this.radius * 1000);
            }
            this.overlayStyle$.next(this.PointStyle);
            this.drawStyle$.next(this.PointStyle);
        }
    }
    toggleVisibleList() {
        this.listIsVisible = !this.listIsVisible;
    }
    createTableTemplate() {
        const typeColumn = {
            name: 'meta.title',
            title: this.languageService.translate.instant('igo.geo.spatialFilter.type'),
            renderer: EntityTableColumnRenderer.UnsanitizedHTML
        };
        const nameColumn = {
            name: 'properties.nom',
            title: this.languageService.translate.instant('igo.geo.spatialFilter.searchResults'),
            renderer: EntityTableColumnRenderer.UnsanitizedHTML
        };
        const columns = [typeColumn, nameColumn];
        this.tableTemplate = {
            selection: true,
            sort: true,
            columns
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SpatialFilterItemComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: SpatialFilterService }, { token: i2.MessageService }, { token: i2.LanguageService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: SpatialFilterItemComponent, selector: "igo-spatial-filter-item", inputs: { map: "map", type: "type", queryType: "queryType", zone: "zone", loading: "loading", store: "store", layers: "layers", allLayers: "allLayers", thematicLength: "thematicLength" }, outputs: { toggleSearch: "toggleSearch", itemTypeChange: "itemTypeChange", thematicChange: "thematicChange", drawZoneEvent: "drawZoneEvent", bufferEvent: "bufferEvent", zoneWithBufferChange: "zoneWithBufferChange", measureUnitChange: "measureUnitChange", radiusEvent: "radiusEvent", freehandControl: "freehandControl", predefinedRadius: "predefinedRadius", clearButtonEvent: "clearButtonEvent", clearSearchEvent: "clearSearchEvent", export: "export", openWorkspace: "openWorkspace", entityChange: "entityChange" }, ngImport: i0, template: "<igo-geometry-form-field-input\n  [formControl]=\"formControl\"\n  [map]=\"map\"\n  [geometryType]=\"geometryType\"\n  [drawGuide]=\"drawGuide$ | async\"\n  [measure]=\"measure\"\n  [drawControlIsActive]=\"drawControlIsActive\"\n  [freehandDrawIsActive]=\"freehandDrawIsActive\"\n  [drawStyle]=\"drawStyle$ | async\"\n  [overlayStyle]=\"overlayStyle$ | async\"\n  [radius]=\"radius\"\n  [predefinedRadius]=\"predefinedRadius\"\n>\n</igo-geometry-form-field-input>\n\n<div class=\"header\">\n  <mat-slide-toggle\n    *ngIf=\"!isPredefined()\"\n    [checked]=\"drawControlIsActive\"\n    [labelPosition]=\"'before'\"\n    (change)=\"onDrawControlChange()\"\n  >\n    {{ 'igo.geo.spatialFilter.drawControl' | translate }}\n  </mat-slide-toggle>\n  <mat-slide-toggle\n    *ngIf=\"!isPredefined()\"\n    [checked]=\"freehandDrawIsActive\"\n    [labelPosition]=\"'before'\"\n    (change)=\"onfreehandControlChange()\"\n  >\n    {{ 'igo.geo.spatialFilter.freehandControl' | translate }}\n  </mat-slide-toggle>\n</div>\n\n<div class=\"buffer-unit\" *ngIf=\"isPolygon()\">\n  <mat-form-field class=\"buffer\">\n    <input\n      type=\"number\"\n      matInput\n      placeholder=\"{{ 'igo.geo.spatialFilter.buffer' | translate }}\"\n      [formControl]=\"bufferFormControl\"\n      [value]=\"0\"\n      [readonly]=\"this.formControl.value === null\"\n    />\n  </mat-form-field>\n\n  <mat-form-field class=\"unit-field\">\n    <mat-select\n      [value]=\"measureUnit\"\n      (selectionChange)=\"onMeasureUnitChange($event.value)\"\n    >\n      <mat-option\n        *ngFor=\"let measureUnit of measureUnits\"\n        [value]=\"measureUnit\"\n      >\n        {{ 'igo.geo.measure.' + measureUnit | translate }}\n      </mat-option>\n    </mat-select>\n  </mat-form-field>\n</div>\n\n<div class=\"radius-unit\" *ngIf=\"isPoint()\">\n  <mat-form-field class=\"radius\">\n    <input\n      type=\"number\"\n      matInput\n      placeholder=\"{{ 'igo.geo.spatialFilter.radius' | translate }}\"\n      [formControl]=\"radiusFormControl\"\n      [value]=\"1000\"\n      (input)=\"getRadius()\"\n      [readonly]=\"this.freehandDrawIsActive && this.formControl.value === null\"\n    />\n  </mat-form-field>\n\n  <mat-form-field class=\"unit-field\">\n    <mat-select\n      [value]=\"measureUnit\"\n      (selectionChange)=\"onMeasureUnitChange($event.value)\"\n    >\n      <mat-option\n        *ngFor=\"let measureUnit of measureUnits\"\n        [value]=\"measureUnit\"\n      >\n        {{ 'igo.geo.measure.' + measureUnit | translate }}\n      </mat-option>\n    </mat-select>\n  </mat-form-field>\n</div>\n\n<mat-label class=\"title mat-typography\"\n  >{{ 'igo.geo.spatialFilter.search' | translate }} :\n</mat-label>\n<mat-radio-group [value]=\"selectedItemType\">\n  <mat-radio-button\n    *ngFor=\"let item of itemType\"\n    [value]=\"item\"\n    (change)=\"onItemTypeChange($event)\"\n  >\n    {{ 'igo.geo.spatialFilter.' + item | translate }}\n  </mat-radio-button>\n</mat-radio-group>\n\n<div\n  class=\"thematics\"\n  *ngIf=\"\n    (selectedItemType === 'Thematics' && !tableTemplate) ||\n    (selectedItemType === 'Thematics' && tableTemplate && !listIsVisible)\n  \"\n>\n  <mat-table>\n    <!-- Name Column -->\n    <ng-container matColumnDef=\"name\">\n      <mat-header-cell *matHeaderCellDef class=\"thematics-header\">{{\n        'igo.geo.spatialFilter.Thematics' | translate\n      }}</mat-header-cell>\n    </ng-container>\n\n    <!-- Select Column -->\n    <ng-container matColumnDef=\"select\">\n      <mat-header-cell *matHeaderCellDef class=\"checks-header\">\n        <mat-checkbox\n          (change)=\"$event ? masterToggle() : null\"\n          [checked]=\"isAllSelected()\"\n          [indeterminate]=\"selectedThematics.hasValue() && !isAllSelected()\"\n        >\n        </mat-checkbox>\n      </mat-header-cell>\n    </ng-container>\n\n    <mat-header-row *matHeaderRowDef=\"displayedColumns\"></mat-header-row>\n    <mat-row *matRowDef=\"let row; columns: displayedColumns\"></mat-row>\n  </mat-table>\n\n  <mat-tree [dataSource]=\"dataSource\" [treeControl]=\"treeControl\">\n    <!-- This is the tree node template for leaf nodes -->\n    <mat-tree-node *matTreeNodeDef=\"let node\" matTreeNodeToggle>\n      <li class=\"mat-tree-node\">\n        <!-- use a disabled button to provide padding for tree leaf -->\n        <button mat-icon-button disabled></button>\n        {{ node.name }}\n        <mat-checkbox\n          class=\"tree-check\"\n          (click)=\"$event.stopPropagation()\"\n          (change)=\"$event ? onToggleChange(node) : null\"\n          [checked]=\"selectedThematics.isSelected(node)\"\n        >\n        </mat-checkbox>\n      </li>\n    </mat-tree-node>\n\n    <!-- This is the tree node template for expandable nodes -->\n    <mat-nested-tree-node *matTreeNodeDef=\"let node; when: hasChild\">\n      <div class=\"mat-tree-node\">\n        <button mat-icon-button (click)=\"onToggleClick(node)\">\n          <mat-icon\n            [svgIcon]=\"\n              treeControl.isExpanded(node) ? 'chevron-down' : 'chevron-right'\n            \"\n          ></mat-icon>\n        </button>\n        {{ node.name }}\n        <mat-checkbox\n          class=\"tree-check-2\"\n          (change)=\"$event ? childrensToggle(node) : null\"\n          [checked]=\"isAllSelected(node)\"\n          [indeterminate]=\"hasChildrenSelected(node) && !isAllSelected(node)\"\n        >\n        </mat-checkbox>\n      </div>\n      <ul\n        class=\"tree-ul\"\n        [class.example-tree-invisible]=\"!treeControl.isExpanded(node)\"\n      >\n        <ng-container matTreeNodeOutlet></ng-container>\n      </ul>\n    </mat-nested-tree-node>\n  </mat-tree>\n</div>\n\n<div class=\"buttons\">\n  <button\n    *ngIf=\"isPredefined()\"\n    mat-raised-button\n    class=\"clear-search-button\"\n    [disabled]=\"disabledClearSearch()\"\n    (click)=\"clearSearch()\"\n  >\n    {{ 'igo.geo.spatialFilter.clearSearch' | translate }}\n  </button>\n\n  <button\n    *ngIf=\"isPolygon() || isPoint()\"\n    mat-raised-button\n    class=\"clear-form-button\"\n    [disabled]=\"this.formControl.value === null\"\n    (click)=\"clearDrawZone()\"\n  >\n    {{ 'igo.geo.spatialFilter.clearForm' | translate }}\n  </button>\n\n  <button\n    mat-raised-button\n    class=\"search-button\"\n    [disabled]=\"disableSearchButton()\"\n    color=\"primary\"\n    (click)=\"toggleSearchButton()\"\n  >\n    {{ 'igo.geo.spatialFilter.goSearch' | translate }}\n  </button>\n\n  <button\n    mat-raised-button\n    class=\"remove-button\"\n    [disabled]=\"allLayers.length === 0\"\n    (click)=\"clearButton()\"\n  >\n    {{ 'igo.geo.spatialFilter.removeLayer' | translate }}\n  </button>\n\n  <button\n    mat-raised-button\n    class=\"export-button\"\n    [disabled]=\"!store.entities$.getValue().length\"\n    (click)=\"export.emit()\"\n  >\n    {{ 'igo.geo.spatialFilter.exportLayer' | translate }}\n  </button>\n</div>\n\n<button\n  class=\"chevron-down\"\n  *ngIf=\"store.all().length && tableTemplate && !listIsVisible\"\n  mat-icon-button\n  matTooltipShowDelay=\"500\"\n  [matTooltip]=\"'igo.geo.spatialFilter.showSearchResults' | translate\"\n  (click)=\"toggleVisibleList()\"\n>\n  <mat-icon svgIcon=\"chevron-down\"></mat-icon>\n</button>\n\n<div\n  class=\"results\"\n  *ngIf=\"store.all().length && tableTemplate && listIsVisible\"\n>\n  <button\n    *ngIf=\"listIsVisible\"\n    mat-icon-button\n    matTooltipShowDelay=\"500\"\n    [matTooltip]=\"'igo.geo.spatialFilter.hideSearchResults' | translate\"\n    (click)=\"toggleVisibleList()\"\n  >\n    <mat-icon svgIcon=\"chevron-up\"></mat-icon>\n  </button>\n  <igo-entity-table\n    class=\"results-list\"\n    [template]=\"tableTemplate\"\n    [store]=\"store\"\n    (entitySelectChange)=\"entityChange.emit($event)\"\n  >\n  </igo-entity-table>\n</div>\n", styles: [":host .header{margin-top:5px;width:100%}:host .mat-mdc-slide-toggle{padding:5px;width:100%}:host .mat-mdc-slide-toggle ::ng-deep .mdc-form-field{width:100%}:host .mat-mdc-slide-toggle ::ng-deep .mdc-label{margin-left:0;width:calc(100% - 60px)}:host .title{margin-left:5px;font-size:initial}:host .mat-mdc-radio-group{display:flex;flex-direction:column}:host .mat-mdc-radio-button{display:inline-flex;position:relative;margin-left:12px}:host .mat-mdc-form-field{margin-top:5px}:host .mat-column-select{overflow:auto}:host .buttons{display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin:16px 0}:host .thematics{max-height:35%;overflow:auto;margin-top:5px;width:98%}:host .results{overflow:auto;max-height:250px;width:98%}:host .mat-column-typeResults{max-width:100px;margin-right:5px}:host .buffer-unit,:host .radius-unit{display:flex;width:100%;padding:5px;box-sizing:border-box}:host .radius,:host .buffer{flex-flow:column nowrap;flex:2}:host .unit-field{flex:1;margin-left:8px}:host .example-tree-invisible{display:none}:host .tree-ul{margin:0;padding:0 0 0 20px;list-style-type:none}:host .tree-check,:host .tree-check-2{position:relative;margin-left:auto;margin-right:5px}:host .thematics-header{max-width:250px}:host .checks-header{padding:none;max-width:calc(100% - 316px);overflow:hidden}:host .mat-mdc-checkbox{padding:5px}:host .mat-tree-node{position:relative;min-height:42px;width:280px}:host .mat-mdc-header-cell{height:56px}:host .results{max-height:45%;width:98%}:host .results igo-entity-table ::ng-deep div.table-container{overflow:unset}\n"], dependencies: [{ kind: "directive", type: i2$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i2$1.NumberValueAccessor, selector: "input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]" }, { kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$1.FormControlDirective, selector: "[formControl]", inputs: ["formControl", "disabled", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { kind: "component", type: i9.MatOption, selector: "mat-option", exportAs: ["matOption"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i4$1.MatButton, selector: "    button[mat-button], button[mat-raised-button], button[mat-flat-button],    button[mat-stroked-button]  ", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "directive", type: i8$2.MatRadioGroup, selector: "mat-radio-group", exportAs: ["matRadioGroup"] }, { kind: "component", type: i8$2.MatRadioButton, selector: "mat-radio-button", inputs: ["disableRipple", "tabIndex"], exportAs: ["matRadioButton"] }, { kind: "component", type: i9$4.MatTable, selector: "mat-table, table[mat-table]", exportAs: ["matTable"] }, { kind: "directive", type: i9$4.MatHeaderCellDef, selector: "[matHeaderCellDef]" }, { kind: "directive", type: i9$4.MatHeaderRowDef, selector: "[matHeaderRowDef]", inputs: ["matHeaderRowDef", "matHeaderRowDefSticky"] }, { kind: "directive", type: i9$4.MatColumnDef, selector: "[matColumnDef]", inputs: ["sticky", "matColumnDef"] }, { kind: "directive", type: i9$4.MatRowDef, selector: "[matRowDef]", inputs: ["matRowDefColumns", "matRowDefWhen"] }, { kind: "directive", type: i9$4.MatHeaderCell, selector: "mat-header-cell, th[mat-header-cell]" }, { kind: "component", type: i9$4.MatHeaderRow, selector: "mat-header-row, tr[mat-header-row]", exportAs: ["matHeaderRow"] }, { kind: "component", type: i9$4.MatRow, selector: "mat-row, tr[mat-row]", exportAs: ["matRow"] }, { kind: "directive", type: i10$1.MatNestedTreeNode, selector: "mat-nested-tree-node", inputs: ["role", "disabled", "tabIndex", "matNestedTreeNode"], exportAs: ["matNestedTreeNode"] }, { kind: "directive", type: i10$1.MatTreeNodeDef, selector: "[matTreeNodeDef]", inputs: ["matTreeNodeDefWhen", "matTreeNode"] }, { kind: "directive", type: i10$1.MatTreeNodeToggle, selector: "[matTreeNodeToggle]", inputs: ["matTreeNodeToggleRecursive"] }, { kind: "component", type: i10$1.MatTree, selector: "mat-tree", exportAs: ["matTree"] }, { kind: "directive", type: i10$1.MatTreeNode, selector: "mat-tree-node", inputs: ["role", "disabled", "tabIndex"], exportAs: ["matTreeNode"] }, { kind: "directive", type: i10$1.MatTreeNodeOutlet, selector: "[matTreeNodeOutlet]" }, { kind: "component", type: i11.MatCheckbox, selector: "mat-checkbox", inputs: ["disableRipple", "color", "tabIndex"], exportAs: ["matCheckbox"] }, { kind: "component", type: i7.MatSlideToggle, selector: "mat-slide-toggle", inputs: ["disabled", "disableRipple", "color", "tabIndex"], exportAs: ["matSlideToggle"] }, { kind: "component", type: i8.MatFormField, selector: "mat-form-field", inputs: ["hideRequiredMarker", "color", "floatLabel", "appearance", "subscriptSizing", "hintLabel"], exportAs: ["matFormField"] }, { kind: "directive", type: i8.MatLabel, selector: "mat-label" }, { kind: "directive", type: i9$3.MatInput, selector: "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", inputs: ["disabled", "id", "placeholder", "name", "required", "type", "errorStateMatcher", "aria-describedby", "value", "readonly"], exportAs: ["matInput"] }, { kind: "component", type: i15.MatSelect, selector: "mat-select", inputs: ["disabled", "disableRipple", "tabIndex", "panelWidth", "hideSingleSelectionIndicator"], exportAs: ["matSelect"] }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "component", type: i9$1.EntityTableComponent, selector: "igo-entity-table", inputs: ["store", "paginator", "template", "scrollBehavior", "sortNullsFirst", "withPaginator", "paginatorOptions"], outputs: ["entityClick", "entitySelectChange", "entitySortChange"] }, { kind: "component", type: GeometryFormFieldInputComponent, selector: "igo-geometry-form-field-input", inputs: ["map", "geometryType", "drawGuide", "measure", "drawControlIsActive", "freehandDrawIsActive", "predefinedRadius", "controlOptions", "drawStyle", "overlayStyle", "value", "radius"] }, { kind: "pipe", type: i2$2.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SpatialFilterItemComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-spatial-filter-item', changeDetection: ChangeDetectionStrategy.OnPush, template: "<igo-geometry-form-field-input\n  [formControl]=\"formControl\"\n  [map]=\"map\"\n  [geometryType]=\"geometryType\"\n  [drawGuide]=\"drawGuide$ | async\"\n  [measure]=\"measure\"\n  [drawControlIsActive]=\"drawControlIsActive\"\n  [freehandDrawIsActive]=\"freehandDrawIsActive\"\n  [drawStyle]=\"drawStyle$ | async\"\n  [overlayStyle]=\"overlayStyle$ | async\"\n  [radius]=\"radius\"\n  [predefinedRadius]=\"predefinedRadius\"\n>\n</igo-geometry-form-field-input>\n\n<div class=\"header\">\n  <mat-slide-toggle\n    *ngIf=\"!isPredefined()\"\n    [checked]=\"drawControlIsActive\"\n    [labelPosition]=\"'before'\"\n    (change)=\"onDrawControlChange()\"\n  >\n    {{ 'igo.geo.spatialFilter.drawControl' | translate }}\n  </mat-slide-toggle>\n  <mat-slide-toggle\n    *ngIf=\"!isPredefined()\"\n    [checked]=\"freehandDrawIsActive\"\n    [labelPosition]=\"'before'\"\n    (change)=\"onfreehandControlChange()\"\n  >\n    {{ 'igo.geo.spatialFilter.freehandControl' | translate }}\n  </mat-slide-toggle>\n</div>\n\n<div class=\"buffer-unit\" *ngIf=\"isPolygon()\">\n  <mat-form-field class=\"buffer\">\n    <input\n      type=\"number\"\n      matInput\n      placeholder=\"{{ 'igo.geo.spatialFilter.buffer' | translate }}\"\n      [formControl]=\"bufferFormControl\"\n      [value]=\"0\"\n      [readonly]=\"this.formControl.value === null\"\n    />\n  </mat-form-field>\n\n  <mat-form-field class=\"unit-field\">\n    <mat-select\n      [value]=\"measureUnit\"\n      (selectionChange)=\"onMeasureUnitChange($event.value)\"\n    >\n      <mat-option\n        *ngFor=\"let measureUnit of measureUnits\"\n        [value]=\"measureUnit\"\n      >\n        {{ 'igo.geo.measure.' + measureUnit | translate }}\n      </mat-option>\n    </mat-select>\n  </mat-form-field>\n</div>\n\n<div class=\"radius-unit\" *ngIf=\"isPoint()\">\n  <mat-form-field class=\"radius\">\n    <input\n      type=\"number\"\n      matInput\n      placeholder=\"{{ 'igo.geo.spatialFilter.radius' | translate }}\"\n      [formControl]=\"radiusFormControl\"\n      [value]=\"1000\"\n      (input)=\"getRadius()\"\n      [readonly]=\"this.freehandDrawIsActive && this.formControl.value === null\"\n    />\n  </mat-form-field>\n\n  <mat-form-field class=\"unit-field\">\n    <mat-select\n      [value]=\"measureUnit\"\n      (selectionChange)=\"onMeasureUnitChange($event.value)\"\n    >\n      <mat-option\n        *ngFor=\"let measureUnit of measureUnits\"\n        [value]=\"measureUnit\"\n      >\n        {{ 'igo.geo.measure.' + measureUnit | translate }}\n      </mat-option>\n    </mat-select>\n  </mat-form-field>\n</div>\n\n<mat-label class=\"title mat-typography\"\n  >{{ 'igo.geo.spatialFilter.search' | translate }} :\n</mat-label>\n<mat-radio-group [value]=\"selectedItemType\">\n  <mat-radio-button\n    *ngFor=\"let item of itemType\"\n    [value]=\"item\"\n    (change)=\"onItemTypeChange($event)\"\n  >\n    {{ 'igo.geo.spatialFilter.' + item | translate }}\n  </mat-radio-button>\n</mat-radio-group>\n\n<div\n  class=\"thematics\"\n  *ngIf=\"\n    (selectedItemType === 'Thematics' && !tableTemplate) ||\n    (selectedItemType === 'Thematics' && tableTemplate && !listIsVisible)\n  \"\n>\n  <mat-table>\n    <!-- Name Column -->\n    <ng-container matColumnDef=\"name\">\n      <mat-header-cell *matHeaderCellDef class=\"thematics-header\">{{\n        'igo.geo.spatialFilter.Thematics' | translate\n      }}</mat-header-cell>\n    </ng-container>\n\n    <!-- Select Column -->\n    <ng-container matColumnDef=\"select\">\n      <mat-header-cell *matHeaderCellDef class=\"checks-header\">\n        <mat-checkbox\n          (change)=\"$event ? masterToggle() : null\"\n          [checked]=\"isAllSelected()\"\n          [indeterminate]=\"selectedThematics.hasValue() && !isAllSelected()\"\n        >\n        </mat-checkbox>\n      </mat-header-cell>\n    </ng-container>\n\n    <mat-header-row *matHeaderRowDef=\"displayedColumns\"></mat-header-row>\n    <mat-row *matRowDef=\"let row; columns: displayedColumns\"></mat-row>\n  </mat-table>\n\n  <mat-tree [dataSource]=\"dataSource\" [treeControl]=\"treeControl\">\n    <!-- This is the tree node template for leaf nodes -->\n    <mat-tree-node *matTreeNodeDef=\"let node\" matTreeNodeToggle>\n      <li class=\"mat-tree-node\">\n        <!-- use a disabled button to provide padding for tree leaf -->\n        <button mat-icon-button disabled></button>\n        {{ node.name }}\n        <mat-checkbox\n          class=\"tree-check\"\n          (click)=\"$event.stopPropagation()\"\n          (change)=\"$event ? onToggleChange(node) : null\"\n          [checked]=\"selectedThematics.isSelected(node)\"\n        >\n        </mat-checkbox>\n      </li>\n    </mat-tree-node>\n\n    <!-- This is the tree node template for expandable nodes -->\n    <mat-nested-tree-node *matTreeNodeDef=\"let node; when: hasChild\">\n      <div class=\"mat-tree-node\">\n        <button mat-icon-button (click)=\"onToggleClick(node)\">\n          <mat-icon\n            [svgIcon]=\"\n              treeControl.isExpanded(node) ? 'chevron-down' : 'chevron-right'\n            \"\n          ></mat-icon>\n        </button>\n        {{ node.name }}\n        <mat-checkbox\n          class=\"tree-check-2\"\n          (change)=\"$event ? childrensToggle(node) : null\"\n          [checked]=\"isAllSelected(node)\"\n          [indeterminate]=\"hasChildrenSelected(node) && !isAllSelected(node)\"\n        >\n        </mat-checkbox>\n      </div>\n      <ul\n        class=\"tree-ul\"\n        [class.example-tree-invisible]=\"!treeControl.isExpanded(node)\"\n      >\n        <ng-container matTreeNodeOutlet></ng-container>\n      </ul>\n    </mat-nested-tree-node>\n  </mat-tree>\n</div>\n\n<div class=\"buttons\">\n  <button\n    *ngIf=\"isPredefined()\"\n    mat-raised-button\n    class=\"clear-search-button\"\n    [disabled]=\"disabledClearSearch()\"\n    (click)=\"clearSearch()\"\n  >\n    {{ 'igo.geo.spatialFilter.clearSearch' | translate }}\n  </button>\n\n  <button\n    *ngIf=\"isPolygon() || isPoint()\"\n    mat-raised-button\n    class=\"clear-form-button\"\n    [disabled]=\"this.formControl.value === null\"\n    (click)=\"clearDrawZone()\"\n  >\n    {{ 'igo.geo.spatialFilter.clearForm' | translate }}\n  </button>\n\n  <button\n    mat-raised-button\n    class=\"search-button\"\n    [disabled]=\"disableSearchButton()\"\n    color=\"primary\"\n    (click)=\"toggleSearchButton()\"\n  >\n    {{ 'igo.geo.spatialFilter.goSearch' | translate }}\n  </button>\n\n  <button\n    mat-raised-button\n    class=\"remove-button\"\n    [disabled]=\"allLayers.length === 0\"\n    (click)=\"clearButton()\"\n  >\n    {{ 'igo.geo.spatialFilter.removeLayer' | translate }}\n  </button>\n\n  <button\n    mat-raised-button\n    class=\"export-button\"\n    [disabled]=\"!store.entities$.getValue().length\"\n    (click)=\"export.emit()\"\n  >\n    {{ 'igo.geo.spatialFilter.exportLayer' | translate }}\n  </button>\n</div>\n\n<button\n  class=\"chevron-down\"\n  *ngIf=\"store.all().length && tableTemplate && !listIsVisible\"\n  mat-icon-button\n  matTooltipShowDelay=\"500\"\n  [matTooltip]=\"'igo.geo.spatialFilter.showSearchResults' | translate\"\n  (click)=\"toggleVisibleList()\"\n>\n  <mat-icon svgIcon=\"chevron-down\"></mat-icon>\n</button>\n\n<div\n  class=\"results\"\n  *ngIf=\"store.all().length && tableTemplate && listIsVisible\"\n>\n  <button\n    *ngIf=\"listIsVisible\"\n    mat-icon-button\n    matTooltipShowDelay=\"500\"\n    [matTooltip]=\"'igo.geo.spatialFilter.hideSearchResults' | translate\"\n    (click)=\"toggleVisibleList()\"\n  >\n    <mat-icon svgIcon=\"chevron-up\"></mat-icon>\n  </button>\n  <igo-entity-table\n    class=\"results-list\"\n    [template]=\"tableTemplate\"\n    [store]=\"store\"\n    (entitySelectChange)=\"entityChange.emit($event)\"\n  >\n  </igo-entity-table>\n</div>\n", styles: [":host .header{margin-top:5px;width:100%}:host .mat-mdc-slide-toggle{padding:5px;width:100%}:host .mat-mdc-slide-toggle ::ng-deep .mdc-form-field{width:100%}:host .mat-mdc-slide-toggle ::ng-deep .mdc-label{margin-left:0;width:calc(100% - 60px)}:host .title{margin-left:5px;font-size:initial}:host .mat-mdc-radio-group{display:flex;flex-direction:column}:host .mat-mdc-radio-button{display:inline-flex;position:relative;margin-left:12px}:host .mat-mdc-form-field{margin-top:5px}:host .mat-column-select{overflow:auto}:host .buttons{display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin:16px 0}:host .thematics{max-height:35%;overflow:auto;margin-top:5px;width:98%}:host .results{overflow:auto;max-height:250px;width:98%}:host .mat-column-typeResults{max-width:100px;margin-right:5px}:host .buffer-unit,:host .radius-unit{display:flex;width:100%;padding:5px;box-sizing:border-box}:host .radius,:host .buffer{flex-flow:column nowrap;flex:2}:host .unit-field{flex:1;margin-left:8px}:host .example-tree-invisible{display:none}:host .tree-ul{margin:0;padding:0 0 0 20px;list-style-type:none}:host .tree-check,:host .tree-check-2{position:relative;margin-left:auto;margin-right:5px}:host .thematics-header{max-width:250px}:host .checks-header{padding:none;max-width:calc(100% - 316px);overflow:hidden}:host .mat-mdc-checkbox{padding:5px}:host .mat-tree-node{position:relative;min-height:42px;width:280px}:host .mat-mdc-header-cell{height:56px}:host .results{max-height:45%;width:98%}:host .results igo-entity-table ::ng-deep div.table-container{overflow:unset}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: SpatialFilterService }, { type: i2.MessageService }, { type: i2.LanguageService }]; }, propDecorators: { map: [{
                type: Input
            }], type: [{
                type: Input
            }], queryType: [{
                type: Input
            }], zone: [{
                type: Input
            }], loading: [{
                type: Input
            }], store: [{
                type: Input
            }], layers: [{
                type: Input
            }], allLayers: [{
                type: Input
            }], thematicLength: [{
                type: Input
            }], toggleSearch: [{
                type: Output
            }], itemTypeChange: [{
                type: Output
            }], thematicChange: [{
                type: Output
            }], drawZoneEvent: [{
                type: Output
            }], bufferEvent: [{
                type: Output
            }], zoneWithBufferChange: [{
                type: Output
            }], measureUnitChange: [{
                type: Output
            }], radiusEvent: [{
                type: Output
            }], freehandControl: [{
                type: Output
            }], predefinedRadius: [{
                type: Output
            }], clearButtonEvent: [{
                type: Output
            }], clearSearchEvent: [{
                type: Output
            }], export: [{
                type: Output
            }], openWorkspace: [{
                type: Output
            }], entityChange: [{
                type: Output
            }] } });

class SpatialFilterListComponent {
    spatialFilterService;
    messageService;
    get store() {
        return this._store;
    }
    set store(store) {
        this._store = store;
    }
    _store;
    get queryType() {
        return this._queryType;
    }
    set queryType(queryType) {
        this.formControl.setValue('');
        this._queryType = queryType;
    }
    _queryType;
    get zone() {
        return this._zone;
    }
    set zone(value) {
        this._zone = value;
        if (!value) {
            this.zoneWithBuffer = undefined;
            this.bufferFormControl.setValue(0);
        }
    }
    _zone;
    layers = [];
    zoneWithBuffer;
    selectedZone;
    measureUnit = MeasureLengthUnit.Meters;
    formControl = new UntypedFormControl();
    bufferFormControl = new UntypedFormControl();
    /**
     * Available measure units for the measure type given
     * @internal
     */
    get measureUnits() {
        return [MeasureLengthUnit.Meters, MeasureLengthUnit.Kilometers];
    }
    zoneChange = new EventEmitter();
    zoneWithBufferChange = new EventEmitter();
    bufferChange = new EventEmitter();
    measureUnitChange = new EventEmitter();
    formValueChanges$$;
    bufferValueChanges$$;
    constructor(spatialFilterService, messageService) {
        this.spatialFilterService = spatialFilterService;
        this.messageService = messageService;
    }
    ngOnInit() {
        this.formValueChanges$$ = this.formControl.valueChanges.subscribe((value) => {
            if (value.length) {
                this.store.view.filter((feature) => {
                    const filterNormalized = value
                        .toLowerCase()
                        .normalize('NFD')
                        .replace(/[\u0300-\u036f]/g, '');
                    const featureNameNormalized = feature.properties.nom
                        .toLowerCase()
                        .normalize('NFD')
                        .replace(/[\u0300-\u036f]/g, '');
                    return featureNameNormalized.includes(filterNormalized);
                });
            }
        });
        this.bufferValueChanges$$ = this.bufferFormControl.valueChanges
            .pipe(debounceTime(500), distinctUntilChanged())
            .subscribe((value) => {
            if (this.measureUnit === MeasureLengthUnit.Meters &&
                value > 0 &&
                value <= 100000) {
                this.bufferChange.emit(value);
                this.spatialFilterService
                    .loadBufferGeometry(this.selectedZone, SpatialFilterType.Predefined, value, this.queryType)
                    .subscribe((featureGeom) => {
                    this.zoneWithBuffer = featureGeom;
                    this.zoneWithBufferChange.emit(this.zoneWithBuffer);
                });
            }
            else if (this.measureUnit === MeasureLengthUnit.Kilometers &&
                value > 0 &&
                value <= 100) {
                this.bufferChange.emit(value);
                this.spatialFilterService
                    .loadBufferGeometry(this.selectedZone, SpatialFilterType.Predefined, value * 1000, this.queryType)
                    .subscribe((featureGeom) => {
                    this.zoneWithBuffer = featureGeom;
                    this.zoneWithBufferChange.emit(this.zoneWithBuffer);
                });
            }
            else if (value === 0 && this.layers.length > 0) {
                this.bufferChange.emit(value);
                this.zoneWithBufferChange.emit(this.selectedZone);
            }
            else if (value < 0 ||
                (this.measureUnit === MeasureLengthUnit.Meters && value > 100000) ||
                (this.measureUnit === MeasureLengthUnit.Kilometers && value > 100)) {
                this.bufferFormControl.setValue(0);
                this.messageService.alert('igo.geo.spatialFilter.bufferAlert', 'igo.geo.spatialFilter.warning');
            }
        });
    }
    ngOnDestroy() {
        this.formValueChanges$$.unsubscribe();
    }
    displayFn(feature) {
        return feature ? feature.properties.nom : undefined;
    }
    onZoneChange(feature) {
        if (feature && this.queryType) {
            this.spatialFilterService
                .loadItemById(feature, this.queryType)
                .subscribe((featureGeom) => {
                this.selectedZone = featureGeom;
                this.zoneChange.emit(featureGeom);
            });
        }
    }
    /**
     * Set the measure unit
     * @internal
     */
    onMeasureUnitChange(unit) {
        if (unit === this.measureUnit) {
            return;
        }
        else {
            this.measureUnit = unit;
            this.measureUnitChange.emit(this.measureUnit);
            this.measureUnit === MeasureLengthUnit.Meters
                ? this.bufferFormControl.setValue(this.bufferFormControl.value * 1000)
                : this.bufferFormControl.setValue(this.bufferFormControl.value / 1000);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SpatialFilterListComponent, deps: [{ token: SpatialFilterService }, { token: i2.MessageService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: SpatialFilterListComponent, selector: "igo-spatial-filter-list", inputs: { store: "store", queryType: "queryType", zone: "zone", layers: "layers" }, outputs: { zoneChange: "zoneChange", zoneWithBufferChange: "zoneWithBufferChange", bufferChange: "bufferChange", measureUnitChange: "measureUnitChange" }, ngImport: i0, template: "<div class=\"form-list\">\n  <mat-form-field class=\"zone-list\">\n    <mat-label>{{ 'igo.geo.spatialFilter.listLabel' | translate }}</mat-label>\n    <input\n      #input\n      type=\"text\"\n      placeholder=\"{{ 'igo.geo.spatialFilter.listLabel' | translate }}\"\n      matInput\n      [formControl]=\"formControl\"\n      [matAutocomplete]=\"auto\"\n    />\n    <mat-autocomplete\n      #auto=\"matAutocomplete\"\n      (optionSelected)=\"onZoneChange($event.option.value)\"\n      [displayWith]=\"displayFn\"\n    >\n      <mat-option\n        *ngFor=\"let entities of this.store.view.all$() | async\"\n        [value]=\"entities\"\n      >\n        {{ entities.properties.nom }}\n      </mat-option>\n    </mat-autocomplete>\n  </mat-form-field>\n  <div>\n    <div class=\"buffer-div\">\n      <mat-form-field class=\"buffer\">\n        <mat-label>{{ 'igo.geo.spatialFilter.buffer' | translate }}</mat-label>\n        <input\n          type=\"number\"\n          matInput\n          placeholder=\"{{ 'igo.geo.spatialFilter.buffer' | translate }}\"\n          [formControl]=\"bufferFormControl\"\n          [value]=\"0\"\n          [readonly]=\"!zone\"\n        />\n      </mat-form-field>\n\n      <mat-form-field class=\"unit-field\">\n        <mat-select\n          [value]=\"measureUnit\"\n          (selectionChange)=\"onMeasureUnitChange($event.value)\"\n        >\n          <mat-option\n            *ngFor=\"let measureUnit of measureUnits\"\n            [value]=\"measureUnit\"\n          >\n            {{ 'igo.geo.measure.' + measureUnit | translate }}\n          </mat-option>\n        </mat-select>\n      </mat-form-field>\n    </div>\n  </div>\n</div>\n", styles: [":host{display:block}:host .buffer-div{display:flex;width:100%}:host .zone-list{width:100%}:host .buffer{flex:2}:host .unit-field{flex:1;margin-left:8px}\n"], dependencies: [{ kind: "directive", type: i2$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i2$1.NumberValueAccessor, selector: "input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]" }, { kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$1.FormControlDirective, selector: "[formControl]", inputs: ["formControl", "disabled", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { kind: "component", type: i6$2.MatAutocomplete, selector: "mat-autocomplete", inputs: ["disableRipple", "hideSingleSelectionIndicator"], exportAs: ["matAutocomplete"] }, { kind: "component", type: i9.MatOption, selector: "mat-option", exportAs: ["matOption"] }, { kind: "directive", type: i6$2.MatAutocompleteTrigger, selector: "input[matAutocomplete], textarea[matAutocomplete]", exportAs: ["matAutocompleteTrigger"] }, { kind: "component", type: i8.MatFormField, selector: "mat-form-field", inputs: ["hideRequiredMarker", "color", "floatLabel", "appearance", "subscriptSizing", "hintLabel"], exportAs: ["matFormField"] }, { kind: "directive", type: i8.MatLabel, selector: "mat-label" }, { kind: "directive", type: i9$3.MatInput, selector: "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", inputs: ["disabled", "id", "placeholder", "name", "required", "type", "errorStateMatcher", "aria-describedby", "value", "readonly"], exportAs: ["matInput"] }, { kind: "component", type: i15.MatSelect, selector: "mat-select", inputs: ["disabled", "disableRipple", "tabIndex", "panelWidth", "hideSingleSelectionIndicator"], exportAs: ["matSelect"] }, { kind: "pipe", type: i2$2.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SpatialFilterListComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-spatial-filter-list', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div class=\"form-list\">\n  <mat-form-field class=\"zone-list\">\n    <mat-label>{{ 'igo.geo.spatialFilter.listLabel' | translate }}</mat-label>\n    <input\n      #input\n      type=\"text\"\n      placeholder=\"{{ 'igo.geo.spatialFilter.listLabel' | translate }}\"\n      matInput\n      [formControl]=\"formControl\"\n      [matAutocomplete]=\"auto\"\n    />\n    <mat-autocomplete\n      #auto=\"matAutocomplete\"\n      (optionSelected)=\"onZoneChange($event.option.value)\"\n      [displayWith]=\"displayFn\"\n    >\n      <mat-option\n        *ngFor=\"let entities of this.store.view.all$() | async\"\n        [value]=\"entities\"\n      >\n        {{ entities.properties.nom }}\n      </mat-option>\n    </mat-autocomplete>\n  </mat-form-field>\n  <div>\n    <div class=\"buffer-div\">\n      <mat-form-field class=\"buffer\">\n        <mat-label>{{ 'igo.geo.spatialFilter.buffer' | translate }}</mat-label>\n        <input\n          type=\"number\"\n          matInput\n          placeholder=\"{{ 'igo.geo.spatialFilter.buffer' | translate }}\"\n          [formControl]=\"bufferFormControl\"\n          [value]=\"0\"\n          [readonly]=\"!zone\"\n        />\n      </mat-form-field>\n\n      <mat-form-field class=\"unit-field\">\n        <mat-select\n          [value]=\"measureUnit\"\n          (selectionChange)=\"onMeasureUnitChange($event.value)\"\n        >\n          <mat-option\n            *ngFor=\"let measureUnit of measureUnits\"\n            [value]=\"measureUnit\"\n          >\n            {{ 'igo.geo.measure.' + measureUnit | translate }}\n          </mat-option>\n        </mat-select>\n      </mat-form-field>\n    </div>\n  </div>\n</div>\n", styles: [":host{display:block}:host .buffer-div{display:flex;width:100%}:host .zone-list{width:100%}:host .buffer{flex:2}:host .unit-field{flex:1;margin-left:8px}\n"] }]
        }], ctorParameters: function () { return [{ type: SpatialFilterService }, { type: i2.MessageService }]; }, propDecorators: { store: [{
                type: Input
            }], queryType: [{
                type: Input
            }], zone: [{
                type: Input
            }], layers: [{
                type: Input
            }], zoneChange: [{
                type: Output
            }], zoneWithBufferChange: [{
                type: Output
            }], bufferChange: [{
                type: Output
            }], measureUnitChange: [{
                type: Output
            }] } });

/**
 * Spatial Filter Type
 */
class SpatialFilterTypeComponent {
    get store() {
        return this._store;
    }
    set store(store) {
        this._store = store;
    }
    _store;
    queryType = [
        'Arrond',
        'CircFed',
        'CircProv',
        'DirReg',
        'Mun',
        'MRC',
        'AdmRegion',
        'RegTour'
    ];
    selectedTypeIndex = new UntypedFormControl(0);
    /**
     * Reference to the SpatialFIlterType enum
     * @internal
     */
    spatialType = SpatialFilterType;
    activeDrawType = this.spatialType.Polygon;
    selectedQueryType;
    zone;
    layers = [];
    type;
    eventType = new EventEmitter();
    eventQueryType = new EventEmitter();
    zoneChange = new EventEmitter();
    zoneWithBufferChange = new EventEmitter();
    bufferChange = new EventEmitter();
    measureUnitChange = new EventEmitter();
    constructor() { }
    ngOnInit() {
        if (this.selectedTypeIndex.value === 0) {
            this.type = this.spatialType.Predefined;
        }
        if (this.selectedTypeIndex.value === 1) {
            this.type = this.activeDrawType;
        }
        this.eventType.emit(this.type);
    }
    onTypeChange(event) {
        if (this.selectedTypeIndex.value === 0) {
            this.type = SpatialFilterType.Predefined;
        }
        if (this.selectedTypeIndex.value === 1) {
            this.type = this.activeDrawType;
        }
        this.eventType.emit(this.type);
    }
    onDrawTypeChange(spatialType) {
        this.activeDrawType = spatialType;
        this.eventType.emit(this.activeDrawType);
    }
    onSelectionChange() {
        this.eventQueryType.emit(this.selectedQueryType);
        this.zoneChange.emit(undefined);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SpatialFilterTypeComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: SpatialFilterTypeComponent, selector: "igo-spatial-filter-type", inputs: { store: "store", selectedQueryType: "selectedQueryType", zone: "zone", layers: "layers" }, outputs: { eventType: "eventType", eventQueryType: "eventQueryType", zoneChange: "zoneChange", zoneWithBufferChange: "zoneWithBufferChange", bufferChange: "bufferChange", measureUnitChange: "measureUnitChange" }, ngImport: i0, template: "<mat-tab-group\n  [selectedIndex]=\"selectedTypeIndex.value\"\n  (selectedIndexChange)=\"selectedTypeIndex.setValue($event)\"\n  (selectedTabChange)=\"onTypeChange($event)\"\n>\n  <mat-tab [label]=\"'igo.geo.spatialFilter.predefined' | translate\">\n    <mat-form-field>\n      <mat-label>{{\n        'igo.geo.spatialFilter.searchLabel' | translate\n      }}</mat-label>\n      <mat-select\n        (selectionChange)=\"onSelectionChange()\"\n        [(value)]=\"selectedQueryType\"\n      >\n        <mat-option *ngFor=\"let queryType of queryType\" [value]=\"queryType\">\n          {{ 'igo.geo.terrapi.' + queryType | translate }}\n        </mat-option>\n      </mat-select>\n    </mat-form-field>\n    <igo-spatial-filter-list\n      [store]=\"store\"\n      [queryType]=\"selectedQueryType\"\n      [zone]=\"zone\"\n      [layers]=\"layers\"\n      (zoneChange)=\"zoneChange.emit($event)\"\n      (zoneWithBufferChange)=\"zoneWithBufferChange.emit($event)\"\n      (bufferChange)=\"bufferChange.emit($event)\"\n      (measureUnitChange)=\"measureUnitChange.emit($event)\"\n    >\n    </igo-spatial-filter-list>\n  </mat-tab>\n\n  <mat-tab [label]=\"'igo.geo.spatialFilter.draw' | translate\">\n    <div class=\"spatial-type-toggle\">\n      <mat-button-toggle-group\n        [value]=\"activeDrawType\"\n        (change)=\"onDrawTypeChange($event.value)\"\n      >\n        <mat-button-toggle\n          [value]=\"spatialType.Polygon\"\n          [matTooltip]=\"'igo.geo.spatialFilter.drawPolygon' | translate\"\n        >\n          <mat-icon svgIcon=\"pentagon-outline\"></mat-icon>\n        </mat-button-toggle>\n        <mat-button-toggle\n          [value]=\"spatialType.Point\"\n          [matTooltip]=\"'igo.geo.spatialFilter.drawCircle' | translate\"\n        >\n          <mat-icon svgIcon=\"record-circle-outline\"></mat-icon>\n        </mat-button-toggle>\n      </mat-button-toggle-group>\n    </div>\n  </mat-tab>\n</mat-tab-group>\n", styles: [":host .mat-mdc-form-field{width:100%}:host .mat-mdc-tab-group ::ng-deep .mat-mdc-tab-body-content{overflow:hidden}:host .mat-mdc-tab-group ::ng-deep .mat-mdc-tab-label{padding:10px}:host .mat-mdc-tab-group ::ng-deep .mat-mdc-tab-body-wrapper{margin-top:5px}:host .spatial-type-toggle{padding:10px;text-align:center}:host .spatial-type-toggle mat-button-toggle-group{width:50%}:host .spatial-type-toggle mat-button-toggle-group mat-button-toggle{width:50%}\n"], dependencies: [{ kind: "directive", type: i2$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "component", type: i9.MatOption, selector: "mat-option", exportAs: ["matOption"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i4$2.MatTab, selector: "mat-tab", inputs: ["disabled"], exportAs: ["matTab"] }, { kind: "component", type: i4$2.MatTabGroup, selector: "mat-tab-group", inputs: ["color", "disableRipple", "fitInkBarToContent", "mat-stretch-tabs"], exportAs: ["matTabGroup"] }, { kind: "directive", type: i5$1.MatButtonToggleGroup, selector: "mat-button-toggle-group", inputs: ["appearance", "name", "vertical", "value", "multiple", "disabled"], outputs: ["valueChange", "change"], exportAs: ["matButtonToggleGroup"] }, { kind: "component", type: i5$1.MatButtonToggle, selector: "mat-button-toggle", inputs: ["disableRipple", "aria-label", "aria-labelledby", "id", "name", "value", "tabIndex", "appearance", "checked", "disabled"], outputs: ["change"], exportAs: ["matButtonToggle"] }, { kind: "component", type: i8.MatFormField, selector: "mat-form-field", inputs: ["hideRequiredMarker", "color", "floatLabel", "appearance", "subscriptSizing", "hintLabel"], exportAs: ["matFormField"] }, { kind: "directive", type: i8.MatLabel, selector: "mat-label" }, { kind: "component", type: i15.MatSelect, selector: "mat-select", inputs: ["disabled", "disableRipple", "tabIndex", "panelWidth", "hideSingleSelectionIndicator"], exportAs: ["matSelect"] }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "component", type: SpatialFilterListComponent, selector: "igo-spatial-filter-list", inputs: ["store", "queryType", "zone", "layers"], outputs: ["zoneChange", "zoneWithBufferChange", "bufferChange", "measureUnitChange"] }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SpatialFilterTypeComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-spatial-filter-type', changeDetection: ChangeDetectionStrategy.OnPush, template: "<mat-tab-group\n  [selectedIndex]=\"selectedTypeIndex.value\"\n  (selectedIndexChange)=\"selectedTypeIndex.setValue($event)\"\n  (selectedTabChange)=\"onTypeChange($event)\"\n>\n  <mat-tab [label]=\"'igo.geo.spatialFilter.predefined' | translate\">\n    <mat-form-field>\n      <mat-label>{{\n        'igo.geo.spatialFilter.searchLabel' | translate\n      }}</mat-label>\n      <mat-select\n        (selectionChange)=\"onSelectionChange()\"\n        [(value)]=\"selectedQueryType\"\n      >\n        <mat-option *ngFor=\"let queryType of queryType\" [value]=\"queryType\">\n          {{ 'igo.geo.terrapi.' + queryType | translate }}\n        </mat-option>\n      </mat-select>\n    </mat-form-field>\n    <igo-spatial-filter-list\n      [store]=\"store\"\n      [queryType]=\"selectedQueryType\"\n      [zone]=\"zone\"\n      [layers]=\"layers\"\n      (zoneChange)=\"zoneChange.emit($event)\"\n      (zoneWithBufferChange)=\"zoneWithBufferChange.emit($event)\"\n      (bufferChange)=\"bufferChange.emit($event)\"\n      (measureUnitChange)=\"measureUnitChange.emit($event)\"\n    >\n    </igo-spatial-filter-list>\n  </mat-tab>\n\n  <mat-tab [label]=\"'igo.geo.spatialFilter.draw' | translate\">\n    <div class=\"spatial-type-toggle\">\n      <mat-button-toggle-group\n        [value]=\"activeDrawType\"\n        (change)=\"onDrawTypeChange($event.value)\"\n      >\n        <mat-button-toggle\n          [value]=\"spatialType.Polygon\"\n          [matTooltip]=\"'igo.geo.spatialFilter.drawPolygon' | translate\"\n        >\n          <mat-icon svgIcon=\"pentagon-outline\"></mat-icon>\n        </mat-button-toggle>\n        <mat-button-toggle\n          [value]=\"spatialType.Point\"\n          [matTooltip]=\"'igo.geo.spatialFilter.drawCircle' | translate\"\n        >\n          <mat-icon svgIcon=\"record-circle-outline\"></mat-icon>\n        </mat-button-toggle>\n      </mat-button-toggle-group>\n    </div>\n  </mat-tab>\n</mat-tab-group>\n", styles: [":host .mat-mdc-form-field{width:100%}:host .mat-mdc-tab-group ::ng-deep .mat-mdc-tab-body-content{overflow:hidden}:host .mat-mdc-tab-group ::ng-deep .mat-mdc-tab-label{padding:10px}:host .mat-mdc-tab-group ::ng-deep .mat-mdc-tab-body-wrapper{margin-top:5px}:host .spatial-type-toggle{padding:10px;text-align:center}:host .spatial-type-toggle mat-button-toggle-group{width:50%}:host .spatial-type-toggle mat-button-toggle-group mat-button-toggle{width:50%}\n"] }]
        }], ctorParameters: function () { return []; }, propDecorators: { store: [{
                type: Input
            }], selectedQueryType: [{
                type: Input
            }], zone: [{
                type: Input
            }], layers: [{
                type: Input
            }], eventType: [{
                type: Output
            }], eventQueryType: [{
                type: Output
            }], zoneChange: [{
                type: Output
            }], zoneWithBufferChange: [{
                type: Output
            }], bufferChange: [{
                type: Output
            }], measureUnitChange: [{
                type: Output
            }] } });

class TimeFilterFormComponent {
    dateAdapter;
    layer;
    options;
    color = 'primary';
    date;
    startDate;
    endDate;
    year;
    startYear;
    endYear;
    initStartYear;
    initEndYear;
    listYears = [];
    startListYears = [];
    endListYears = [];
    set currentValue(value) {
        if (value) {
            if (this.type !== TimeFilterType.YEAR) {
                const valueArray = value.split('/');
                if (valueArray.length > 0) {
                    const startDate = new Date(valueArray[0]);
                    const endDate = new Date(valueArray[1]);
                    if (!isNaN(startDate.valueOf())) {
                        this.startDate = startDate;
                    }
                    if (!isNaN(endDate.valueOf())) {
                        this.endDate = endDate;
                    }
                }
            }
        }
    }
    interval;
    playIcon = 'play-circle';
    resetIcon = 'replay';
    change = new EventEmitter();
    yearChange = new EventEmitter();
    mySlider;
    get type() {
        return this.options.type === undefined
            ? TimeFilterType.DATE
            : this.options.type;
    }
    get isRange() {
        return this.options.range === undefined ||
            this.options.style === TimeFilterStyle.SLIDER
            ? false
            : this.options.range;
    }
    get style() {
        return this.options.style === undefined
            ? TimeFilterStyle.SLIDER
            : this.options.style;
    }
    get step() {
        let step = 10800000;
        if (this.options.step === undefined) {
            switch (this.type) {
                case TimeFilterType.DATE:
                case TimeFilterType.DATETIME:
                    step = 10800000;
                    break;
                case TimeFilterType.TIME:
                    step = 3600000;
                    break;
                case TimeFilterType.YEAR:
                    step = 31536000000;
                    break;
                default:
                    step = 10800000;
            }
        }
        else {
            step = this.getStepDefinition(this.options.step);
        }
        return step;
    }
    get timeInterval() {
        return this.options.timeInterval === undefined
            ? 2000
            : this.options.timeInterval;
    }
    get min() {
        if (this.options.min) {
            const min = new Date(this.options.min);
            return new Date(min.getTime() + min.getTimezoneOffset() * 60000);
        }
        else {
            return undefined;
        }
    }
    get max() {
        if (this.options.max) {
            const max = new Date(this.options.max);
            return new Date(max.getTime() + max.getTimezoneOffset() * 60000);
        }
        else {
            return undefined;
        }
    }
    get is() {
        return this.options.range === undefined ? false : this.options.range;
    }
    constructor(dateAdapter) {
        this.dateAdapter = dateAdapter;
        this.dateAdapter.setLocale('fr');
    }
    ngOnInit() {
        if (this.startDate === undefined) {
            this.startDate = new Date(this.min);
        }
        if (this.endDate === undefined) {
            this.endDate = new Date(this.max);
        }
        if (this.startYear === undefined) {
            this.startYear = new Date(this.startDate).getFullYear();
            this.initStartYear = this.startYear;
        }
        if (this.endYear === undefined) {
            this.endYear = new Date(this.endDate).getFullYear();
            this.initEndYear = this.endYear;
        }
        if (!this.isRange) {
            for (let i = this.startYear; i <= this.endYear + 1; i++) {
                this.listYears.push(i);
            }
        }
        else {
            for (let i = this.startYear; i < this.endYear; i++) {
                this.startListYears.push(i);
            }
            for (let i = this.startYear + 1; i <= this.endYear; i++) {
                this.endListYears.push(i);
            }
        }
        this.options.enabled =
            this.options.enabled === undefined ? true : this.options.enabled;
        this.checkFilterValue();
        if (this.options.enabled) {
            if (!this.isRange && this.style === 'slider' && this.type === 'year') {
                this.yearChange.emit(this.year);
            }
        }
        else {
            this.storeCurrentFilterValue();
            this.yearChange.emit(undefined); // TODO: FIX THIS for ALL OTHER TYPES STYLES OR RANGE.
        }
    }
    storeCurrentFilterValue() {
        // TODO: FIX THIS for ALL OTHER TYPES STYLES OR RANGE.
        if (!this.isRange &&
            this.style === TimeFilterStyle.SLIDER &&
            this.type === TimeFilterType.YEAR) {
            this.options.value = this.year.toString();
        }
    }
    checkFilterValue() {
        const olSource = this.layer.dataSource.ol;
        const timeFromWms = olSource.getParams().TIME;
        if (!this.isRange &&
            this.style === TimeFilterStyle.SLIDER &&
            this.type === TimeFilterType.YEAR) {
            if (timeFromWms) {
                this.year = new Date(timeFromWms.toString()).getFullYear() + 1;
            }
            else if (this.options.value) {
                this.year = new Date(this.options.value.toString()).getFullYear() + 1;
            }
            else {
                this.year = new Date(this.min).getFullYear() + 1;
            }
        }
        else if (this.isRange &&
            this.style === TimeFilterStyle.CALENDAR &&
            this.type === TimeFilterType.YEAR) {
            if (timeFromWms) {
                this.startYear = parseInt(timeFromWms.substr(0, 4), 10);
                this.endYear = parseInt(timeFromWms.substr(5, 4), 10);
                const newStartListYears = [];
                const newEndListYears = [];
                for (let i = this.initStartYear; i < this.endYear; i++) {
                    newStartListYears.push(i);
                }
                for (let i = this.startYear + 1; i <= this.initEndYear; i++) {
                    newEndListYears.push(i);
                }
                this.startListYears = newStartListYears;
                this.endListYears = newEndListYears;
            }
        }
        // TODO: FIX THIS for ALL OTHER TYPES STYLES OR RANGE.
    }
    handleDateChange(event) {
        this.setupDateOutput();
        this.applyTypeChange();
        // Only if is range, use 2 dates to make the range
        if (this.isRange) {
            this.change.emit([this.startDate, this.endDate]);
        }
        else {
            this.change.emit(this.startDate);
        }
    }
    handleYearChange(event) {
        if (this.isRange) {
            this.endListYears = [];
            for (let i = this.startYear + 1; i <= this.initEndYear; i++) {
                this.endListYears.push(i);
            }
            this.startListYears = [];
            for (let i = this.initStartYear + 1; i < this.endYear; i++) {
                this.startListYears.push(i);
            }
            this.yearChange.emit([this.startYear, this.endYear]);
        }
        else {
            this.yearChange.emit(this.year);
        }
    }
    handleListYearChange(event) {
        this.handleYearChange([this.startYear, this.endYear]);
    }
    handleListYearStartChange(event) {
        this.change.emit([this.startDate, this.endDate]);
    }
    dateToNumber(date) {
        let newDate;
        if (date) {
            newDate = new Date(date);
        }
        else {
            newDate = new Date(this.min);
        }
        return newDate.getTime();
    }
    setSliderThumbLabel(label) {
        const thumbLabel = this.findThumbLabel(this.mySlider._elementRef.nativeElement.childNodes);
        if (thumbLabel) {
            thumbLabel.textContent = label;
        }
    }
    findThumbLabel(test) {
        let thumbLabel;
        test.forEach((value) => {
            if (value.className === 'mat-slider-thumb-label-text') {
                thumbLabel = value;
            }
            if (value.children.length > 0 && !thumbLabel) {
                thumbLabel = this.findThumbLabel(value.childNodes);
            }
        }, this);
        return thumbLabel;
    }
    toggleFilterState() {
        this.options.enabled = !this.options.enabled;
        if (this.options.enabled) {
            if (!this.isRange &&
                TimeFilterStyle.SLIDER &&
                this.type === TimeFilterType.YEAR) {
                this.yearChange.emit(this.year);
            }
        }
        else {
            this.stopFilter();
            this.storeCurrentFilterValue();
            this.change.emit(undefined); // TODO: FIX THIS for ALL OTHER TYPES STYLES OR RANGE.
        }
    }
    resetFilter(event) {
        this.date = new Date(this.min);
        this.year = this.date.getFullYear();
        if (!this.isRange &&
            TimeFilterStyle.SLIDER &&
            this.type === TimeFilterType.YEAR) {
            this.yearChange.emit(this.year);
        }
        else {
            this.setupDateOutput();
            this.change.emit(undefined); // TODO: FIX THIS for ALL OTHER TYPES STYLES OR RANGE.
        }
    }
    playFilter(event) {
        if (this.interval) {
            this.stopFilter();
        }
        else {
            this.playIcon = 'pause-circle';
            this.interval = setInterval((that) => {
                let newMinDateNumber;
                const maxDateNumber = new Date(that.max);
                newMinDateNumber =
                    that.date === undefined ? that.min.getTime() : that.date.getTime();
                newMinDateNumber += that.mySlider.step;
                that.date = new Date(newMinDateNumber);
                if (newMinDateNumber > maxDateNumber.getTime()) {
                    that.stopFilter();
                }
                that.handleDateChange({ value: that.date, date: that.date });
            }, this.timeInterval, this);
        }
    }
    playYear(event) {
        if (this.year + this.mySlider.step >
            this.max.getFullYear() + this.mySlider.step) {
            this.stopFilter();
            this.resetFilter(event);
        }
        if (this.interval) {
            this.stopFilter();
        }
        else {
            this.playIcon = 'pause-circle';
            this.interval = setInterval(() => {
                if (this.year + this.mySlider.step > this.max.getFullYear()) {
                    this.stopFilter();
                }
                else {
                    this.year = this.year + this.mySlider.step;
                }
                this.yearChange.emit(this.year);
            }, this.timeInterval, this);
        }
    }
    stopFilter() {
        if (this.interval) {
            clearInterval(this.interval);
        }
        this.interval = undefined;
        this.playIcon = 'play-circle';
    }
    handleSliderDateChange(event) {
        this.date = new Date(event.value);
        this.setSliderThumbLabel(this.handleSliderTooltip());
        this.handleDateChange(event);
    }
    handleSliderYearChange(event) {
        this.year = event.value;
        this.yearChange.emit(this.year);
    }
    handleSliderValue() {
        if (this.options.current === true || !this.min) {
            const currentDate = new Date();
            this.date = this.getRoundedDate(currentDate);
        }
        if (this.type === TimeFilterType.YEAR) {
            return this.year;
        }
        else {
            return this.date === undefined ? this.min.getTime() : this.date.getTime();
        }
    }
    handleSliderTooltip() {
        let label;
        switch (this.type) {
            case TimeFilterType.DATE:
                label =
                    this.date === undefined
                        ? this.min.toDateString()
                        : this.date.toDateString();
                break;
            case TimeFilterType.TIME:
                label =
                    this.date === undefined
                        ? this.min.toTimeString()
                        : this.date.toTimeString();
                break;
            // datetime
            default:
                label =
                    this.date === undefined
                        ? this.min.toUTCString()
                        : this.date.toUTCString();
                break;
        }
        return label;
    }
    setupDateOutput() {
        if (this.style === TimeFilterStyle.SLIDER) {
            this.startDate = new Date(this.date);
            this.startDate.setSeconds(-(this.step / 1000));
            this.endDate = new Date(this.startDate);
            this.endDate.setSeconds(this.step / 1000);
        }
        else if (!this.isRange && !!this.date) {
            this.endDate = new Date(this.date);
            this.startDate = new Date(this.date);
        }
        else if (this.isRange && (!!this.date || !this.date)) {
            this.startDate =
                this.startDate === undefined ? new Date(this.min) : this.startDate;
            this.endDate =
                this.endDate === undefined ? new Date(this.max) : this.endDate;
        }
        else if (!this.date) {
            this.startDate =
                this.startDate === undefined ? new Date(this.min) : this.startDate;
            this.endDate =
                this.endDate === undefined ? new Date(this.max) : this.endDate;
        }
    }
    applyTypeChange() {
        switch (this.type) {
            case TimeFilterType.DATE:
                if (this.startDate !== undefined || this.endDate !== undefined) {
                    this.startDate.setHours(0);
                    this.startDate.setMinutes(0);
                    this.startDate.setSeconds(0);
                    this.endDate.setHours(23);
                    this.endDate.setMinutes(59);
                    this.endDate.setSeconds(59);
                }
                break;
            case TimeFilterType.TIME:
                if (this.style === TimeFilterStyle.CALENDAR) {
                    if (this.startDate.getDay() !== this.min.getDay()) {
                        const selectedHour = this.startDate.getHours();
                        const selectedMinute = this.startDate.getMinutes();
                        this.startDate = this.min;
                        this.startDate.setHours(selectedHour);
                        this.startDate.setMinutes(selectedMinute);
                    }
                    if (this.endDate.getDay() !== this.min.getDay()) {
                        const selectedHour = this.endDate.getHours();
                        const selectedMinute = this.endDate.getMinutes();
                        this.endDate = this.min;
                        this.endDate.setHours(selectedHour);
                        this.endDate.setMinutes(selectedMinute);
                    }
                }
                if (!this.isRange && this.step > 60 * 60 * 1000) {
                    this.startDate.setMinutes(0);
                    this.startDate.setSeconds(0);
                    this.endDate.setMinutes(59);
                    this.endDate.setSeconds(59);
                }
                break;
            // datetime
            default:
            // do nothing
        }
    }
    getRangeMinDate() {
        return this.startDate === undefined ? this.min : this.startDate;
    }
    getRangeMaxDate() {
        return this.endDate === undefined ? this.max : this.endDate;
    }
    /**
     * Round date at a certain time, 10 minutes by Default
     * @param date - Date to Round
     * @param atMinute - round to closest 'atMinute' minute, rounded 10 by default
     * @return the rounded date
     */
    getRoundedDate(date, atMinute = 10) {
        const coeff = 1000 * 60 * atMinute;
        return new Date(Math.round(date.getTime() / coeff) * coeff);
    }
    /**
     * Get the step (period) definition from the layer dimension tag
     * @param step The step as ISO 8601 example: PT10M for 10 Minutes
     * @return the duration in milliseconds
     */
    getStepDefinition(step) {
        return moment.duration(step).asMilliseconds();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TimeFilterFormComponent, deps: [{ token: i9.DateAdapter }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: TimeFilterFormComponent, selector: "igo-time-filter-form", inputs: { layer: "layer", options: "options", currentValue: "currentValue" }, outputs: { change: "change", yearChange: "yearChange" }, viewQueries: [{ propertyName: "mySlider", first: true, predicate: MatSlider, descendants: true }], ngImport: i0, template: "<div *ngIf=\"style === 'calendar' && type !== 'year'\">\n  <div *ngIf=\"!isRange\" class=\"igo-col igo-col-100 igo-col-100-m\">\n    <mat-form-field>\n      <mat-datetimepicker-toggle\n        class=\"time-filter-mat-datetimepicker-toggle\"\n        [for]=\"datetimePicker\"\n        matSuffix\n      ></mat-datetimepicker-toggle>\n      <mat-datetimepicker\n        #datetimePicker\n        type=\"{{ type }}\"\n        openOnFocus=\"true\"\n        timeInterval=\"5\"\n      ></mat-datetimepicker>\n      <input\n        matInput\n        autocomplete=\"false\"\n        placeholder=\"{{ 'igo.geo.timeFilter.date' | translate }}\"\n        [matDatetimepicker]=\"datetimePicker\"\n        [(ngModel)]=\"date\"\n        [min]=\"min\"\n        [max]=\"max\"\n        readonly=\"readonly\"\n        (dateChange)=\"handleDateChange($event)\"\n      />\n    </mat-form-field>\n  </div>\n\n  <div *ngIf=\"isRange\">\n    <div class=\"igo-col igo-col-100\">\n      <mat-form-field>\n        <mat-datetimepicker-toggle\n          class=\"time-filter-mat-datetimepicker-toggle\"\n          [for]=\"minDatetimePicker\"\n          matSuffix\n        ></mat-datetimepicker-toggle>\n        <mat-datetimepicker\n          #minDatetimePicker\n          type=\"{{ type }}\"\n          openOnFocus=\"true\"\n          timeInterval=\"5\"\n        ></mat-datetimepicker>\n        <input\n          matInput\n          autocomplete=\"false\"\n          placeholder=\"{{ 'igo.geo.timeFilter.startDate' | translate }}\"\n          [matDatetimepicker]=\"minDatetimePicker\"\n          [(ngModel)]=\"startDate\"\n          [min]=\"min\"\n          [max]=\"getRangeMaxDate()\"\n          readonly=\"readonly\"\n          (input)=\"(startDate)\"\n          (dateChange)=\"handleDateChange($event)\"\n        />\n      </mat-form-field>\n    </div>\n\n    <div class=\"igo-col igo-col-100\">\n      <mat-form-field>\n        <mat-datetimepicker-toggle\n          class=\"time-filter-mat-datetimepicker-toggle\"\n          [for]=\"maxDatetimePicker\"\n          matSuffix\n        ></mat-datetimepicker-toggle>\n        <mat-datetimepicker\n          #maxDatetimePicker\n          type=\"{{ type }}\"\n          openOnFocus=\"true\"\n          timeInterval=\"5\"\n        ></mat-datetimepicker>\n        <input\n          matInput\n          autocomplete=\"false\"\n          placeholder=\"{{ 'igo.geo.timeFilter.endDate' | translate }}\"\n          [matDatetimepicker]=\"maxDatetimePicker\"\n          [(ngModel)]=\"endDate\"\n          [min]=\"getRangeMinDate()\"\n          [max]=\"max\"\n          readonly=\"readonly\"\n          (dateChange)=\"handleDateChange($event)\"\n        />\n      </mat-form-field>\n    </div>\n  </div>\n</div>\n\n<div *ngIf=\"style === 'calendar' && type === 'year'\">\n  <div *ngIf=\"!isRange\" class=\"igo-col igo-col-100 igo-col-100-m\">\n    <mat-form-field>\n      <mat-select\n        placeholder=\"{{ 'igo.geo.timeFilter.date' | translate }}\"\n        [(ngModel)]=\"year\"\n        (selectionChange)=\"handleYearChange($event)\"\n      >\n        <mat-option [value]=\"year\" *ngFor=\"let year of listYears\">{{\n          year\n        }}</mat-option>\n      </mat-select>\n    </mat-form-field>\n  </div>\n\n  <div *ngIf=\"isRange\">\n    <div class=\"igo-col igo-col-100\">\n      <mat-form-field>\n        <mat-select\n          placeholder=\"{{ 'igo.geo.timeFilter.startDate' | translate }}\"\n          [(ngModel)]=\"startYear\"\n          (selectionChange)=\"handleYearChange($event)\"\n        >\n          <mat-option\n            [value]=\"startYear\"\n            *ngFor=\"let startYear of startListYears\"\n            >{{ startYear }}</mat-option\n          >\n        </mat-select>\n      </mat-form-field>\n    </div>\n\n    <div class=\"igo-col igo-col-100\">\n      <mat-form-field>\n        <mat-select\n          placeholder=\"{{ 'igo.geo.timeFilter.endDate' | translate }}\"\n          [(ngModel)]=\"endYear\"\n          (selectionChange)=\"handleYearChange($event)\"\n        >\n          <mat-option [value]=\"endYear\" *ngFor=\"let endYear of endListYears\">{{\n            endYear\n          }}</mat-option>\n        </mat-select>\n      </mat-form-field>\n    </div>\n  </div>\n</div>\n\n<br />\n<div\n  *ngIf=\"!isRange && style === 'slider' && type === 'year'\"\n  class=\"igo-col igo-col-100 igo-col-100-m mat-typography\"\n>\n  <span>{{ startYear }}</span>\n  <!-- TODO: The 'tickInterval' property no longer exists -->\n  <mat-slider\n    id=\"time-slider\"\n    step=\"{{ step }}\"\n    [min]=\"startYear\"\n    [max]=\"endYear\"\n    [color]=\"color\"\n    thumbLabel\n    [disabled]=\"!options.enabled || !layer.visible\"\n    #ngSlider\n    ><input\n      matSliderThumb\n      [value]=\"handleSliderValue()\"\n      (input)=\"\n        handleSliderYearChange({\n          source: ngSliderThumb,\n          parent: ngSlider,\n          value: ngSliderThumb.value\n        })\n      \"\n      #ngSliderThumb=\"matSliderThumb\"\n      (change)=\"\n        handleSliderYearChange({\n          source: ngSliderThumb,\n          parent: ngSlider,\n          value: ngSliderThumb.value\n        })\n      \"\n    />\n  </mat-slider>\n  <span>{{ endYear }}</span>\n  <p *ngIf=\"options.enabled\" class=\"date-below\">{{ year }}</p>\n  <div #actions class=\"igo-layer-actions-container\">\n    <mat-slide-toggle\n      (change)=\"toggleFilterState()\"\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"'igo.geo.filter.toggleFilterState' | translate\"\n      [color]=\"color\"\n      [checked]=\"options.enabled\"\n      [disabled]=\"!layer.visible\"\n    >\n    </mat-slide-toggle>\n    <button\n      [disabled]=\"!options.enabled || !layer.visible\"\n      mat-icon-button\n      color=\"primary\"\n      (click)=\"playYear($event)\"\n    >\n      <mat-icon svgIcon=\"{{ playIcon }}\"></mat-icon>\n    </button>\n    <button\n      [disabled]=\"!options.enabled || !layer.visible\"\n      mat-icon-button\n      color=\"primary\"\n      (click)=\"resetFilter($event)\"\n    >\n      <mat-icon svgIcon=\"{{ resetIcon }}\"></mat-icon>\n    </button>\n  </div>\n</div>\n\n<div\n  *ngIf=\"style === 'slider' && type !== 'year'\"\n  class=\"igo-col igo-col-100 igo-col-100-m\"\n>\n  <!-- TODO: The 'tickInterval' property no longer exists -->\n  <mat-slider\n    id=\"time-slider\"\n    step=\"{{ step }}\"\n    [min]=\"dateToNumber(min)\"\n    [max]=\"dateToNumber(max)\"\n    thumbLabel\n    (selectionChange)=\"handleSliderDateChange($event)\"\n    #ngSlider\n    ><input\n      matSliderThumb\n      [value]=\"handleSliderValue()\"\n      (input)=\"\n        handleSliderDateChange({\n          source: ngSliderThumb,\n          parent: ngSlider,\n          value: ngSliderThumb.value\n        })\n      \"\n      #ngSliderThumb=\"matSliderThumb\"\n    />\n  </mat-slider>\n  <p class=\"date-below\">{{ handleSliderTooltip() }}</p>\n  <button mat-icon-button color=\"primary\" (click)=\"playFilter($event)\">\n    <mat-icon svgIcon=\"{{ playIcon }}\"></mat-icon>\n  </button>\n</div>\n", styles: [":host .igo-layer-filters-container{padding-left:5px}:host #time-slider{width:70%}@media only screen and (orientation:portrait) and (max-width: 599px),only screen and (orientation:landscape) and (max-width: 959px){:host #time-slider{width:60%}}:host .date-below{margin:0}:host .igo-layer-actions-container{display:flex;align-items:center;justify-content:center}\n"], dependencies: [{ kind: "directive", type: i2$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "component", type: i9.MatOption, selector: "mat-option", exportAs: ["matOption"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "component", type: i8$1.MatSlider, selector: "mat-slider", inputs: ["color", "disableRipple", "disabled", "discrete", "showTickMarks", "min", "max", "step", "displayWith"], exportAs: ["matSlider"] }, { kind: "directive", type: i8$1.MatSliderThumb, selector: "input[matSliderThumb]", inputs: ["value"], outputs: ["valueChange", "dragStart", "dragEnd"], exportAs: ["matSliderThumb"] }, { kind: "component", type: i7.MatSlideToggle, selector: "mat-slide-toggle", inputs: ["disabled", "disableRipple", "color", "tabIndex"], exportAs: ["matSlideToggle"] }, { kind: "component", type: i8.MatFormField, selector: "mat-form-field", inputs: ["hideRequiredMarker", "color", "floatLabel", "appearance", "subscriptSizing", "hintLabel"], exportAs: ["matFormField"] }, { kind: "directive", type: i8.MatSuffix, selector: "[matSuffix], [matIconSuffix], [matTextSuffix]", inputs: ["matTextSuffix"] }, { kind: "directive", type: i9$3.MatInput, selector: "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", inputs: ["disabled", "id", "placeholder", "name", "required", "type", "errorStateMatcher", "aria-describedby", "value", "readonly"], exportAs: ["matInput"] }, { kind: "component", type: i15.MatSelect, selector: "mat-select", inputs: ["disabled", "disableRipple", "tabIndex", "panelWidth", "hideSingleSelectionIndicator"], exportAs: ["matSelect"] }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "component", type: i12$1.MatDatetimepickerComponent, selector: "mat-datetimepicker", inputs: ["multiYearSelector", "twelvehour", "startView", "mode", "timeInterval", "ariaNextMonthLabel", "ariaPrevMonthLabel", "ariaNextYearLabel", "ariaPrevYearLabel", "preventSameDateTimeSelection", "panelClass", "startAt", "openOnFocus", "type", "touchUi", "disabled"], outputs: ["selectedChanged", "opened", "closed", "viewChanged"], exportAs: ["matDatetimepicker"] }, { kind: "component", type: i12$1.MatDatetimepickerToggleComponent, selector: "mat-datetimepicker-toggle", inputs: ["for", "disabled"], exportAs: ["matDatetimepickerToggle"] }, { kind: "directive", type: i12$1.MatDatetimepickerInputDirective, selector: "input[matDatetimepicker]", inputs: ["matDatetimepicker", "matDatepickerFilter", "value", "min", "max", "disabled"], outputs: ["dateChange", "dateInput"], exportAs: ["matDatepickerInput"] }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TimeFilterFormComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-time-filter-form', template: "<div *ngIf=\"style === 'calendar' && type !== 'year'\">\n  <div *ngIf=\"!isRange\" class=\"igo-col igo-col-100 igo-col-100-m\">\n    <mat-form-field>\n      <mat-datetimepicker-toggle\n        class=\"time-filter-mat-datetimepicker-toggle\"\n        [for]=\"datetimePicker\"\n        matSuffix\n      ></mat-datetimepicker-toggle>\n      <mat-datetimepicker\n        #datetimePicker\n        type=\"{{ type }}\"\n        openOnFocus=\"true\"\n        timeInterval=\"5\"\n      ></mat-datetimepicker>\n      <input\n        matInput\n        autocomplete=\"false\"\n        placeholder=\"{{ 'igo.geo.timeFilter.date' | translate }}\"\n        [matDatetimepicker]=\"datetimePicker\"\n        [(ngModel)]=\"date\"\n        [min]=\"min\"\n        [max]=\"max\"\n        readonly=\"readonly\"\n        (dateChange)=\"handleDateChange($event)\"\n      />\n    </mat-form-field>\n  </div>\n\n  <div *ngIf=\"isRange\">\n    <div class=\"igo-col igo-col-100\">\n      <mat-form-field>\n        <mat-datetimepicker-toggle\n          class=\"time-filter-mat-datetimepicker-toggle\"\n          [for]=\"minDatetimePicker\"\n          matSuffix\n        ></mat-datetimepicker-toggle>\n        <mat-datetimepicker\n          #minDatetimePicker\n          type=\"{{ type }}\"\n          openOnFocus=\"true\"\n          timeInterval=\"5\"\n        ></mat-datetimepicker>\n        <input\n          matInput\n          autocomplete=\"false\"\n          placeholder=\"{{ 'igo.geo.timeFilter.startDate' | translate }}\"\n          [matDatetimepicker]=\"minDatetimePicker\"\n          [(ngModel)]=\"startDate\"\n          [min]=\"min\"\n          [max]=\"getRangeMaxDate()\"\n          readonly=\"readonly\"\n          (input)=\"(startDate)\"\n          (dateChange)=\"handleDateChange($event)\"\n        />\n      </mat-form-field>\n    </div>\n\n    <div class=\"igo-col igo-col-100\">\n      <mat-form-field>\n        <mat-datetimepicker-toggle\n          class=\"time-filter-mat-datetimepicker-toggle\"\n          [for]=\"maxDatetimePicker\"\n          matSuffix\n        ></mat-datetimepicker-toggle>\n        <mat-datetimepicker\n          #maxDatetimePicker\n          type=\"{{ type }}\"\n          openOnFocus=\"true\"\n          timeInterval=\"5\"\n        ></mat-datetimepicker>\n        <input\n          matInput\n          autocomplete=\"false\"\n          placeholder=\"{{ 'igo.geo.timeFilter.endDate' | translate }}\"\n          [matDatetimepicker]=\"maxDatetimePicker\"\n          [(ngModel)]=\"endDate\"\n          [min]=\"getRangeMinDate()\"\n          [max]=\"max\"\n          readonly=\"readonly\"\n          (dateChange)=\"handleDateChange($event)\"\n        />\n      </mat-form-field>\n    </div>\n  </div>\n</div>\n\n<div *ngIf=\"style === 'calendar' && type === 'year'\">\n  <div *ngIf=\"!isRange\" class=\"igo-col igo-col-100 igo-col-100-m\">\n    <mat-form-field>\n      <mat-select\n        placeholder=\"{{ 'igo.geo.timeFilter.date' | translate }}\"\n        [(ngModel)]=\"year\"\n        (selectionChange)=\"handleYearChange($event)\"\n      >\n        <mat-option [value]=\"year\" *ngFor=\"let year of listYears\">{{\n          year\n        }}</mat-option>\n      </mat-select>\n    </mat-form-field>\n  </div>\n\n  <div *ngIf=\"isRange\">\n    <div class=\"igo-col igo-col-100\">\n      <mat-form-field>\n        <mat-select\n          placeholder=\"{{ 'igo.geo.timeFilter.startDate' | translate }}\"\n          [(ngModel)]=\"startYear\"\n          (selectionChange)=\"handleYearChange($event)\"\n        >\n          <mat-option\n            [value]=\"startYear\"\n            *ngFor=\"let startYear of startListYears\"\n            >{{ startYear }}</mat-option\n          >\n        </mat-select>\n      </mat-form-field>\n    </div>\n\n    <div class=\"igo-col igo-col-100\">\n      <mat-form-field>\n        <mat-select\n          placeholder=\"{{ 'igo.geo.timeFilter.endDate' | translate }}\"\n          [(ngModel)]=\"endYear\"\n          (selectionChange)=\"handleYearChange($event)\"\n        >\n          <mat-option [value]=\"endYear\" *ngFor=\"let endYear of endListYears\">{{\n            endYear\n          }}</mat-option>\n        </mat-select>\n      </mat-form-field>\n    </div>\n  </div>\n</div>\n\n<br />\n<div\n  *ngIf=\"!isRange && style === 'slider' && type === 'year'\"\n  class=\"igo-col igo-col-100 igo-col-100-m mat-typography\"\n>\n  <span>{{ startYear }}</span>\n  <!-- TODO: The 'tickInterval' property no longer exists -->\n  <mat-slider\n    id=\"time-slider\"\n    step=\"{{ step }}\"\n    [min]=\"startYear\"\n    [max]=\"endYear\"\n    [color]=\"color\"\n    thumbLabel\n    [disabled]=\"!options.enabled || !layer.visible\"\n    #ngSlider\n    ><input\n      matSliderThumb\n      [value]=\"handleSliderValue()\"\n      (input)=\"\n        handleSliderYearChange({\n          source: ngSliderThumb,\n          parent: ngSlider,\n          value: ngSliderThumb.value\n        })\n      \"\n      #ngSliderThumb=\"matSliderThumb\"\n      (change)=\"\n        handleSliderYearChange({\n          source: ngSliderThumb,\n          parent: ngSlider,\n          value: ngSliderThumb.value\n        })\n      \"\n    />\n  </mat-slider>\n  <span>{{ endYear }}</span>\n  <p *ngIf=\"options.enabled\" class=\"date-below\">{{ year }}</p>\n  <div #actions class=\"igo-layer-actions-container\">\n    <mat-slide-toggle\n      (change)=\"toggleFilterState()\"\n      tooltip-position=\"below\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"'igo.geo.filter.toggleFilterState' | translate\"\n      [color]=\"color\"\n      [checked]=\"options.enabled\"\n      [disabled]=\"!layer.visible\"\n    >\n    </mat-slide-toggle>\n    <button\n      [disabled]=\"!options.enabled || !layer.visible\"\n      mat-icon-button\n      color=\"primary\"\n      (click)=\"playYear($event)\"\n    >\n      <mat-icon svgIcon=\"{{ playIcon }}\"></mat-icon>\n    </button>\n    <button\n      [disabled]=\"!options.enabled || !layer.visible\"\n      mat-icon-button\n      color=\"primary\"\n      (click)=\"resetFilter($event)\"\n    >\n      <mat-icon svgIcon=\"{{ resetIcon }}\"></mat-icon>\n    </button>\n  </div>\n</div>\n\n<div\n  *ngIf=\"style === 'slider' && type !== 'year'\"\n  class=\"igo-col igo-col-100 igo-col-100-m\"\n>\n  <!-- TODO: The 'tickInterval' property no longer exists -->\n  <mat-slider\n    id=\"time-slider\"\n    step=\"{{ step }}\"\n    [min]=\"dateToNumber(min)\"\n    [max]=\"dateToNumber(max)\"\n    thumbLabel\n    (selectionChange)=\"handleSliderDateChange($event)\"\n    #ngSlider\n    ><input\n      matSliderThumb\n      [value]=\"handleSliderValue()\"\n      (input)=\"\n        handleSliderDateChange({\n          source: ngSliderThumb,\n          parent: ngSlider,\n          value: ngSliderThumb.value\n        })\n      \"\n      #ngSliderThumb=\"matSliderThumb\"\n    />\n  </mat-slider>\n  <p class=\"date-below\">{{ handleSliderTooltip() }}</p>\n  <button mat-icon-button color=\"primary\" (click)=\"playFilter($event)\">\n    <mat-icon svgIcon=\"{{ playIcon }}\"></mat-icon>\n  </button>\n</div>\n", styles: [":host .igo-layer-filters-container{padding-left:5px}:host #time-slider{width:70%}@media only screen and (orientation:portrait) and (max-width: 599px),only screen and (orientation:landscape) and (max-width: 959px){:host #time-slider{width:60%}}:host .date-below{margin:0}:host .igo-layer-actions-container{display:flex;align-items:center;justify-content:center}\n"] }]
        }], ctorParameters: function () { return [{ type: i9.DateAdapter }]; }, propDecorators: { layer: [{
                type: Input
            }], options: [{
                type: Input
            }], currentValue: [{
                type: Input
            }], change: [{
                type: Output
            }], yearChange: [{
                type: Output
            }], mySlider: [{
                type: ViewChild,
                args: [MatSlider]
            }] } });

class TimeFilterItemComponent {
    timeFilterService;
    color = 'primary';
    showLegend$ = new BehaviorSubject(false);
    inResolutionRange$ = new BehaviorSubject(true);
    resolution$$;
    filtersCollapsed = false;
    header = true;
    layer;
    get datasource() {
        return this.layer.dataSource;
    }
    constructor(timeFilterService) {
        this.timeFilterService = timeFilterService;
    }
    ngOnInit() {
        const resolution$ = this.layer.map.viewController.resolution$;
        this.resolution$$ = resolution$.subscribe(() => {
            this.inResolutionRange$.next(this.layer.isInResolutionsRange);
        });
    }
    ngOnDestroy() {
        this.resolution$$.unsubscribe();
    }
    handleYearChange(year) {
        this.timeFilterService.filterByYear(this.datasource, year);
    }
    handleDateChange(date) {
        this.timeFilterService.filterByDate(this.datasource, date);
    }
    toggleLegend(collapsed) {
        this.layer.legendCollapsed = collapsed;
        this.showLegend$.next(!collapsed);
    }
    toggleLegendOnClick() {
        if (!this.filtersCollapsed) {
            this.toggleLegend(this.showLegend$.value);
        }
    }
    setVisible() {
        this.layer.visible = true;
    }
    toggleFiltersCollapsed() {
        this.filtersCollapsed = !this.filtersCollapsed;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TimeFilterItemComponent, deps: [{ token: TimeFilterService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: TimeFilterItemComponent, selector: "igo-time-filter-item", inputs: { header: "header", layer: "layer" }, ngImport: i0, template: "<mat-list-item *ngIf=\"header\">\n  <mat-icon\n    class=\"igo-chevron\"\n    matListItemIcon\n    igoCollapse\n    [target]=\"filters\"\n    [collapsed]=\"filtersCollapsed\"\n    (click)=\"toggleFiltersCollapsed()\"\n    svgIcon=\"chevron-up\"\n  >\n  </mat-icon>\n\n  <span\n    matListItemTitle\n    (click)=\"toggleLegendOnClick()\"\n    [ngStyle]=\"{ cursor: filtersCollapsed ? 'default' : 'pointer' }\"\n    >{{ layer.title }}</span\n  >\n\n  <button\n    *ngIf=\"header\"\n    mat-icon-button\n    matListItemMeta\n    [color]=\"layer.visible ? 'primary' : 'default'\"\n    collapsibleButton\n    tooltip-position=\"below\"\n    matTooltipShowDelay=\"500\"\n    [matTooltip]=\"\n      layer.visible\n        ? ('igo.geo.layer.hideLayer' | translate)\n        : ('igo.geo.layer.showLayer' | translate)\n    \"\n    (click)=\"layer.visible = !layer.visible\"\n  >\n    <mat-icon\n      [ngClass]=\"{ disabled: (inResolutionRange$ | async) === false }\"\n      [svgIcon]=\"layer.visible ? 'eye' : 'eye-off'\"\n    >\n    </mat-icon>\n  </button>\n</mat-list-item>\n\n<div #filters class=\"igo-datasource-filters-container\">\n  <div #legend class=\"igo-layer-legend-container\">\n    <igo-layer-legend *ngIf=\"showLegend$ | async\" [layer]=\"layer\">\n    </igo-layer-legend>\n  </div>\n  <igo-time-filter-form\n    [layer]=\"layer\"\n    [options]=\"datasource.options.timeFilter\"\n    [currentValue]=\"datasource.options.params.TIME\"\n    (change)=\"handleDateChange($event)\"\n    (yearChange)=\"handleYearChange($event)\"\n  >\n  </igo-time-filter-form>\n</div>\n", styles: [":host{overflow:hidden}:host .igo-datasource-filters-container{text-align:center;width:100%;display:inline-block;padding-top:5px}:host .igo-layer-legend-container{padding-left:1.125em;width:calc(100% - 18px)}\n"], dependencies: [{ kind: "directive", type: i2$2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2$2.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "component", type: i5.MatListItem, selector: "mat-list-item, a[mat-list-item], button[mat-list-item]", inputs: ["activated"], exportAs: ["matListItem"] }, { kind: "directive", type: i5.MatListItemIcon, selector: "[matListItemIcon]" }, { kind: "directive", type: i5.MatListItemTitle, selector: "[matListItemTitle]" }, { kind: "directive", type: i5.MatListItemMeta, selector: "[matListItemMeta]" }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "component", type: LayerLegendComponent, selector: "igo-layer-legend", inputs: ["updateLegendOnResolutionChange", "layer"] }, { kind: "directive", type: i9$1.CollapseDirective, selector: "[igoCollapse]", inputs: ["target", "collapsed"], outputs: ["toggle"] }, { kind: "component", type: TimeFilterFormComponent, selector: "igo-time-filter-form", inputs: ["layer", "options", "currentValue"], outputs: ["change", "yearChange"] }, { kind: "pipe", type: i2$2.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TimeFilterItemComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-time-filter-item', template: "<mat-list-item *ngIf=\"header\">\n  <mat-icon\n    class=\"igo-chevron\"\n    matListItemIcon\n    igoCollapse\n    [target]=\"filters\"\n    [collapsed]=\"filtersCollapsed\"\n    (click)=\"toggleFiltersCollapsed()\"\n    svgIcon=\"chevron-up\"\n  >\n  </mat-icon>\n\n  <span\n    matListItemTitle\n    (click)=\"toggleLegendOnClick()\"\n    [ngStyle]=\"{ cursor: filtersCollapsed ? 'default' : 'pointer' }\"\n    >{{ layer.title }}</span\n  >\n\n  <button\n    *ngIf=\"header\"\n    mat-icon-button\n    matListItemMeta\n    [color]=\"layer.visible ? 'primary' : 'default'\"\n    collapsibleButton\n    tooltip-position=\"below\"\n    matTooltipShowDelay=\"500\"\n    [matTooltip]=\"\n      layer.visible\n        ? ('igo.geo.layer.hideLayer' | translate)\n        : ('igo.geo.layer.showLayer' | translate)\n    \"\n    (click)=\"layer.visible = !layer.visible\"\n  >\n    <mat-icon\n      [ngClass]=\"{ disabled: (inResolutionRange$ | async) === false }\"\n      [svgIcon]=\"layer.visible ? 'eye' : 'eye-off'\"\n    >\n    </mat-icon>\n  </button>\n</mat-list-item>\n\n<div #filters class=\"igo-datasource-filters-container\">\n  <div #legend class=\"igo-layer-legend-container\">\n    <igo-layer-legend *ngIf=\"showLegend$ | async\" [layer]=\"layer\">\n    </igo-layer-legend>\n  </div>\n  <igo-time-filter-form\n    [layer]=\"layer\"\n    [options]=\"datasource.options.timeFilter\"\n    [currentValue]=\"datasource.options.params.TIME\"\n    (change)=\"handleDateChange($event)\"\n    (yearChange)=\"handleYearChange($event)\"\n  >\n  </igo-time-filter-form>\n</div>\n", styles: [":host{overflow:hidden}:host .igo-datasource-filters-container{text-align:center;width:100%;display:inline-block;padding-top:5px}:host .igo-layer-legend-container{padding-left:1.125em;width:calc(100% - 18px)}\n"] }]
        }], ctorParameters: function () { return [{ type: TimeFilterService }]; }, propDecorators: { header: [{
                type: Input
            }], layer: [{
                type: Input
            }] } });

class TimeFilterButtonComponent {
    options;
    get badge() {
        const filter = this.options.timeFilter;
        if (filter && filter.enabled) {
            return 1;
        }
        else {
            return;
        }
    }
    get layer() {
        return this._layer;
    }
    set layer(value) {
        this._layer = value;
        if (value) {
            this.options = this.layer.dataSource.options;
        }
    }
    _layer;
    map;
    color = 'primary';
    header = true;
    timeFilterCollapse = false;
    constructor() { }
    ngOnInit() {
        this.options = this.layer.dataSource.options;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TimeFilterButtonComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: TimeFilterButtonComponent, selector: "igo-time-filter-button", inputs: { layer: "layer", map: "map", color: "color", header: "header" }, ngImport: i0, template: "<button\n  *ngIf=\"header && options.timeFilterable && options.timeFilter\"\n  mat-icon-button\n  collapsibleButton\n  tooltip-position=\"below\"\n  matTooltipShowDelay=\"500\"\n  [matTooltip]=\"'igo.geo.filter.filterBy' | translate\"\n  [color]=\"color\"\n>\n  <mat-icon\n    aria-hidden=\"false\"\n    [matBadge]=\"badge\"\n    matBadgeColor=\"warn\"\n    matBadgeSize=\"medium\"\n    svgIcon=\"history\"\n  ></mat-icon>\n</button>\n\n<div\n  #ogcFilter\n  class=\"igo-layer-actions-container\"\n  *ngIf=\"header && options.timeFilterable && options.timeFilter\"\n>\n  <igo-time-filter-item\n    *ngIf=\"timeFilterCollapse && options.timeFilter\"\n    igoListItem\n    [header]=\"false\"\n    [layer]=\"layer\"\n  >\n  </igo-time-filter-item>\n</div>\n", styles: [""], dependencies: [{ kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "directive", type: i9$1.ListItemDirective, selector: "[igoListItem]", inputs: ["color", "focused", "selected", "disabled"], outputs: ["beforeSelect", "beforeFocus", "beforeUnselect", "beforeUnfocus", "beforeDisable", "beforeEnable", "focus", "unfocus", "select", "unselect", "disable", "enable"] }, { kind: "directive", type: i6.MatBadge, selector: "[matBadge]", inputs: ["matBadgeDisabled", "matBadgeColor", "matBadgeOverlap", "matBadgePosition", "matBadge", "matBadgeDescription", "matBadgeSize", "matBadgeHidden"] }, { kind: "component", type: TimeFilterItemComponent, selector: "igo-time-filter-item", inputs: ["header", "layer"] }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TimeFilterButtonComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-time-filter-button', changeDetection: ChangeDetectionStrategy.OnPush, template: "<button\n  *ngIf=\"header && options.timeFilterable && options.timeFilter\"\n  mat-icon-button\n  collapsibleButton\n  tooltip-position=\"below\"\n  matTooltipShowDelay=\"500\"\n  [matTooltip]=\"'igo.geo.filter.filterBy' | translate\"\n  [color]=\"color\"\n>\n  <mat-icon\n    aria-hidden=\"false\"\n    [matBadge]=\"badge\"\n    matBadgeColor=\"warn\"\n    matBadgeSize=\"medium\"\n    svgIcon=\"history\"\n  ></mat-icon>\n</button>\n\n<div\n  #ogcFilter\n  class=\"igo-layer-actions-container\"\n  *ngIf=\"header && options.timeFilterable && options.timeFilter\"\n>\n  <igo-time-filter-item\n    *ngIf=\"timeFilterCollapse && options.timeFilter\"\n    igoListItem\n    [header]=\"false\"\n    [layer]=\"layer\"\n  >\n  </igo-time-filter-item>\n</div>\n" }]
        }], ctorParameters: function () { return []; }, propDecorators: { layer: [{
                type: Input
            }], map: [{
                type: Input
            }], color: [{
                type: Input
            }], header: [{
                type: Input
            }] } });

class TimeFilterListComponent {
    cdRef;
    get layers() {
        return this._layers;
    }
    set layers(value) {
        this._layers = value;
        this.cdRef.detectChanges();
    }
    _layers = [];
    constructor(cdRef) {
        this.cdRef = cdRef;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TimeFilterListComponent, deps: [{ token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: TimeFilterListComponent, selector: "igo-time-filter-list", inputs: { layers: "layers" }, ngImport: i0, template: "<igo-list [navigation]=\"false\" [selection]=\"false\">\n  <ng-template\n    ngFor\n    let-layer\n    [ngForOf]=\"layers | filterableDataSource: 'time'\"\n  >\n    <igo-time-filter-item\n      [header]=\"true\"\n      igoListItem\n      [layer]=\"layer\"\n    ></igo-time-filter-item>\n  </ng-template>\n</igo-list>\n", dependencies: [{ kind: "directive", type: i2$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i9$1.ListItemDirective, selector: "[igoListItem]", inputs: ["color", "focused", "selected", "disabled"], outputs: ["beforeSelect", "beforeFocus", "beforeUnselect", "beforeUnfocus", "beforeDisable", "beforeEnable", "focus", "unfocus", "select", "unselect", "disable", "enable"] }, { kind: "component", type: i9$1.ListComponent, selector: "igo-list", inputs: ["navigation", "selection"] }, { kind: "component", type: TimeFilterItemComponent, selector: "igo-time-filter-item", inputs: ["header", "layer"] }, { kind: "pipe", type: FilterableDataSourcePipe, name: "filterableDataSource" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TimeFilterListComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-time-filter-list', changeDetection: ChangeDetectionStrategy.OnPush, template: "<igo-list [navigation]=\"false\" [selection]=\"false\">\n  <ng-template\n    ngFor\n    let-layer\n    [ngForOf]=\"layers | filterableDataSource: 'time'\"\n  >\n    <igo-time-filter-item\n      [header]=\"true\"\n      igoListItem\n      [layer]=\"layer\"\n    ></igo-time-filter-item>\n  </ng-template>\n</igo-list>\n" }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }]; }, propDecorators: { layers: [{
                type: Input
            }] } });

class TimeFilterListBindingDirective {
    mapService;
    component;
    layers$$;
    constructor(component, mapService) {
        this.mapService = mapService;
        this.component = component;
    }
    ngOnInit() {
        // Override input layers
        this.component.layers = [];
        this.layers$$ = this.mapService.getMap().layers$.subscribe((layers) => {
            this.component.layers = layers;
        });
    }
    ngOnDestroy() {
        this.layers$$.unsubscribe();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TimeFilterListBindingDirective, deps: [{ token: TimeFilterListComponent, self: true }, { token: MapService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: TimeFilterListBindingDirective, selector: "[igoTimeFilterListBinding]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TimeFilterListBindingDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igoTimeFilterListBinding]'
                }]
        }], ctorParameters: function () { return [{ type: TimeFilterListComponent, decorators: [{
                    type: Self
                }] }, { type: MapService }]; } });

class IgoFilterModule {
    static forRoot() {
        return {
            ngModule: IgoFilterModule,
            providers: [
                {
                    provide: MAT_DATE_LOCALE,
                    useValue: 'fr-FR'
                }
            ]
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoFilterModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoFilterModule, declarations: [FilterableDataSourcePipe,
            TimeFilterButtonComponent,
            TimeFilterFormComponent,
            TimeFilterItemComponent,
            TimeFilterListComponent,
            TimeFilterListBindingDirective,
            OgcFilterFormComponent,
            OgcFilterButtonComponent,
            OgcFilterSelectionComponent,
            OgcFilterableFormComponent,
            OgcFilterableItemComponent,
            OgcFilterableListComponent,
            OgcFilterableListBindingDirective,
            SpatialFilterTypeComponent,
            SpatialFilterListComponent,
            SpatialFilterItemComponent,
            OgcFilterTimeComponent,
            OgcFilterTimeSliderComponent], imports: [CommonModule,
            FormsModule,
            ReactiveFormsModule,
            MatAutocompleteModule,
            MatIconModule,
            MatButtonModule,
            MatTabsModule,
            MatRadioModule,
            MatMenuModule,
            MatTableModule,
            MatTreeModule,
            MatButtonToggleModule,
            MatCheckboxModule,
            MatSliderModule,
            MatSlideToggleModule,
            MatFormFieldModule,
            MatInputModule,
            MatOptionModule,
            MatSelectModule,
            MatListModule,
            MatTooltipModule,
            MatDatepickerModule,
            MatNativeDateModule,
            MatDatetimepickerModule,
            MatNativeDatetimeModule,
            IgoLanguageModule,
            IgoLayerModule,
            IgoCollapsibleModule,
            IgoListModule,
            IgoEntityModule,
            IgoDOMModule,
            IgoKeyValueModule,
            IgoGeometryModule,
            MatBadgeModule], exports: [FilterableDataSourcePipe,
            TimeFilterButtonComponent,
            TimeFilterFormComponent,
            TimeFilterItemComponent,
            TimeFilterListComponent,
            TimeFilterListBindingDirective,
            OgcFilterFormComponent,
            OgcFilterButtonComponent,
            OgcFilterSelectionComponent,
            OgcFilterableFormComponent,
            OgcFilterableItemComponent,
            OgcFilterableListComponent,
            OgcFilterableListBindingDirective,
            SpatialFilterTypeComponent,
            SpatialFilterListComponent,
            SpatialFilterItemComponent,
            OgcFilterTimeComponent,
            OgcFilterTimeSliderComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoFilterModule, providers: [
            TimeFilterService,
            OGCFilterService,
            OGCFilterTimeService,
            SpatialFilterService
        ], imports: [CommonModule,
            FormsModule,
            ReactiveFormsModule,
            MatAutocompleteModule,
            MatIconModule,
            MatButtonModule,
            MatTabsModule,
            MatRadioModule,
            MatMenuModule,
            MatTableModule,
            MatTreeModule,
            MatButtonToggleModule,
            MatCheckboxModule,
            MatSliderModule,
            MatSlideToggleModule,
            MatFormFieldModule,
            MatInputModule,
            MatOptionModule,
            MatSelectModule,
            MatListModule,
            MatTooltipModule,
            MatDatepickerModule,
            MatNativeDateModule,
            MatDatetimepickerModule,
            MatNativeDatetimeModule,
            IgoLanguageModule,
            IgoLayerModule,
            IgoCollapsibleModule,
            IgoListModule,
            IgoEntityModule,
            IgoDOMModule,
            IgoKeyValueModule,
            IgoGeometryModule,
            MatBadgeModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoFilterModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        FormsModule,
                        ReactiveFormsModule,
                        MatAutocompleteModule,
                        MatIconModule,
                        MatButtonModule,
                        MatTabsModule,
                        MatRadioModule,
                        MatMenuModule,
                        MatTableModule,
                        MatTreeModule,
                        MatButtonToggleModule,
                        MatCheckboxModule,
                        MatSliderModule,
                        MatSlideToggleModule,
                        MatFormFieldModule,
                        MatInputModule,
                        MatOptionModule,
                        MatSelectModule,
                        MatListModule,
                        MatTooltipModule,
                        MatDatepickerModule,
                        MatNativeDateModule,
                        MatDatetimepickerModule,
                        MatNativeDatetimeModule,
                        IgoLanguageModule,
                        IgoLayerModule,
                        IgoCollapsibleModule,
                        IgoListModule,
                        IgoEntityModule,
                        IgoDOMModule,
                        IgoKeyValueModule,
                        IgoGeometryModule,
                        MatBadgeModule
                    ],
                    exports: [
                        FilterableDataSourcePipe,
                        TimeFilterButtonComponent,
                        TimeFilterFormComponent,
                        TimeFilterItemComponent,
                        TimeFilterListComponent,
                        TimeFilterListBindingDirective,
                        OgcFilterFormComponent,
                        OgcFilterButtonComponent,
                        OgcFilterSelectionComponent,
                        OgcFilterableFormComponent,
                        OgcFilterableItemComponent,
                        OgcFilterableListComponent,
                        OgcFilterableListBindingDirective,
                        SpatialFilterTypeComponent,
                        SpatialFilterListComponent,
                        SpatialFilterItemComponent,
                        OgcFilterTimeComponent,
                        OgcFilterTimeSliderComponent
                    ],
                    declarations: [
                        FilterableDataSourcePipe,
                        TimeFilterButtonComponent,
                        TimeFilterFormComponent,
                        TimeFilterItemComponent,
                        TimeFilterListComponent,
                        TimeFilterListBindingDirective,
                        OgcFilterFormComponent,
                        OgcFilterButtonComponent,
                        OgcFilterSelectionComponent,
                        OgcFilterableFormComponent,
                        OgcFilterableItemComponent,
                        OgcFilterableListComponent,
                        OgcFilterableListBindingDirective,
                        SpatialFilterTypeComponent,
                        SpatialFilterListComponent,
                        SpatialFilterItemComponent,
                        OgcFilterTimeComponent,
                        OgcFilterTimeSliderComponent
                    ],
                    providers: [
                        TimeFilterService,
                        OGCFilterService,
                        OGCFilterTimeService,
                        SpatialFilterService
                    ]
                }]
        }] });

class ExportButtonComponent {
    get layer() {
        return this._layer;
    }
    set layer(value) {
        this._layer = value;
    }
    _layer;
    get color() {
        return this._color;
    }
    set color(value) {
        this._color = value;
    }
    _color = 'primary';
    constructor() { }
    get options() {
        if (!this.layer) {
            return;
        }
        return this.layer.dataSource.options;
    }
    layerIsExportable() {
        if ((this.layer instanceof VectorLayer && this.layer.exportable === true) ||
            (this.layer.dataSource.options.download &&
                this.layer.dataSource.options.download.url) ||
            (this.layer.options.workspace?.enabled &&
                this.layer.options.workspace?.workspaceId !== this.layer.id)) {
            return true;
        }
        return false;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ExportButtonComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: ExportButtonComponent, selector: "igo-export-button", inputs: { layer: "layer", color: "color" }, ngImport: i0, template: "<button\n  *ngIf=\"layerIsExportable()\"\n  mat-icon-button\n  tooltip-position=\"below\"\n  matTooltipShowDelay=\"500\"\n  [matTooltip]=\"'igo.geo.download.action' | translate\"\n  [color]=\"color\"\n>\n  <!-- (click)=\"openDownload(layer)\"> -->\n  <mat-icon svgIcon=\"file-export\"></mat-icon>\n</button>\n", styles: [""], dependencies: [{ kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ExportButtonComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-export-button', changeDetection: ChangeDetectionStrategy.OnPush, template: "<button\n  *ngIf=\"layerIsExportable()\"\n  mat-icon-button\n  tooltip-position=\"below\"\n  matTooltipShowDelay=\"500\"\n  [matTooltip]=\"'igo.geo.download.action' | translate\"\n  [color]=\"color\"\n>\n  <!-- (click)=\"openDownload(layer)\"> -->\n  <mat-icon svgIcon=\"file-export\"></mat-icon>\n</button>\n" }]
        }], ctorParameters: function () { return []; }, propDecorators: { layer: [{
                type: Input
            }], color: [{
                type: Input
            }] } });

class StyleListService {
    styleList = {};
    httpClient;
    constructor(handler) {
        this.httpClient = new HttpClient(handler);
    }
    /**
     * Use to get the data found in styleList file
     */
    getStyleList(key) {
        return ObjectUtils.resolve(this.styleList, key);
    }
    /**
     * This method loads "[path]" to get all styleList's variables
     */
    load(options) {
        const baseStyleList = options.default || {};
        if (!options.path) {
            this.styleList = baseStyleList;
            return true;
        }
        return new Promise((resolve, _reject) => {
            this.httpClient
                .get(options.path)
                .pipe(catchError((error) => {
                console.log(`StyleList file ${options.path} could not be read`);
                resolve(true);
                return throwError(error.error || 'Server error');
            }))
                .subscribe((styleListResponse) => {
                this.styleList = ObjectUtils.mergeDeep(baseStyleList, styleListResponse);
                resolve(true);
            });
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: StyleListService, deps: [{ token: i1.HttpBackend }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: StyleListService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: StyleListService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i1.HttpBackend }]; } });

class ExportError extends Error {
}
class ExportInvalidFileError extends ExportError {
    constructor() {
        super('Invalid file');
        Object.setPrototypeOf(this, ExportInvalidFileError.prototype);
    }
}
class ExportNothingToExportError extends ExportError {
    constructor() {
        super('Nothing to export');
        Object.setPrototypeOf(this, ExportNothingToExportError.prototype);
    }
}

const ExportFormat = strEnum([
    'URL',
    'GeoJSON',
    'GML',
    'GPX',
    'KML',
    'Shapefile',
    'CSVcomma',
    'CSVsemicolon'
]);
const EncodingFormat = strEnum(['UTF8', 'LATIN1']);

class ExportService {
    config;
    static ogreFormats = {
        GML: 'gml',
        GPX: 'gpx',
        KML: 'kml',
        Shapefile: 'ESRI Shapefile',
        CSVcomma: 'CSVcomma',
        CSVsemicolon: 'CSVsemicolon'
    };
    static noOgreFallbacks = ['GML', 'GPX', 'KML'];
    ogreUrl;
    aggregateInComment = true;
    constructor(config) {
        this.config = config;
        this.ogreUrl = this.config.getConfig('importExport.url');
        const gpxAggregateInComment = this.config.getConfig('importExport.gpxAggregateInComment');
        if (gpxAggregateInComment !== undefined) {
            this.aggregateInComment = gpxAggregateInComment;
        }
    }
    export(olFeatures, format, title, encoding, projectionIn = 'EPSG:4326', projectionOut = 'EPSG:4326') {
        const exportOlFeatures = this.generateFeature(olFeatures, format, '_featureStore');
        return this.exportAsync(exportOlFeatures, format, title, encoding, projectionIn, projectionOut);
    }
    generateFeature(olFeatures, format, excludePrefix = '_') {
        if (format === ExportFormat.GPX && this.aggregateInComment) {
            return this.generateAggregatedFeature(olFeatures);
        }
        return olFeatures.map((olFeature) => {
            const keys = olFeature
                .getKeys()
                .filter((key) => !key.startsWith(excludePrefix));
            const properties = keys.reduce((acc, key) => {
                acc[key] = olFeature.get(key);
                return acc;
            }, { geometry: olFeature.getGeometry() });
            return new OlFeature(properties);
        });
    }
    generateAggregatedFeature(olFeatures) {
        return olFeatures.map((olFeature) => {
            const keys = olFeature
                .getKeys()
                .filter((key) => !key.startsWith('_'));
            let comment = '';
            const properties = keys.reduce((acc, key) => {
                if (key && key !== 'geometry') {
                    key === 'id' && olFeature.get('draw')
                        ? (comment += key + ':' + olFeature.get('draw') + '   \r\n')
                        : (comment += key + ':' + olFeature.get(key) + '   \r\n');
                }
                acc[key] = olFeature.get(key);
                return acc;
            }, {
                geometry: olFeature.getGeometry()
            });
            const newFeature = new OlFeature(properties);
            newFeature.set('name', olFeature.getId());
            newFeature.set('cmt', comment);
            return newFeature;
        });
    }
    exportAsync(olFeatures, format, title, encoding, projectionIn, projectionOut) {
        const doExport = (observer) => {
            const nothingToExport = this.nothingToExport(olFeatures, format);
            if (nothingToExport) {
                observer.error(new ExportNothingToExportError());
                return;
            }
            const ogreFormats = Object.keys(ExportService.ogreFormats);
            if (ogreFormats.indexOf(format) >= 0) {
                if (!this.ogreUrl) {
                    if (ExportService.noOgreFallbacks.indexOf(format) >= 0) {
                        this.exportToFile(olFeatures, observer, format, title, projectionIn, projectionOut);
                    }
                    else {
                        observer.error(new ExportInvalidFileError());
                    }
                    return;
                }
                this.exportWithOgre(olFeatures, observer, format, title, encoding, projectionIn, projectionOut);
            }
            else {
                this.exportToFile(olFeatures, observer, format, title, projectionIn, projectionOut);
            }
        };
        return new Observable(doExport);
    }
    exportToFile(olFeatures, observer, format, title, projectionIn, projectionOut) {
        const olFormat = new olformat[format]();
        const featuresText = olFormat.writeFeatures(olFeatures, {
            dataProjection: projectionOut,
            featureProjection: projectionIn,
            featureType: 'feature',
            featureNS: 'http://example.com/feature'
        });
        const fileName = `${title}.${format.toLowerCase()}`;
        downloadContent(featuresText, 'attachment/plain;charset=utf-8', fileName);
        observer.complete();
    }
    exportWithOgre(olFeatures, observer, format, title, encodingType, projectionIn, projectionOut) {
        let featuresText = new olformat.GeoJSON().writeFeatures(olFeatures, {
            dataProjection: projectionOut,
            featureProjection: projectionIn
        });
        const url = `${this.ogreUrl}/convertJson`;
        const form = document.createElement('form');
        form.style.display = 'none';
        document.body.appendChild(form);
        form.setAttribute('method', 'post');
        form.setAttribute('target', '_blank');
        form.setAttribute('action', url);
        if (encodingType === EncodingFormat.UTF8) {
            form.acceptCharset = 'UTF-8';
            form.enctype = 'application/x-www-form-urlencoded; charset=utf-8;';
        }
        else if (encodingType === EncodingFormat.LATIN1) {
            const enctype = 'ISO-8859-1';
            const featuresJson = JSON.parse(featuresText);
            featuresJson.features.map((f) => {
                const encodedProperties = String.fromCharCode.apply(null, encode(JSON.stringify(f.properties), { mode: 'replacement' }));
                f.properties = JSON.parse(encodedProperties);
            });
            featuresText = JSON.stringify(featuresJson);
            const encoding = document.createElement('input');
            encoding.setAttribute('type', 'hidden');
            encoding.setAttribute('name', 'encoding');
            encoding.setAttribute('value', enctype);
            form.appendChild(encoding);
        }
        if (format === 'CSVsemicolon') {
            const options = document.createElement('input');
            options.setAttribute('type', 'hidden');
            options.setAttribute('name', 'lco');
            options.setAttribute('value', 'SEPARATOR=SEMICOLON');
            form.appendChild(options);
        }
        const geojsonField = document.createElement('input');
        geojsonField.setAttribute('type', 'hidden');
        geojsonField.setAttribute('name', 'json');
        geojsonField.setAttribute('value', featuresText);
        form.appendChild(geojsonField);
        const outputNameField = document.createElement('input');
        let outputName = format === 'Shapefile'
            ? `${title}.zip`
            : `${title}.${format.toLowerCase()}`;
        if (format === 'CSVcomma' || format === 'CSVsemicolon') {
            outputName = `${title}.csv`;
        }
        outputName = outputName.replace(' ', '_');
        outputName = outputName
            .normalize('NFD')
            .replace(/[\u0300-\u036f]/g, '')
            .replace(/’/g, "'");
        outputNameField.setAttribute('type', 'hidden');
        outputNameField.setAttribute('name', 'outputName');
        outputNameField.setAttribute('value', outputName);
        form.appendChild(outputNameField);
        let ogreFormat = ExportService.ogreFormats[format];
        if (format === 'CSVcomma' || format === 'CSVsemicolon') {
            ogreFormat = 'CSV';
        }
        const outputFormatField = document.createElement('input');
        outputFormatField.setAttribute('type', 'hidden');
        outputFormatField.setAttribute('name', 'format');
        outputFormatField.setAttribute('value', ogreFormat);
        form.appendChild(outputFormatField);
        form.submit();
        document.body.removeChild(form);
        observer.complete();
    }
    nothingToExport(olFeatures, format) {
        if (olFeatures.length === 0) {
            return true;
        }
        if (format === 'GPX') {
            const pointOrLine = olFeatures.find((olFeature) => {
                return (['Point', 'LineString', 'MultiLineString'].indexOf(olFeature.getGeometry().getType()) >= 0);
            });
            return pointOrLine === undefined;
        }
        return false;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ExportService, deps: [{ token: i2.ConfigService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ExportService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ExportService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i2.ConfigService }]; } });

function handleFileExportError(error, messageService) {
    if (error instanceof ExportNothingToExportError) {
        handleNothingToExportError(messageService);
        return;
    }
    messageService.error('igo.geo.export.failed.text', 'igo.geo.export.failed.title');
}
function handleFileExportSuccess(messageService) {
    messageService.success('igo.geo.export.success.text', 'igo.geo.export.success.title');
}
function handleNothingToExportError(messageService) {
    messageService.error('igo.geo.export.nothing.text', 'igo.geo.export.nothing.title');
}
/**
 * Export array to CSV
 *
 * @param rows Array of arrays to export as CSV
 * @param separator Cell separator
 */
function exportToCSV(rows, fileName, separator = ';') {
    const lines = rows.map((row, index) => row.join(separator));
    const csvContent = lines.join('\n');
    downloadContent(csvContent, 'text/csv;charset=utf-8', fileName);
}
/**
 * Return an array of values from an array of entities.
 *
 * @param entities Array of entities
 * @param scolumns Columns definition of the output data
 */
function entitiesToRowData(entities, columns) {
    return entities.map((entity) => {
        return columns.map((column) => {
            let valueAccessor;
            if (column.renderer === undefined ||
                column.renderer === EntityTableColumnRenderer.Default) {
                valueAccessor = column.valueAccessor;
            }
            valueAccessor = valueAccessor ? valueAccessor : getEntityProperty;
            return valueAccessor(entity, column.name);
        });
    });
}

class ImportError extends Error {
}
class ImportInvalidFileError extends ImportError {
    constructor() {
        super('Invalid file');
        Object.setPrototypeOf(this, ImportInvalidFileError.prototype);
    }
}
class ImportUnreadableFileError extends ImportError {
    constructor() {
        super('Failed to read file');
        Object.setPrototypeOf(this, ImportUnreadableFileError.prototype);
    }
}
class ImportNothingToImportError extends ImportError {
    constructor() {
        super('Nothing to import');
        Object.setPrototypeOf(this, ImportNothingToImportError.prototype);
    }
}
class ImportSizeError extends ImportError {
    constructor() {
        super('File is too large');
        Object.setPrototypeOf(this, ImportNothingToImportError.prototype);
    }
}
class ImportSRSError extends ImportError {
    constructor() {
        super('Invalid SRS definition');
        Object.setPrototypeOf(this, ImportNothingToImportError.prototype);
    }
}
class ImportOgreServerError extends ImportError {
    constructor() {
        super('Error 500 with OGRE');
        Object.setPrototypeOf(this, ImportOgreServerError.prototype);
    }
}

function addLayerAndFeaturesToMap(features, map, contextUri, layerTitle, layerService, storeToIdb = false) {
    const olFeatures = features.map((feature) => featureToOl(feature, map.projection));
    const id = uuid();
    const sourceOptions = {
        id,
        type: 'vector',
        queryable: true
    };
    const source = new FeatureDataSource(sourceOptions);
    source.ol.addFeatures(olFeatures);
    let randomStyle;
    let editable = false;
    if (olFeatures[0].getKeys().includes('_style') ||
        olFeatures[0].getKeys().includes('_mapTitle')) {
        randomStyle = featureRandomStyleFunction();
    }
    else {
        randomStyle = featureRandomStyle();
        editable = true;
    }
    const layer = layerService.createLayer({
        id,
        title: layerTitle,
        workspace: { enabled: true, searchIndexEnabled: true },
        isIgoInternalLayer: true,
        source,
        igoStyle: { editable },
        idbInfo: { firstLoad: true, storeToIdb, contextUri: contextUri || '*' },
        style: randomStyle
    });
    layer.setExtent(computeOlFeaturesExtent(olFeatures, map.viewProjection));
    map.addLayer(layer);
    moveToOlFeatures(map.viewController, olFeatures);
    return layer;
}
function addLayerAndFeaturesStyledToMap(features, map, layerTitle, styleListService, styleService, layerId, imposedSourceOptions, imposedLayerOptions, zoomTo = true) {
    const olFeatures = features.map((feature) => featureToOl(feature, map.projection));
    let style;
    let distance;
    if (styleListService.getStyleList(layerTitle.toString() + '.styleByAttribute')) {
        const styleByAttribute = styleListService.getStyleList(layerTitle.toString() + '.styleByAttribute');
        style = (feature, resolution) => {
            return styleService.createStyleByAttribute(feature, styleByAttribute, resolution);
        };
    }
    else if (styleListService.getStyleList(layerTitle.toString() + '.clusterStyle')) {
        const clusterParam = styleListService.getStyleList(layerTitle.toString() + '.clusterParam');
        distance = styleListService.getStyleList(layerTitle.toString() + '.distance');
        style = (feature, resolution) => {
            const baseStyle = styleService.createStyle(styleListService.getStyleList(layerTitle.toString() + '.clusterStyle'), feature, resolution);
            return styleService.createClusterStyle(feature, resolution, clusterParam, baseStyle);
        };
    }
    else if (styleListService.getStyleList(layerTitle.toString() + '.style')) {
        style = (feature, resolution) => styleService.createStyle(styleListService.getStyleList(layerTitle.toString() + '.style'), feature, resolution);
    }
    else if (styleListService.getStyleList('default.clusterStyle') &&
        features[0].geometry.type === 'Point') {
        const clusterParam = styleListService.getStyleList('default.clusterParam');
        distance = styleListService.getStyleList('default.distance');
        style = (feature, resolution) => {
            const baseStyle = styleService.createStyle(styleListService.getStyleList('default.clusterStyle'), feature, resolution);
            return styleService.createClusterStyle(feature, resolution, clusterParam, baseStyle);
        };
    }
    else {
        style = (feature, resolution) => styleService.createStyle(styleListService.getStyleList('default.style'), feature, resolution);
    }
    let source;
    if (styleListService.getStyleList(layerTitle.toString() + '.clusterStyle')) {
        const sourceOptions = {
            distance,
            type: 'cluster',
            queryable: true
        };
        source = new ClusterDataSource(Object.assign(sourceOptions, imposedSourceOptions));
        source.ol.source.addFeatures(olFeatures);
    }
    else if (styleListService.getStyleList(layerTitle.toString())) {
        const sourceOptions = {
            type: 'vector',
            queryable: true
        };
        source = new FeatureDataSource(Object.assign(sourceOptions, imposedSourceOptions));
        source.ol.addFeatures(olFeatures);
    }
    else if (styleListService.getStyleList('default.clusterStyle') &&
        features[0].geometry.type === 'Point') {
        const sourceOptions = {
            distance,
            type: 'cluster',
            queryable: true
        };
        source = new ClusterDataSource(Object.assign(sourceOptions, imposedSourceOptions));
        source.ol.source.addFeatures(olFeatures);
    }
    else {
        const sourceOptions = {
            type: 'vector',
            queryable: true
        };
        source = new FeatureDataSource(Object.assign(sourceOptions, imposedSourceOptions));
        source.ol.addFeatures(olFeatures);
    }
    const layer = new VectorLayer(Object.assign({
        title: layerTitle,
        id: layerId || uuid(),
        isIgoInternalLayer: true,
        source,
        style
    }, imposedLayerOptions));
    map.addLayer(layer);
    if (zoomTo) {
        moveToOlFeatures(map.viewController, olFeatures);
    }
    return layer;
}
function padTo2Digits(num) {
    return num.toString().padStart(2, '0');
}
function handleFileImportSuccess(file, features, map, contextUri, messageService, layerService, confirmDialogService, styleListService, styleService) {
    if (features.length === 0) {
        handleNothingToImportError(file, messageService);
        return;
    }
    let layerTitle = computeLayerTitleFromFile(file);
    const obs$ = confirmDialogService
        ? confirmDialogService.open('igo.geo.import.promptStoreToIdb')
        : of(false);
    obs$.pipe(first$1()).subscribe((confirm) => {
        const d = new Date();
        const dformat = [
            d.getFullYear(),
            padTo2Digits(d.getMonth() + 1),
            padTo2Digits(d.getDate())
        ].join('/') +
            ' ' +
            [padTo2Digits(d.getHours()), padTo2Digits(d.getMinutes())].join(':');
        layerTitle = confirm ? `${layerTitle} (${dformat})` : layerTitle;
        if (!styleListService) {
            addLayerAndFeaturesToMap(features, map, contextUri, layerTitle, layerService, confirm);
        }
        else {
            addLayerAndFeaturesStyledToMap(features, map, layerTitle, styleListService, styleService);
        }
        messageService.success('igo.geo.dropGeoFile.success.text', 'igo.geo.dropGeoFile.success.title', undefined, { value: layerTitle });
    });
}
function handleFileImportError(file, error, messageService, sizeMb) {
    sizeMb = sizeMb ? sizeMb : 30;
    const errMapping = {
        'Invalid file': handleInvalidFileImportError,
        'File is too large': handleSizeFileImportError,
        'Failed to read file': handleUnreadbleFileImportError,
        'Invalid SRS definition': handleSRSImportError,
        'Error 500 with OGRE': handleOgreServerImportError
    };
    errMapping[error.message](file, error, messageService, sizeMb);
}
function handleInvalidFileImportError(file, error, messageService) {
    messageService.error('igo.geo.dropGeoFile.invalid.text', 'igo.geo.dropGeoFile.invalid.title', undefined, {
        value: file.name,
        mimeType: file.type
    });
}
function handleUnreadbleFileImportError(file, error, messageService) {
    messageService.error('igo.geo.dropGeoFile.unreadable.text', 'igo.geo.dropGeoFile.unreadable.title', undefined, { value: file.name });
}
function handleSizeFileImportError(file, error, messageService, sizeMb) {
    messageService.error('igo.geo.dropGeoFile.tooLarge.text', 'igo.geo.dropGeoFile.tooLarge.title', undefined, {
        value: file.name,
        size: sizeMb
    });
}
function handleNothingToImportError(file, messageService) {
    messageService.error('igo.geo.dropGeoFile.empty.text', 'igo.geo.dropGeoFile.empty.title', undefined, {
        value: file.name,
        mimeType: file.type
    });
}
function handleSRSImportError(file, messageService) {
    messageService.error('igo.geo.dropGeoFile.invalidSRS.text', 'igo.geo.dropGeoFile.invalidSRS.title', undefined, {
        value: file.name,
        mimeType: file.type
    });
}
function handleOgreServerImportError(file, error, messageService) {
    messageService.error('igo.geo.dropGeoFile.ogreServer.text', 'igo.geo.dropGeoFile.ogreServer.title');
}
function getFileExtension(file) {
    return file.name.split('.').pop().toLowerCase();
}
function computeLayerTitleFromFile(file) {
    return file.name.substr(0, file.name.lastIndexOf('.'));
}

class ImportService {
    http;
    config;
    static formatExtensionAssociation = {
        GeoJSON: 'geojson',
        GML: 'gml',
        GPX: 'gpx',
        KML: 'kml',
        Shapefile: 'zip'
    };
    static allowedMimeTypes = [
        'application/gml+xml',
        'application/vnd.google-earth.kml+xml',
        'application/gpx+xml',
        'application/json'
    ];
    static allowedZipMimeTypes = [
        'application/zip',
        'application/x-zip-compressed',
        'application/x-zip'
    ];
    static allowedExtensions = ['geojson', 'kml', 'gpx', 'json', 'gml', 'zip'];
    ogreUrl;
    clientSideFileSizeMax;
    constructor(http, config) {
        this.http = http;
        this.config = config;
        const importConfig = this.config.getConfig('importExport');
        this.ogreUrl = importConfig.url;
        const configFileSizeMb = importConfig.clientSideFileSizeMaxMb;
        this.clientSideFileSizeMax =
            (configFileSizeMb ? configFileSizeMb : 30) * Math.pow(1024, 2);
        if (importConfig.formats) {
            ImportService.allowedExtensions = importConfig.formats
                .map((format) => ImportService.formatExtensionAssociation[format])
                .filter((e) => e);
            if (ImportService.allowedExtensions.includes('geojson')) {
                ImportService.allowedExtensions.push('json');
            }
        }
    }
    import(file, projectionIn = 'EPSG:4326', projectionOut = 'EPSG:4326') {
        return this.importAsync(file, projectionIn, projectionOut);
    }
    getFileImporter(file) {
        const extension = getFileExtension(file);
        const allowedExtensions = ImportService.allowedExtensions;
        let zipMimeTypes = [];
        if (allowedExtensions.includes('zip')) {
            zipMimeTypes = ImportService.allowedZipMimeTypes;
        }
        const mimeType = file.type;
        const allowedMimeTypes = [
            ...ImportService.allowedMimeTypes,
            ...zipMimeTypes
        ];
        if (allowedMimeTypes.indexOf(mimeType) < 0 &&
            allowedExtensions.indexOf(extension) < 0) {
            return undefined;
        }
        else if (mimeType === 'application/json' ||
            ['json', 'geojson', 'kml', 'gpx'].indexOf(extension) >= 0) {
            return this.importFile;
        }
        else if (this.ogreUrl !== undefined) {
            return this.importFileWithOgre;
        }
        return undefined;
    }
    importAsync(file, projectionIn, projectionOut) {
        const doImport = (observer) => {
            if (file.size >= this.clientSideFileSizeMax) {
                observer.error(new ImportSizeError());
                return;
            }
            const importer = this.getFileImporter(file);
            if (importer === undefined) {
                observer.error(new ImportInvalidFileError());
                return;
            }
            importer.call(this, file, observer, projectionIn, projectionOut);
        };
        return new Observable(doImport);
    }
    importFile(file, observer, projectionIn, projectionOut) {
        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const features = this.parseFeaturesFromFile(file, event.target.result, projectionIn, projectionOut);
                observer.next(features);
            }
            catch (e) {
                observer.error(new ImportUnreadableFileError());
            }
            observer.complete();
        };
        reader.onerror = (evt) => {
            observer.error(new ImportUnreadableFileError());
        };
        reader.readAsText(file, 'UTF-8');
    }
    importFileWithOgre(file, observer, projectionIn, projectionOut) {
        const url = `${this.ogreUrl}/convert`;
        const formData = new FormData();
        formData.append('upload', file);
        formData.append('sourceSrs', projectionIn);
        formData.append('targetSrs', projectionOut);
        formData.append('formatOutput', 'GEOJSON');
        formData.append('skipFailures', '');
        this.http.post(url, formData, { headers: new HttpHeaders() }).subscribe((response) => {
            if (response === null) {
                observer.error(new ImportUnreadableFileError());
                return;
            }
            const errors = response.errors || [];
            if (errors.length > 0) {
                observer.error(new ImportUnreadableFileError());
            }
            else {
                const features = this.parseFeaturesFromGeoJSON(file, response, projectionOut);
                observer.next(features);
                observer.complete();
            }
        }, (error) => {
            error.error.caught = true;
            const errMsg = error.error.msg || '';
            if (errMsg === 'No valid files found') {
                observer.error(new ImportInvalidFileError());
            }
            else if (errMsg &&
                errMsg.startWith('ERROR 1: Failed to process SRS definition')) {
                observer.error(new ImportSRSError());
            }
            else if (error.status === 500) {
                observer.error(new ImportOgreServerError());
            }
            else {
                observer.error(new ImportUnreadableFileError());
            }
        });
    }
    parseFeaturesFromFile(file, data, projectionIn, projectionOut) {
        const extension = getFileExtension(file);
        const mimeType = file.type;
        const GeoJSON = new olformat.GeoJSON();
        let format;
        if (mimeType === 'application/vnd.google-earth.kml+xml') {
            format = new olformat.KML();
        }
        else if (mimeType === 'application/gml+xml') {
            format = new olformat.GML();
        }
        else if (mimeType === 'application/gpx+xml') {
            format = new olformat.GPX();
        }
        else {
            switch (extension) {
                case 'kml':
                    format = new olformat.KML();
                    break;
                case 'gpx':
                    format = new olformat.GPX();
                    break;
                case 'gml':
                    format = new olformat.GML();
                    break;
                default:
                    format = GeoJSON;
                    break;
            }
        }
        const olFeatures = format.readFeatures(data, {
            dataProjection: projectionIn,
            featureProjection: projectionOut
        });
        const features = olFeatures.map((olFeature) => {
            return Object.assign(GeoJSON.writeFeatureObject(olFeature), {
                projection: projectionOut,
                meta: {
                    id: uuid(),
                    title: computeLayerTitleFromFile(file)
                }
            });
        });
        return features;
    }
    parseFeaturesFromGeoJSON(file, data, projectionOut) {
        const olFormat = new olformat.GeoJSON();
        const olFeatures = olFormat.readFeatures(data);
        const features = olFeatures.map((olFeature) => {
            return Object.assign(olFormat.writeFeatureObject(olFeature), {
                projection: projectionOut,
                meta: {
                    id: uuid(),
                    title: computeLayerTitleFromFile(file)
                }
            });
        });
        return features;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ImportService, deps: [{ token: i1.HttpClient }, { token: i2.ConfigService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ImportService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ImportService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: i2.ConfigService }]; } });

class ImportExportComponent {
    importService;
    exportService;
    languageService;
    messageService;
    styleListService;
    styleService;
    formBuilder;
    config;
    cdRef;
    storageService;
    downloadService;
    layerService;
    confirmDialogService;
    form;
    importForm;
    formats$ = new BehaviorSubject(undefined);
    encodings$ = new BehaviorSubject(undefined);
    exportableLayers$ = new BehaviorSubject([]);
    loading$ = new BehaviorSubject(false);
    forceNaming = false;
    controlFormat = 'format';
    layers$$;
    exportableLayers$$;
    formats$$;
    encodings$$;
    formLayer$$;
    exportOptions$$;
    importHtmlClarifications;
    exportHtmlClarifications;
    espgCodeRegex = new RegExp('^\\d{4,6}');
    clientSideFileSizeMax;
    fileSizeMb;
    projections$ = new BehaviorSubject([]);
    projectionsConstraints;
    popupChecked = false;
    previousLayerSpecs$ = new BehaviorSubject(undefined);
    selectFirstProj = false;
    map;
    contextUri;
    _projectionsLimitations = {};
    set projectionsLimitations(value) {
        this._projectionsLimitations = value;
        this.computeProjections();
    }
    get projectionsLimitations() {
        return this._projectionsLimitations || {};
    }
    /**
     * Store that holds the available workspaces.
     */
    store;
    selectedMode = 'import';
    selectMode = new EventEmitter();
    exportOptions$ = new BehaviorSubject(undefined);
    exportOptionsChange = new EventEmitter();
    get layers() {
        return this.form.get('layers').value;
    }
    set layers(value) {
        this.form.patchValue({ layers: value });
    }
    get inputProj() {
        return this.importForm.get('inputProj').value;
    }
    set inputProj(value) {
        this.importForm.patchValue({ inputProj: value });
    }
    get popupAllowed() {
        return (this.storageService.get('importExportPopupAllowed') || false);
    }
    set popupAllowed(value) {
        this.storageService.set('importExportPopupAllowed', value);
    }
    constructor(importService, exportService, languageService, messageService, styleListService, styleService, formBuilder, config, cdRef, storageService, downloadService, layerService, confirmDialogService) {
        this.importService = importService;
        this.exportService = exportService;
        this.languageService = languageService;
        this.messageService = messageService;
        this.styleListService = styleListService;
        this.styleService = styleService;
        this.formBuilder = formBuilder;
        this.config = config;
        this.cdRef = cdRef;
        this.storageService = storageService;
        this.downloadService = downloadService;
        this.layerService = layerService;
        this.confirmDialogService = confirmDialogService;
        this.loadConfig();
        this.buildForm();
        this.computeProjections();
        this.importHtmlClarifications = this.languageService.translate.instant('igo.geo.importExportForm.importHtmlClarifications');
        this.exportHtmlClarifications = this.languageService.translate.instant('igo.geo.importExportForm.exportHtmlClarifications');
    }
    ngOnInit() {
        this.layers$$ = this.map.layers$.subscribe((layers) => {
            this.exportableLayers$.next(layers.filter((layer) => {
                return ((layer instanceof VectorLayer && layer.exportable === true) ||
                    (layer.dataSource.options.download &&
                        layer.dataSource.options.download.url));
            }));
        });
        const configFileSizeMb = this.config.getConfig('importExport.clientSideFileSizeMaxMb');
        this.clientSideFileSizeMax =
            (configFileSizeMb ? configFileSizeMb : 30) * Math.pow(1024, 2);
        this.fileSizeMb = this.clientSideFileSizeMax / Math.pow(1024, 2);
        this.exportOptions$$ = this.exportOptions$
            .pipe(skipWhile((exportOptions) => !exportOptions))
            .subscribe((exportOptions) => {
            this.form.patchValue(exportOptions, { emitEvent: true });
            if (exportOptions.layers) {
                this.computeFormats(exportOptions.layers.map((l) => this.map.getLayerById(l)));
            }
        });
        this.formLayer$$ = this.form
            .get('format')
            .valueChanges.subscribe((format) => {
            const ogreFormats = Object.keys(ExportService.ogreFormats);
            if (!this.popupChecked &&
                this.form.get('layers').value?.length > 1 &&
                (ogreFormats.indexOf(format) >= 0 || format === ExportFormat.URL)) {
                if (!this.handlePopup(true)) {
                    this.form.patchValue({ format: undefined }, { emitEvent: false });
                }
            }
        });
        this.formLayer$$ = this.form
            .get('layers')
            .valueChanges.subscribe((layersId) => {
            this.handlePreviousLayerSpecs();
            const selectedLayers = layersId instanceof Array ? layersId : [layersId];
            this.form.patchValue({ layers: selectedLayers }, { emitEvent: false });
            const layers = selectedLayers.map((l) => this.map.getLayerById(l));
            this.computeFormats(layers);
            if (Object.keys(this.formats$.value).indexOf(this.form.value.format) ===
                -1) {
                this.form.patchValue({ format: undefined });
            }
            this.loading$.next(true);
            const previousSpecs = [];
            layers.forEach((layer) => {
                if (layer instanceof VectorLayer &&
                    layer.dataSource.ol.getFeatures().length === 0) {
                    previousSpecs.push({
                        id: layer.id,
                        visible: layer.visible,
                        opacity: layer.opacity,
                        queryable: layer.queryable
                    });
                    layer.opacity = 0;
                    layer.visible = true;
                }
            });
            this.previousLayerSpecs$.next(previousSpecs);
            setTimeout(() => {
                this.loading$.next(false);
            }, 500);
        });
        this.formats$$ = this.formats$
            .pipe(skipWhile((formats) => !formats))
            .subscribe((formats) => {
            if (Object.keys(formats).length === 1) {
                this.form.patchValue({ format: formats[Object.keys(formats)[0]] });
            }
        });
        this.encodings$$ = this.encodings$
            .pipe(skipWhile((encodings) => !encodings))
            .subscribe((encodings) => {
            if (Object.keys(encodings).length === 1) {
                this.form.patchValue({
                    encoding: encodings[Object.keys(encodings)[0]]
                });
            }
        });
        this.exportableLayers$$ = this.exportableLayers$
            .pipe(skipWhile((layers) => !layers))
            .subscribe((layers) => {
            if (layers.length === 1) {
                this.form.patchValue({ layers: layers[0].id });
            }
        });
        this.form.controls[this.controlFormat].valueChanges.subscribe((format) => {
            if (format === ExportFormat.CSVcomma ||
                format === ExportFormat.CSVsemicolon) {
                this.form.patchValue({ encoding: EncodingFormat.LATIN1 });
            }
            else {
                this.form.patchValue({ encoding: EncodingFormat.UTF8 });
            }
            this.cdRef.detectChanges();
        });
        if (this.selectFirstProj) {
            if (this.projections$.value.length === 0) {
                this.importForm.patchValue({
                    inputProj: {
                        translateKey: 'nad83',
                        alias: 'NAD83',
                        code: 'EPSG:4326',
                        zone: ''
                    }
                });
            }
            else {
                this.importForm.patchValue({ inputProj: this.projections$.value[0] });
            }
        }
        else {
            this.importForm.patchValue({ inputProj: undefined });
        }
    }
    computeProjections() {
        this.projectionsConstraints = computeProjectionsConstraints(this.projectionsLimitations);
        const projections = [];
        if (this.projectionsConstraints.nad83) {
            projections.push({
                translateKey: 'nad83',
                alias: 'NAD83',
                code: 'EPSG:4269',
                zone: '',
                extent: undefined,
                def: undefined
            });
        }
        if (this.projectionsConstraints.wgs84) {
            projections.push({
                translateKey: 'wgs84',
                alias: 'WGS84',
                code: 'EPSG:4326',
                zone: '',
                extent: undefined,
                def: undefined
            });
        }
        if (this.projectionsConstraints.webMercator) {
            projections.push({
                translateKey: 'webMercator',
                alias: 'Web Mercator',
                code: 'EPSG:3857',
                zone: '',
                extent: undefined,
                def: undefined
            });
        }
        if (this.projectionsConstraints.mtm) {
            // all mtm zones
            const minZone = this.projectionsConstraints.mtmZone.minZone;
            const maxZone = this.projectionsConstraints.mtmZone.maxZone;
            for (let mtmZone = minZone; mtmZone <= maxZone; mtmZone++) {
                const code = mtmZone < 10 ? `EPSG:3218${mtmZone}` : `EPSG:321${80 + mtmZone}`;
                projections.push({
                    translateKey: 'mtm',
                    alias: `MTM ${mtmZone}`,
                    code,
                    zone: `${mtmZone}`,
                    extent: undefined,
                    def: undefined
                });
            }
        }
        if (this.projectionsConstraints.utm) {
            // all utm zones
            const minZone = this.projectionsConstraints.utmZone.minZone;
            const maxZone = this.projectionsConstraints.utmZone.maxZone;
            for (let utmZone = minZone; utmZone <= maxZone; utmZone++) {
                const code = utmZone < 10 ? `EPSG:3260${utmZone}` : `EPSG:326${utmZone}`;
                projections.push({
                    translateKey: 'utm',
                    alias: `UTM ${utmZone}`,
                    code,
                    zone: `${utmZone}`,
                    extent: undefined,
                    def: undefined
                });
            }
        }
        let configProjection = [];
        if (this.projectionsConstraints.projFromConfig) {
            configProjection = (this.config.getConfig('projections') ||
                []);
        }
        this.projections$.next(configProjection.concat(projections));
    }
    getWorkspaceByLayerId(id) {
        const wksFromLayerId = this.store
            .all()
            .find((workspace) => workspace
            .layer.id === id);
        if (wksFromLayerId) {
            return wksFromLayerId;
        }
        return;
    }
    getLayerTitleById(id) {
        return this.map.getLayerById(id)?.title;
    }
    layerHasSelectedFeatures(layer) {
        const wksFromLayer = this.getWorkspaceByLayerId(layer.id);
        if (wksFromLayer) {
            const recs = wksFromLayer.entityStore.stateView.firstBy((record) => {
                return record.state.selected === true;
            });
            return recs ? true : false;
        }
    }
    onlySelected(event, id) {
        let layersWithSelection = this.form.value.layersWithSelection;
        if (event.checked) {
            layersWithSelection.push(id);
        }
        else {
            layersWithSelection = layersWithSelection.filter((layerId) => layerId !== id);
        }
        this.form.patchValue({ layersWithSelection });
    }
    onlySelectedClick(event, id) {
        if (this.form.value.layers.find((layerId) => layerId === id)) {
            event.stopPropagation();
        }
    }
    inLayersIdToExportSelectionOnly(layer) {
        return this.form.value.layersWithSelection.find((layerId) => layerId === layer.id)
            ? true
            : false;
    }
    ngOnDestroy() {
        this.layers$$.unsubscribe();
        this.exportableLayers$$.unsubscribe();
        this.formats$$.unsubscribe();
        this.encodings$$.unsubscribe();
        this.formLayer$$.unsubscribe();
        if (this.exportOptions$$) {
            this.exportOptions$$.unsubscribe();
        }
        this.exportOptionsChange.emit(this.form.value);
        this.handlePreviousLayerSpecs();
    }
    handlePreviousLayerSpecs() {
        const previousSpecs = this.previousLayerSpecs$.value;
        if (previousSpecs && previousSpecs.length) {
            previousSpecs.forEach((specs) => {
                const previousLayer = this.map.getLayerById(specs.id);
                previousLayer.visible = specs.visible;
                previousLayer.opacity = specs.opacity;
                previousLayer.queryable = specs.queryable;
            });
        }
        this.previousLayerSpecs$.next(undefined);
    }
    importFiles(files) {
        let inputProj = this.inputProj.code;
        if (this.espgCodeRegex.test(inputProj)) {
            inputProj = `EPSG:${inputProj}`;
        }
        this.loading$.next(true);
        for (const file of files) {
            this.importService.import(file, inputProj).subscribe((features) => this.onFileImportSuccess(file, features), (error) => this.onFileImportError(file, error), () => {
                this.loading$.next(false);
            });
        }
    }
    handlePopup(preCheck = true) {
        const p1 = window.open('', 'popup', 'width=1, height=1');
        p1.close();
        const p2 = window.open('', 'popup', 'width=1, height=1');
        if (!p2 || p2.closed || typeof p2.closed === 'undefined' || p2 === null) {
            this.onPopupBlockedError(preCheck);
            this.popupAllowed = false;
        }
        else {
            p2.close();
            this.popupAllowed = true;
            this.popupChecked = true;
        }
        return this.popupAllowed;
    }
    handleExportFormSubmit(data) {
        this.loading$.next(true);
        const ogreFormats = Object.keys(ExportService.ogreFormats);
        if (!this.popupChecked &&
            data.layers.length > 1 &&
            (ogreFormats.indexOf(data.format) >= 0 ||
                data.format === ExportFormat.URL) &&
            !this.popupAllowed) {
            this.handlePopup();
        }
        let geomTypesCSV = [];
        let featuresCSV = [];
        let filename = '';
        for (const [layerIndex, layer] of data.layers.entries()) {
            const lay = this.map.getLayerById(layer);
            if (!(data.format === ExportFormat.CSVsemicolon ||
                data.format === ExportFormat.CSVcomma) ||
                !data.combineLayers ||
                data.layers.length === 1) {
                filename = lay.title;
                if (data.name) {
                    filename = data.name;
                }
            }
            else {
                filename = this.languageService.translate.instant('igo.geo.export.combinedLayers');
            }
            const dSOptions = lay.dataSource.options;
            if (data.format === ExportFormat.URL &&
                dSOptions.download &&
                (dSOptions.download.url || dSOptions.download.dynamicUrl)) {
                setTimeout(() => {
                    // better look an feel
                    const url = dSOptions.download.url || dSOptions.download.dynamicUrl;
                    url.match(/service=wfs/gi)
                        ? this.downloadService.open(lay)
                        : window.open(url, '_blank');
                    this.loading$.next(false);
                }, 500);
                return;
            }
            const wks = this.getWorkspaceByLayerId(layer);
            let olFeatures;
            if (wks && wks.entityStore && wks.entityStore.stateView.all().length) {
                if (data.layersWithSelection.indexOf(layer) !== -1 &&
                    data.featureInMapExtent) {
                    // Only export selected feature && into map extent
                    olFeatures = wks.entityStore.stateView
                        .all()
                        .filter((e) => e.state.inMapExtent && e.state.selected)
                        .map((e) => e.entity.ol);
                }
                else if (data.layersWithSelection.indexOf(layer) !== -1 &&
                    !data.featureInMapExtent) {
                    // Only export selected feature &&  (into map extent OR not)
                    olFeatures = wks.entityStore.stateView
                        .all()
                        .filter((e) => e.state.selected)
                        .map((e) => e.entity.ol);
                }
                else if (data.featureInMapExtent) {
                    // Only into map extent
                    olFeatures = wks.entityStore.stateView
                        .all()
                        .filter((e) => e.state.inMapExtent)
                        .map((e) => e.entity.ol);
                }
                else {
                    // All features
                    olFeatures = wks.entityStore.stateView
                        .all()
                        .map((e) => e.entity.ol);
                }
            }
            else {
                const ol = lay.dataSource.ol;
                if (data.featureInMapExtent) {
                    olFeatures = ol.getFeaturesInExtent(lay.map.viewController.getExtent());
                }
                else {
                    olFeatures = ol.getFeatures();
                }
                if (lay.dataSource instanceof ClusterDataSource) {
                    olFeatures = olFeatures.flatMap((cluster) => cluster.get('features'));
                }
            }
            let geomTypes = [];
            if (data.format === ExportFormat.Shapefile ||
                data.format === ExportFormat.GPX) {
                olFeatures.forEach((olFeature) => {
                    const featureGeomType = olFeature.getGeometry().getType();
                    const currentGeomType = geomTypes.find((geomType) => geomType.geometryType === featureGeomType);
                    if (currentGeomType) {
                        currentGeomType.features.push(olFeature);
                    }
                    else {
                        geomTypes.push({
                            geometryType: featureGeomType,
                            features: [olFeature]
                        });
                    }
                });
            }
            else {
                geomTypes = [{ geometryType: '', features: olFeatures }];
            }
            geomTypes.forEach((geomType) => {
                geomType.features.forEach((feature) => {
                    const radius = feature.get('rad');
                    if (radius) {
                        const center4326 = [
                            feature.get('longitude'),
                            feature.get('latitude')
                        ];
                        const circle = circular(center4326, radius, 500);
                        circle.transform('EPSG:4326', feature.get('_projection'));
                        feature.setGeometry(circle);
                    }
                });
            });
            if (data.format === ExportFormat.GPX) {
                const gpxFeatureCnt = geomTypes.length;
                geomTypes = geomTypes.filter((geomType) => ['LineString', 'Point'].includes(geomType.geometryType));
                const gpxFeatureCntPointOrPoly = geomTypes.length;
                if (gpxFeatureCnt > gpxFeatureCntPointOrPoly) {
                    this.messageService.error('igo.geo.export.gpx.error.poly.text', 'igo.geo.export.gpx.error.poly.title', { timeOut: 20000 });
                }
            }
            else if ((data.format === ExportFormat.CSVsemicolon ||
                data.format === ExportFormat.CSVcomma) &&
                data.combineLayers) {
                geomTypes.forEach((geomType) => geomTypesCSV.push(geomType));
                if (layerIndex !== data.layers.length - 1) {
                    continue;
                }
                else {
                    let previousFeature = undefined;
                    geomTypesCSV.forEach((geomType) => {
                        geomType.features.forEach((currentFeature) => {
                            if (data.separator) {
                                if (previousFeature) {
                                    if (currentFeature.get('_featureStore').layer.options.title !==
                                        previousFeature.get('_featureStore').layer.options.title) {
                                        const titleEmptyRows = this.createTitleEmptyRows(previousFeature, currentFeature);
                                        featuresCSV.push(titleEmptyRows[2]);
                                        featuresCSV.push(titleEmptyRows[0]);
                                        featuresCSV.push(titleEmptyRows[1]);
                                    }
                                }
                                else {
                                    const titleEmptyRows = this.createTitleEmptyRows(currentFeature, currentFeature);
                                    featuresCSV.push(titleEmptyRows[0]);
                                }
                            }
                            featuresCSV.push(currentFeature);
                            previousFeature = currentFeature;
                        });
                    });
                }
            }
            if (geomTypes.length === 0) {
                this.loading$.next(false);
                this.messageService.error('igo.geo.export.nothing.text', 'igo.geo.export.nothing.title', { timeOut: 20000 });
            }
            else {
                if (!(data.format === ExportFormat.CSVsemicolon ||
                    data.format === ExportFormat.CSVcomma) ||
                    !data.combineLayers) {
                    geomTypes.map((geomType) => this.exportService
                        .export(geomType.features, data.format, filename + geomType.geometryType, data.encoding, this.map.projection)
                        .subscribe(() => { }, (error) => this.onFileExportError(error), () => {
                        this.onFileExportSuccess();
                        geomType.features.forEach((feature) => {
                            this.circleToPoint(feature);
                        });
                        this.loading$.next(false);
                    }));
                }
            }
        }
        if ((data.format === ExportFormat.CSVsemicolon ||
            data.format === ExportFormat.CSVcomma) &&
            data.combineLayers) {
            this.exportService
                .export(featuresCSV, data.format, filename, data.encoding, this.map.projection)
                .subscribe(() => { }, (error) => this.onFileExportError(error), () => {
                this.onFileExportSuccess();
                featuresCSV.forEach((feature) => {
                    this.circleToPoint(feature);
                });
                this.loading$.next(false);
            });
        }
    }
    createTitleEmptyRows(previousFeature, currentFeature) {
        const titleRow = currentFeature.clone();
        const headerRow = currentFeature.clone();
        const emptyRow = currentFeature.clone();
        const previousFeatureKeys = previousFeature.getKeys();
        let firstKeyPrevious = '';
        for (const key in previousFeatureKeys) {
            if (previousFeatureKeys[key] !== 'geometry') {
                firstKeyPrevious = previousFeatureKeys[key];
                break;
            }
        }
        const currentFeatureKeys = currentFeature.getKeys();
        let firstKeyCurrent = '';
        for (const key in currentFeatureKeys) {
            if (currentFeatureKeys[key] !== 'geometry') {
                firstKeyCurrent = currentFeatureKeys[key];
                break;
            }
        }
        const allKeys = currentFeature.getKeys();
        previousFeatureKeys.forEach((previousKey) => {
            if (allKeys.includes(previousKey) && previousKey !== firstKeyPrevious) {
                allKeys.push(previousKey);
            }
        });
        allKeys.unshift(firstKeyPrevious);
        let firstKeyAll = '';
        for (const key in allKeys) {
            if (allKeys[key] !== 'geometry') {
                firstKeyAll = allKeys[key];
                break;
            }
        }
        allKeys.forEach((key) => {
            const sameKeys = previousFeatureKeys.length === currentFeatureKeys.length &&
                previousFeatureKeys.every((value, index) => value === currentFeatureKeys[index]);
            if (key === firstKeyAll && !sameKeys) {
                titleRow.set(key, currentFeature.get('_featureStore').layer.options.title +
                    ' ===============>', true);
                headerRow.set(key, key, true);
                emptyRow.unset(key, true);
            }
            else if (key === firstKeyAll && sameKeys) {
                titleRow.set(key, currentFeature.get('_featureStore').layer.options.title, true);
                headerRow.set(key, key, true);
                emptyRow.unset(key, true);
            }
            else if (key === firstKeyCurrent) {
                titleRow.set(key, currentFeature.get('_featureStore').layer.options.title, true);
                headerRow.set(key, key, true);
                emptyRow.unset(key, true);
            }
            else if (key !== 'geometry') {
                titleRow.unset(key, true);
                headerRow.set(key, key, true);
                emptyRow.unset(key, true);
            }
            else {
                titleRow.unset(key, true);
                emptyRow.unset(key, true);
            }
            if (!currentFeatureKeys.includes(key)) {
                headerRow.unset(key, true);
            }
        });
        const titleEmptyRows = [titleRow, headerRow, emptyRow];
        return titleEmptyRows;
    }
    circleToPoint(feature) {
        const radius = feature.get('rad');
        if (radius) {
            const point = new OlPoint([
                feature.get('longitude'),
                feature.get('latitude')
            ]);
            point.transform('EPSG:4326', feature.get('_projection'));
            feature.setGeometry(point);
        }
    }
    buildForm() {
        this.importForm = this.formBuilder.group({
            inputProj: ['', [Validators.required]]
        });
        if (this.forceNaming) {
            this.form = this.formBuilder.group({
                format: ['', [Validators.required]],
                layers: [[], [Validators.required]],
                layersWithSelection: [[]],
                encoding: [EncodingFormat.UTF8, [Validators.required]],
                combineLayers: [true, [Validators.required]],
                separator: [false, [Validators.required]],
                featureInMapExtent: [false, [Validators.required]],
                name: ['', [Validators.required]]
            });
        }
        else {
            this.form = this.formBuilder.group({
                format: ['', [Validators.required]],
                layers: [[], [Validators.required]],
                layersWithSelection: [[]],
                encoding: [EncodingFormat.UTF8, [Validators.required]],
                combineLayers: [true, [Validators.required]],
                separator: [false, [Validators.required]],
                featureInMapExtent: [false, [Validators.required]]
            });
        }
    }
    onFileImportSuccess(file, features) {
        const importExportOptions = this.config.getConfig('importExport');
        const confirmDialogService = importExportOptions?.allowToStoreLayer
            ? this.confirmDialogService
            : undefined;
        if (!importExportOptions?.importWithStyle) {
            handleFileImportSuccess(file, features, this.map, this.contextUri, this.messageService, this.layerService, confirmDialogService);
        }
        else {
            handleFileImportSuccess(file, features, this.map, this.contextUri, this.messageService, this.layerService, confirmDialogService, this.styleListService, this.styleService);
        }
    }
    onFileImportError(file, error) {
        this.loading$.next(false);
        handleFileImportError(file, error, this.messageService, this.fileSizeMb);
    }
    onPopupBlockedError(preCheck = true) {
        this.loading$.next(false);
        const extraMessage = preCheck
            ? 'igo.geo.export.popupBlocked.selectAgain'
            : 'igo.geo.export.popupBlocked.retry';
        this.messageService.error('igo.geo.export.popupBlocked.text', 'igo.geo.export.popupBlocked.title', { timeOut: 20000 }, { extraMessage });
    }
    onFileExportError(error) {
        this.loading$.next(false);
        handleFileExportError(error, this.messageService);
    }
    loadConfig() {
        const forceNamingConfig = this.config.getConfig('importExport.forceNaming');
        this.forceNaming =
            forceNamingConfig !== undefined ? forceNamingConfig : false;
        this.computeFormats();
        this.loadEncodings();
    }
    encodingDefaultValue(format) {
        if (format === ExportFormat.CSVcomma ||
            format === ExportFormat.CSVsemicolon) {
            this.form.patchValue({ encoding: EncodingFormat.LATIN1 });
            return EncodingFormat.LATIN1;
        }
        else {
            this.form.patchValue({ encoding: EncodingFormat.UTF8 });
            return EncodingFormat.UTF8;
        }
    }
    loadEncodings() {
        this.encodings$.next(EncodingFormat);
    }
    computeFormats(layers) {
        let appliedformats = Object.keys(ExportFormat);
        const formatsType = {
            onlyUrl: false,
            onlyVector: false,
            vectorAndUrl: false,
            customList: false
        };
        const customList = [];
        if (layers && layers.length) {
            layers.forEach((layer) => {
                if (!layer) {
                    return;
                }
                if (layer.dataSource.options.download?.allowedFormats) {
                    formatsType.customList = true;
                    customList.push({
                        layer: layer.title,
                        formats: this.validateListFormat(layer.dataSource.options.download.allowedFormats)
                    });
                }
                else if (!(layer instanceof VectorLayer) &&
                    layer.dataSource.options.download &&
                    layer.dataSource.options.download.url) {
                    formatsType.onlyUrl = true;
                }
                else if (layer.dataSource.options.download &&
                    (layer.dataSource.options.download.url ||
                        layer.dataSource.options.download.dynamicUrl)) {
                    formatsType.vectorAndUrl = true;
                }
                else if (layer instanceof VectorLayer) {
                    formatsType.onlyVector = true;
                }
            });
            if (formatsType.onlyUrl === true && formatsType.onlyVector === false) {
                appliedformats = ['URL'];
            }
            else if (formatsType.onlyVector === true &&
                formatsType.onlyUrl === false) {
                this.computeFormats(); // reset
                if (ExportFormat.URL in this.formats$.value) {
                    const keys = Object.keys(this.formats$.value).filter((key) => key !== 'URL');
                    appliedformats = keys;
                }
            }
            else if (formatsType.vectorAndUrl === true &&
                formatsType.onlyUrl === false &&
                formatsType.onlyVector === false) {
                this.computeFormats(); // reset
                if (!(ExportFormat.URL in this.formats$.value)) {
                    const keys = Object.keys(this.formats$.value);
                    keys.push('URL');
                    appliedformats = keys;
                }
            }
        }
        const configImportExportFormats = this.config.getConfig('importExport.formats');
        if (configImportExportFormats) {
            const validatedListFormat = this.validateListFormat(configImportExportFormats);
            appliedformats = appliedformats.filter((af) => validatedListFormat.includes(af));
        }
        if (formatsType.customList) {
            let commonFormats;
            const layersWithCustomFormats = [];
            let previousCustomListFormats = customList[0].formats;
            customList.map((list) => {
                layersWithCustomFormats.push(list.layer);
                commonFormats = list.formats.filter((value) => previousCustomListFormats.includes(value));
                previousCustomListFormats = list.formats;
            });
            const finalFormats = commonFormats.filter((value) => appliedformats.includes(value));
            if (finalFormats.length > 0) {
                this.formats$.next(strEnum(finalFormats));
                if (layers && layers.length) {
                    if (layers.length > 1) {
                        this.messageService.alert('igo.geo.export.customList.text', 'igo.geo.export.customList.title', undefined, { value: layersWithCustomFormats.join() });
                    }
                }
            }
            else {
                this.formats$.next([]);
                this.messageService.alert('igo.geo.export.noFormat.text', 'igo.geo.export.noFormat.title');
            }
            return;
        }
        else {
            this.formats$.next(strEnum(appliedformats));
        }
    }
    validateListFormat(formats) {
        return formats
            .filter((format) => {
            if (format.toUpperCase() === ExportFormat.CSVcomma.toUpperCase() ||
                format.toUpperCase() === ExportFormat.CSVsemicolon.toUpperCase() ||
                format.toUpperCase() === ExportFormat.GML.toUpperCase() ||
                format.toUpperCase() === ExportFormat.GPX.toUpperCase() ||
                format.toUpperCase() === ExportFormat.GeoJSON.toUpperCase() ||
                format.toUpperCase() === ExportFormat.KML.toUpperCase() ||
                format.toUpperCase() === ExportFormat.Shapefile.toUpperCase() ||
                format.toUpperCase() === ExportFormat.URL.toUpperCase()) {
                return format;
            }
        })
            .map((format) => {
            if (format.toUpperCase() === ExportFormat.CSVcomma.toUpperCase()) {
                format = ExportFormat.CSVcomma;
                return format;
            }
            if (format.toUpperCase() === ExportFormat.CSVsemicolon.toUpperCase()) {
                format = ExportFormat.CSVsemicolon;
                return format;
            }
            if (format.toUpperCase() === ExportFormat.GML.toUpperCase()) {
                format = ExportFormat.GML;
                return format;
            }
            if (format.toUpperCase() === ExportFormat.GPX.toUpperCase()) {
                format = ExportFormat.GPX;
                return format;
            }
            if (format.toUpperCase() === ExportFormat.GeoJSON.toUpperCase()) {
                format = ExportFormat.GeoJSON;
                return format;
            }
            if (format.toUpperCase() === ExportFormat.KML.toUpperCase()) {
                format = ExportFormat.KML;
                return format;
            }
            if (format.toUpperCase() === ExportFormat.Shapefile.toUpperCase()) {
                format = ExportFormat.Shapefile;
                return format;
            }
            if (format.toUpperCase() === ExportFormat.URL.toUpperCase()) {
                format = ExportFormat.URL;
                return format;
            }
        });
    }
    modeChanged(mode) {
        this.selectMode.emit(mode);
    }
    onFileExportSuccess() {
        handleFileExportSuccess(this.messageService);
    }
    onImportExportChange(event) {
        this.selectedMode = event.value;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ImportExportComponent, deps: [{ token: ImportService }, { token: ExportService }, { token: i2.LanguageService }, { token: i2.MessageService }, { token: StyleListService }, { token: StyleService }, { token: i2$1.UntypedFormBuilder }, { token: i2.ConfigService }, { token: i0.ChangeDetectorRef }, { token: i2.StorageService }, { token: DownloadService }, { token: LayerService }, { token: i9$1.ConfirmDialogService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: ImportExportComponent, selector: "igo-import-export", inputs: { selectFirstProj: "selectFirstProj", map: "map", contextUri: "contextUri", projectionsLimitations: "projectionsLimitations", store: "store", selectedMode: "selectedMode", exportOptions$: "exportOptions$" }, outputs: { selectMode: "selectMode", exportOptionsChange: "exportOptionsChange" }, ngImport: i0, template: "<div class=\"import-export-toggle mat-typography\">\r\n  <mat-button-toggle-group\r\n    [value]=\"selectedMode\"\r\n    (change)=\"onImportExportChange($event)\"\r\n  >\r\n    <mat-button-toggle [value]=\"'import'\">\r\n      {{ 'igo.geo.importExportForm.importTabTitle' | translate }}\r\n    </mat-button-toggle>\r\n    <mat-button-toggle [value]=\"'export'\">\r\n      {{ 'igo.geo.importExportForm.exportTabTitle' | translate }}\r\n    </mat-button-toggle>\r\n  </mat-button-toggle-group>\r\n</div>\r\n\r\n<form\r\n  class=\"igo-form\"\r\n  [formGroup]=\"importForm\"\r\n  *ngIf=\"selectedMode === 'import'\"\r\n>\r\n  <div class=\"igo-input-container\">\r\n    <mat-form-field>\r\n      <mat-label>{{\r\n        'igo.geo.importExportForm.importProjPlaceholder' | translate\r\n      }}</mat-label>\r\n      <mat-select [(value)]=\"inputProj\">\r\n        <mat-option\r\n          *ngFor=\"let projection of projections$ | async\"\r\n          [value]=\"projection\"\r\n          (click)=\"$event.stopPropagation()\"\r\n        >\r\n          <p matListItemTitle *ngIf=\"projection.translateKey\">\r\n            {{\r\n              'igo.geo.importExportForm.projections.' + projection.translateKey\r\n                | translate: projection\r\n            }}\r\n          </p>\r\n          <p matListItemTitle *ngIf=\"!projection.translateKey\">\r\n            {{ projection.alias }}\r\n          </p>\r\n        </mat-option>\r\n      </mat-select>\r\n    </mat-form-field>\r\n  </div>\r\n\r\n  <div\r\n    tooltip-position=\"below\"\r\n    matTooltipShowDelay=\"500\"\r\n    [matTooltip]=\"\r\n      importForm.invalid\r\n        ? ('igo.geo.importExportForm.projections.choose' | translate)\r\n        : ('igo.geo.importExportForm.importButton' | translate)\r\n    \"\r\n    class=\"igo-form-button-group\"\r\n  >\r\n    <button\r\n      [disabled]=\"importForm.invalid || (loading$ | async)\"\r\n      mat-raised-button\r\n      type=\"button\"\r\n      (click)=\"fileInput.click()\"\r\n    >\r\n      {{ 'igo.geo.importExportForm.importButton' | translate }}\r\n    </button>\r\n    <igo-spinner [shown]=\"loading$ | async\"></igo-spinner>\r\n    <input\r\n      hidden\r\n      #fileInput\r\n      type=\"file\"\r\n      [style.display]=\"'none'\"\r\n      (click)=\"fileInput.value = null\"\r\n      (change)=\"importFiles($event.target.files)\"\r\n    />\r\n  </div>\r\n</form>\r\n<section class=\"mat-typography\" *ngIf=\"selectedMode === 'import'\">\r\n  <div *ngIf=\"importHtmlClarifications === ''\">\r\n    <h4>{{ 'igo.geo.importExportForm.importClarifications' | translate }}</h4>\r\n    <ul>\r\n      <li>\r\n        {{\r\n          'igo.geo.importExportForm.importSizeMax'\r\n            | translate: { size: fileSizeMb }\r\n        }}\r\n      </li>\r\n      <li>\r\n        {{ 'igo.geo.importExportForm.importFormatAuthorized' | translate }}\r\n      </li>\r\n      <li>{{ 'igo.geo.importExportForm.importShpZip' | translate }}</li>\r\n    </ul>\r\n  </div>\r\n  <igo-custom-html\r\n    *ngIf=\"importHtmlClarifications !== ''\"\r\n    class=\"mat-typography\"\r\n    [html]=\"importHtmlClarifications\"\r\n  >\r\n  </igo-custom-html>\r\n</section>\r\n\r\n<section\r\n  class=\"mat-typography\"\r\n  *ngIf=\"(exportableLayers$ | async).length === 0 && selectedMode === 'export'\"\r\n>\r\n  <h4>{{ 'igo.geo.importExportForm.exportNoLayersExportable' | translate }}</h4>\r\n</section>\r\n\r\n<form\r\n  class=\"igo-form\"\r\n  [formGroup]=\"form\"\r\n  *ngIf=\"(exportableLayers$ | async).length > 0 && selectedMode === 'export'\"\r\n>\r\n  <div class=\"igo-input-container\">\r\n    <mat-form-field>\r\n      <mat-label>{{\r\n        'igo.geo.importExportForm.exportLayerPlaceholder' | translate\r\n      }}</mat-label>\r\n      <mat-select [(value)]=\"layers\" multiple>\r\n        <mat-select-trigger>\r\n          {{ layers.length ? getLayerTitleById(layers[0]) : '' }}\r\n          <span *ngIf=\"layers.length > 1\" class=\"export-select-trigger\">\r\n            (+{{ layers.length - 1 }}\r\n            {{\r\n              (layers?.length === 2\r\n                ? 'igo.geo.importExportForm.other'\r\n                : 'igo.geo.importExportForm.others'\r\n              ) | translate\r\n            }})\r\n          </span>\r\n        </mat-select-trigger>\r\n        <mat-option\r\n          *ngFor=\"let layer of exportableLayers$ | async\"\r\n          [ngClass]=\"{\r\n            'igo-export-layer-mat-option': layerHasSelectedFeatures(layer)\r\n          }\"\r\n          [value]=\"layer.id\"\r\n          (click)=\"$event.stopPropagation()\"\r\n        >\r\n          <p matListItemTitle>{{ layer.title }}</p>\r\n          <p matListItemTitle>\r\n            <mat-slide-toggle\r\n              *ngIf=\"layerHasSelectedFeatures(layer)\"\r\n              (click)=\"onlySelectedClick($event, layer.id)\"\r\n              (checked)=\"inLayersIdToExportSelectionOnly(layer)\"\r\n              (change)=\"onlySelected($event, layer.id)\"\r\n            >\r\n              <small>{{\r\n                'igo.geo.importExportForm.exportSelectedFeature' | translate\r\n              }}</small>\r\n            </mat-slide-toggle>\r\n          </p>\r\n        </mat-option>\r\n      </mat-select>\r\n    </mat-form-field>\r\n  </div>\r\n\r\n  <div class=\"igo-input-container\">\r\n    <mat-form-field>\r\n      <mat-label>{{\r\n        'igo.geo.importExportForm.exportFormatPlaceholder' | translate\r\n      }}</mat-label>\r\n      <mat-select formControlName=\"format\">\r\n        <ng-container *ngIf=\"(formats$ | async).length !== 0\">\r\n          <mat-option\r\n            *ngFor=\"let format of formats$ | async | keyvalue\"\r\n            [value]=\"format.key\"\r\n          >\r\n            {{ 'igo.geo.export.format.' + format.value | translate }}\r\n          </mat-option>\r\n        </ng-container>\r\n        <mat-option *ngIf=\"(formats$ | async).length === 0\" disabled=\"true\">\r\n          {{ 'igo.geo.export.noFormat.title' | translate }}\r\n        </mat-option>\r\n      </mat-select>\r\n    </mat-form-field>\r\n  </div>\r\n\r\n  <div\r\n    class=\"igo-input-container\"\r\n    *ngIf=\"forceNaming && form.value.format !== 'URL'\"\r\n  >\r\n    <mat-form-field>\r\n      <input\r\n        matInput\r\n        formControlName=\"name\"\r\n        placeholder=\"{{\r\n          'igo.geo.importExportForm.exportFileNamePlaceholder' | translate\r\n        }}\"\r\n      />\r\n    </mat-form-field>\r\n  </div>\r\n\r\n  <div\r\n    class=\"igo-input-container\"\r\n    *ngIf=\"\r\n      form.value.format === 'CSVcomma' || form.value.format === 'CSVsemicolon'\r\n    \"\r\n  >\r\n    <mat-form-field>\r\n      <mat-label>{{\r\n        'igo.geo.importExportForm.encodingPlaceholder' | translate\r\n      }}</mat-label>\r\n      <mat-select formControlName=\"encoding\">\r\n        <ng-container *ngIf=\"(encodings$ | async).length !== 0\">\r\n          <mat-option\r\n            *ngFor=\"let encoding of encodings$ | async | keyvalue\"\r\n            [value]=\"encoding.key\"\r\n          >\r\n            {{ 'igo.geo.export.encoding.' + encoding.value | translate }}\r\n          </mat-option>\r\n        </ng-container>\r\n      </mat-select>\r\n    </mat-form-field>\r\n  </div>\r\n\r\n  <div\r\n    class=\"export-combine-layers mat-typography\"\r\n    *ngIf=\"\r\n      layers.length > 1 &&\r\n      (form.value.format === 'CSVcomma' || form.value.format === 'CSVsemicolon')\r\n    \"\r\n  >\r\n    <mat-slide-toggle\r\n      formControlName=\"combineLayers\"\r\n      [labelPosition]=\"'before'\"\r\n    >\r\n      {{ 'igo.geo.importExportForm.exportCombineResults' | translate }}\r\n    </mat-slide-toggle>\r\n  </div>\r\n\r\n  <div\r\n    class=\"export-separator mat-typography\"\r\n    *ngIf=\"\r\n      layers.length > 1 &&\r\n      (form.value.format === 'CSVcomma' ||\r\n        form.value.format === 'CSVsemicolon') &&\r\n      form.value.combineLayers\r\n    \"\r\n  >\r\n    <mat-slide-toggle formControlName=\"separator\" [labelPosition]=\"'before'\">\r\n      {{ 'igo.geo.importExportForm.exportSeparator' | translate }}\r\n    </mat-slide-toggle>\r\n  </div>\r\n\r\n  <div\r\n    class=\"export-options mat-typography\"\r\n    *ngIf=\"form.value.format !== 'URL'\"\r\n  >\r\n    <mat-slide-toggle\r\n      formControlName=\"featureInMapExtent\"\r\n      [labelPosition]=\"'before'\"\r\n    >\r\n      {{ 'igo.geo.importExportForm.exportFeatureInExtent' | translate }}\r\n    </mat-slide-toggle>\r\n  </div>\r\n\r\n  <div class=\"igo-form-button-group\">\r\n    <button\r\n      mat-raised-button\r\n      type=\"button\"\r\n      [disabled]=\"!form.valid || (loading$ | async)\"\r\n      (click)=\"handleExportFormSubmit(form.value)\"\r\n    >\r\n      {{\r\n        form.value.format !== 'URL'\r\n          ? ('igo.geo.importExportForm.exportButton' | translate)\r\n          : form.value.layers.length > 1\r\n          ? ('igo.geo.importExportForm.exportButtonLinks' | translate)\r\n          : ('igo.geo.importExportForm.exportButtonLink' | translate)\r\n      }}\r\n    </button>\r\n    <igo-spinner [shown]=\"loading$ | async\"></igo-spinner>\r\n  </div>\r\n\r\n  <igo-custom-html\r\n    *ngIf=\"exportHtmlClarifications !== ''\"\r\n    class=\"mat-typography\"\r\n    [html]=\"exportHtmlClarifications\"\r\n  >\r\n  </igo-custom-html>\r\n</form>\r\n", styles: [":host mat-option.igo-export-layer-mat-option{height:5em;line-height:1em}:host .import-export-toggle{padding:10px;text-align:center}:host .import-export-toggle mat-button-toggle-group{width:100%}:host .import-export-toggle mat-button-toggle-group mat-button-toggle{width:50%}:host h4{padding:0 5px}:host .igo-form{padding:15px 5px}:host .igo-input-container mat-form-field{width:100%}:host .igo-form-button-group{text-align:center;padding-top:10px}:host igo-spinner{position:absolute;padding-left:10px}:host .export-options mat-slide-toggle,:host .export-combine-layers mat-slide-toggle,:host .export-separator mat-slide-toggle{width:100%;padding:10px}:host .export-options mat-slide-toggle ::ng-deep .mdc-form-field,:host .export-combine-layers mat-slide-toggle ::ng-deep .mdc-form-field,:host .export-separator mat-slide-toggle ::ng-deep .mdc-form-field{width:100%}:host .export-options mat-slide-toggle ::ng-deep .mdc-label,:host .export-combine-layers mat-slide-toggle ::ng-deep .mdc-label,:host .export-separator mat-slide-toggle ::ng-deep .mdc-label{margin-left:0;width:calc(100% - 60px)}:host .export-select-trigger{opacity:.75;font-size:.75em}\n"], dependencies: [{ kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "directive", type: i2$1.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { kind: "directive", type: i2$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i2$1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "directive", type: i2$1.FormControlName, selector: "[formControlName]", inputs: ["formControlName", "disabled", "ngModel"], outputs: ["ngModelChange"] }, { kind: "directive", type: i2$2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i4$1.MatButton, selector: "    button[mat-button], button[mat-raised-button], button[mat-flat-button],    button[mat-stroked-button]  ", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "directive", type: i5$1.MatButtonToggleGroup, selector: "mat-button-toggle-group", inputs: ["appearance", "name", "vertical", "value", "multiple", "disabled"], outputs: ["valueChange", "change"], exportAs: ["matButtonToggleGroup"] }, { kind: "component", type: i5$1.MatButtonToggle, selector: "mat-button-toggle", inputs: ["disableRipple", "aria-label", "aria-labelledby", "id", "name", "value", "tabIndex", "appearance", "checked", "disabled"], outputs: ["change"], exportAs: ["matButtonToggle"] }, { kind: "component", type: i8.MatFormField, selector: "mat-form-field", inputs: ["hideRequiredMarker", "color", "floatLabel", "appearance", "subscriptSizing", "hintLabel"], exportAs: ["matFormField"] }, { kind: "directive", type: i8.MatLabel, selector: "mat-label" }, { kind: "component", type: i15.MatSelect, selector: "mat-select", inputs: ["disabled", "disableRipple", "tabIndex", "panelWidth", "hideSingleSelectionIndicator"], exportAs: ["matSelect"] }, { kind: "directive", type: i15.MatSelectTrigger, selector: "mat-select-trigger" }, { kind: "component", type: i9.MatOption, selector: "mat-option", exportAs: ["matOption"] }, { kind: "directive", type: i9$3.MatInput, selector: "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", inputs: ["disabled", "id", "placeholder", "name", "required", "type", "errorStateMatcher", "aria-describedby", "value", "readonly"], exportAs: ["matInput"] }, { kind: "component", type: i7.MatSlideToggle, selector: "mat-slide-toggle", inputs: ["disabled", "disableRipple", "color", "tabIndex"], exportAs: ["matSlideToggle"] }, { kind: "component", type: i9$1.SpinnerComponent, selector: "igo-spinner", inputs: ["shown"] }, { kind: "component", type: i9$1.CustomHtmlComponent, selector: "igo-custom-html", inputs: ["html"] }, { kind: "pipe", type: i2$2.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }, { kind: "pipe", type: i9$1.KeyValuePipe, name: "keyvalue" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ImportExportComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-import-export', template: "<div class=\"import-export-toggle mat-typography\">\r\n  <mat-button-toggle-group\r\n    [value]=\"selectedMode\"\r\n    (change)=\"onImportExportChange($event)\"\r\n  >\r\n    <mat-button-toggle [value]=\"'import'\">\r\n      {{ 'igo.geo.importExportForm.importTabTitle' | translate }}\r\n    </mat-button-toggle>\r\n    <mat-button-toggle [value]=\"'export'\">\r\n      {{ 'igo.geo.importExportForm.exportTabTitle' | translate }}\r\n    </mat-button-toggle>\r\n  </mat-button-toggle-group>\r\n</div>\r\n\r\n<form\r\n  class=\"igo-form\"\r\n  [formGroup]=\"importForm\"\r\n  *ngIf=\"selectedMode === 'import'\"\r\n>\r\n  <div class=\"igo-input-container\">\r\n    <mat-form-field>\r\n      <mat-label>{{\r\n        'igo.geo.importExportForm.importProjPlaceholder' | translate\r\n      }}</mat-label>\r\n      <mat-select [(value)]=\"inputProj\">\r\n        <mat-option\r\n          *ngFor=\"let projection of projections$ | async\"\r\n          [value]=\"projection\"\r\n          (click)=\"$event.stopPropagation()\"\r\n        >\r\n          <p matListItemTitle *ngIf=\"projection.translateKey\">\r\n            {{\r\n              'igo.geo.importExportForm.projections.' + projection.translateKey\r\n                | translate: projection\r\n            }}\r\n          </p>\r\n          <p matListItemTitle *ngIf=\"!projection.translateKey\">\r\n            {{ projection.alias }}\r\n          </p>\r\n        </mat-option>\r\n      </mat-select>\r\n    </mat-form-field>\r\n  </div>\r\n\r\n  <div\r\n    tooltip-position=\"below\"\r\n    matTooltipShowDelay=\"500\"\r\n    [matTooltip]=\"\r\n      importForm.invalid\r\n        ? ('igo.geo.importExportForm.projections.choose' | translate)\r\n        : ('igo.geo.importExportForm.importButton' | translate)\r\n    \"\r\n    class=\"igo-form-button-group\"\r\n  >\r\n    <button\r\n      [disabled]=\"importForm.invalid || (loading$ | async)\"\r\n      mat-raised-button\r\n      type=\"button\"\r\n      (click)=\"fileInput.click()\"\r\n    >\r\n      {{ 'igo.geo.importExportForm.importButton' | translate }}\r\n    </button>\r\n    <igo-spinner [shown]=\"loading$ | async\"></igo-spinner>\r\n    <input\r\n      hidden\r\n      #fileInput\r\n      type=\"file\"\r\n      [style.display]=\"'none'\"\r\n      (click)=\"fileInput.value = null\"\r\n      (change)=\"importFiles($event.target.files)\"\r\n    />\r\n  </div>\r\n</form>\r\n<section class=\"mat-typography\" *ngIf=\"selectedMode === 'import'\">\r\n  <div *ngIf=\"importHtmlClarifications === ''\">\r\n    <h4>{{ 'igo.geo.importExportForm.importClarifications' | translate }}</h4>\r\n    <ul>\r\n      <li>\r\n        {{\r\n          'igo.geo.importExportForm.importSizeMax'\r\n            | translate: { size: fileSizeMb }\r\n        }}\r\n      </li>\r\n      <li>\r\n        {{ 'igo.geo.importExportForm.importFormatAuthorized' | translate }}\r\n      </li>\r\n      <li>{{ 'igo.geo.importExportForm.importShpZip' | translate }}</li>\r\n    </ul>\r\n  </div>\r\n  <igo-custom-html\r\n    *ngIf=\"importHtmlClarifications !== ''\"\r\n    class=\"mat-typography\"\r\n    [html]=\"importHtmlClarifications\"\r\n  >\r\n  </igo-custom-html>\r\n</section>\r\n\r\n<section\r\n  class=\"mat-typography\"\r\n  *ngIf=\"(exportableLayers$ | async).length === 0 && selectedMode === 'export'\"\r\n>\r\n  <h4>{{ 'igo.geo.importExportForm.exportNoLayersExportable' | translate }}</h4>\r\n</section>\r\n\r\n<form\r\n  class=\"igo-form\"\r\n  [formGroup]=\"form\"\r\n  *ngIf=\"(exportableLayers$ | async).length > 0 && selectedMode === 'export'\"\r\n>\r\n  <div class=\"igo-input-container\">\r\n    <mat-form-field>\r\n      <mat-label>{{\r\n        'igo.geo.importExportForm.exportLayerPlaceholder' | translate\r\n      }}</mat-label>\r\n      <mat-select [(value)]=\"layers\" multiple>\r\n        <mat-select-trigger>\r\n          {{ layers.length ? getLayerTitleById(layers[0]) : '' }}\r\n          <span *ngIf=\"layers.length > 1\" class=\"export-select-trigger\">\r\n            (+{{ layers.length - 1 }}\r\n            {{\r\n              (layers?.length === 2\r\n                ? 'igo.geo.importExportForm.other'\r\n                : 'igo.geo.importExportForm.others'\r\n              ) | translate\r\n            }})\r\n          </span>\r\n        </mat-select-trigger>\r\n        <mat-option\r\n          *ngFor=\"let layer of exportableLayers$ | async\"\r\n          [ngClass]=\"{\r\n            'igo-export-layer-mat-option': layerHasSelectedFeatures(layer)\r\n          }\"\r\n          [value]=\"layer.id\"\r\n          (click)=\"$event.stopPropagation()\"\r\n        >\r\n          <p matListItemTitle>{{ layer.title }}</p>\r\n          <p matListItemTitle>\r\n            <mat-slide-toggle\r\n              *ngIf=\"layerHasSelectedFeatures(layer)\"\r\n              (click)=\"onlySelectedClick($event, layer.id)\"\r\n              (checked)=\"inLayersIdToExportSelectionOnly(layer)\"\r\n              (change)=\"onlySelected($event, layer.id)\"\r\n            >\r\n              <small>{{\r\n                'igo.geo.importExportForm.exportSelectedFeature' | translate\r\n              }}</small>\r\n            </mat-slide-toggle>\r\n          </p>\r\n        </mat-option>\r\n      </mat-select>\r\n    </mat-form-field>\r\n  </div>\r\n\r\n  <div class=\"igo-input-container\">\r\n    <mat-form-field>\r\n      <mat-label>{{\r\n        'igo.geo.importExportForm.exportFormatPlaceholder' | translate\r\n      }}</mat-label>\r\n      <mat-select formControlName=\"format\">\r\n        <ng-container *ngIf=\"(formats$ | async).length !== 0\">\r\n          <mat-option\r\n            *ngFor=\"let format of formats$ | async | keyvalue\"\r\n            [value]=\"format.key\"\r\n          >\r\n            {{ 'igo.geo.export.format.' + format.value | translate }}\r\n          </mat-option>\r\n        </ng-container>\r\n        <mat-option *ngIf=\"(formats$ | async).length === 0\" disabled=\"true\">\r\n          {{ 'igo.geo.export.noFormat.title' | translate }}\r\n        </mat-option>\r\n      </mat-select>\r\n    </mat-form-field>\r\n  </div>\r\n\r\n  <div\r\n    class=\"igo-input-container\"\r\n    *ngIf=\"forceNaming && form.value.format !== 'URL'\"\r\n  >\r\n    <mat-form-field>\r\n      <input\r\n        matInput\r\n        formControlName=\"name\"\r\n        placeholder=\"{{\r\n          'igo.geo.importExportForm.exportFileNamePlaceholder' | translate\r\n        }}\"\r\n      />\r\n    </mat-form-field>\r\n  </div>\r\n\r\n  <div\r\n    class=\"igo-input-container\"\r\n    *ngIf=\"\r\n      form.value.format === 'CSVcomma' || form.value.format === 'CSVsemicolon'\r\n    \"\r\n  >\r\n    <mat-form-field>\r\n      <mat-label>{{\r\n        'igo.geo.importExportForm.encodingPlaceholder' | translate\r\n      }}</mat-label>\r\n      <mat-select formControlName=\"encoding\">\r\n        <ng-container *ngIf=\"(encodings$ | async).length !== 0\">\r\n          <mat-option\r\n            *ngFor=\"let encoding of encodings$ | async | keyvalue\"\r\n            [value]=\"encoding.key\"\r\n          >\r\n            {{ 'igo.geo.export.encoding.' + encoding.value | translate }}\r\n          </mat-option>\r\n        </ng-container>\r\n      </mat-select>\r\n    </mat-form-field>\r\n  </div>\r\n\r\n  <div\r\n    class=\"export-combine-layers mat-typography\"\r\n    *ngIf=\"\r\n      layers.length > 1 &&\r\n      (form.value.format === 'CSVcomma' || form.value.format === 'CSVsemicolon')\r\n    \"\r\n  >\r\n    <mat-slide-toggle\r\n      formControlName=\"combineLayers\"\r\n      [labelPosition]=\"'before'\"\r\n    >\r\n      {{ 'igo.geo.importExportForm.exportCombineResults' | translate }}\r\n    </mat-slide-toggle>\r\n  </div>\r\n\r\n  <div\r\n    class=\"export-separator mat-typography\"\r\n    *ngIf=\"\r\n      layers.length > 1 &&\r\n      (form.value.format === 'CSVcomma' ||\r\n        form.value.format === 'CSVsemicolon') &&\r\n      form.value.combineLayers\r\n    \"\r\n  >\r\n    <mat-slide-toggle formControlName=\"separator\" [labelPosition]=\"'before'\">\r\n      {{ 'igo.geo.importExportForm.exportSeparator' | translate }}\r\n    </mat-slide-toggle>\r\n  </div>\r\n\r\n  <div\r\n    class=\"export-options mat-typography\"\r\n    *ngIf=\"form.value.format !== 'URL'\"\r\n  >\r\n    <mat-slide-toggle\r\n      formControlName=\"featureInMapExtent\"\r\n      [labelPosition]=\"'before'\"\r\n    >\r\n      {{ 'igo.geo.importExportForm.exportFeatureInExtent' | translate }}\r\n    </mat-slide-toggle>\r\n  </div>\r\n\r\n  <div class=\"igo-form-button-group\">\r\n    <button\r\n      mat-raised-button\r\n      type=\"button\"\r\n      [disabled]=\"!form.valid || (loading$ | async)\"\r\n      (click)=\"handleExportFormSubmit(form.value)\"\r\n    >\r\n      {{\r\n        form.value.format !== 'URL'\r\n          ? ('igo.geo.importExportForm.exportButton' | translate)\r\n          : form.value.layers.length > 1\r\n          ? ('igo.geo.importExportForm.exportButtonLinks' | translate)\r\n          : ('igo.geo.importExportForm.exportButtonLink' | translate)\r\n      }}\r\n    </button>\r\n    <igo-spinner [shown]=\"loading$ | async\"></igo-spinner>\r\n  </div>\r\n\r\n  <igo-custom-html\r\n    *ngIf=\"exportHtmlClarifications !== ''\"\r\n    class=\"mat-typography\"\r\n    [html]=\"exportHtmlClarifications\"\r\n  >\r\n  </igo-custom-html>\r\n</form>\r\n", styles: [":host mat-option.igo-export-layer-mat-option{height:5em;line-height:1em}:host .import-export-toggle{padding:10px;text-align:center}:host .import-export-toggle mat-button-toggle-group{width:100%}:host .import-export-toggle mat-button-toggle-group mat-button-toggle{width:50%}:host h4{padding:0 5px}:host .igo-form{padding:15px 5px}:host .igo-input-container mat-form-field{width:100%}:host .igo-form-button-group{text-align:center;padding-top:10px}:host igo-spinner{position:absolute;padding-left:10px}:host .export-options mat-slide-toggle,:host .export-combine-layers mat-slide-toggle,:host .export-separator mat-slide-toggle{width:100%;padding:10px}:host .export-options mat-slide-toggle ::ng-deep .mdc-form-field,:host .export-combine-layers mat-slide-toggle ::ng-deep .mdc-form-field,:host .export-separator mat-slide-toggle ::ng-deep .mdc-form-field{width:100%}:host .export-options mat-slide-toggle ::ng-deep .mdc-label,:host .export-combine-layers mat-slide-toggle ::ng-deep .mdc-label,:host .export-separator mat-slide-toggle ::ng-deep .mdc-label{margin-left:0;width:calc(100% - 60px)}:host .export-select-trigger{opacity:.75;font-size:.75em}\n"] }]
        }], ctorParameters: function () { return [{ type: ImportService }, { type: ExportService }, { type: i2.LanguageService }, { type: i2.MessageService }, { type: StyleListService }, { type: StyleService }, { type: i2$1.UntypedFormBuilder }, { type: i2.ConfigService }, { type: i0.ChangeDetectorRef }, { type: i2.StorageService }, { type: DownloadService }, { type: LayerService }, { type: i9$1.ConfirmDialogService }]; }, propDecorators: { selectFirstProj: [{
                type: Input
            }], map: [{
                type: Input
            }], contextUri: [{
                type: Input
            }], projectionsLimitations: [{
                type: Input
            }], store: [{
                type: Input
            }], selectedMode: [{
                type: Input
            }], selectMode: [{
                type: Output
            }], exportOptions$: [{
                type: Input
            }], exportOptionsChange: [{
                type: Output
            }] } });

class DropGeoFileDirective extends DragAndDropDirective {
    component;
    importService;
    styleListService;
    styleService;
    config;
    messageService;
    layerService;
    confirmDialogService;
    filesDropped = new EventEmitter();
    filesInvalid = new EventEmitter();
    epsgCode$ = new BehaviorSubject(undefined);
    epsgCode$$ = [];
    filesDropped$$;
    get map() {
        return this.component.map;
    }
    contextUri;
    constructor(component, importService, styleListService, styleService, config, messageService, layerService, confirmDialogService) {
        super();
        this.component = component;
        this.importService = importService;
        this.styleListService = styleListService;
        this.styleService = styleService;
        this.config = config;
        this.messageService = messageService;
        this.layerService = layerService;
        this.confirmDialogService = confirmDialogService;
    }
    ngOnInit() {
        this.filesDropped$$ = this.filesDropped.subscribe((files) => {
            this.onFilesDropped(files);
        });
    }
    ngOnDestroy() {
        this.filesDropped$$.unsubscribe();
    }
    onDragOver(evt) {
        super.onDragOver(evt);
    }
    onDragLeave(evt) {
        super.onDragLeave(evt);
    }
    onDrop(evt) {
        super.onDrop(evt);
    }
    onFilesDropped(files) {
        for (const file of files) {
            this.detectEPSG(file);
            this.epsgCode$$.push(this.epsgCode$
                .pipe(skipWhile((code) => !code), first(), concatMap((epsgCode) => {
                const epsg = epsgCode === 'epsgNotDefined' ? undefined : epsgCode;
                this.epsgCode$.next(undefined);
                return this.importService.import(file, epsg);
            }))
                .subscribe((features) => this.onFileImportSuccess(file, features), (error) => this.onFileImportError(file, error)));
        }
    }
    detectEPSG(file, nbLines = 500) {
        if (!file.name.toLowerCase().endsWith('.geojson') &&
            !file.name.toLowerCase().endsWith('.gml')) {
            this.epsgCode$.next('epsgNotDefined');
            return;
        }
        const reader = new FileReader();
        reader.onload = (e) => {
            if (file.name.toLowerCase().endsWith('.geojson')) {
                const geojson = JSON.parse(reader.result);
                if (geojson.crs?.properties?.name) {
                    const epsg = geojson.crs.properties.name.match(/EPSG:{1,2}\d{0,6}/gm);
                    if (epsg !== null && epsg.length) {
                        this.epsgCode$.next(epsg[0].replace(/::/g, ':'));
                        return;
                    }
                    else {
                        this.epsgCode$.next('epsgNotDefined');
                        return;
                    }
                }
                else {
                    this.epsgCode$.next('epsgNotDefined');
                    return;
                }
            }
            else if (file.name.toLowerCase().endsWith('.gml')) {
                const text = reader.result;
                const lines = text.split('\n');
                for (let line = 0; line <= nbLines; line++) {
                    const epsg = lines[line].match(/EPSG:\d{0,6}/gm);
                    if (epsg !== null && epsg.length) {
                        this.epsgCode$.next(epsg[0]);
                        break;
                    }
                    else {
                        this.epsgCode$.next(undefined);
                        return;
                    }
                }
            }
            else {
                this.epsgCode$.next('epsgNotDefined');
                return;
            }
        };
        reader.readAsText(file, 'UTF-8');
    }
    onFileImportSuccess(file, features) {
        const importExportOptions = this.config.getConfig('importExport');
        const confirmDialogService = importExportOptions?.allowToStoreLayer
            ? this.confirmDialogService
            : undefined;
        if (!importExportOptions?.importWithStyle) {
            handleFileImportSuccess(file, features, this.map, this.contextUri, this.messageService, this.layerService, confirmDialogService);
        }
        else {
            handleFileImportSuccess(file, features, this.map, this.contextUri, this.messageService, this.layerService, confirmDialogService, this.styleListService, this.styleService);
        }
    }
    onFileImportError(file, error) {
        handleFileImportError(file, error, this.messageService, this.config.getConfig('importExport.clientSideFileSizeMaxMb'));
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DropGeoFileDirective, deps: [{ token: MapBrowserComponent }, { token: ImportService }, { token: StyleListService }, { token: StyleService }, { token: i2.ConfigService }, { token: i2.MessageService }, { token: LayerService }, { token: i9$1.ConfirmDialogService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: DropGeoFileDirective, selector: "[igoDropGeoFile]", inputs: { contextUri: "contextUri" }, host: { listeners: { "dragover": "onDragOver($event)", "dragleave": "onDragLeave($event)", "drop": "onDrop($event)" } }, usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DropGeoFileDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igoDropGeoFile]'
                }]
        }], ctorParameters: function () { return [{ type: MapBrowserComponent }, { type: ImportService }, { type: StyleListService }, { type: StyleService }, { type: i2.ConfigService }, { type: i2.MessageService }, { type: LayerService }, { type: i9$1.ConfirmDialogService }]; }, propDecorators: { contextUri: [{
                type: Input
            }], onDragOver: [{
                type: HostListener,
                args: ['dragover', ['$event']]
            }], onDragLeave: [{
                type: HostListener,
                args: ['dragleave', ['$event']]
            }], onDrop: [{
                type: HostListener,
                args: ['drop', ['$event']]
            }] } });

class IgoImportExportModule {
    static forRoot() {
        return {
            ngModule: IgoImportExportModule
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoImportExportModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoImportExportModule, declarations: [ImportExportComponent,
            DropGeoFileDirective,
            ExportButtonComponent], imports: [MatIconModule,
            MatTooltipModule,
            FormsModule,
            ReactiveFormsModule,
            CommonModule,
            MatButtonModule,
            MatButtonToggleModule,
            MatTabsModule,
            MatSelectModule,
            MatOptionModule,
            MatFormFieldModule,
            MatInputModule,
            MatSlideToggleModule,
            IgoLanguageModule,
            IgoSpinnerModule,
            IgoKeyValueModule,
            IgoDrapDropModule,
            IgoCustomHtmlModule], exports: [ImportExportComponent, DropGeoFileDirective, ExportButtonComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoImportExportModule, imports: [MatIconModule,
            MatTooltipModule,
            FormsModule,
            ReactiveFormsModule,
            CommonModule,
            MatButtonModule,
            MatButtonToggleModule,
            MatTabsModule,
            MatSelectModule,
            MatOptionModule,
            MatFormFieldModule,
            MatInputModule,
            MatSlideToggleModule,
            IgoLanguageModule,
            IgoSpinnerModule,
            IgoKeyValueModule,
            IgoDrapDropModule,
            IgoCustomHtmlModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoImportExportModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        MatIconModule,
                        MatTooltipModule,
                        FormsModule,
                        ReactiveFormsModule,
                        CommonModule,
                        MatButtonModule,
                        MatButtonToggleModule,
                        MatTabsModule,
                        MatSelectModule,
                        MatOptionModule,
                        MatFormFieldModule,
                        MatInputModule,
                        MatSlideToggleModule,
                        IgoLanguageModule,
                        IgoSpinnerModule,
                        IgoKeyValueModule,
                        IgoDrapDropModule,
                        IgoCustomHtmlModule
                    ],
                    exports: [ImportExportComponent, DropGeoFileDirective, ExportButtonComponent],
                    declarations: [
                        ImportExportComponent,
                        DropGeoFileDirective,
                        ExportButtonComponent
                    ]
                }]
        }] });

class IgoMapModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoMapModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoMapModule, declarations: [MapBrowserComponent,
            ZoomButtonComponent,
            GeolocateButtonComponent,
            HomeExtentButtonComponent,
            RotationButtonComponent,
            InfoSectionComponent,
            BaseLayersSwitcherComponent,
            MiniBaseMapComponent,
            MapOfflineDirective,
            OfflineButtonComponent,
            WakeLockButtonComponent,
            PointerPositionDirective,
            HoverFeatureDirective,
            SwipeControlComponent,
            MapCenterComponent,
            MenuButtonComponent], imports: [CommonModule,
            IgoLanguageModule,
            IgoConfirmDialogModule,
            MatIconModule,
            MatButtonModule,
            MatTooltipModule], exports: [MapBrowserComponent,
            ZoomButtonComponent,
            GeolocateButtonComponent,
            HomeExtentButtonComponent,
            RotationButtonComponent,
            InfoSectionComponent,
            BaseLayersSwitcherComponent,
            MiniBaseMapComponent,
            MapOfflineDirective,
            OfflineButtonComponent,
            WakeLockButtonComponent,
            PointerPositionDirective,
            HoverFeatureDirective,
            SwipeControlComponent,
            MapCenterComponent,
            MenuButtonComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoMapModule, imports: [CommonModule,
            IgoLanguageModule,
            IgoConfirmDialogModule,
            MatIconModule,
            MatButtonModule,
            MatTooltipModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoMapModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        IgoLanguageModule,
                        IgoConfirmDialogModule,
                        MatIconModule,
                        MatButtonModule,
                        MatTooltipModule
                    ],
                    exports: [
                        MapBrowserComponent,
                        ZoomButtonComponent,
                        GeolocateButtonComponent,
                        HomeExtentButtonComponent,
                        RotationButtonComponent,
                        InfoSectionComponent,
                        BaseLayersSwitcherComponent,
                        MiniBaseMapComponent,
                        MapOfflineDirective,
                        OfflineButtonComponent,
                        WakeLockButtonComponent,
                        PointerPositionDirective,
                        HoverFeatureDirective,
                        SwipeControlComponent,
                        MapCenterComponent,
                        MenuButtonComponent
                    ],
                    declarations: [
                        MapBrowserComponent,
                        ZoomButtonComponent,
                        GeolocateButtonComponent,
                        HomeExtentButtonComponent,
                        RotationButtonComponent,
                        InfoSectionComponent,
                        BaseLayersSwitcherComponent,
                        MiniBaseMapComponent,
                        MapOfflineDirective,
                        OfflineButtonComponent,
                        WakeLockButtonComponent,
                        PointerPositionDirective,
                        HoverFeatureDirective,
                        SwipeControlComponent,
                        MapCenterComponent,
                        MenuButtonComponent
                    ]
                }]
        }] });

/**
 * @ignore
 */
class IgoMeasurerModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoMeasurerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoMeasurerModule, declarations: [MeasureFormatPipe,
            MeasurerItemComponent,
            MeasurerComponent,
            MeasurerDialogComponent], imports: [CommonModule,
            MatButtonModule,
            MatButtonToggleModule,
            MatDialogModule,
            MatIconModule,
            MatTooltipModule,
            MatFormFieldModule,
            MatInputModule,
            MatSelectModule,
            MatSlideToggleModule,
            MatDividerModule,
            IgoLanguageModule,
            IgoEntityTableModule], exports: [MeasureFormatPipe, MeasurerComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoMeasurerModule, imports: [CommonModule,
            MatButtonModule,
            MatButtonToggleModule,
            MatDialogModule,
            MatIconModule,
            MatTooltipModule,
            MatFormFieldModule,
            MatInputModule,
            MatSelectModule,
            MatSlideToggleModule,
            MatDividerModule,
            IgoLanguageModule,
            IgoEntityTableModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoMeasurerModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        MatButtonModule,
                        MatButtonToggleModule,
                        MatDialogModule,
                        MatIconModule,
                        MatTooltipModule,
                        MatFormFieldModule,
                        MatInputModule,
                        MatSelectModule,
                        MatSlideToggleModule,
                        MatDividerModule,
                        IgoLanguageModule,
                        IgoEntityTableModule
                    ],
                    declarations: [
                        MeasureFormatPipe,
                        MeasurerItemComponent,
                        MeasurerComponent,
                        MeasurerDialogComponent
                    ],
                    exports: [MeasureFormatPipe, MeasurerComponent]
                }]
        }] });

class IgoMeasureModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoMeasureModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoMeasureModule, exports: [IgoMeasurerModule] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoMeasureModule, imports: [IgoMeasurerModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoMeasureModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [],
                    declarations: [],
                    exports: [IgoMeasurerModule]
                }]
        }] });

var OverlayAction;
(function (OverlayAction) {
    OverlayAction[OverlayAction["None"] = 0] = "None";
    OverlayAction[OverlayAction["Move"] = 1] = "Move";
    OverlayAction[OverlayAction["Zoom"] = 2] = "Zoom";
    OverlayAction[OverlayAction["ZoomIfOutMapExtent"] = 3] = "ZoomIfOutMapExtent";
})(OverlayAction || (OverlayAction = {}));

class OverlayService {
    features$ = new BehaviorSubject([
        [],
        undefined
    ]);
    constructor() { }
    setFeatures(features, action = OverlayAction.None) {
        this.features$.next([features, action]);
    }
    clear() {
        this.features$.next([[], OverlayAction.None]);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OverlayService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OverlayService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OverlayService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return []; } });

class OverlayDirective {
    component;
    overlayService;
    features$$;
    format = new OlGeoJSON();
    get map() {
        return this.component.map;
    }
    constructor(component, overlayService) {
        this.component = component;
        this.overlayService = overlayService;
    }
    ngOnInit() {
        this.features$$ = this.overlayService.features$.subscribe((res) => this.handleFeatures(res[0], res[1]));
    }
    ngOnDestroy() {
        this.features$$.unsubscribe();
    }
    handleFeatures(features, action) { }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OverlayDirective, deps: [{ token: MapBrowserComponent, self: true }, { token: OverlayService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: OverlayDirective, selector: "[igoOverlay]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OverlayDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igoOverlay]'
                }]
        }], ctorParameters: function () { return [{ type: MapBrowserComponent, decorators: [{
                    type: Self
                }] }, { type: OverlayService }]; } });

class IgoOverlayModule {
    static forRoot() {
        return {
            ngModule: IgoOverlayModule
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoOverlayModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoOverlayModule, declarations: [OverlayDirective], exports: [OverlayDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoOverlayModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoOverlayModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [],
                    exports: [OverlayDirective],
                    declarations: [OverlayDirective]
                }]
        }] });

class PrintFormComponent {
    formBuilder;
    mediaService;
    form;
    outputFormats = PrintOutputFormat;
    paperFormats = PrintPaperFormat;
    orientations = PrintOrientation;
    resolutions = [...PrintResolution];
    imageFormats = PrintSaveImageFormat;
    legendPositions = PrintLegendPosition;
    isPrintService = true;
    disabled$;
    get imageFormat() {
        return this.imageFormatField.value;
    }
    set imageFormat(value) {
        this.imageFormatField.setValue(value || PrintSaveImageFormat.Jpeg, {
            onlySelf: true
        });
    }
    get outputFormat() {
        return this.outputFormatField.value;
    }
    set outputFormat(value) {
        this.outputFormatField.setValue(value || PrintOutputFormat.Pdf, {
            onlySelf: true
        });
    }
    get paperFormat() {
        return this.paperFormatField.value;
    }
    set paperFormat(value) {
        this.paperFormatField.setValue(value || PrintPaperFormat.Letter, {
            onlySelf: true
        });
    }
    get orientation() {
        return this.orientationField.value;
    }
    set orientation(value) {
        this.orientationField.setValue(value || PrintOrientation.landscape, {
            onlySelf: true
        });
    }
    get resolution() {
        return this.resolutionField.value;
    }
    set resolution(value) {
        this.resolutionField.setValue(value || ('96'), {
            onlySelf: true
        });
    }
    get legendPosition() {
        return this.legendPositionField.value;
    }
    set legendPosition(value) {
        this.legendPositionField.setValue(value || PrintLegendPosition.none, {
            onlySelf: true
        });
    }
    get title() {
        return this.titleField.value;
    }
    set title(value) {
        this.titleField.setValue(value, { onlySelf: true });
    }
    get subtitle() {
        return this.subtitleField.value;
    }
    set subtitle(value) {
        this.subtitleField.setValue(value, { onlySelf: true });
    }
    get comment() {
        return this.commentField.value;
    }
    set comment(value) {
        this.commentField.setValue(value, { onlySelf: true });
    }
    get showProjection() {
        return this.showProjectionField.value;
    }
    set showProjection(value) {
        this.showProjectionField.setValue(value, { onlySelf: true });
    }
    get showScale() {
        return this.showScaleField.value;
    }
    set showScale(value) {
        this.showScaleField.setValue(value, { onlySelf: true });
    }
    get showLegend() {
        return this.showLegendField.value;
    }
    set showLegend(value) {
        this.showLegendField.setValue(value, { onlySelf: true });
    }
    get doZipFile() {
        return this.doZipFileField.value;
    }
    set doZipFile(value) {
        this.doZipFileField.setValue(value, { onlySelf: true });
    }
    get outputFormatField() {
        return this.form.controls.outputFormat;
    }
    get paperFormatField() {
        return this.form.controls.paperFormat;
    }
    get imageFormatField() {
        return this.form.controls.imageFormat;
    }
    get orientationField() {
        return this.form.controls.orientation;
    }
    get resolutionField() {
        return this.form.controls.resolution;
    }
    get commentField() {
        return this.form.controls.comment;
    }
    get showProjectionField() {
        return this.form.controls.showProjection;
    }
    get showScaleField() {
        return this.form.controls.showScale;
    }
    get showLegendField() {
        return this.form.controls.showLegend;
    }
    get doZipFileField() {
        return this.form.controls.doZipFile;
    }
    get titleField() {
        return this.form.controls.title;
    }
    get subtitleField() {
        return this.form.controls.subtitle;
    }
    get legendPositionField() {
        return this.form.controls.legendPosition;
    }
    submit = new EventEmitter();
    maxLength = 180;
    constructor(formBuilder, mediaService) {
        this.formBuilder = formBuilder;
        this.mediaService = mediaService;
        this.form = this.formBuilder.group({
            title: ['', [Validators.minLength(0), Validators.maxLength(130)]],
            subtitle: ['', [Validators.minLength(0), Validators.maxLength(120)]],
            comment: [
                '',
                [Validators.minLength(0), Validators.maxLength(this.maxLength)]
            ],
            outputFormat: ['', [Validators.required]],
            paperFormat: ['', [Validators.required]],
            imageFormat: ['', [Validators.required]],
            resolution: ['', [Validators.required]],
            orientation: ['', [Validators.required]],
            legendPosition: ['', [Validators.required]],
            showProjection: false,
            showScale: false,
            showLegend: false,
            doZipFile: [{ hidden: this.isPrintService }]
        });
    }
    ngOnInit() {
        this.doZipFileField.setValue(false);
        if (this.mediaService.isMobile()) {
            this.resolutions = this.resolutions.filter((resolution) => resolution !== '300');
        }
    }
    handleFormSubmit(data, isValid) {
        data.isPrintService = this.isPrintService;
        if (isValid) {
            this.submit.emit(data);
        }
    }
    toggleImageSaveProp() {
        if (this.outputFormatField.value === 'Image') {
            this.isPrintService = false;
            this.commentField.clearValidators();
            this.commentField.updateValueAndValidity();
        }
        else {
            this.isPrintService = true;
        }
    }
    changeCommentLength() {
        switch (this.paperFormat) {
            case PrintPaperFormat.A0:
                // A0, landscape, length 900 | A0, portrait, comment length:  600
                this.maxLength =
                    this.orientation === PrintOrientation.landscape ? 900 : 600;
                break;
            case PrintPaperFormat.A1:
                // A1, landscape, length 600 | A1, portrait, length 400;
                this.maxLength =
                    this.orientation === PrintOrientation.landscape ? 600 : 400;
                break;
            case PrintPaperFormat.A2:
                // A2, landscape, length 400 | A2, portrait, length 300;
                this.maxLength =
                    this.orientation === PrintOrientation.landscape ? 400 : 300;
                break;
            case PrintPaperFormat.A3:
                // A3, landscape, length 300 | A3, portrait, length 200;
                this.maxLength =
                    this.orientation === PrintOrientation.landscape ? 300 : 200;
                break;
            case PrintPaperFormat.A4:
                // A4, landscape length 200 | A4, portrait length 120;
                this.maxLength =
                    this.orientation === PrintOrientation.landscape ? 200 : 100;
                break;
            case PrintPaperFormat.A5:
                // A5, landscape length 120 | A5, portrait length 80;
                this.maxLength =
                    this.orientation === PrintOrientation.landscape ? 120 : 80;
                break;
            case PrintPaperFormat.Letter:
                // lettre, landscape, 180 | lettre, portrait, 140
                this.maxLength =
                    this.orientation === PrintOrientation.landscape ? 180 : 140;
                break;
            default:
                // legal, landscape, 200 | legal, portrait, 140
                this.maxLength =
                    this.orientation === PrintOrientation.landscape ? 200 : 140;
                break;
        }
        this.commentField.setValidators([Validators.maxLength(this.maxLength)]);
        this.commentField.updateValueAndValidity();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PrintFormComponent, deps: [{ token: i2$1.UntypedFormBuilder }, { token: i2.MediaService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: PrintFormComponent, selector: "igo-print-form", inputs: { disabled$: "disabled$", imageFormat: "imageFormat", outputFormat: "outputFormat", paperFormat: "paperFormat", orientation: "orientation", resolution: "resolution", legendPosition: "legendPosition", title: "title", subtitle: "subtitle", comment: "comment", showProjection: "showProjection", showScale: "showScale", showLegend: "showLegend", doZipFile: "doZipFile" }, outputs: { submit: "submit" }, ngImport: i0, template: "<form class=\"igo-form\" [formGroup]=\"form\">\n  <div class=\"igo-input-container\">\n    <mat-form-field>\n      <mat-label>{{ 'igo.geo.printForm.title' | translate }}</mat-label>\n      <input\n        matInput\n        formControlName=\"title\"\n        placeholder=\"{{ 'igo.geo.printForm.title' | translate }}\"\n      />\n      <mat-error *ngIf=\"titleField.errors?.maxlength\">{{\n        'igo.geo.formValidation.maxLength'\n          | translate\n            : {\n                column: 'igo.geo.printForm.title' | translate,\n                value: 130\n              }\n      }}</mat-error>\n    </mat-form-field>\n  </div>\n  <div class=\"igo-input-container\">\n    <mat-form-field>\n      <mat-label>{{ 'igo.geo.printForm.subtitle' | translate }}</mat-label>\n      <input\n        matInput\n        formControlName=\"subtitle\"\n        placeholder=\"{{ 'igo.geo.printForm.subtitle' | translate }}\"\n      />\n      <mat-error *ngIf=\"subtitleField.errors?.maxlength\">{{\n        'igo.geo.formValidation.maxLength'\n          | translate\n            : {\n                column: 'igo.geo.printForm.subtitle' | translate,\n                value: 120\n              }\n      }}</mat-error>\n    </mat-form-field>\n  </div>\n  <div class=\"igo-input-container\">\n    <mat-form-field>\n      <mat-label>{{ 'igo.geo.printForm.comment' | translate }}</mat-label>\n      <input\n        matInput\n        formControlName=\"comment\"\n        placeholder=\"{{ 'igo.geo.printForm.comment' | translate }}\"\n      />\n      <mat-error *ngIf=\"commentField.errors?.maxlength\">{{\n        'igo.geo.formValidation.maxLength'\n          | translate\n            : {\n                column: 'igo.geo.printForm.comment' | translate,\n                value: maxLength\n              }\n      }}</mat-error>\n    </mat-form-field>\n  </div>\n\n  <div class=\"igo-input-container slide-toggle-container\">\n    <div class=\"print-slide-toggle-container\">\n      <mat-slide-toggle\n        class=\"print-option\"\n        formControlName=\"showProjection\"\n        [labelPosition]=\"'before'\"\n      >\n        {{ 'igo.geo.printForm.showProjection' | translate }}\n      </mat-slide-toggle>\n      <mat-slide-toggle\n        class=\"print-option\"\n        formControlName=\"showScale\"\n        [labelPosition]=\"'before'\"\n      >\n        {{ 'igo.geo.printForm.showScale' | translate }}\n      </mat-slide-toggle>\n      <mat-slide-toggle\n        class=\"print-option\"\n        formControlName=\"doZipFile\"\n        [labelPosition]=\"'before'\"\n        [style.display]=\"isPrintService ? 'none' : ''\"\n      >\n        {{ 'igo.geo.printForm.doZipFile' | translate }}\n      </mat-slide-toggle>\n    </div>\n  </div>\n\n  <div class=\"igo-input-container\">\n    <mat-form-field>\n      <mat-label>{{\n        'igo.geo.printForm.legendPosition' | translate\n      }}</mat-label>\n      <mat-select\n        formControlName=\"legendPosition\"\n        placeholder=\"{{ 'igo.geo.printForm.legendPosition' | translate }}\"\n      >\n        <mat-option\n          *ngFor=\"let legendPosition of legendPositions | keyvalue\"\n          [value]=\"legendPosition.key\"\n        >\n          <ng-container\n            *ngIf=\"!['newpage', 'newimage'].includes(legendPosition.value)\"\n          >\n            {{\n              'igo.geo.printForm.legendPositions.' + legendPosition.value\n                | translate\n            }}\n          </ng-container>\n\n          <ng-container\n            *ngIf=\"['newpage', 'newimage'].includes(legendPosition.value)\"\n          >\n            {{\n              (outputFormat === 'Pdf'\n                ? 'igo.geo.printForm.legendPositions.newpage'\n                : 'igo.geo.printForm.legendPositions.newimage'\n              ) | translate\n            }}\n          </ng-container>\n        </mat-option>\n      </mat-select>\n    </mat-form-field>\n  </div>\n\n  <div class=\"igo-input-container\">\n    <mat-form-field>\n      <mat-label>{{ 'igo.geo.printForm.outputFormat' | translate }}</mat-label>\n      <mat-select\n        (selectionChange)=\"toggleImageSaveProp()\"\n        formControlName=\"outputFormat\"\n        placeholder=\"{{ 'igo.geo.printForm.outputFormat' | translate }}\"\n      >\n        <mat-option\n          *ngFor=\"let outputFormat of outputFormats | keyvalue\"\n          [value]=\"outputFormat.key\"\n        >\n          {{ outputFormat.value }}\n        </mat-option>\n      </mat-select>\n    </mat-form-field>\n  </div>\n\n  <div\n    class=\"igo-input-container\"\n    [style.display]=\"isPrintService ? 'block' : 'none'\"\n  >\n    <mat-form-field>\n      <mat-label>{{ 'igo.geo.printForm.paperFormat' | translate }}</mat-label>\n      <mat-select\n        (selectionChange)=\"changeCommentLength()\"\n        formControlName=\"paperFormat\"\n        placeholder=\"{{ 'igo.geo.printForm.paperFormat' | translate }}\"\n      >\n        <mat-option\n          *ngFor=\"let paperFormat of paperFormats | keyvalue\"\n          [value]=\"paperFormat.key\"\n        >\n          {{\n            'igo.geo.printForm.paperFormats.' + paperFormat.value | translate\n          }}\n        </mat-option>\n      </mat-select>\n    </mat-form-field>\n  </div>\n\n  <div\n    class=\"igo-input-container\"\n    [style.display]=\"isPrintService ? 'none' : 'block'\"\n  >\n    <mat-form-field>\n      <mat-label>{{ 'igo.geo.printForm.imageFormat' | translate }}</mat-label>\n      <mat-select\n        formControlName=\"imageFormat\"\n        placeholder=\"{{ 'igo.geo.printForm.imageFormat' | translate }}\"\n      >\n        <mat-option\n          *ngFor=\"let imageFormat of imageFormats | keyvalue\"\n          [value]=\"imageFormat.key\"\n        >\n          {{ imageFormat.value }}\n        </mat-option>\n      </mat-select>\n    </mat-form-field>\n  </div>\n\n  <div class=\"igo-input-container\">\n    <mat-form-field>\n      <mat-label\n        >{{ 'igo.geo.printForm.resolution' | translate }} ({{\n          'igo.geo.printForm.resolutionUnit' | translate\n        }})</mat-label\n      >\n      <mat-select\n        formControlName=\"resolution\"\n        placeholder=\"{{ 'igo.geo.printForm.resolution' | translate }}\"\n      >\n        <mat-option *ngFor=\"let resolution of resolutions\" [value]=\"resolution\">\n          {{ resolution }}\n        </mat-option>\n      </mat-select>\n    </mat-form-field>\n  </div>\n\n  <div\n    class=\"igo-input-container\"\n    [style.display]=\"isPrintService ? 'block' : 'none'\"\n  >\n    <mat-form-field>\n      <mat-label>{{ 'igo.geo.printForm.orientation' | translate }}</mat-label>\n      <mat-select\n        (selectionChange)=\"changeCommentLength()\"\n        formControlName=\"orientation\"\n        placeholder=\"{{ 'igo.geo.printForm.orientation' | translate }}\"\n      >\n        <mat-option\n          *ngFor=\"let orientation of orientations | keyvalue\"\n          [value]=\"orientation.key\"\n        >\n          {{ 'igo.geo.printForm.' + orientation.value | translate }}\n        </mat-option>\n      </mat-select>\n    </mat-form-field>\n  </div>\n\n  <div class=\"igo-form-button-group print-button-top-padding\">\n    <button\n      mat-raised-button\n      type=\"button\"\n      [disabled]=\"!form.valid || (disabled$ | async)\"\n      (click)=\"handleFormSubmit(form.value, form.valid)\"\n    >\n      {{ 'igo.geo.printForm.saveBtn' | translate }}\n    </button>\n  </div>\n</form>\n", styles: [":host mat-form-field{width:100%}:host .slide-toggle-container{margin-bottom:16px}:host .print-slide-toggle-container mat-slide-toggle{width:100%;padding:0 8px}:host .print-slide-toggle-container mat-slide-toggle ::ng-deep .mdc-form-field{width:100%}:host .print-slide-toggle-container mat-slide-toggle ::ng-deep .mdc-label{margin-left:0;width:calc(100% - 60px)}:host .print-option{display:block;margin-bottom:12px}:host .igo-form{padding:10px 5px 5px}:host .igo-form-button-group{text-align:center}\n"], dependencies: [{ kind: "directive", type: i2$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2$1.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { kind: "directive", type: i2$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i2$1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "directive", type: i2$1.FormControlName, selector: "[formControlName]", inputs: ["formControlName", "disabled", "ngModel"], outputs: ["ngModelChange"] }, { kind: "component", type: i4$1.MatButton, selector: "    button[mat-button], button[mat-raised-button], button[mat-flat-button],    button[mat-stroked-button]  ", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "component", type: i8.MatFormField, selector: "mat-form-field", inputs: ["hideRequiredMarker", "color", "floatLabel", "appearance", "subscriptSizing", "hintLabel"], exportAs: ["matFormField"] }, { kind: "directive", type: i8.MatLabel, selector: "mat-label" }, { kind: "directive", type: i8.MatError, selector: "mat-error, [matError]", inputs: ["id"] }, { kind: "component", type: i15.MatSelect, selector: "mat-select", inputs: ["disabled", "disableRipple", "tabIndex", "panelWidth", "hideSingleSelectionIndicator"], exportAs: ["matSelect"] }, { kind: "component", type: i9.MatOption, selector: "mat-option", exportAs: ["matOption"] }, { kind: "directive", type: i9$3.MatInput, selector: "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", inputs: ["disabled", "id", "placeholder", "name", "required", "type", "errorStateMatcher", "aria-describedby", "value", "readonly"], exportAs: ["matInput"] }, { kind: "component", type: i7.MatSlideToggle, selector: "mat-slide-toggle", inputs: ["disabled", "disableRipple", "color", "tabIndex"], exportAs: ["matSlideToggle"] }, { kind: "pipe", type: i2$2.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }, { kind: "pipe", type: i9$1.KeyValuePipe, name: "keyvalue" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PrintFormComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-print-form', template: "<form class=\"igo-form\" [formGroup]=\"form\">\n  <div class=\"igo-input-container\">\n    <mat-form-field>\n      <mat-label>{{ 'igo.geo.printForm.title' | translate }}</mat-label>\n      <input\n        matInput\n        formControlName=\"title\"\n        placeholder=\"{{ 'igo.geo.printForm.title' | translate }}\"\n      />\n      <mat-error *ngIf=\"titleField.errors?.maxlength\">{{\n        'igo.geo.formValidation.maxLength'\n          | translate\n            : {\n                column: 'igo.geo.printForm.title' | translate,\n                value: 130\n              }\n      }}</mat-error>\n    </mat-form-field>\n  </div>\n  <div class=\"igo-input-container\">\n    <mat-form-field>\n      <mat-label>{{ 'igo.geo.printForm.subtitle' | translate }}</mat-label>\n      <input\n        matInput\n        formControlName=\"subtitle\"\n        placeholder=\"{{ 'igo.geo.printForm.subtitle' | translate }}\"\n      />\n      <mat-error *ngIf=\"subtitleField.errors?.maxlength\">{{\n        'igo.geo.formValidation.maxLength'\n          | translate\n            : {\n                column: 'igo.geo.printForm.subtitle' | translate,\n                value: 120\n              }\n      }}</mat-error>\n    </mat-form-field>\n  </div>\n  <div class=\"igo-input-container\">\n    <mat-form-field>\n      <mat-label>{{ 'igo.geo.printForm.comment' | translate }}</mat-label>\n      <input\n        matInput\n        formControlName=\"comment\"\n        placeholder=\"{{ 'igo.geo.printForm.comment' | translate }}\"\n      />\n      <mat-error *ngIf=\"commentField.errors?.maxlength\">{{\n        'igo.geo.formValidation.maxLength'\n          | translate\n            : {\n                column: 'igo.geo.printForm.comment' | translate,\n                value: maxLength\n              }\n      }}</mat-error>\n    </mat-form-field>\n  </div>\n\n  <div class=\"igo-input-container slide-toggle-container\">\n    <div class=\"print-slide-toggle-container\">\n      <mat-slide-toggle\n        class=\"print-option\"\n        formControlName=\"showProjection\"\n        [labelPosition]=\"'before'\"\n      >\n        {{ 'igo.geo.printForm.showProjection' | translate }}\n      </mat-slide-toggle>\n      <mat-slide-toggle\n        class=\"print-option\"\n        formControlName=\"showScale\"\n        [labelPosition]=\"'before'\"\n      >\n        {{ 'igo.geo.printForm.showScale' | translate }}\n      </mat-slide-toggle>\n      <mat-slide-toggle\n        class=\"print-option\"\n        formControlName=\"doZipFile\"\n        [labelPosition]=\"'before'\"\n        [style.display]=\"isPrintService ? 'none' : ''\"\n      >\n        {{ 'igo.geo.printForm.doZipFile' | translate }}\n      </mat-slide-toggle>\n    </div>\n  </div>\n\n  <div class=\"igo-input-container\">\n    <mat-form-field>\n      <mat-label>{{\n        'igo.geo.printForm.legendPosition' | translate\n      }}</mat-label>\n      <mat-select\n        formControlName=\"legendPosition\"\n        placeholder=\"{{ 'igo.geo.printForm.legendPosition' | translate }}\"\n      >\n        <mat-option\n          *ngFor=\"let legendPosition of legendPositions | keyvalue\"\n          [value]=\"legendPosition.key\"\n        >\n          <ng-container\n            *ngIf=\"!['newpage', 'newimage'].includes(legendPosition.value)\"\n          >\n            {{\n              'igo.geo.printForm.legendPositions.' + legendPosition.value\n                | translate\n            }}\n          </ng-container>\n\n          <ng-container\n            *ngIf=\"['newpage', 'newimage'].includes(legendPosition.value)\"\n          >\n            {{\n              (outputFormat === 'Pdf'\n                ? 'igo.geo.printForm.legendPositions.newpage'\n                : 'igo.geo.printForm.legendPositions.newimage'\n              ) | translate\n            }}\n          </ng-container>\n        </mat-option>\n      </mat-select>\n    </mat-form-field>\n  </div>\n\n  <div class=\"igo-input-container\">\n    <mat-form-field>\n      <mat-label>{{ 'igo.geo.printForm.outputFormat' | translate }}</mat-label>\n      <mat-select\n        (selectionChange)=\"toggleImageSaveProp()\"\n        formControlName=\"outputFormat\"\n        placeholder=\"{{ 'igo.geo.printForm.outputFormat' | translate }}\"\n      >\n        <mat-option\n          *ngFor=\"let outputFormat of outputFormats | keyvalue\"\n          [value]=\"outputFormat.key\"\n        >\n          {{ outputFormat.value }}\n        </mat-option>\n      </mat-select>\n    </mat-form-field>\n  </div>\n\n  <div\n    class=\"igo-input-container\"\n    [style.display]=\"isPrintService ? 'block' : 'none'\"\n  >\n    <mat-form-field>\n      <mat-label>{{ 'igo.geo.printForm.paperFormat' | translate }}</mat-label>\n      <mat-select\n        (selectionChange)=\"changeCommentLength()\"\n        formControlName=\"paperFormat\"\n        placeholder=\"{{ 'igo.geo.printForm.paperFormat' | translate }}\"\n      >\n        <mat-option\n          *ngFor=\"let paperFormat of paperFormats | keyvalue\"\n          [value]=\"paperFormat.key\"\n        >\n          {{\n            'igo.geo.printForm.paperFormats.' + paperFormat.value | translate\n          }}\n        </mat-option>\n      </mat-select>\n    </mat-form-field>\n  </div>\n\n  <div\n    class=\"igo-input-container\"\n    [style.display]=\"isPrintService ? 'none' : 'block'\"\n  >\n    <mat-form-field>\n      <mat-label>{{ 'igo.geo.printForm.imageFormat' | translate }}</mat-label>\n      <mat-select\n        formControlName=\"imageFormat\"\n        placeholder=\"{{ 'igo.geo.printForm.imageFormat' | translate }}\"\n      >\n        <mat-option\n          *ngFor=\"let imageFormat of imageFormats | keyvalue\"\n          [value]=\"imageFormat.key\"\n        >\n          {{ imageFormat.value }}\n        </mat-option>\n      </mat-select>\n    </mat-form-field>\n  </div>\n\n  <div class=\"igo-input-container\">\n    <mat-form-field>\n      <mat-label\n        >{{ 'igo.geo.printForm.resolution' | translate }} ({{\n          'igo.geo.printForm.resolutionUnit' | translate\n        }})</mat-label\n      >\n      <mat-select\n        formControlName=\"resolution\"\n        placeholder=\"{{ 'igo.geo.printForm.resolution' | translate }}\"\n      >\n        <mat-option *ngFor=\"let resolution of resolutions\" [value]=\"resolution\">\n          {{ resolution }}\n        </mat-option>\n      </mat-select>\n    </mat-form-field>\n  </div>\n\n  <div\n    class=\"igo-input-container\"\n    [style.display]=\"isPrintService ? 'block' : 'none'\"\n  >\n    <mat-form-field>\n      <mat-label>{{ 'igo.geo.printForm.orientation' | translate }}</mat-label>\n      <mat-select\n        (selectionChange)=\"changeCommentLength()\"\n        formControlName=\"orientation\"\n        placeholder=\"{{ 'igo.geo.printForm.orientation' | translate }}\"\n      >\n        <mat-option\n          *ngFor=\"let orientation of orientations | keyvalue\"\n          [value]=\"orientation.key\"\n        >\n          {{ 'igo.geo.printForm.' + orientation.value | translate }}\n        </mat-option>\n      </mat-select>\n    </mat-form-field>\n  </div>\n\n  <div class=\"igo-form-button-group print-button-top-padding\">\n    <button\n      mat-raised-button\n      type=\"button\"\n      [disabled]=\"!form.valid || (disabled$ | async)\"\n      (click)=\"handleFormSubmit(form.value, form.valid)\"\n    >\n      {{ 'igo.geo.printForm.saveBtn' | translate }}\n    </button>\n  </div>\n</form>\n", styles: [":host mat-form-field{width:100%}:host .slide-toggle-container{margin-bottom:16px}:host .print-slide-toggle-container mat-slide-toggle{width:100%;padding:0 8px}:host .print-slide-toggle-container mat-slide-toggle ::ng-deep .mdc-form-field{width:100%}:host .print-slide-toggle-container mat-slide-toggle ::ng-deep .mdc-label{margin-left:0;width:calc(100% - 60px)}:host .print-option{display:block;margin-bottom:12px}:host .igo-form{padding:10px 5px 5px}:host .igo-form-button-group{text-align:center}\n"] }]
        }], ctorParameters: function () { return [{ type: i2$1.UntypedFormBuilder }, { type: i2.MediaService }]; }, propDecorators: { disabled$: [{
                type: Input
            }], imageFormat: [{
                type: Input
            }], outputFormat: [{
                type: Input
            }], paperFormat: [{
                type: Input
            }], orientation: [{
                type: Input
            }], resolution: [{
                type: Input
            }], legendPosition: [{
                type: Input
            }], title: [{
                type: Input
            }], subtitle: [{
                type: Input
            }], comment: [{
                type: Input
            }], showProjection: [{
                type: Input
            }], showScale: [{
                type: Input
            }], showLegend: [{
                type: Input
            }], doZipFile: [{
                type: Input
            }], submit: [{
                type: Output
            }] } });

class PrintComponent {
    printService;
    disabled$ = new BehaviorSubject(false);
    get map() {
        return this._map;
    }
    set map(value) {
        this._map = value;
    }
    _map;
    get outputFormat() {
        return this._outputFormat;
    }
    set outputFormat(value) {
        this._outputFormat = value;
    }
    _outputFormat;
    get paperFormat() {
        return this._paperFormat;
    }
    set paperFormat(value) {
        this._paperFormat = value;
    }
    _paperFormat;
    get orientation() {
        return this._orientation;
    }
    set orientation(value) {
        this._orientation = value;
    }
    _orientation;
    get imageFormat() {
        return this._imageFormat;
    }
    set imageFormat(value) {
        this._imageFormat = value;
    }
    _imageFormat;
    get legendPosition() {
        return this._legendPosition;
    }
    set legendPosition(value) {
        this._legendPosition = value;
    }
    _legendPosition;
    get resolution() {
        return this._resolution;
    }
    set resolution(value) {
        this._resolution = value;
    }
    _resolution;
    constructor(printService) {
        this.printService = printService;
    }
    handleFormSubmit(data) {
        this.disabled$.next(true);
        if (data.isPrintService === true) {
            this.printService
                .print(this.map, data)
                .pipe(take(1))
                .subscribe(() => {
                this.disabled$.next(false);
            });
        }
        else {
            let nbFileToProcess = 1;
            if (data.showLegend) {
                nbFileToProcess++;
            }
            if (data.imageFormat.toLowerCase() === 'tiff') {
                nbFileToProcess++;
            }
            if (data.legendPosition === 'newpage') {
                nbFileToProcess++;
            }
            this.printService.defineNbFileToProcess(nbFileToProcess);
            this.printService
                .downloadMapImage(this.map, data.resolution, data.imageFormat, data.showProjection, data.showScale, data.title, data.subtitle, data.comment, data.doZipFile, data.legendPosition)
                .pipe(take(1))
                .subscribe(() => {
                this.disabled$.next(false);
            });
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PrintComponent, deps: [{ token: PrintService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: PrintComponent, selector: "igo-print", inputs: { map: "map", outputFormat: "outputFormat", paperFormat: "paperFormat", orientation: "orientation", imageFormat: "imageFormat", legendPosition: "legendPosition", resolution: "resolution" }, ngImport: i0, template: "<igo-print-form\n  [outputFormat]=\"outputFormat\"\n  [paperFormat]=\"paperFormat\"\n  [orientation]=\"orientation\"\n  [imageFormat]=\"imageFormat\"\n  [resolution]=\"resolution\"\n  [legendPosition]=\"legendPosition\"\n  [disabled$]=\"disabled$\"\n  (submit)=\"handleFormSubmit($event)\"\n>\n</igo-print-form>\n", dependencies: [{ kind: "component", type: PrintFormComponent, selector: "igo-print-form", inputs: ["disabled$", "imageFormat", "outputFormat", "paperFormat", "orientation", "resolution", "legendPosition", "title", "subtitle", "comment", "showProjection", "showScale", "showLegend", "doZipFile"], outputs: ["submit"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PrintComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-print', template: "<igo-print-form\n  [outputFormat]=\"outputFormat\"\n  [paperFormat]=\"paperFormat\"\n  [orientation]=\"orientation\"\n  [imageFormat]=\"imageFormat\"\n  [resolution]=\"resolution\"\n  [legendPosition]=\"legendPosition\"\n  [disabled$]=\"disabled$\"\n  (submit)=\"handleFormSubmit($event)\"\n>\n</igo-print-form>\n" }]
        }], ctorParameters: function () { return [{ type: PrintService }]; }, propDecorators: { map: [{
                type: Input
            }], outputFormat: [{
                type: Input
            }], paperFormat: [{
                type: Input
            }], orientation: [{
                type: Input
            }], imageFormat: [{
                type: Input
            }], legendPosition: [{
                type: Input
            }], resolution: [{
                type: Input
            }] } });

class IgoPrintModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoPrintModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoPrintModule, declarations: [PrintComponent, PrintFormComponent], imports: [CommonModule,
            FormsModule,
            ReactiveFormsModule,
            MatIconModule,
            MatButtonModule,
            MatSelectModule,
            MatOptionModule,
            MatInputModule,
            MatFormFieldModule,
            MatSlideToggleModule,
            IgoLanguageModule,
            IgoKeyValueModule], exports: [PrintComponent, PrintFormComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoPrintModule, imports: [CommonModule,
            FormsModule,
            ReactiveFormsModule,
            MatIconModule,
            MatButtonModule,
            MatSelectModule,
            MatOptionModule,
            MatInputModule,
            MatFormFieldModule,
            MatSlideToggleModule,
            IgoLanguageModule,
            IgoKeyValueModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoPrintModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        FormsModule,
                        ReactiveFormsModule,
                        MatIconModule,
                        MatButtonModule,
                        MatSelectModule,
                        MatOptionModule,
                        MatInputModule,
                        MatFormFieldModule,
                        MatSlideToggleModule,
                        IgoLanguageModule,
                        IgoKeyValueModule
                    ],
                    exports: [PrintComponent, PrintFormComponent],
                    declarations: [PrintComponent, PrintFormComponent]
                }]
        }] });

/**
 * Map search source. For now it has no search capability. All it does
 * is act as a placeholder for the map query results' "search source".
 */
class QuerySearchSource extends SearchSource {
    static id = 'map';
    static type = FEATURE;
    constructor(options) {
        super(options);
    }
    getId() {
        return QuerySearchSource.id;
    }
    getType() {
        return QuerySearchSource.type;
    }
    getDefaultOptions() {
        return {
            title: 'Carte'
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: QuerySearchSource, deps: [{ token: 'options' }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: QuerySearchSource });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: QuerySearchSource, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: ['options']
                }] }]; } });

/**
 * Map search source factory
 * @ignore
 */
function querySearchSourceFactory(config) {
    return new QuerySearchSource(config.getConfig(`searchSources.${QuerySearchSource.id}`) || {});
}
/**
 * Function that returns a provider for the map search source
 */
function provideQuerySearchSource() {
    return {
        provide: SearchSource,
        useFactory: querySearchSourceFactory,
        multi: true,
        deps: [ConfigService]
    };
}

/**
 * This directive makes a map queryable with a click of with a drag box.
 * By default, all layers are queryable but this can ben controlled at
 * the layer level.
 */
class QueryDirective {
    component;
    queryService;
    /**
     * Subscriptions to ongoing queries
     */
    queries$$ = [];
    /**
     * Listener to the map click event
     */
    mapClickListener;
    /**
     * OL drag box interaction
     */
    olDragSelectInteraction;
    /**
     * Ol drag box "end" event key
     */
    olDragSelectInteractionEndKey;
    /**
     * Whter to query features or not
     */
    queryFeatures = false;
    /**
     * Feature query hit tolerance
     */
    queryFeaturesHitTolerance = 0;
    /**
     * Feature query hit tolerance
     */
    queryFeaturesCondition;
    /**
     * Whether all query should complete before emitting an event
     */
    waitForAllQueries = true;
    /**
     * Event emitted when a query (or all queries) complete
     */
    query = new EventEmitter();
    /**
     * IGO map
     * @internal
     */
    get map() {
        return this.component.map;
    }
    constructor(component, queryService) {
        this.component = component;
        this.queryService = queryService;
    }
    /**
     * Start listening to click and drag box events
     * @internal
     */
    ngAfterViewInit() {
        this.listenToMapClick();
        this.addDragBoxInteraction();
    }
    /**
     * Stop listening to click and drag box events and cancel ongoind requests
     * @internal
     */
    ngOnDestroy() {
        this.cancelOngoingQueries();
        this.unlistenToMapClick();
        this.removeDragBoxInteraction();
    }
    /**
     * On map click, issue queries
     */
    listenToMapClick() {
        this.mapClickListener = this.map.ol.on('singleclick', (event) => this.onMapEvent(event));
    }
    /**
     * Stop listening for map clicks
     */
    unlistenToMapClick() {
        unByKey(this.mapClickListener);
        this.mapClickListener = undefined;
    }
    /**
     * Issue queries from a map event and emit events with the results
     * @param event OL map browser pointer event
     */
    onMapEvent(event) {
        this.cancelOngoingQueries();
        if (!this.queryService.queryEnabled) {
            return;
        }
        const queries$ = [];
        if (this.queryFeatures) {
            queries$.push(this.doQueryFeatures(event));
        }
        const resolution = this.map.ol.getView().getResolution();
        const queryLayers = this.map.layers.filter(layerIsQueryable);
        queries$.push(...this.queryService.query(queryLayers, {
            coordinates: event.coordinate,
            projection: this.map.projection,
            resolution
        }));
        if (queries$.length === 0) {
            return;
        }
        if (this.waitForAllQueries) {
            this.queries$$.push(zip(...queries$).subscribe((results) => {
                const features = [].concat(...results);
                this.query.emit({ features, event });
            }));
        }
        else {
            this.queries$$ = queries$.map((query$) => {
                return query$.subscribe((features) => {
                    this.query.emit({ features, event });
                });
            });
        }
    }
    /**
     * Query features already present on the map
     * @param event OL map browser pointer event
     */
    doQueryFeatures(event) {
        const clickedFeatures = [];
        if (event.type === 'singleclick') {
            this.map.ol.forEachFeatureAtPixel(event.pixel, (featureOL, layerOL) => {
                const layer = this.map.getLayerById(layerOL.values_._layer.id);
                if (layer.dataSource.options
                    .queryFormatAsWms) {
                    return;
                }
                if (featureOL) {
                    if (featureOL.get('features')) {
                        for (const feature of featureOL.get('features')) {
                            const newFeature = featureFromOl(feature, this.map.projection);
                            newFeature.meta = {
                                title: feature.values_.nom,
                                id: layerOL.values_._layer.id + '.' + feature.id_,
                                icon: feature.values_._icon,
                                sourceTitle: layerOL.values_.title,
                                alias: this.queryService.getAllowedFieldsAndAlias(layer)
                                // title: this.queryService.getQueryTitle(newFeature, layer) || newFeature.meta.title
                            };
                            clickedFeatures.push(newFeature);
                        }
                    }
                    else if (featureOL instanceof RenderFeature) {
                        const newFeature = renderFeatureFromOl(featureOL, this.map.projection, layerOL);
                        newFeature.meta = {
                            id: layerOL.values_._layer.id + '.' + newFeature.meta.id,
                            sourceTitle: layerOL.values_.title,
                            alias: this.queryService.getAllowedFieldsAndAlias(layer),
                            title: this.queryService.getQueryTitle(newFeature, layer) ||
                                newFeature.meta.title
                        };
                        clickedFeatures.push(newFeature);
                    }
                    else {
                        const newFeature = featureFromOl(featureOL, this.map.projection, layerOL);
                        newFeature.meta = {
                            id: layerOL.values_._layer.id + '.' + newFeature.meta.id,
                            sourceTitle: layerOL.values_.title,
                            alias: this.queryService.getAllowedFieldsAndAlias(layer),
                            title: this.queryService.getQueryTitle(newFeature, layer) ||
                                newFeature.meta.title
                        };
                        clickedFeatures.push(newFeature);
                    }
                }
            }, {
                hitTolerance: this.queryFeaturesHitTolerance || 0,
                layerFilter: this.queryFeaturesCondition
                    ? this.queryFeaturesCondition
                    : olLayerFeatureIsQueryable
            });
        }
        else if (event.type === 'boxend') {
            const target = event.target;
            const dragExtent = target.getGeometry().getExtent();
            this.map.layers
                .filter(layerIsQueryable)
                .filter((layer) => layer instanceof VectorLayer && layer.visible)
                .map((layer) => {
                const featuresOL = layer.dataSource.ol;
                featuresOL.forEachFeatureIntersectingExtent(dragExtent, (olFeature) => {
                    const newFeature = featureFromOl(olFeature, this.map.projection, layer.ol);
                    newFeature.meta = {
                        id: layer.id + '.' + olFeature.getId(),
                        icon: olFeature.values_._icon,
                        sourceTitle: layer.title,
                        alias: this.queryService.getAllowedFieldsAndAlias(layer),
                        title: this.queryService.getQueryTitle(newFeature, layer) ||
                            newFeature.meta.title
                    };
                    clickedFeatures.push(newFeature);
                });
            });
        }
        return of(clickedFeatures);
    }
    /**
     * Cancel ongoing requests, if any
     */
    cancelOngoingQueries() {
        this.queries$$.forEach((sub) => sub.unsubscribe());
        this.queries$$ = [];
    }
    /**
     * Add a drag box interaction and, on drag box end, select features
     */
    addDragBoxInteraction() {
        let olDragSelectInteractionOnQuery;
        const olInteractions = this.map.ol.getInteractions().getArray();
        // There can only be one dragbox interaction, so find the current one, if any
        // Don't keep a reference to the current dragbox because we don't want
        // to remove it when this startegy is deactivated
        for (const olInteraction of olInteractions) {
            if (olInteraction instanceof OlDragSelectInteraction) {
                olDragSelectInteractionOnQuery = olInteraction;
                break;
            }
        }
        // If no drag box interaction is found, create a new one and add it to the map
        if (olDragSelectInteractionOnQuery === undefined) {
            olDragSelectInteractionOnQuery = new OlDragSelectInteraction({
                condition: ctrlKeyDown
            });
            this.map.ol.addInteraction(olDragSelectInteractionOnQuery);
            this.olDragSelectInteraction = olDragSelectInteractionOnQuery;
        }
        this.olDragSelectInteractionEndKey = olDragSelectInteractionOnQuery.on('boxend', (event) => this.onMapEvent(event));
    }
    /**
     * Remove drag box interaction
     */
    removeDragBoxInteraction() {
        if (this.olDragSelectInteractionEndKey !== undefined) {
            unByKey(this.olDragSelectInteractionEndKey);
        }
        if (this.olDragSelectInteraction !== undefined) {
            this.map.ol.removeInteraction(this.olDragSelectInteraction);
        }
        this.olDragSelectInteraction = undefined;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: QueryDirective, deps: [{ token: MapBrowserComponent, self: true }, { token: QueryService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: QueryDirective, selector: "[igoQuery]", inputs: { queryFeatures: "queryFeatures", queryFeaturesHitTolerance: "queryFeaturesHitTolerance", queryFeaturesCondition: "queryFeaturesCondition", waitForAllQueries: "waitForAllQueries" }, outputs: { query: "query" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: QueryDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igoQuery]'
                }]
        }], ctorParameters: function () { return [{ type: MapBrowserComponent, decorators: [{
                    type: Self
                }] }, { type: QueryService }]; }, propDecorators: { queryFeatures: [{
                type: Input
            }], queryFeaturesHitTolerance: [{
                type: Input
            }], queryFeaturesCondition: [{
                type: Input
            }], waitForAllQueries: [{
                type: Input
            }], query: [{
                type: Output
            }] } });

class IgoQueryModule {
    static forRoot() {
        return {
            ngModule: IgoQueryModule,
            providers: [provideQuerySearchSource()]
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoQueryModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoQueryModule, declarations: [QueryDirective], imports: [CommonModule, IgoLanguageModule, IgoMessageModule], exports: [QueryDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoQueryModule, providers: [QueryService], imports: [CommonModule, IgoLanguageModule, IgoMessageModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoQueryModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, IgoLanguageModule, IgoMessageModule],
                    exports: [QueryDirective],
                    declarations: [QueryDirective],
                    providers: [QueryService]
                }]
        }] });

const SEARCH_TYPES = [FEATURE, LAYER];

/**
 * This component allows a user to select a search type yo enable. In it's
 * current version, only one search type can be selected at once (radio). If
 * this component were to support more than one search source enabled (checkbox),
 * the searchbar component would require a small change to it's
 * placeholder getter. The search source service already supports having
 * more than one search source enabled.
 */
class SearchSelectorComponent {
    searchSourceService;
    searchType$ = new BehaviorSubject(undefined);
    /**
     * Subscription to the search type
     */
    searchType$$;
    /**
     * List of available search types
     */
    searchTypes = SEARCH_TYPES;
    /**
     * The search type enabled
     */
    set searchType(value) {
        this.setSearchType(value);
    }
    get searchType() {
        return this.searchType$.value;
    }
    /**
     * Event emitted when the enabled search type changes
     */
    searchTypeChange = new EventEmitter();
    constructor(searchSourceService) {
        this.searchSourceService = searchSourceService;
    }
    ngOnInit() {
        this.searchType$$ = this.searchType$
            .pipe(distinctUntilChanged())
            .subscribe((searchType) => this.onSetSearchType(searchType));
    }
    ngOnDestroy() {
        this.searchType$$.unsubscribe();
    }
    /**
     * Enable the selected search type
     * @param searchType Search type
     * @internal
     */
    onSearchTypeChange(searchType) {
        this.setSearchType(searchType);
    }
    /**
     * Get a search type's title. The title
     * for all availables search typers needs to be defined in the locale
     * files or an error will be thrown.
     * @param searchType Search type
     * @internal
     */
    getSearchTypeTitle(searchType) {
        return `igo.geo.search.${searchType.toLowerCase()}.title`;
    }
    /**
     * Emit an event and enable the search sources of the given type.
     * @param searchType Search type
     */
    setSearchType(searchType) {
        this.searchType$.next(searchType);
    }
    onSetSearchType(searchType) {
        if (searchType === undefined || searchType === null) {
            return;
        }
        this.searchSourceService.enableSourcesByType(searchType);
        this.searchTypeChange.emit(searchType);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SearchSelectorComponent, deps: [{ token: SearchSourceService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: SearchSelectorComponent, selector: "igo-search-selector", inputs: { searchTypes: "searchTypes", searchType: "searchType" }, outputs: { searchTypeChange: "searchTypeChange" }, ngImport: i0, template: "<div class=\"igo-search-selector\">\n  <button\n    mat-icon-button\n    class=\"igo-search-selector-button\"\n    color=\"primary\"\n    tooltip-position=\"below\"\n    matTooltipShowDelay=\"500\"\n    [matTooltip]=\"'igo.geo.search.menu.tooltip' | translate\"\n    [matMenuTriggerFor]=\"searchSelectorMenu\"\n  >\n    <mat-icon svgIcon=\"menu-down\"></mat-icon>\n  </button>\n\n  <mat-menu\n    #searchSelectorMenu=\"matMenu\"\n    class=\"no-border-radius\"\n    xPosition=\"before\"\n    yPosition=\"above\"\n  >\n    <mat-radio-group\n      class=\"igo-search-selector-radio-group\"\n      [value]=\"searchType$ | async\"\n      (change)=\"onSearchTypeChange($event.value)\"\n    >\n      <mat-radio-button\n        *ngFor=\"let searchType of searchTypes\"\n        [value]=\"searchType\"\n      >\n        {{ getSearchTypeTitle(searchType) | translate }}\n      </mat-radio-button>\n    </mat-radio-group>\n  </mat-menu>\n</div>\n", styles: [":host .igo-search-selector-button{border-radius:0}:host .igo-search-selector-button button{border-radius:0!important}:host .igo-search-selector-button button .mat-ripple,:host .igo-search-selector-button button .mdc-icon-button__ripple{border-radius:0!important}:host .igo-search-selector-radio-group{display:inline-flex;flex-direction:column}:host .igo-search-selector-radio-group mat-radio-button{margin:5px}\n"], dependencies: [{ kind: "directive", type: i2$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "component", type: i7$1.MatMenu, selector: "mat-menu", exportAs: ["matMenu"] }, { kind: "directive", type: i7$1.MatMenuTrigger, selector: "[mat-menu-trigger-for], [matMenuTriggerFor]", exportAs: ["matMenuTrigger"] }, { kind: "directive", type: i8$2.MatRadioGroup, selector: "mat-radio-group", exportAs: ["matRadioGroup"] }, { kind: "component", type: i8$2.MatRadioButton, selector: "mat-radio-button", inputs: ["disableRipple", "tabIndex"], exportAs: ["matRadioButton"] }, { kind: "pipe", type: i2$2.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SearchSelectorComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-search-selector', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div class=\"igo-search-selector\">\n  <button\n    mat-icon-button\n    class=\"igo-search-selector-button\"\n    color=\"primary\"\n    tooltip-position=\"below\"\n    matTooltipShowDelay=\"500\"\n    [matTooltip]=\"'igo.geo.search.menu.tooltip' | translate\"\n    [matMenuTriggerFor]=\"searchSelectorMenu\"\n  >\n    <mat-icon svgIcon=\"menu-down\"></mat-icon>\n  </button>\n\n  <mat-menu\n    #searchSelectorMenu=\"matMenu\"\n    class=\"no-border-radius\"\n    xPosition=\"before\"\n    yPosition=\"above\"\n  >\n    <mat-radio-group\n      class=\"igo-search-selector-radio-group\"\n      [value]=\"searchType$ | async\"\n      (change)=\"onSearchTypeChange($event.value)\"\n    >\n      <mat-radio-button\n        *ngFor=\"let searchType of searchTypes\"\n        [value]=\"searchType\"\n      >\n        {{ getSearchTypeTitle(searchType) | translate }}\n      </mat-radio-button>\n    </mat-radio-group>\n  </mat-menu>\n</div>\n", styles: [":host .igo-search-selector-button{border-radius:0}:host .igo-search-selector-button button{border-radius:0!important}:host .igo-search-selector-button button .mat-ripple,:host .igo-search-selector-button button .mdc-icon-button__ripple{border-radius:0!important}:host .igo-search-selector-radio-group{display:inline-flex;flex-direction:column}:host .igo-search-selector-radio-group mat-radio-button{margin:5px}\n"] }]
        }], ctorParameters: function () { return [{ type: SearchSourceService }]; }, propDecorators: { searchTypes: [{
                type: Input
            }], searchType: [{
                type: Input
            }], searchTypeChange: [{
                type: Output
            }] } });

/**
 * @ignore
 */
class IgoSearchSelectorModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoSearchSelectorModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoSearchSelectorModule, declarations: [SearchSelectorComponent], imports: [CommonModule,
            MatTooltipModule,
            MatIconModule,
            MatButtonModule,
            MatMenuModule,
            MatRadioModule,
            MatTabsModule,
            MatCheckboxModule,
            IgoLanguageModule], exports: [SearchSelectorComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoSearchSelectorModule, imports: [CommonModule,
            MatTooltipModule,
            MatIconModule,
            MatButtonModule,
            MatMenuModule,
            MatRadioModule,
            MatTabsModule,
            MatCheckboxModule,
            IgoLanguageModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoSearchSelectorModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        MatTooltipModule,
                        MatIconModule,
                        MatButtonModule,
                        MatMenuModule,
                        MatRadioModule,
                        MatTabsModule,
                        MatCheckboxModule,
                        IgoLanguageModule
                    ],
                    exports: [SearchSelectorComponent],
                    declarations: [SearchSelectorComponent]
                }]
        }] });

/**
 * This component allows a user to select a search type yo enable. In it's
 * current version, only one search type can be selected at once (radio). If
 * this component were to support more than one search source enabled (checkbox),
 * the searchbar component would require a small change to it's
 * placeholder getter. The search source service already supports having
 * more than one search source enabled.
 */
class SearchSettingsComponent {
    searchSourceService;
    mediaService;
    storageService;
    hasPointerReverseSearchSource = false;
    searchSourcesAllEnabled = false;
    buffer = [];
    lastKeyTime = Date.now();
    displayBlock = 'block';
    get isTouchScreen() {
        return this.mediaService.isTouchScreen();
    }
    pointerSummaryEnabled = false;
    searchResultsGeometryEnabled = false;
    reverseSearchCoordsFormatEnabled = false;
    /**
     * Event emitted when the enabled search source changes
     */
    searchSourceChange = new EventEmitter();
    /**
     * Event emitted when the pointer summary is activated
     */
    pointerSummaryStatus = new EventEmitter();
    /**
     * Event emitted when the show geometry summary is changed
     */
    searchResultsGeometryStatus = new EventEmitter();
    /**
     * Event emitted when the coords format is changed
     */
    reverseSearchCoordsFormatStatus = new EventEmitter();
    handleKeyboardEvent(event) {
        if (event.key === 'F2') {
            this.pointerSummaryEnabled = !this.pointerSummaryEnabled;
            this.pointerSummaryStatus.emit(this.pointerSummaryEnabled);
        }
    }
    constructor(searchSourceService, mediaService, storageService) {
        this.searchSourceService = searchSourceService;
        this.mediaService = mediaService;
        this.storageService = storageService;
    }
    ngOnInit() {
        this.hasPointerReverseSearchSource =
            this.hasReverseSearchSourcesForPointerSummary();
    }
    /**
     * Get all search sources
     * @internal
     */
    getSearchSources() {
        const textSearchSources = this.searchSourceService
            .getSources()
            .filter(sourceCanSearch)
            .filter((s) => s.available && s.getId() !== 'map' && s.showInSettings);
        const reverseSearchSources = this.searchSourceService
            .getSources()
            .filter(sourceCanReverseSearch)
            .filter((s) => s.available && s.getId() !== 'map' && s.showInSettings);
        const sources = textSearchSources.concat(reverseSearchSources);
        this.computeSourcesCheckAllBehavior(sources);
        return sources;
    }
    /**
     * Get all search sources usable for pointer summary
     * @internal
     */
    hasReverseSearchSourcesForPointerSummary() {
        if (this.searchSourceService
            .getEnabledSources()
            .filter(sourceCanReverseSearchAsSummary).length) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Triggered when a setting is checked (checkbox style)
     * @internal
     */
    settingsValueCheckedCheckbox(event, source, setting, settingValue) {
        settingValue.enabled = event.checked;
        source.setParamFromSetting(setting);
        this.searchSourceChange.emit(source);
    }
    /**
     * Defining the action to do for check/uncheck checkboxes (settings)
     * return true if all checkbox must be checked
     * return false if all checkbox must be unchecked
     * @internal
     */
    computeSettingCheckAllBehavior(setting) {
        if (setting.allEnabled === undefined) {
            if (setting.values.find((settingValue) => settingValue.enabled)) {
                setting.allEnabled = false;
            }
            else {
                setting.allEnabled = true;
            }
        }
        else {
            setting.allEnabled = !setting.allEnabled;
        }
    }
    /**
     * Defining the action to do for check/uncheck checkboxes (sources)
     * return true if all checkbox must be checked
     * return false if all checkbox must be unchecked
     * @internal
     */
    computeSourcesCheckAllBehavior(sources) {
        const enabledSourcesCnt = sources.filter((source) => source.enabled).length;
        const disabledSourcesCnt = sources.filter((source) => !source.enabled).length;
        this.searchSourcesAllEnabled =
            enabledSourcesCnt >= disabledSourcesCnt ? false : true;
    }
    /**
     * Triggered when the check all / uncheck all type is clicked,
     * @internal
     */
    checkUncheckAll(event, source, setting) {
        event.stopPropagation();
        this.computeSettingCheckAllBehavior(setting);
        setting.values.forEach((settingValue) => {
            settingValue.enabled = setting.allEnabled;
        });
        source.setParamFromSetting(setting);
        this.searchSourceChange.emit(source);
    }
    /**
     * Triggered when the check all / uncheck all type is clicked,
     * @internal
     */
    checkUncheckAllSources(event) {
        event.stopPropagation();
        this.getSearchSources().map((source) => {
            source.enabled = this.searchSourcesAllEnabled;
            this.searchSourceChange.emit(source);
        });
    }
    /**
     * Triggered when a setting is checked (radiobutton style)
     * @internal
     */
    settingsValueCheckedRadioButton(event, source, setting, settingValue) {
        setting.values.forEach((conf) => {
            if (conf.value !== settingValue.value) {
                conf.enabled = !event.source.checked;
            }
            else {
                conf.enabled = event.source.checked;
            }
        });
        source.setParamFromSetting(setting);
        this.searchSourceChange.emit(source);
    }
    onCheckSearchSource(event, source) {
        source.enabled = event.checked;
        const storage = (this.storageService.get(source.getId() + '.options') ||
            {});
        storage.enabled = source.enabled;
        this.storageService.set(source.getId() + '.options', storage);
        this.searchSourceChange.emit(source);
    }
    getAvailableValues(setting) {
        return setting.values.filter((s) => s.available !== false);
    }
    getAvailableHashtagsValues(setting) {
        if (setting.hashtags) {
            return setting.hashtags.map((h) => '#' + h).join(', ');
        }
        return;
    }
    stopPropagation(event) {
        event.stopPropagation();
    }
    changePointerReverseSearch(event) {
        this.pointerSummaryEnabled = event.checked;
        this.pointerSummaryStatus.emit(this.pointerSummaryEnabled);
    }
    changeSearchResultsGeometry(event) {
        this.searchResultsGeometryEnabled = event.checked;
        this.searchResultsGeometryStatus.emit(this.searchResultsGeometryEnabled);
    }
    reverseSearchCoordsFormat(event) {
        this.reverseSearchCoordsFormatEnabled = event.checked;
        this.reverseSearchCoordsFormatStatus.emit(this.reverseSearchCoordsFormatEnabled);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SearchSettingsComponent, deps: [{ token: SearchSourceService }, { token: i2.MediaService }, { token: i2.StorageService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: SearchSettingsComponent, selector: "igo-search-settings", inputs: { pointerSummaryEnabled: "pointerSummaryEnabled", searchResultsGeometryEnabled: "searchResultsGeometryEnabled", reverseSearchCoordsFormatEnabled: "reverseSearchCoordsFormatEnabled" }, outputs: { searchSourceChange: "searchSourceChange", pointerSummaryStatus: "pointerSummaryStatus", searchResultsGeometryStatus: "searchResultsGeometryStatus", reverseSearchCoordsFormatStatus: "reverseSearchCoordsFormatStatus" }, host: { listeners: { "document:keydown": "handleKeyboardEvent($event)" } }, ngImport: i0, template: "<div class=\"igo-search-settings\">\n  <button\n    mat-icon-button\n    class=\"igo-search-settings-button\"\n    color=\"primary\"\n    tooltip-position=\"below\"\n    matTooltipShowDelay=\"500\"\n    [matTooltip]=\"'igo.geo.search.menu.tooltip' | translate\"\n    [matMenuTriggerFor]=\"searchSettingsMenu\"\n  >\n    <mat-icon svgIcon=\"chevron-down\"></mat-icon>\n  </button>\n  <mat-menu #searchSettingsMenu=\"matMenu\" class=\"no-border-radius\">\n    <div class=\"checkAllButton\" *ngIf=\"getSearchSources().length > 4\">\n      <button mat-raised-button (click)=\"checkUncheckAllSources($event)\">\n        {{\n          !searchSourcesAllEnabled\n            ? ('igo.geo.search.searchSources.unselectAll' | translate)\n            : ('igo.geo.search.searchSources.selectAll' | translate)\n        }}\n      </button>\n    </div>\n    <ng-container *ngFor=\"let source of getSearchSources()\">\n      <span class=\"igo-search-settings-search-source\">\n        <mat-checkbox\n          class=\"igo-search-settings-checkbox\"\n          [checked]=\"source.enabled\"\n          [value]=\"source\"\n          (click)=\"$event.stopPropagation()\"\n          (change)=\"onCheckSearchSource($event, source)\"\n        >\n        </mat-checkbox>\n        <button\n          *ngIf=\"source.settings.length > 0\"\n          [matMenuTriggerFor]=\"sub_menu\"\n          mat-menu-item\n        >\n          {{ source.title }}\n        </button>\n        <button mat-menu-item *ngIf=\"source.settings.length === 0\">\n          {{ source.title }}\n        </button>\n      </span>\n      <mat-menu #sub_menu=\"matMenu\">\n        <ng-container *ngFor=\"let setting of source.settings\">\n          <button mat-menu-item [matMenuTriggerFor]=\"test_sub_menu\">\n            {{\n              'igo.geo.search.searchSources.settings.' + setting.title\n                | translate\n            }}\n          </button>\n          <mat-menu\n            #test_sub_menu=\"matMenu\"\n            [ngSwitch]=\"setting.type\"\n            yPosition=\"above\"\n          >\n            <span *ngSwitchCase=\"'radiobutton'\">\n              <mat-radio-group\n                class=\"igo-search-settings-radio-group\"\n                [value]=\"setting\"\n              >\n                <mat-radio-button\n                  *ngFor=\"let settingValue of setting.values\"\n                  class=\"mat-typography\"\n                  [value]=\"settingValue\"\n                  [matTooltip]=\"getAvailableHashtagsValues(settingValue)\"\n                  [checked]=\"settingValue.enabled\"\n                  (click)=\"$event.stopPropagation()\"\n                  (change)=\"\n                    settingsValueCheckedRadioButton(\n                      $event,\n                      source,\n                      setting,\n                      settingValue\n                    )\n                  \"\n                >\n                  {{ settingValue.title | translate }}\n                </mat-radio-button>\n              </mat-radio-group>\n            </span>\n            <span *ngSwitchCase=\"'checkbox'\">\n              <div class=\"checkAllButton\" *ngIf=\"setting.values.length > 3\">\n                <button\n                  mat-raised-button\n                  (click)=\"checkUncheckAll($event, source, setting)\"\n                >\n                  {{\n                    setting.allEnabled || setting.allEnabled === undefined\n                      ? ('igo.geo.search.searchSources.settings.unselectAll'\n                        | translate)\n                      : ('igo.geo.search.searchSources.settings.selectAll'\n                        | translate)\n                  }}\n                </button>\n              </div>\n              <div\n                class=\"igo-search-settings-sub-menu\"\n                mat-menu-item\n                *ngFor=\"let settingValue of getAvailableValues(setting)\"\n              >\n                <mat-checkbox\n                  [style.display]=\"displayBlock\"\n                  [checked]=\"settingValue.enabled\"\n                  [value]=\"setting\"\n                  [matTooltip]=\"getAvailableHashtagsValues(settingValue)\"\n                  (click)=\"$event.stopPropagation()\"\n                  (change)=\"\n                    settingsValueCheckedCheckbox(\n                      $event,\n                      source,\n                      setting,\n                      settingValue\n                    )\n                  \"\n                >\n                  {{ settingValue.title | translate }}\n                </mat-checkbox>\n              </div>\n            </span>\n          </mat-menu>\n        </ng-container>\n      </mat-menu>\n    </ng-container>\n    <mat-divider></mat-divider>\n    <span class=\"pointer-summary-slide-toggle-container\">\n      <div mat-menu-item>\n        <mat-slide-toggle\n          class=\"search-option\"\n          (change)=\"changePointerReverseSearch($event)\"\n          tooltip-position=\"below\"\n          *ngIf=\"hasPointerReverseSearchSource && !isTouchScreen\"\n          matTooltipShowDelay=\"500\"\n          [matTooltip]=\"\n            'igo.geo.search.pointerSearchSummary.tooltip' | translate\n          \"\n          (click)=\"$event.stopPropagation()\"\n          [checked]=\"pointerSummaryEnabled\"\n        >\n          {{ 'igo.geo.search.pointerSearchSummary.title' | translate }}\n        </mat-slide-toggle>\n      </div>\n      <div mat-menu-item>\n        <mat-slide-toggle\n          class=\"search-option\"\n          (change)=\"changeSearchResultsGeometry($event)\"\n          tooltip-position=\"below\"\n          matTooltipShowDelay=\"500\"\n          [matTooltip]=\"\n            'igo.geo.search.searchResultsGeometry.tooltip' | translate\n          \"\n          (click)=\"$event.stopPropagation()\"\n          [checked]=\"searchResultsGeometryEnabled\"\n        >\n          {{ 'igo.geo.search.searchResultsGeometry.title' | translate }}\n        </mat-slide-toggle>\n      </div>\n      <div mat-menu-item>\n        <mat-slide-toggle\n          class=\"search-option\"\n          (change)=\"reverseSearchCoordsFormat($event)\"\n          tooltip-position=\"below\"\n          matTooltipShowDelay=\"500\"\n          [matTooltip]=\"\n            reverseSearchCoordsFormatEnabled\n              ? ('igo.geo.search.reverseCoordFormat.tooltipLatLon' | translate)\n              : ('igo.geo.search.reverseCoordFormat.tooltipLonLat' | translate)\n          \"\n          (click)=\"$event.stopPropagation()\"\n          [checked]=\"reverseSearchCoordsFormatEnabled\"\n        >\n          {{ 'igo.geo.search.reverseCoordFormat.title' | translate }}\n        </mat-slide-toggle>\n      </div>\n    </span>\n  </mat-menu>\n</div>\n", styles: [":host{display:flex;align-items:center}.checkAllButton{text-align:center;padding:0 5px}.igo-search-settings-radio-group{display:flex;flex-direction:column;padding-right:16px}.igo-search-settings-checkbox mat-radio-button{display:flex}.igo-search-settings-search-source{display:flex;width:100%}.igo-search-settings-search-source mat-checkbox{display:flex;margin-left:5px;margin-right:5px}.search-option{display:block;margin-right:10px;margin-bottom:15px}.pointer-summary-slide-toggle-container{overflow-x:hidden}.pointer-summary-slide-toggle-container mat-slide-toggle{margin:10px 0}.igo-search-settings-button button,.igo-search-settings-button button .mat-ripple,.igo-search-settings-button button .mdc-icon-button__ripple{border-radius:0!important}.igo-search-settings-sub-menu{min-height:34px}\n"], dependencies: [{ kind: "directive", type: i2$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2$2.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { kind: "directive", type: i2$2.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i4$1.MatButton, selector: "    button[mat-button], button[mat-raised-button], button[mat-flat-button],    button[mat-stroked-button]  ", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "component", type: i7$1.MatMenu, selector: "mat-menu", exportAs: ["matMenu"] }, { kind: "component", type: i7$1.MatMenuItem, selector: "[mat-menu-item]", inputs: ["disabled", "disableRipple", "role"], exportAs: ["matMenuItem"] }, { kind: "directive", type: i7$1.MatMenuTrigger, selector: "[mat-menu-trigger-for], [matMenuTriggerFor]", exportAs: ["matMenuTrigger"] }, { kind: "directive", type: i8$2.MatRadioGroup, selector: "mat-radio-group", exportAs: ["matRadioGroup"] }, { kind: "component", type: i8$2.MatRadioButton, selector: "mat-radio-button", inputs: ["disableRipple", "tabIndex"], exportAs: ["matRadioButton"] }, { kind: "component", type: i11.MatCheckbox, selector: "mat-checkbox", inputs: ["disableRipple", "color", "tabIndex"], exportAs: ["matCheckbox"] }, { kind: "component", type: i9$2.MatDivider, selector: "mat-divider", inputs: ["vertical", "inset"] }, { kind: "component", type: i7.MatSlideToggle, selector: "mat-slide-toggle", inputs: ["disabled", "disableRipple", "color", "tabIndex"], exportAs: ["matSlideToggle"] }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SearchSettingsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-search-settings', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div class=\"igo-search-settings\">\n  <button\n    mat-icon-button\n    class=\"igo-search-settings-button\"\n    color=\"primary\"\n    tooltip-position=\"below\"\n    matTooltipShowDelay=\"500\"\n    [matTooltip]=\"'igo.geo.search.menu.tooltip' | translate\"\n    [matMenuTriggerFor]=\"searchSettingsMenu\"\n  >\n    <mat-icon svgIcon=\"chevron-down\"></mat-icon>\n  </button>\n  <mat-menu #searchSettingsMenu=\"matMenu\" class=\"no-border-radius\">\n    <div class=\"checkAllButton\" *ngIf=\"getSearchSources().length > 4\">\n      <button mat-raised-button (click)=\"checkUncheckAllSources($event)\">\n        {{\n          !searchSourcesAllEnabled\n            ? ('igo.geo.search.searchSources.unselectAll' | translate)\n            : ('igo.geo.search.searchSources.selectAll' | translate)\n        }}\n      </button>\n    </div>\n    <ng-container *ngFor=\"let source of getSearchSources()\">\n      <span class=\"igo-search-settings-search-source\">\n        <mat-checkbox\n          class=\"igo-search-settings-checkbox\"\n          [checked]=\"source.enabled\"\n          [value]=\"source\"\n          (click)=\"$event.stopPropagation()\"\n          (change)=\"onCheckSearchSource($event, source)\"\n        >\n        </mat-checkbox>\n        <button\n          *ngIf=\"source.settings.length > 0\"\n          [matMenuTriggerFor]=\"sub_menu\"\n          mat-menu-item\n        >\n          {{ source.title }}\n        </button>\n        <button mat-menu-item *ngIf=\"source.settings.length === 0\">\n          {{ source.title }}\n        </button>\n      </span>\n      <mat-menu #sub_menu=\"matMenu\">\n        <ng-container *ngFor=\"let setting of source.settings\">\n          <button mat-menu-item [matMenuTriggerFor]=\"test_sub_menu\">\n            {{\n              'igo.geo.search.searchSources.settings.' + setting.title\n                | translate\n            }}\n          </button>\n          <mat-menu\n            #test_sub_menu=\"matMenu\"\n            [ngSwitch]=\"setting.type\"\n            yPosition=\"above\"\n          >\n            <span *ngSwitchCase=\"'radiobutton'\">\n              <mat-radio-group\n                class=\"igo-search-settings-radio-group\"\n                [value]=\"setting\"\n              >\n                <mat-radio-button\n                  *ngFor=\"let settingValue of setting.values\"\n                  class=\"mat-typography\"\n                  [value]=\"settingValue\"\n                  [matTooltip]=\"getAvailableHashtagsValues(settingValue)\"\n                  [checked]=\"settingValue.enabled\"\n                  (click)=\"$event.stopPropagation()\"\n                  (change)=\"\n                    settingsValueCheckedRadioButton(\n                      $event,\n                      source,\n                      setting,\n                      settingValue\n                    )\n                  \"\n                >\n                  {{ settingValue.title | translate }}\n                </mat-radio-button>\n              </mat-radio-group>\n            </span>\n            <span *ngSwitchCase=\"'checkbox'\">\n              <div class=\"checkAllButton\" *ngIf=\"setting.values.length > 3\">\n                <button\n                  mat-raised-button\n                  (click)=\"checkUncheckAll($event, source, setting)\"\n                >\n                  {{\n                    setting.allEnabled || setting.allEnabled === undefined\n                      ? ('igo.geo.search.searchSources.settings.unselectAll'\n                        | translate)\n                      : ('igo.geo.search.searchSources.settings.selectAll'\n                        | translate)\n                  }}\n                </button>\n              </div>\n              <div\n                class=\"igo-search-settings-sub-menu\"\n                mat-menu-item\n                *ngFor=\"let settingValue of getAvailableValues(setting)\"\n              >\n                <mat-checkbox\n                  [style.display]=\"displayBlock\"\n                  [checked]=\"settingValue.enabled\"\n                  [value]=\"setting\"\n                  [matTooltip]=\"getAvailableHashtagsValues(settingValue)\"\n                  (click)=\"$event.stopPropagation()\"\n                  (change)=\"\n                    settingsValueCheckedCheckbox(\n                      $event,\n                      source,\n                      setting,\n                      settingValue\n                    )\n                  \"\n                >\n                  {{ settingValue.title | translate }}\n                </mat-checkbox>\n              </div>\n            </span>\n          </mat-menu>\n        </ng-container>\n      </mat-menu>\n    </ng-container>\n    <mat-divider></mat-divider>\n    <span class=\"pointer-summary-slide-toggle-container\">\n      <div mat-menu-item>\n        <mat-slide-toggle\n          class=\"search-option\"\n          (change)=\"changePointerReverseSearch($event)\"\n          tooltip-position=\"below\"\n          *ngIf=\"hasPointerReverseSearchSource && !isTouchScreen\"\n          matTooltipShowDelay=\"500\"\n          [matTooltip]=\"\n            'igo.geo.search.pointerSearchSummary.tooltip' | translate\n          \"\n          (click)=\"$event.stopPropagation()\"\n          [checked]=\"pointerSummaryEnabled\"\n        >\n          {{ 'igo.geo.search.pointerSearchSummary.title' | translate }}\n        </mat-slide-toggle>\n      </div>\n      <div mat-menu-item>\n        <mat-slide-toggle\n          class=\"search-option\"\n          (change)=\"changeSearchResultsGeometry($event)\"\n          tooltip-position=\"below\"\n          matTooltipShowDelay=\"500\"\n          [matTooltip]=\"\n            'igo.geo.search.searchResultsGeometry.tooltip' | translate\n          \"\n          (click)=\"$event.stopPropagation()\"\n          [checked]=\"searchResultsGeometryEnabled\"\n        >\n          {{ 'igo.geo.search.searchResultsGeometry.title' | translate }}\n        </mat-slide-toggle>\n      </div>\n      <div mat-menu-item>\n        <mat-slide-toggle\n          class=\"search-option\"\n          (change)=\"reverseSearchCoordsFormat($event)\"\n          tooltip-position=\"below\"\n          matTooltipShowDelay=\"500\"\n          [matTooltip]=\"\n            reverseSearchCoordsFormatEnabled\n              ? ('igo.geo.search.reverseCoordFormat.tooltipLatLon' | translate)\n              : ('igo.geo.search.reverseCoordFormat.tooltipLonLat' | translate)\n          \"\n          (click)=\"$event.stopPropagation()\"\n          [checked]=\"reverseSearchCoordsFormatEnabled\"\n        >\n          {{ 'igo.geo.search.reverseCoordFormat.title' | translate }}\n        </mat-slide-toggle>\n      </div>\n    </span>\n  </mat-menu>\n</div>\n", styles: [":host{display:flex;align-items:center}.checkAllButton{text-align:center;padding:0 5px}.igo-search-settings-radio-group{display:flex;flex-direction:column;padding-right:16px}.igo-search-settings-checkbox mat-radio-button{display:flex}.igo-search-settings-search-source{display:flex;width:100%}.igo-search-settings-search-source mat-checkbox{display:flex;margin-left:5px;margin-right:5px}.search-option{display:block;margin-right:10px;margin-bottom:15px}.pointer-summary-slide-toggle-container{overflow-x:hidden}.pointer-summary-slide-toggle-container mat-slide-toggle{margin:10px 0}.igo-search-settings-button button,.igo-search-settings-button button .mat-ripple,.igo-search-settings-button button .mdc-icon-button__ripple{border-radius:0!important}.igo-search-settings-sub-menu{min-height:34px}\n"] }]
        }], ctorParameters: function () { return [{ type: SearchSourceService }, { type: i2.MediaService }, { type: i2.StorageService }]; }, propDecorators: { pointerSummaryEnabled: [{
                type: Input
            }], searchResultsGeometryEnabled: [{
                type: Input
            }], reverseSearchCoordsFormatEnabled: [{
                type: Input
            }], searchSourceChange: [{
                type: Output
            }], pointerSummaryStatus: [{
                type: Output
            }], searchResultsGeometryStatus: [{
                type: Output
            }], reverseSearchCoordsFormatStatus: [{
                type: Output
            }], handleKeyboardEvent: [{
                type: HostListener,
                args: ['document:keydown', ['$event']]
            }] } });

/**
 * @ignore
 */
class IgoSearchSettingsModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoSearchSettingsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoSearchSettingsModule, declarations: [SearchSettingsComponent], imports: [CommonModule,
            MatTooltipModule,
            MatIconModule,
            MatButtonModule,
            MatMenuModule,
            MatRadioModule,
            MatCheckboxModule,
            MatDividerModule,
            MatSlideToggleModule,
            IgoLanguageModule], exports: [SearchSettingsComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoSearchSettingsModule, imports: [CommonModule,
            MatTooltipModule,
            MatIconModule,
            MatButtonModule,
            MatMenuModule,
            MatRadioModule,
            MatCheckboxModule,
            MatDividerModule,
            MatSlideToggleModule,
            IgoLanguageModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoSearchSettingsModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [SearchSettingsComponent],
                    imports: [
                        CommonModule,
                        MatTooltipModule,
                        MatIconModule,
                        MatButtonModule,
                        MatMenuModule,
                        MatRadioModule,
                        MatCheckboxModule,
                        MatDividerModule,
                        MatSlideToggleModule,
                        IgoLanguageModule
                    ],
                    exports: [SearchSettingsComponent]
                }]
        }] });

/**
 * Searchbar that triggers a research in all search sources enabled.
 * If the store input is defined, the search results will be loaded
 * into that store. An event is always emitted when a research is completed.
 */
class SearchBarComponent {
    configService;
    searchService;
    searchSourceService;
    /**
     * Invalid keys
     */
    static invalidKeys = [
        'Control',
        'Shift',
        'Alt',
        'ArrowDown',
        'ArrowUp',
        'ArrowRight',
        'ArrowLeft'
    ];
    placeholder$ = new BehaviorSubject('igo.geo.search.placeholder');
    empty$ = new BehaviorSubject(true);
    /**
     * Subscription to the ssearch bar term
     */
    term$$;
    /**
     * Search term stream
     */
    stream$ = new BehaviorSubject('');
    /**
     * Subscription to the search term stream
     */
    stream$$;
    /**
     * Subscription to the search type
     */
    searchType$$;
    researches$$;
    /**
     * whether to show search button or not
     */
    showSearchButton = false;
    /**
     * List of available search types
     */
    searchTypes = SEARCH_TYPES;
    withDivider;
    /**
     * Search term
     */
    set searchType(value) {
        this.setSearchType(value);
    }
    get searchType() {
        return this.searchType$.value;
    }
    searchType$ = new BehaviorSubject(undefined);
    /**
     * Event emitted when the pointer summary is activated by the searchbar setting
     */
    pointerSummaryStatus = new EventEmitter();
    /**
     * Event emitted when the show geometry setting is changed
     */
    searchResultsGeometryStatus = new EventEmitter();
    /**
     * Event emitted when the coords format setting is changed
     */
    reverseSearchCoordsFormatStatus = new EventEmitter();
    /**
     * Search term
     */
    set term(value) {
        this.setTerm(value);
    }
    get term() {
        return this.term$.value;
    }
    term$ = new BehaviorSubject('');
    /**
     * Whether this component is disabled
     */
    set disabled(value) {
        this.disabled$.next(value);
    }
    get disabled() {
        return this.disabled$.value;
    }
    disabled$ = new BehaviorSubject(false);
    pointerSummaryEnabled = false;
    searchResultsGeometryEnabled = false;
    /**
     * When reverse coordinates status change
     */
    get reverseSearchCoordsFormatEnabled() {
        return this._reverseSearchCoordsFormatEnabled;
    }
    set reverseSearchCoordsFormatEnabled(value) {
        this._reverseSearchCoordsFormatEnabled = value;
        this.setTerm(this.term, true);
    }
    _reverseSearchCoordsFormatEnabled = false;
    /**
     * Whether a float label should be displayed
     */
    floatLabel = 'auto';
    appearance = 'fill';
    placeholder;
    label;
    /**
     * Icons color (search and clear)
     */
    color = 'primary';
    termSplitter = '|';
    /**
     * Debounce time between each keystroke
     */
    debounce = 200;
    /**
     * Minimum term length required to trigger a research
     */
    minLength = 2;
    /**
     * Search Selector
     */
    searchSelector = false;
    /**
     * Search Settings
     */
    searchSettings = false;
    /**
     * Force coordinates in north america
     */
    forceNA = false;
    /**
     * Search results store
     */
    store;
    /**
     * Event emitted when the search term changes
     */
    searchTermChange = new EventEmitter();
    /**
     * Event emitted when a research is completed
     */
    search = new EventEmitter();
    /**
     * Event emitted when the search type changes
     */
    searchTypeChange = new EventEmitter();
    /**
     * Event emitted when the search type changes
     */
    clearFeature = new EventEmitter();
    /**
     * Event emitted when the search settings changes
     */
    searchSettingsChange = new EventEmitter();
    /**
     * Input element
     * @internal
     */
    input;
    /**
     * Whether the search bar is empty
     * @internal
     */
    get empty() {
        return this.term.length === 0;
    }
    constructor(configService, searchService, searchSourceService) {
        this.configService = configService;
        this.searchService = searchService;
        this.searchSourceService = searchSourceService;
    }
    /**
     * Subscribe to the search term stream and trigger researches
     * @internal
     */
    ngOnInit() {
        this.term$$ = this.term$.subscribe((term) => {
            this.empty$.next(term === undefined || term.length === 0);
        });
        this.stream$$ = this.stream$
            .pipe(debounce(() => timer(this.debounce)))
            .subscribe((term) => this.onSetTerm(term));
        this.handlePlaceholder();
        this.searchType$$ = this.searchType$
            .pipe(distinctUntilChanged())
            .subscribe((searchType) => this.onSetSearchType(searchType));
        const configValue = this.configService.getConfig('searchBar.showSearchButton');
        this.showSearchButton = configValue !== undefined ? configValue : false;
    }
    /**
     * Unsubscribe to the search term stream
     * @internal
     */
    ngOnDestroy() {
        this.term$$.unsubscribe();
        this.stream$$.unsubscribe();
        this.searchType$$.unsubscribe();
    }
    /**
     * When a user types, validates the key and send it into the
     * stream if it's valid
     * @param event Keyboard event
     * @internal
     */
    onKeyup(event) {
        const key = event.key;
        if (!this.keyIsValid(key)) {
            return;
        }
        const term = event.target.value;
        this.setTerm(term);
    }
    /**
     * Clear the stream and the input
     * @internal
     */
    onClearButtonClick() {
        this.clear();
        this.clearFeature.emit();
    }
    /**
     * Update search type
     * @param searchType Enabled search type
     * @internal
     */
    onSearchTypeChange(searchType) {
        this.setSearchType(searchType);
    }
    /**
     * Update the placeholder with the enabled search type. The placeholder
     * for all availables search typers needs to be defined in the locale
     * files or an error will be thrown.
     * @param searchType Enabled search type
     * @internal
     */
    setSearchType(searchType) {
        this.searchType$.next(searchType);
    }
    onSearchSettingsChange() {
        this.doSearch(this.term);
        this.searchSettingsChange.emit();
        this.handlePlaceholder();
    }
    /**
     * Send the term into the stream only if this component is not disabled
     * @param term Search term
     */
    setTerm(term, reverseCoordEvent) {
        if (this.disabled) {
            return;
        }
        term = term || '';
        if (term !== this.term && !reverseCoordEvent) {
            this.term$.next(term);
        }
        const slug = term.replace(/(#[^\s]*)/g, '').trim();
        if (slug.length >= this.minLength || slug.length === 0) {
            this.stream$.next(term);
        }
    }
    /**
     * Clear the stream and the input
     */
    clear() {
        this.term$.next('');
        this.stream$.next('');
        this.input.nativeElement.focus();
    }
    /**
     * Validate if a given key stroke is a valid input
     */
    keyIsValid(key) {
        return SearchBarComponent.invalidKeys.indexOf(key) === -1;
    }
    /**
     * When the search term changes, emit an event and trigger a
     * research in every enabled search sources.
     * @param term Search term
     */
    onSetTerm(term) {
        this.searchTermChange.emit(term);
        this.doSearch(term);
    }
    handlePlaceholder() {
        const searchTypes = [
            ...new Set(this.searchSourceService
                .getEnabledSources()
                .filter((ss) => !['map', 'coordinatesreverse'].includes(ss.getId()))
                .map((ss) => ss.getType()))
        ];
        let placeholder = `igo.geo.search.placeholder`;
        if (searchTypes.length === 1) {
            placeholder = `igo.geo.search.${searchTypes[0].toLowerCase()}.placeholder`;
        }
        else if (searchTypes.length === 0) {
            placeholder = `igo.geo.search.emptyType.placeholder`;
        }
        this.placeholder$.next(placeholder);
    }
    onSetSearchType(searchType) {
        if (searchType === undefined || searchType === null) {
            return;
        }
        this.searchTypeChange.emit(searchType);
        const placeholder = `igo.geo.search.${searchType.toLowerCase()}.placeholder`;
        this.placeholder$.next(placeholder);
        this.setTerm(this.term);
    }
    /**
     * Execute the search
     * @param term Search term
     */
    doSearch(rawTerm) {
        if (this.researches$$) {
            this.researches$$.map((research) => research.unsubscribe());
            this.researches$$ = undefined;
        }
        let terms;
        if (this.termSplitter &&
            rawTerm.match(new RegExp(this.termSplitter, 'g'))) {
            terms = rawTerm
                .split(this.termSplitter)
                .filter((t) => t.length >= this.minLength);
            if (this.store) {
                this.store.clear();
            }
        }
        else {
            terms = [rawTerm];
        }
        let researches = [];
        terms.map((term) => {
            const slug = term ? term.replace(/(#[^\s]*)/g, '').trim() : '';
            if (slug === '') {
                if (this.store !== undefined) {
                    this.store.clear();
                }
                return;
            }
            researches = researches.concat(this.searchService.search(term, {
                forceNA: this.forceNA
            }));
        });
        this.researches$$ = researches.map((research) => {
            return research.request.subscribe((results) => {
                this.onResearchCompleted(research, results);
            });
        });
    }
    /**
     * When a research  is completed, emit an event and update
     * the store's items.
     * @param research Research
     * @param results Research results
     */
    onResearchCompleted(research, results) {
        this.search.emit({ research, results });
        if (this.store !== undefined) {
            const newResults = this.store
                .all()
                .filter((result) => result.source !== research.source)
                .concat(results);
            this.store.updateMany(newResults);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SearchBarComponent, deps: [{ token: i2.ConfigService }, { token: SearchService }, { token: SearchSourceService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: SearchBarComponent, selector: "igo-search-bar", inputs: { searchTypes: "searchTypes", withDivider: "withDivider", searchType: "searchType", term: "term", disabled: "disabled", pointerSummaryEnabled: "pointerSummaryEnabled", searchResultsGeometryEnabled: "searchResultsGeometryEnabled", reverseSearchCoordsFormatEnabled: "reverseSearchCoordsFormatEnabled", floatLabel: "floatLabel", appearance: "appearance", placeholder: "placeholder", label: "label", color: "color", termSplitter: "termSplitter", debounce: "debounce", minLength: "minLength", searchSelector: "searchSelector", searchSettings: "searchSettings", forceNA: "forceNA", store: "store" }, outputs: { pointerSummaryStatus: "pointerSummaryStatus", searchResultsGeometryStatus: "searchResultsGeometryStatus", reverseSearchCoordsFormatStatus: "reverseSearchCoordsFormatStatus", searchTermChange: "searchTermChange", search: "search", searchTypeChange: "searchTypeChange", clearFeature: "clearFeature", searchSettingsChange: "searchSettingsChange" }, viewQueries: [{ propertyName: "input", first: true, predicate: ["input"], descendants: true, static: true }], ngImport: i0, template: "<div class=\"igo-search-bar-container\" [ngClass]=\"{ empty: empty$ | async }\">\r\n  <mat-form-field [floatLabel]=\"floatLabel\" [appearance]=\"appearance\">\r\n    <mat-label *ngIf=\"label\">{{ label }}</mat-label>\r\n    <input\r\n      #input\r\n      matInput\r\n      autocomplete=\"off\"\r\n      [ngClass]=\"{ hasSearchIcon: showSearchButton }\"\r\n      [disabled]=\"disabled$ | async\"\r\n      [placeholder]=\"\r\n        placeholder\r\n          ? placeholder\r\n          : (placeholder$ | async)\r\n          ? (placeholder$.value | translate)\r\n          : undefined\r\n      \"\r\n      [value]=\"term$ | async\"\r\n      (keyup)=\"onKeyup($event)\"\r\n      (touchend)=\"onKeyup($event)\"\r\n    />\r\n    <button\r\n      *ngIf=\"(empty$ | async) === false\"\r\n      mat-icon-button\r\n      matSuffix\r\n      [color]=\"color\"\r\n      (click)=\"onClearButtonClick()\"\r\n      [matTooltip]=\"'igo.geo.search.clearSearch' | translate\"\r\n    >\r\n      <mat-icon svgIcon=\"close\"></mat-icon>\r\n    </button>\r\n  </mat-form-field>\r\n\r\n  <mat-divider *ngIf=\"withDivider\" [vertical]=\"true\"></mat-divider>\r\n\r\n  <div class=\"search-bar-buttons\">\r\n    <button *ngIf=\"showSearchButton\" mat-icon-button [color]=\"color\">\r\n      <mat-icon svgIcon=\"magnify\"></mat-icon>\r\n    </button>\r\n\r\n    <igo-search-selector\r\n      *ngIf=\"searchSelector\"\r\n      [searchTypes]=\"searchTypes\"\r\n      [searchType]=\"searchType$ | async\"\r\n      (searchTypeChange)=\"onSearchTypeChange($event)\"\r\n    >\r\n    </igo-search-selector>\r\n\r\n    <igo-search-settings\r\n      *ngIf=\"searchSettings\"\r\n      [pointerSummaryEnabled]=\"pointerSummaryEnabled\"\r\n      (pointerSummaryStatus)=\"pointerSummaryStatus.emit($event)\"\r\n      [searchResultsGeometryEnabled]=\"searchResultsGeometryEnabled\"\r\n      (searchResultsGeometryStatus)=\"searchResultsGeometryStatus.emit($event)\"\r\n      [reverseSearchCoordsFormatEnabled]=\"reverseSearchCoordsFormatEnabled\"\r\n      (reverseSearchCoordsFormatStatus)=\"\r\n        reverseSearchCoordsFormatStatus.emit($event)\r\n      \"\r\n      (searchSourceChange)=\"onSearchSettingsChange()\"\r\n    >\r\n    </igo-search-settings>\r\n  </div>\r\n</div>\r\n", styles: [":host ::ng-deep .mat-mdc-form-field-subscript-wrapper{display:none}:host ::ng-deep .mat-mdc-text-field-wrapper{align-items:center;padding-right:0}:host ::ng-deep .mat-mdc-form-field-infix{align-self:center}@media (max-width: 599px){:host ::ng-deep .mat-mdc-form-field-infix{width:158px}}:host ::ng-deep mat-form-field .mdc-line-ripple{display:none}:host ::ng-deep mat-form-field input{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.igo-search-bar-container{position:relative;width:100%;display:flex}mat-form-field{flex:1}mat-divider{margin:8px 0}.search-bar-buttons{position:relative;display:inline-flex}.search-bar-buttons>button:nth-child(2):before{content:\"\";border-right:1px solid #ddd;height:28px}igo-search-selector{background-color:#fff;top:0;border-radius:0}igo-search-settings{background-color:#fff;top:0;border-radius:0}\n"], dependencies: [{ kind: "directive", type: i2$2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "component", type: i9$2.MatDivider, selector: "mat-divider", inputs: ["vertical", "inset"] }, { kind: "component", type: i8.MatFormField, selector: "mat-form-field", inputs: ["hideRequiredMarker", "color", "floatLabel", "appearance", "subscriptSizing", "hintLabel"], exportAs: ["matFormField"] }, { kind: "directive", type: i8.MatLabel, selector: "mat-label" }, { kind: "directive", type: i8.MatSuffix, selector: "[matSuffix], [matIconSuffix], [matTextSuffix]", inputs: ["matTextSuffix"] }, { kind: "directive", type: i9$3.MatInput, selector: "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", inputs: ["disabled", "id", "placeholder", "name", "required", "type", "errorStateMatcher", "aria-describedby", "value", "readonly"], exportAs: ["matInput"] }, { kind: "component", type: SearchSelectorComponent, selector: "igo-search-selector", inputs: ["searchTypes", "searchType"], outputs: ["searchTypeChange"] }, { kind: "component", type: SearchSettingsComponent, selector: "igo-search-settings", inputs: ["pointerSummaryEnabled", "searchResultsGeometryEnabled", "reverseSearchCoordsFormatEnabled"], outputs: ["searchSourceChange", "pointerSummaryStatus", "searchResultsGeometryStatus", "reverseSearchCoordsFormatStatus"] }, { kind: "pipe", type: i2$2.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SearchBarComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-search-bar', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div class=\"igo-search-bar-container\" [ngClass]=\"{ empty: empty$ | async }\">\r\n  <mat-form-field [floatLabel]=\"floatLabel\" [appearance]=\"appearance\">\r\n    <mat-label *ngIf=\"label\">{{ label }}</mat-label>\r\n    <input\r\n      #input\r\n      matInput\r\n      autocomplete=\"off\"\r\n      [ngClass]=\"{ hasSearchIcon: showSearchButton }\"\r\n      [disabled]=\"disabled$ | async\"\r\n      [placeholder]=\"\r\n        placeholder\r\n          ? placeholder\r\n          : (placeholder$ | async)\r\n          ? (placeholder$.value | translate)\r\n          : undefined\r\n      \"\r\n      [value]=\"term$ | async\"\r\n      (keyup)=\"onKeyup($event)\"\r\n      (touchend)=\"onKeyup($event)\"\r\n    />\r\n    <button\r\n      *ngIf=\"(empty$ | async) === false\"\r\n      mat-icon-button\r\n      matSuffix\r\n      [color]=\"color\"\r\n      (click)=\"onClearButtonClick()\"\r\n      [matTooltip]=\"'igo.geo.search.clearSearch' | translate\"\r\n    >\r\n      <mat-icon svgIcon=\"close\"></mat-icon>\r\n    </button>\r\n  </mat-form-field>\r\n\r\n  <mat-divider *ngIf=\"withDivider\" [vertical]=\"true\"></mat-divider>\r\n\r\n  <div class=\"search-bar-buttons\">\r\n    <button *ngIf=\"showSearchButton\" mat-icon-button [color]=\"color\">\r\n      <mat-icon svgIcon=\"magnify\"></mat-icon>\r\n    </button>\r\n\r\n    <igo-search-selector\r\n      *ngIf=\"searchSelector\"\r\n      [searchTypes]=\"searchTypes\"\r\n      [searchType]=\"searchType$ | async\"\r\n      (searchTypeChange)=\"onSearchTypeChange($event)\"\r\n    >\r\n    </igo-search-selector>\r\n\r\n    <igo-search-settings\r\n      *ngIf=\"searchSettings\"\r\n      [pointerSummaryEnabled]=\"pointerSummaryEnabled\"\r\n      (pointerSummaryStatus)=\"pointerSummaryStatus.emit($event)\"\r\n      [searchResultsGeometryEnabled]=\"searchResultsGeometryEnabled\"\r\n      (searchResultsGeometryStatus)=\"searchResultsGeometryStatus.emit($event)\"\r\n      [reverseSearchCoordsFormatEnabled]=\"reverseSearchCoordsFormatEnabled\"\r\n      (reverseSearchCoordsFormatStatus)=\"\r\n        reverseSearchCoordsFormatStatus.emit($event)\r\n      \"\r\n      (searchSourceChange)=\"onSearchSettingsChange()\"\r\n    >\r\n    </igo-search-settings>\r\n  </div>\r\n</div>\r\n", styles: [":host ::ng-deep .mat-mdc-form-field-subscript-wrapper{display:none}:host ::ng-deep .mat-mdc-text-field-wrapper{align-items:center;padding-right:0}:host ::ng-deep .mat-mdc-form-field-infix{align-self:center}@media (max-width: 599px){:host ::ng-deep .mat-mdc-form-field-infix{width:158px}}:host ::ng-deep mat-form-field .mdc-line-ripple{display:none}:host ::ng-deep mat-form-field input{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.igo-search-bar-container{position:relative;width:100%;display:flex}mat-form-field{flex:1}mat-divider{margin:8px 0}.search-bar-buttons{position:relative;display:inline-flex}.search-bar-buttons>button:nth-child(2):before{content:\"\";border-right:1px solid #ddd;height:28px}igo-search-selector{background-color:#fff;top:0;border-radius:0}igo-search-settings{background-color:#fff;top:0;border-radius:0}\n"] }]
        }], ctorParameters: function () { return [{ type: i2.ConfigService }, { type: SearchService }, { type: SearchSourceService }]; }, propDecorators: { searchTypes: [{
                type: Input
            }], withDivider: [{
                type: Input
            }], searchType: [{
                type: Input
            }], pointerSummaryStatus: [{
                type: Output
            }], searchResultsGeometryStatus: [{
                type: Output
            }], reverseSearchCoordsFormatStatus: [{
                type: Output
            }], term: [{
                type: Input
            }], disabled: [{
                type: Input
            }], pointerSummaryEnabled: [{
                type: Input
            }], searchResultsGeometryEnabled: [{
                type: Input
            }], reverseSearchCoordsFormatEnabled: [{
                type: Input
            }], floatLabel: [{
                type: Input
            }], appearance: [{
                type: Input
            }], placeholder: [{
                type: Input
            }], label: [{
                type: Input
            }], color: [{
                type: Input
            }], termSplitter: [{
                type: Input
            }], debounce: [{
                type: Input
            }], minLength: [{
                type: Input
            }], searchSelector: [{
                type: Input
            }], searchSettings: [{
                type: Input
            }], forceNA: [{
                type: Input
            }], store: [{
                type: Input
            }], searchTermChange: [{
                type: Output
            }], search: [{
                type: Output
            }], searchTypeChange: [{
                type: Output
            }], clearFeature: [{
                type: Output
            }], searchSettingsChange: [{
                type: Output
            }], input: [{
                type: ViewChild,
                args: ['input', { static: true }]
            }] } });

class SearchUrlParamDirective {
    component;
    ref;
    route;
    constructor(component, ref, route) {
        this.component = component;
        this.ref = ref;
        this.route = route;
    }
    ngOnInit() {
        if (this.route && this.route.options.searchKey) {
            this.route.queryParams.subscribe((params) => {
                const searchParams = params[this.route.options.searchKey];
                if (searchParams) {
                    this.component.setTerm(searchParams);
                    this.ref.detectChanges();
                }
            });
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SearchUrlParamDirective, deps: [{ token: SearchBarComponent, self: true }, { token: i0.ChangeDetectorRef }, { token: i2.RouteService, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: SearchUrlParamDirective, selector: "[igoSearchUrlParam]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SearchUrlParamDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igoSearchUrlParam]'
                }]
        }], ctorParameters: function () { return [{ type: SearchBarComponent, decorators: [{
                    type: Self
                }] }, { type: i0.ChangeDetectorRef }, { type: i2.RouteService, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * @ignore
 */
class IgoSearchBarModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoSearchBarModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoSearchBarModule, declarations: [SearchBarComponent, SearchUrlParamDirective], imports: [CommonModule,
            FormsModule,
            MatTooltipModule,
            MatIconModule,
            MatButtonModule,
            MatDividerModule,
            MatMenuModule,
            MatRadioModule,
            MatFormFieldModule,
            MatInputModule,
            IgoLanguageModule,
            IgoSearchSelectorModule,
            IgoSearchSettingsModule], exports: [SearchBarComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoSearchBarModule, imports: [CommonModule,
            FormsModule,
            MatTooltipModule,
            MatIconModule,
            MatButtonModule,
            MatDividerModule,
            MatMenuModule,
            MatRadioModule,
            MatFormFieldModule,
            MatInputModule,
            IgoLanguageModule,
            IgoSearchSelectorModule,
            IgoSearchSettingsModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoSearchBarModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        FormsModule,
                        MatTooltipModule,
                        MatIconModule,
                        MatButtonModule,
                        MatDividerModule,
                        MatMenuModule,
                        MatRadioModule,
                        MatFormFieldModule,
                        MatInputModule,
                        IgoLanguageModule,
                        IgoSearchSelectorModule,
                        IgoSearchSettingsModule
                    ],
                    exports: [SearchBarComponent],
                    declarations: [SearchBarComponent, SearchUrlParamDirective]
                }]
        }] });

/**
 * Search results list item
 */
class SearchResultsItemComponent {
    /**
     * Search result item
     */
    result;
    map;
    /**
     * Search result title
     * @internal
     */
    /**
     * to show hide results icons
     */
    showIcons;
    /**
     * Whether there should be a zoom button
     */
    withZoomButton = false;
    zoomEvent = new EventEmitter();
    format = new OlGeoJSON();
    get title() {
        return getEntityTitle(this.result);
    }
    /**
     * Search result HTML title
     * @internal
     */
    get titleHtml() {
        return getEntityTitleHtml(this.result);
    }
    /**
     * Search result tooltip
     * @internal
     */
    get tooltipHtml() {
        return this.titleHtml
            .replace(/<small?[^>]+(>|$)/g, '\n')
            .replace(/<\/?[^>]+(>|$)/g, '');
    }
    /**
     * Search result icon
     * @internal
     */
    get icon() {
        return getEntityIcon(this.result);
    }
    onZoomHandler() {
        const olFeature = this.format.readFeature(this.result.data, {
            dataProjection: this.result.data.projection,
            featureProjection: this.map.projection
        });
        moveToOlFeatures(this.map.viewController, [olFeature], FeatureMotion.Default);
    }
    /**
     * On mouse event, mouseenter /mouseleave
     * @internal
     */
    onMouseEvent(event) {
        const element = event.target;
        const type = event.type;
        switch (type) {
            case 'mouseenter':
                const hideBtn = element.querySelector('#hide-save-search-result-btn');
                hideBtn
                    ? hideBtn.setAttribute('id', 'show-save-search-result-btn')
                    : null;
                break;
            case 'mouseleave':
                const showBtn = element.querySelector('#show-save-search-result-btn');
                showBtn
                    ? showBtn.setAttribute('id', 'hide-save-search-result-btn')
                    : null;
                break;
            default:
                break;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SearchResultsItemComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: SearchResultsItemComponent, selector: "igo-search-results-item", inputs: { result: "result", map: "map", showIcons: "showIcons", withZoomButton: "withZoomButton" }, outputs: { zoomEvent: "zoomEvent" }, ngImport: i0, template: "<mat-list-item\n  (mouseenter)=\"onMouseEvent($event)\"\n  (mouseleave)=\"onMouseEvent($event)\"\n>\n  <mat-icon\n    *ngIf=\"icon\"\n    matListItemIcon\n    [svgIcon]=\"showIcons ? icon : 'blank'\"\n  ></mat-icon>\n\n  <div\n    matListItemTitle\n    *ngIf=\"titleHtml; else normalTitle\"\n    [innerHtml]=\"titleHtml\"\n    matTooltipShowDelay=\"500\"\n    [matTooltip]=\"tooltipHtml\"\n    matTooltipClass=\"search-result-tooltip\"\n  ></div>\n  <ng-template #normalTitle>\n    <span\n      matListItemTitle\n      *ngIf=\"!titleHtml\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"title\"\n      >{{ title }}</span\n    >\n  </ng-template>\n\n  <div matListItemMeta>\n    <button\n      *ngIf=\"withZoomButton\"\n      igoStopPropagation\n      mat-icon-button\n      (click)=\"onZoomHandler()\"\n    >\n      <mat-icon svgIcon=\"magnify\"></mat-icon>\n    </button>\n\n    <ng-content select=\"[igoSearchItemToolbar]\"> </ng-content>\n  </div>\n</mat-list-item>\n", styles: [":host ::ng-deep small{color:#8c8c8c}:host div[matlistitemmeta]:empty{display:none}:host ::ng-deep .search-result-tooltip{white-space:pre-line}\n"], dependencies: [{ kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i9$1.StopPropagationDirective, selector: "[igoStopPropagation]" }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i5.MatListItem, selector: "mat-list-item, a[mat-list-item], button[mat-list-item]", inputs: ["activated"], exportAs: ["matListItem"] }, { kind: "directive", type: i5.MatListItemIcon, selector: "[matListItemIcon]" }, { kind: "directive", type: i5.MatListItemTitle, selector: "[matListItemTitle]" }, { kind: "directive", type: i5.MatListItemMeta, selector: "[matListItemMeta]" }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SearchResultsItemComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-search-results-item', changeDetection: ChangeDetectionStrategy.OnPush, template: "<mat-list-item\n  (mouseenter)=\"onMouseEvent($event)\"\n  (mouseleave)=\"onMouseEvent($event)\"\n>\n  <mat-icon\n    *ngIf=\"icon\"\n    matListItemIcon\n    [svgIcon]=\"showIcons ? icon : 'blank'\"\n  ></mat-icon>\n\n  <div\n    matListItemTitle\n    *ngIf=\"titleHtml; else normalTitle\"\n    [innerHtml]=\"titleHtml\"\n    matTooltipShowDelay=\"500\"\n    [matTooltip]=\"tooltipHtml\"\n    matTooltipClass=\"search-result-tooltip\"\n  ></div>\n  <ng-template #normalTitle>\n    <span\n      matListItemTitle\n      *ngIf=\"!titleHtml\"\n      matTooltipShowDelay=\"500\"\n      [matTooltip]=\"title\"\n      >{{ title }}</span\n    >\n  </ng-template>\n\n  <div matListItemMeta>\n    <button\n      *ngIf=\"withZoomButton\"\n      igoStopPropagation\n      mat-icon-button\n      (click)=\"onZoomHandler()\"\n    >\n      <mat-icon svgIcon=\"magnify\"></mat-icon>\n    </button>\n\n    <ng-content select=\"[igoSearchItemToolbar]\"> </ng-content>\n  </div>\n</mat-list-item>\n", styles: [":host ::ng-deep small{color:#8c8c8c}:host div[matlistitemmeta]:empty{display:none}:host ::ng-deep .search-result-tooltip{white-space:pre-line}\n"] }]
        }], propDecorators: { result: [{
                type: Input
            }], map: [{
                type: Input
            }], showIcons: [{
                type: Input
            }], withZoomButton: [{
                type: Input
            }], zoomEvent: [{
                type: Output
            }] } });

class SaveFeatureDialogComponent {
    formBuilder;
    languageService;
    dialogRef;
    data;
    form;
    feature;
    layers = [];
    filteredLayers$;
    constructor(formBuilder, languageService, dialogRef, data) {
        this.formBuilder = formBuilder;
        this.languageService = languageService;
        this.dialogRef = dialogRef;
        this.data = data;
        this.form = this.formBuilder.group({
            layerName: ['', [Validators.required]]
        });
    }
    ngOnInit() {
        this.feature = this.data.feature;
        this.layers = this.data.layers;
        this.filteredLayers$ = this.form.controls['layerName'].valueChanges.pipe(startWith(''), map((val) => this.filter(val)));
    }
    filter(val) {
        if (typeof val !== 'string') {
            return;
        }
        return this.layers
            .map((l) => l)
            .filter((layer) => layer?.title?.toLowerCase().includes(val.toLowerCase()));
    }
    displayFn(layer) {
        return layer && layer.title ? layer.title : '';
    }
    save() {
        const data = {
            layer: this.form.value.layerName,
            feature: this.feature
        };
        this.dialogRef.close(data);
    }
    cancel() {
        this.dialogRef.close();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SaveFeatureDialogComponent, deps: [{ token: i2$1.UntypedFormBuilder }, { token: i2.LanguageService }, { token: i1$2.MatDialogRef }, { token: MAT_DIALOG_DATA, optional: true }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: SaveFeatureDialogComponent, selector: "igo-save-feature-dialog", ngImport: i0, template: "<h1 mat-dialog-title class=\"mat-typography\">\n  {{ 'igo.geo.layer.saveFeatureInLayer' | translate }}\n</h1>\n\n<div mat-dialog-content class=\"mat-typography\">\n  <form class=\"igo-form\" [formGroup]=\"form\">\n    <igo-list [navigation]=\"false\" [selection]=\"false\">\n      <igo-search-results-item\n        igoListItem\n        color=\"accent\"\n        [result]=\"feature\"\n        showIcons=\"true\"\n      >\n      </igo-search-results-item>\n    </igo-list>\n\n    <div class=\"igo-input-container\">\n      <mat-form-field>\n        <input\n          type=\"text\"\n          placeholder=\"{{ 'igo.geo.layer.chooseOrSet' | translate }}\"\n          matInput\n          [matAutocomplete]=\"auto\"\n          formControlName=\"layerName\"\n        />\n        <mat-autocomplete [displayWith]=\"displayFn\" #auto=\"matAutocomplete\">\n          <mat-option\n            *ngFor=\"let layer of filteredLayers$ | async\"\n            [value]=\"layer\"\n          >\n            <p matListItemTitle>{{ layer.title }}</p>\n          </mat-option>\n        </mat-autocomplete>\n      </mat-form-field>\n    </div>\n  </form>\n</div>\n\n<div mat-dialog-actions style=\"justify-content: center\">\n  <div class=\"igo-form-button-group create-layer-button-top-padding\">\n    <button mat-raised-button type=\"button\" (click)=\"cancel()\">\n      {{ 'igo.geo.layer.cancelBtn' | translate }}\n    </button>\n    <button\n      id=\"createLayerBtnDialog\"\n      mat-raised-button\n      type=\"button\"\n      color=\"primary\"\n      (click)=\"save()\"\n    >\n      {{ 'igo.geo.layer.saveBtn' | translate }}\n    </button>\n  </div>\n</div>\n", styles: [":host mat-form-field{width:100%}:host .create-layer-button-top-padding{padding-top:25px}:host .igo-form{padding:10px 5px 5px}:host .igo-form-button-group{text-align:center}:host button{cursor:pointer}:host button#createLayerBtnDialog[disabled=true]{cursor:default;background-color:#0000001f;color:#00000042}:host .error{color:red}\n"], dependencies: [{ kind: "directive", type: i2$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i9$1.ListItemDirective, selector: "[igoListItem]", inputs: ["color", "focused", "selected", "disabled"], outputs: ["beforeSelect", "beforeFocus", "beforeUnselect", "beforeUnfocus", "beforeDisable", "beforeEnable", "focus", "unfocus", "select", "unselect", "disable", "enable"] }, { kind: "component", type: i9$1.ListComponent, selector: "igo-list", inputs: ["navigation", "selection"] }, { kind: "component", type: i6$2.MatAutocomplete, selector: "mat-autocomplete", inputs: ["disableRipple", "hideSingleSelectionIndicator"], exportAs: ["matAutocomplete"] }, { kind: "component", type: i9.MatOption, selector: "mat-option", exportAs: ["matOption"] }, { kind: "directive", type: i6$2.MatAutocompleteTrigger, selector: "input[matAutocomplete], textarea[matAutocomplete]", exportAs: ["matAutocompleteTrigger"] }, { kind: "component", type: i4$1.MatButton, selector: "    button[mat-button], button[mat-raised-button], button[mat-flat-button],    button[mat-stroked-button]  ", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "directive", type: i1$2.MatDialogTitle, selector: "[mat-dialog-title], [matDialogTitle]", inputs: ["id"], exportAs: ["matDialogTitle"] }, { kind: "directive", type: i1$2.MatDialogContent, selector: "[mat-dialog-content], mat-dialog-content, [matDialogContent]" }, { kind: "directive", type: i1$2.MatDialogActions, selector: "[mat-dialog-actions], mat-dialog-actions, [matDialogActions]", inputs: ["align"] }, { kind: "component", type: i8.MatFormField, selector: "mat-form-field", inputs: ["hideRequiredMarker", "color", "floatLabel", "appearance", "subscriptSizing", "hintLabel"], exportAs: ["matFormField"] }, { kind: "directive", type: i9$3.MatInput, selector: "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", inputs: ["disabled", "id", "placeholder", "name", "required", "type", "errorStateMatcher", "aria-describedby", "value", "readonly"], exportAs: ["matInput"] }, { kind: "directive", type: i5.MatListItemTitle, selector: "[matListItemTitle]" }, { kind: "directive", type: i2$1.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { kind: "directive", type: i2$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i2$1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "directive", type: i2$1.FormControlName, selector: "[formControlName]", inputs: ["formControlName", "disabled", "ngModel"], outputs: ["ngModelChange"] }, { kind: "component", type: SearchResultsItemComponent, selector: "igo-search-results-item", inputs: ["result", "map", "showIcons", "withZoomButton"], outputs: ["zoomEvent"] }, { kind: "pipe", type: i2$2.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SaveFeatureDialogComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-save-feature-dialog', template: "<h1 mat-dialog-title class=\"mat-typography\">\n  {{ 'igo.geo.layer.saveFeatureInLayer' | translate }}\n</h1>\n\n<div mat-dialog-content class=\"mat-typography\">\n  <form class=\"igo-form\" [formGroup]=\"form\">\n    <igo-list [navigation]=\"false\" [selection]=\"false\">\n      <igo-search-results-item\n        igoListItem\n        color=\"accent\"\n        [result]=\"feature\"\n        showIcons=\"true\"\n      >\n      </igo-search-results-item>\n    </igo-list>\n\n    <div class=\"igo-input-container\">\n      <mat-form-field>\n        <input\n          type=\"text\"\n          placeholder=\"{{ 'igo.geo.layer.chooseOrSet' | translate }}\"\n          matInput\n          [matAutocomplete]=\"auto\"\n          formControlName=\"layerName\"\n        />\n        <mat-autocomplete [displayWith]=\"displayFn\" #auto=\"matAutocomplete\">\n          <mat-option\n            *ngFor=\"let layer of filteredLayers$ | async\"\n            [value]=\"layer\"\n          >\n            <p matListItemTitle>{{ layer.title }}</p>\n          </mat-option>\n        </mat-autocomplete>\n      </mat-form-field>\n    </div>\n  </form>\n</div>\n\n<div mat-dialog-actions style=\"justify-content: center\">\n  <div class=\"igo-form-button-group create-layer-button-top-padding\">\n    <button mat-raised-button type=\"button\" (click)=\"cancel()\">\n      {{ 'igo.geo.layer.cancelBtn' | translate }}\n    </button>\n    <button\n      id=\"createLayerBtnDialog\"\n      mat-raised-button\n      type=\"button\"\n      color=\"primary\"\n      (click)=\"save()\"\n    >\n      {{ 'igo.geo.layer.saveBtn' | translate }}\n    </button>\n  </div>\n</div>\n", styles: [":host mat-form-field{width:100%}:host .create-layer-button-top-padding{padding-top:25px}:host .igo-form{padding:10px 5px 5px}:host .igo-form-button-group{text-align:center}:host button{cursor:pointer}:host button#createLayerBtnDialog[disabled=true]{cursor:default;background-color:#0000001f;color:#00000042}:host .error{color:red}\n"] }]
        }], ctorParameters: function () { return [{ type: i2$1.UntypedFormBuilder }, { type: i2.LanguageService }, { type: i1$2.MatDialogRef }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [MAT_DIALOG_DATA]
                }] }]; } });

class SearchResultAddButtonComponent {
    layerService;
    dialog;
    dataSourceService;
    mediaService;
    tooltip$ = new BehaviorSubject('igo.geo.catalog.layer.addToMap');
    addFeatureToLayerTooltip$ = new BehaviorSubject('igo.geo.search.addToLayer');
    resolution$$;
    layers$$;
    inRange$ = new BehaviorSubject(true);
    isVisible$ = new BehaviorSubject(false);
    isPreview$ = new BehaviorSubject(false);
    layersSubcriptions = [];
    lastTimeoutRequest;
    mouseInsideAdd = false;
    layer;
    store;
    /**
     * Whether the layer is already added to the map
     */
    added;
    /**
     * The map to add the search result layer to
     */
    map;
    /**
     * show hide save search result in layer button
     */
    saveSearchResultInLayer = false;
    get color() {
        return this._color;
    }
    set color(value) {
        this._color = value;
    }
    _color = 'primary';
    stores = [];
    get allLayers() {
        return this.map.layers.filter((layer) => String(layer.id).includes('igo-search-layer'));
    }
    mediaService$$;
    isMobile = false;
    constructor(layerService, dialog, dataSourceService, mediaService) {
        this.layerService = layerService;
        this.dialog = dialog;
        this.dataSourceService = dataSourceService;
        this.mediaService = mediaService;
    }
    /**
     * @internal
     */
    ngOnInit() {
        // check the view if is mobile or not
        this.mediaService$$ = this.mediaService.media$.subscribe((media) => {
            if (media === Media.Mobile) {
                this.isMobile = true;
            }
        });
        if (this.layer.meta.dataType === 'Layer') {
            this.added =
                this.map.layers.findIndex((lay) => lay.id === this.layer.data.sourceOptions.id) !== -1;
        }
        this.layers$$ = this.map.layers$.subscribe(() => {
            this.isVisible();
        });
        this.resolution$$ = this.map.viewController.resolution$.subscribe((value) => {
            this.isInResolutionsRange(value);
            this.isVisible();
        });
    }
    ngOnDestroy() {
        this.resolution$$.unsubscribe();
        this.layers$$.unsubscribe();
        if (this.mediaService$$) {
            this.mediaService$$.unsubscribe();
        }
    }
    /**
     * On mouse event, mouseenter /mouseleave
     * @internal
     */
    onMouseEvent(event) {
        this.onToggleClick(event);
    }
    /**
     * On toggle button click, emit the added change event
     * @internal
     */
    onToggleClick(currEvent) {
        if (typeof this.lastTimeoutRequest !== 'undefined') {
            clearTimeout(this.lastTimeoutRequest);
        }
        const event = currEvent ? currEvent : {};
        if (event.type === 'mouseenter' && this.mouseInsideAdd) {
            return;
        }
        switch (event.type) {
            case 'click':
                if (!this.isPreview$.value) {
                    if (this.added) {
                        this.remove();
                    }
                    else {
                        this.add(event);
                    }
                }
                this.isPreview$.next(false);
                break;
            case 'mouseenter':
                if (!this.isPreview$.value && !this.added) {
                    this.lastTimeoutRequest = setTimeout(() => {
                        this.add(event);
                        this.isPreview$.next(true);
                    }, 500);
                }
                this.mouseInsideAdd = true;
                break;
            case 'mouseleave':
                if (this.isPreview$.value) {
                    this.remove();
                    this.isPreview$.next(false);
                }
                this.mouseInsideAdd = false;
                break;
            default:
                break;
        }
    }
    add(event) {
        if (!this.added) {
            this.added = true;
            this.addLayerToMap(event);
        }
    }
    remove() {
        if (this.added) {
            this.added = false;
            this.removeLayerFromMap();
            this.layersSubcriptions.map((s) => s.unsubscribe());
            this.layersSubcriptions = [];
        }
    }
    /**
     * Emit added change event with added = true
     */
    addLayerToMap(event) {
        if (this.map === undefined) {
            return;
        }
        if (this.layer.meta.dataType !== LAYER) {
            return undefined;
        }
        const layerOptions = this.layer.data;
        if (layerOptions.sourceOptions.optionsFromApi === undefined) {
            layerOptions.sourceOptions.optionsFromApi = true;
        }
        this.layersSubcriptions.push(this.layerService.createAsyncLayer(layerOptions).subscribe((layer) => {
            if (event.type === 'click') {
                this.map.layersAddedByClick$.next([layer]);
            }
            this.map.addLayer(layer);
        }));
    }
    /**
     * Emit added change event with added = false
     */
    removeLayerFromMap() {
        if (this.map === undefined) {
            return;
        }
        if (this.layer.meta.dataType !== LAYER) {
            return undefined;
        }
        const oLayer = this.map.getLayerById(this.layer.data.sourceOptions.id);
        this.map.removeLayer(oLayer);
    }
    isInResolutionsRange(resolution) {
        const minResolution = this.layer.data.minResolution || 0;
        const maxResolution = this.layer.data.maxResolution || Infinity;
        this.inRange$.next(resolution >= minResolution && resolution <= maxResolution);
    }
    isVisible() {
        if (this.layer?.data?.sourceOptions?.id) {
            const oLayer = this.map.getLayerById(this.layer.data.sourceOptions.id);
            oLayer
                ? this.isVisible$.next(oLayer.visible)
                : this.isVisible$.next(false);
        }
    }
    getBadgeIcon() {
        if (this.inRange$.value) {
            return this.isVisible$.value ? '' : 'eye-off';
        }
        else {
            return 'eye-off';
        }
    }
    computeTooltip() {
        if (this.added) {
            if (this.isPreview$.value) {
                return 'igo.geo.catalog.layer.addToMap';
            }
            else if (this.inRange$.value) {
                return this.isVisible$.value
                    ? 'igo.geo.catalog.layer.removeFromMap'
                    : 'igo.geo.catalog.layer.removeFromMapNotVisible';
            }
            else {
                return 'igo.geo.catalog.layer.removeFromMapOutRange';
            }
        }
        else {
            return this.inRange$.value
                ? 'igo.geo.catalog.layer.addToMap'
                : 'igo.geo.catalog.layer.addToMapOutRange';
        }
    }
    addFeatureToLayer() {
        if (this.layer.meta.dataType !== 'Feature') {
            return;
        }
        const selectedFeature = this.layer;
        const dialogRef = this.dialog.open(SaveFeatureDialogComponent, {
            width: '700px',
            data: {
                feature: selectedFeature,
                layers: this.allLayers
            }
        });
        dialogRef
            .afterClosed()
            .subscribe((data) => {
            if (data) {
                if (this.stores.length > 0) {
                    this.stores.map((store) => {
                        store.state.updateAll({ selected: false });
                        if (store?.layer) {
                            store.layer.visible = false;
                        }
                        return store;
                    });
                }
                // check if is new layer
                if (typeof data.layer === 'string') {
                    this.createLayer(data.layer, data.feature);
                }
                else {
                    const activeStore = this.stores.find((store) => store.layer.id === data.layer.id);
                    activeStore.layer.visible = true;
                    activeStore.layer.opacity = 1;
                    this.addFeature(data.feature, activeStore);
                }
            }
        });
    }
    createLayer(layerTitle, selectedFeature) {
        const activeStore = new FeatureStore([], {
            map: this.map
        });
        const styles = [
            new OlStyle({
                image: new Circle({
                    radius: 5,
                    stroke: new Stroke({
                        width: 1,
                        color: 'rgba(143,7,7,1)'
                    }),
                    fill: new Fill({
                        color: 'rgba(143,7,7,1)'
                    })
                })
            }),
            new OlStyle({
                stroke: new Stroke({
                    width: 1,
                    color: 'rgba(143,7,7,1)'
                }),
                fill: new Fill({
                    color: 'rgba(0, 0, 255, 0.1)'
                })
            })
        ];
        // set layer id
        let layerCounterID = 0;
        for (const layer of this.allLayers) {
            let numberId = Number(layer.id.replace('igo-search-layer', ''));
            layerCounterID = Math.max(numberId, layerCounterID);
        }
        this.dataSourceService
            .createAsyncDataSource({
            type: 'vector',
            queryable: true
        })
            .pipe(take$1(1))
            .subscribe((dataSource) => {
            let searchLayer = new VectorLayer({
                isIgoInternalLayer: true,
                id: 'igo-search-layer' + ++layerCounterID,
                title: layerTitle,
                source: dataSource,
                igoStyle: {
                    editable: false,
                    igoStyleObject: {
                        fill: { color: 'rgba(255,255,255,0.4)' },
                        stroke: { color: 'rgba(143,7,7,1)', width: 1 },
                        circle: {
                            fill: { color: 'rgba(255,255,255,0.4)' },
                            stroke: { color: 'rgba(143,7,7,1)', width: 1 },
                            radius: 5
                        }
                    }
                },
                style: styles,
                showInLayerList: true,
                exportable: true,
                workspace: {
                    enabled: true
                }
            });
            tryBindStoreLayer(activeStore, searchLayer);
            tryAddLoadingStrategy(activeStore, new FeatureStoreLoadingStrategy({
                motion: FeatureMotion.None
            }));
            tryAddSelectionStrategy(activeStore, new FeatureStoreSelectionStrategy({
                map: this.map,
                motion: FeatureMotion.None,
                many: true
            }));
            activeStore.layer.visible = true;
            activeStore.source.ol.on('removefeature', (event) => {
                const olGeometry = event.feature.getGeometry();
                this.clearLabelsOfOlGeometry(olGeometry);
            });
            this.addFeature(selectedFeature, activeStore);
            this.stores.push(activeStore);
        });
    }
    addFeature(feature, activeStore) {
        const newFeature = {
            type: feature.data.type,
            geometry: {
                coordinates: feature.data.geometry.coordinates,
                type: feature.data.geometry.type
            },
            projection: feature.data.projection,
            properties: feature.data.properties,
            meta: {
                id: feature.meta.id
            }
        };
        delete newFeature.properties.Route;
        activeStore.update(newFeature);
        activeStore.setLayerExtent();
        activeStore.layer.ol.getSource().refresh();
    }
    clearLabelsOfOlGeometry(olGeometry) {
        getTooltipsOfOlGeometry(olGeometry).forEach((olTooltip) => {
            if (olTooltip && olTooltip.getMap()) {
                this.map.ol.removeOverlay(olTooltip);
            }
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SearchResultAddButtonComponent, deps: [{ token: LayerService }, { token: i1$2.MatDialog }, { token: DataSourceService }, { token: i2.MediaService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: SearchResultAddButtonComponent, selector: "igo-search-add-button", inputs: { layer: "layer", store: "store", added: "added", map: "map", saveSearchResultInLayer: "saveSearchResultInLayer", color: "color", stores: "stores" }, ngImport: i0, template: "<button\n  igoStopPropagation\n  (mouseenter)=\"onMouseEvent($event)\"\n  (mouseleave)=\"onMouseEvent($event)\"\n  *ngIf=\"layer.meta.dataType === 'Layer'\"\n  mat-icon-button\n  tooltip-position=\"below\"\n  matTooltipShowDelay=\"500\"\n  [matTooltip]=\"computeTooltip() | translate\"\n  [color]=\"(isPreview$ | async) ? '' : added ? 'warn' : ''\"\n  (click)=\"onToggleClick($event)\"\n>\n  <mat-icon\n    aria-hidden=\"false\"\n    matBadge=\"icon\"\n    [igoMatBadgeIcon]=\"getBadgeIcon()\"\n    igoMatBadgeColor=\"rgba(0,0,0,0.87)\"\n    igoMatBadgeBackgroundColor=\"none\"\n    igoMatBadgeInverseColor=\"true\"\n    [matBadgeHidden]=\"\n      ((inRange$ | async) && (isVisible$ | async) === true) ||\n      ((inRange$ | async) && !added) ||\n      ((inRange$ | async) && (isPreview$ | async))\n    \"\n    [matBadgeDisabled]=\"(inRange$ | async) === false\"\n    matBadgeSize=\"small\"\n    matBadgePosition=\"after\"\n    [svgIcon]=\"(isPreview$ | async) ? 'plus' : added ? 'delete' : 'plus'\"\n  >\n  </mat-icon>\n</button>\n\n<button\n  [id]=\"!isMobile ? 'hide-save-search-result-btn' : ''\"\n  igoStopPropagation\n  *ngIf=\"layer.meta.dataType === 'Feature' && saveSearchResultInLayer\"\n  mat-icon-button\n  tooltip-position=\"below\"\n  matTooltipShowDelay=\"500\"\n  [matTooltip]=\"addFeatureToLayerTooltip$ | async | translate\"\n  (click)=\"addFeatureToLayer()\"\n>\n  <mat-icon\n    aria-hidden=\"false\"\n    matBadge=\"icon\"\n    igoMatBadgeIcon=\"eye-off\"\n    igoMatBadgeInverseColor=\"true\"\n    [matBadgeHidden]=\"inRange$ | async\"\n    matBadgeDisabled=\"true\"\n    matBadgeSize=\"small\"\n    matBadgePosition=\"after\"\n    svgIcon=\"file-plus-outline\"\n  >\n  </mat-icon>\n</button>\n", styles: [":host #hide-save-search-result-btn{display:none}:host #show-save-search-result-btn{display:block}\n"], dependencies: [{ kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i6.MatBadge, selector: "[matBadge]", inputs: ["matBadgeDisabled", "matBadgeColor", "matBadgeOverlap", "matBadgePosition", "matBadge", "matBadgeDescription", "matBadgeSize", "matBadgeHidden"] }, { kind: "directive", type: i9$1.IgoBadgeIconDirective, selector: "[igoMatBadgeIcon]", inputs: ["igoMatBadgeIcon", "matBadgeHidden", "matBadgeDisabled", "igoMatBadgeInverseColor", "igoMatBadgeInheritColor", "igoMatBadgeColor", "igoMatBadgeBackgroundColor"] }, { kind: "directive", type: i9$1.StopPropagationDirective, selector: "[igoStopPropagation]" }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "pipe", type: i2$2.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SearchResultAddButtonComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-search-add-button', changeDetection: ChangeDetectionStrategy.OnPush, template: "<button\n  igoStopPropagation\n  (mouseenter)=\"onMouseEvent($event)\"\n  (mouseleave)=\"onMouseEvent($event)\"\n  *ngIf=\"layer.meta.dataType === 'Layer'\"\n  mat-icon-button\n  tooltip-position=\"below\"\n  matTooltipShowDelay=\"500\"\n  [matTooltip]=\"computeTooltip() | translate\"\n  [color]=\"(isPreview$ | async) ? '' : added ? 'warn' : ''\"\n  (click)=\"onToggleClick($event)\"\n>\n  <mat-icon\n    aria-hidden=\"false\"\n    matBadge=\"icon\"\n    [igoMatBadgeIcon]=\"getBadgeIcon()\"\n    igoMatBadgeColor=\"rgba(0,0,0,0.87)\"\n    igoMatBadgeBackgroundColor=\"none\"\n    igoMatBadgeInverseColor=\"true\"\n    [matBadgeHidden]=\"\n      ((inRange$ | async) && (isVisible$ | async) === true) ||\n      ((inRange$ | async) && !added) ||\n      ((inRange$ | async) && (isPreview$ | async))\n    \"\n    [matBadgeDisabled]=\"(inRange$ | async) === false\"\n    matBadgeSize=\"small\"\n    matBadgePosition=\"after\"\n    [svgIcon]=\"(isPreview$ | async) ? 'plus' : added ? 'delete' : 'plus'\"\n  >\n  </mat-icon>\n</button>\n\n<button\n  [id]=\"!isMobile ? 'hide-save-search-result-btn' : ''\"\n  igoStopPropagation\n  *ngIf=\"layer.meta.dataType === 'Feature' && saveSearchResultInLayer\"\n  mat-icon-button\n  tooltip-position=\"below\"\n  matTooltipShowDelay=\"500\"\n  [matTooltip]=\"addFeatureToLayerTooltip$ | async | translate\"\n  (click)=\"addFeatureToLayer()\"\n>\n  <mat-icon\n    aria-hidden=\"false\"\n    matBadge=\"icon\"\n    igoMatBadgeIcon=\"eye-off\"\n    igoMatBadgeInverseColor=\"true\"\n    [matBadgeHidden]=\"inRange$ | async\"\n    matBadgeDisabled=\"true\"\n    matBadgeSize=\"small\"\n    matBadgePosition=\"after\"\n    svgIcon=\"file-plus-outline\"\n  >\n  </mat-icon>\n</button>\n", styles: [":host #hide-save-search-result-btn{display:none}:host #show-save-search-result-btn{display:block}\n"] }]
        }], ctorParameters: function () { return [{ type: LayerService }, { type: i1$2.MatDialog }, { type: DataSourceService }, { type: i2.MediaService }]; }, propDecorators: { layer: [{
                type: Input
            }], store: [{
                type: Input
            }], added: [{
                type: Input
            }], map: [{
                type: Input
            }], saveSearchResultInLayer: [{
                type: Input
            }], color: [{
                type: Input
            }], stores: [{
                type: Input
            }] } });

var SearchResultMode;
(function (SearchResultMode) {
    SearchResultMode["Grouped"] = "grouped";
    SearchResultMode["Flat"] = "flat";
})(SearchResultMode || (SearchResultMode = {}));
/**
 * List of search results with focus and selection capabilities.
 * This component is dumb and only emits events.
 */
class SearchResultsComponent {
    cdRef;
    searchService;
    configService;
    showResultsCount = true;
    /**
     * Reference to the SearchResultMode enum
     * @internal
     */
    searchResultMode = SearchResultMode;
    /**
     * Search results store watcher
     */
    watcher;
    settingsChange$$;
    pageIterator = [];
    collapsed = [];
    map;
    /**
     * Search results store
     */
    store;
    /**
     * to show hide results icons
     */
    showIcons;
    /**
     * Search results display mode
     */
    mode = SearchResultMode.Grouped;
    /**
     * Whether there should be a zoom button
     */
    withZoomButton = false;
    /**
     * To check if the view for tabsMode for search-result-tools
     */
    tabsMode = false;
    /**
     * Search term
     */
    get term() {
        return this._term;
    }
    set term(value) {
        this._term = value;
        this.pageIterator = [];
    }
    _term;
    settingsChange$ = new BehaviorSubject(undefined);
    termSplitter = '|';
    /**
     * Event emitted when a result is focused
     */
    resultFocus = new EventEmitter();
    /**
     * Event emitted when a result is unfocused
     */
    resultUnfocus = new EventEmitter();
    /**
     * Event emitted when a result is selected
     */
    resultSelect = new EventEmitter();
    /**
     * Event emitted when a research is completed after displaying more results is clicked
     */
    moreResults = new EventEmitter();
    /**
     * Events emitted when a result is focus or unfocus by mouse event
     */
    resultMouseenter = new EventEmitter();
    resultMouseleave = new EventEmitter();
    templateSearchToolbar;
    get results$() {
        if (this._results$ === undefined) {
            this._results$ = this.liftResults();
        }
        return this._results$;
    }
    _results$;
    constructor(cdRef, searchService, configService) {
        this.cdRef = cdRef;
        this.searchService = searchService;
        this.configService = configService;
    }
    /**
     * Bind the search results store to the watcher
     * @internal
     */
    ngOnInit() {
        this.watcher = new EntityStoreWatcher(this.store, this.cdRef);
        this.settingsChange$$ = this.settingsChange$.subscribe(() => {
            this.pageIterator = [];
        });
        if (this.configService.getConfig('searchSources.showResultsCount') === false) {
            this.showResultsCount = false;
        }
    }
    /**
     * Unbind the search results store from the watcher
     * @internal
     */
    ngOnDestroy() {
        this.watcher.destroy();
        this.settingsChange$$.unsubscribe();
    }
    /**
     * Compute a group title
     * @param group Search results group
     * @returns Group title
     * @internal
     */
    computeGroupTitle(group) {
        const parts = [group.source.title];
        const count = group.results.length;
        if (count > 1 && this.showResultsCount) {
            parts.push(`(${count})`);
        }
        return parts.join(' ');
    }
    /**
     * When a result is selected, update it's state in the store and emit
     * an event. A selected result is also considered focused
     * @param result Search result
     * @internal
     */
    onResultSelect(result) {
        if (this.store.state.get(result)) {
            if (this.store.state.get(result).selected === true) {
                return;
            }
        }
        this.store.state.update(result, { focused: true, selected: true }, true);
        this.resultSelect.emit(result);
    }
    /**
     * Return an observable of the search results, grouped by search source
     * @returns Observable of grouped search results
     * @internal
     */
    liftResults() {
        return this.store.stateView.all$().pipe(debounce((results) => {
            return results.length === 0 ? EMPTY : timer(200);
        }), map((results) => {
            return this.groupResults(results.map((r) => r.entity).sort(this.sortByOrder));
        }));
    }
    /**
     * Sort the results by display order.
     * @param r1 First result
     * @param r2 Second result
     */
    sortByOrder(r1, r2) {
        return r1.source.displayOrder - r2.source.displayOrder;
    }
    /**
     * Group results by search source
     * @param results Search results from all sources
     * @returns Search results grouped by source
     */
    groupResults(results) {
        const grouped = new Map();
        results.forEach((result) => {
            const source = result.source;
            let sourceResults = grouped.get(source);
            if (sourceResults === undefined) {
                sourceResults = [];
                grouped.set(source, sourceResults);
            }
            sourceResults.push(result);
        });
        return Array.from(grouped.keys()).map((source) => {
            if (this.pageIterator[source.getId()] === undefined) {
                this.pageIterator[source.getId()] = 1;
            }
            return { source, results: grouped.get(source) };
        });
    }
    isMoreResults(group) {
        const stategy = this.store.getStrategyOfType(EntityStoreFilterCustomFuncStrategy);
        const active = stategy?.active || false;
        if (!active) {
            return (group.results &&
                group.results[group.results.length - 1].meta.nextPage === true);
        }
        else {
            return (group.results?.length % +group.source.params.limit === 0 &&
                +group.source.params.page < 30);
        }
    }
    displayMoreResults(group) {
        const options = {
            sourceId: group.source.getId(),
            page: ++this.pageIterator[group.source.getId()]
        };
        let terms;
        if (this.termSplitter &&
            this.term.match(new RegExp(this.termSplitter, 'g'))) {
            terms = this.term.split(this.termSplitter);
        }
        else {
            terms = [this.term];
        }
        let researches = [];
        terms.map((term) => {
            researches = researches.concat(this.searchService.search(term, options));
        });
        researches.map((research) => {
            research.request.subscribe((results) => {
                const newResults = group.results.concat(results);
                if (!results.length) {
                    newResults[newResults.length - 1].meta.nextPage = false;
                }
                this.moreResults.emit({ research, results: newResults });
            });
        });
        return;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SearchResultsComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: SearchService }, { token: i2.ConfigService }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: SearchResultsComponent, selector: "igo-search-results", inputs: { map: "map", store: "store", showIcons: "showIcons", mode: "mode", withZoomButton: "withZoomButton", tabsMode: "tabsMode", term: "term", settingsChange$: "settingsChange$", termSplitter: "termSplitter" }, outputs: { resultFocus: "resultFocus", resultUnfocus: "resultUnfocus", resultSelect: "resultSelect", moreResults: "moreResults", resultMouseenter: "resultMouseenter", resultMouseleave: "resultMouseleave" }, queries: [{ propertyName: "templateSearchToolbar", first: true, predicate: ["igoSearchItemToolbar"], descendants: true }], ngImport: i0, template: "<igo-list [navigation]=\"true\" *ngIf=\"tabsMode === false\">\n  <ng-template #groupTemplate ngFor let-group [ngForOf]=\"results$ | async\">\n    <igo-collapsible\n      [class]=\"group.source.getId()\"\n      *ngIf=\"mode === searchResultMode.Grouped; else flatTemplate\"\n      [title]=\"computeGroupTitle(group)\"\n      [collapsed]=\"collapsed[group.source.title]\"\n      (toggle)=\"collapsed[group.source.title] = $event\"\n    >\n      <ng-container\n        *ngTemplateOutlet=\"\n          storeItemTemplate;\n          context: { results: group.results }\n        \"\n      ></ng-container>\n    </igo-collapsible>\n\n    <ng-template #flatTemplate>\n      <ng-container\n        *ngTemplateOutlet=\"\n          storeItemTemplate;\n          context: { results: group.results }\n        \"\n      ></ng-container>\n    </ng-template>\n\n    <ng-template #storeItemTemplate let-results=\"results\">\n      <ng-template ngFor let-result [ngForOf]=\"results\">\n        <igo-search-results-item\n          igoListItem\n          color=\"accent\"\n          [map]=\"map\"\n          [result]=\"result\"\n          [showIcons]=\"showIcons\"\n          [withZoomButton]=\"withZoomButton\"\n          [focused]=\"store.state.get(result).focused\"\n          [selected]=\"store.state.get(result).selected\"\n          (focus)=\"resultFocus.emit(result)\"\n          (unfocus)=\"resultUnfocus.emit(result)\"\n          (select)=\"onResultSelect(result)\"\n          (mouseenter)=\"resultFocus.emit(result)\"\n          (mouseleave)=\"resultUnfocus.emit(result)\"\n        >\n          <ng-container\n            igoSearchItemToolbar\n            [ngTemplateOutlet]=\"templateSearchToolbar\"\n            [ngTemplateOutletContext]=\"{ result: result }\"\n          >\n          </ng-container>\n        </igo-search-results-item>\n      </ng-template>\n      <span\n        class=\"moreResults mat-typography\"\n        *ngIf=\"isMoreResults(group)\"\n        (click)=\"displayMoreResults(group)\"\n      >\n        <u>{{ 'igo.geo.search.displayMoreResults' | translate }}</u>\n      </span>\n    </ng-template>\n  </ng-template>\n</igo-list>\n\n<igo-list [navigation]=\"true\" *ngIf=\"tabsMode\">\n  <ng-container\n    *ngIf=\"\n      mode === searchResultMode.Grouped;\n      then tabsTemplate;\n      else flatTemplate\n    \"\n  ></ng-container>\n\n  <ng-template #tabsTemplate>\n    <mat-tab-group class=\"custom-tabs-view\" dynamicHeight>\n      <mat-tab\n        *ngFor=\"let group of results$ | async\"\n        [label]=\"computeGroupTitle(group)\"\n      >\n        <ng-container\n          *ngTemplateOutlet=\"storeItemTemplate; context: { group: group }\"\n        ></ng-container>\n      </mat-tab>\n    </mat-tab-group>\n  </ng-template>\n\n  <ng-template #flatTemplate>\n    <ng-template ngFor let-group [ngForOf]=\"results$ | async\">\n      <ng-container\n        *ngTemplateOutlet=\"storeItemTemplate; context: { group: group }\"\n      ></ng-container>\n    </ng-template>\n  </ng-template>\n\n  <ng-template #storeItemTemplate let-group=\"group\">\n    <ng-template ngFor let-result [ngForOf]=\"group.results\">\n      <igo-search-results-item\n        igoListItem\n        color=\"accent\"\n        [map]=\"map\"\n        [result]=\"result\"\n        [showIcons]=\"showIcons\"\n        [withZoomButton]=\"withZoomButton\"\n        [focused]=\"store.state.get(result).focused\"\n        [selected]=\"store.state.get(result).selected\"\n        (focus)=\"resultFocus.emit(result)\"\n        (unfocus)=\"resultUnfocus.emit(result)\"\n        (select)=\"onResultSelect(result)\"\n        (mouseenter)=\"resultFocus.emit(result)\"\n        (mouseleave)=\"resultUnfocus.emit(result)\"\n      >\n        <ng-container\n          igoSearchItemToolbar\n          [ngTemplateOutlet]=\"templateSearchToolbar\"\n          [ngTemplateOutletContext]=\"{ result: result }\"\n        >\n        </ng-container>\n      </igo-search-results-item>\n    </ng-template>\n    <span\n      class=\"moreResults mat-typography\"\n      *ngIf=\"isMoreResults(group)\"\n      (click)=\"displayMoreResults(group)\"\n    >\n      <u>{{ 'igo.geo.search.displayMoreResults' | translate }}</u>\n    </span>\n  </ng-template>\n</igo-list>\n", styles: [":host .moreResults{cursor:pointer;color:#00f;float:right;margin-right:10px;margin-top:5px}:host igo-list ::ng-deep mat-list{height:100%}:host igo-list ::ng-deep mat-list .custom-tabs-view .mat-mdc-tab-header-pagination{min-width:20px}\n"], dependencies: [{ kind: "directive", type: i2$2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2$2.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: i9$1.CollapsibleComponent, selector: "igo-collapsible", inputs: ["title", "collapsed"], outputs: ["toggle"] }, { kind: "directive", type: i9$1.ListItemDirective, selector: "[igoListItem]", inputs: ["color", "focused", "selected", "disabled"], outputs: ["beforeSelect", "beforeFocus", "beforeUnselect", "beforeUnfocus", "beforeDisable", "beforeEnable", "focus", "unfocus", "select", "unselect", "disable", "enable"] }, { kind: "component", type: i9$1.ListComponent, selector: "igo-list", inputs: ["navigation", "selection"] }, { kind: "component", type: i4$2.MatTab, selector: "mat-tab", inputs: ["disabled"], exportAs: ["matTab"] }, { kind: "component", type: i4$2.MatTabGroup, selector: "mat-tab-group", inputs: ["color", "disableRipple", "fitInkBarToContent", "mat-stretch-tabs"], exportAs: ["matTabGroup"] }, { kind: "component", type: SearchResultsItemComponent, selector: "igo-search-results-item", inputs: ["result", "map", "showIcons", "withZoomButton"], outputs: ["zoomEvent"] }, { kind: "pipe", type: i2$2.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SearchResultsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-search-results', changeDetection: ChangeDetectionStrategy.OnPush, template: "<igo-list [navigation]=\"true\" *ngIf=\"tabsMode === false\">\n  <ng-template #groupTemplate ngFor let-group [ngForOf]=\"results$ | async\">\n    <igo-collapsible\n      [class]=\"group.source.getId()\"\n      *ngIf=\"mode === searchResultMode.Grouped; else flatTemplate\"\n      [title]=\"computeGroupTitle(group)\"\n      [collapsed]=\"collapsed[group.source.title]\"\n      (toggle)=\"collapsed[group.source.title] = $event\"\n    >\n      <ng-container\n        *ngTemplateOutlet=\"\n          storeItemTemplate;\n          context: { results: group.results }\n        \"\n      ></ng-container>\n    </igo-collapsible>\n\n    <ng-template #flatTemplate>\n      <ng-container\n        *ngTemplateOutlet=\"\n          storeItemTemplate;\n          context: { results: group.results }\n        \"\n      ></ng-container>\n    </ng-template>\n\n    <ng-template #storeItemTemplate let-results=\"results\">\n      <ng-template ngFor let-result [ngForOf]=\"results\">\n        <igo-search-results-item\n          igoListItem\n          color=\"accent\"\n          [map]=\"map\"\n          [result]=\"result\"\n          [showIcons]=\"showIcons\"\n          [withZoomButton]=\"withZoomButton\"\n          [focused]=\"store.state.get(result).focused\"\n          [selected]=\"store.state.get(result).selected\"\n          (focus)=\"resultFocus.emit(result)\"\n          (unfocus)=\"resultUnfocus.emit(result)\"\n          (select)=\"onResultSelect(result)\"\n          (mouseenter)=\"resultFocus.emit(result)\"\n          (mouseleave)=\"resultUnfocus.emit(result)\"\n        >\n          <ng-container\n            igoSearchItemToolbar\n            [ngTemplateOutlet]=\"templateSearchToolbar\"\n            [ngTemplateOutletContext]=\"{ result: result }\"\n          >\n          </ng-container>\n        </igo-search-results-item>\n      </ng-template>\n      <span\n        class=\"moreResults mat-typography\"\n        *ngIf=\"isMoreResults(group)\"\n        (click)=\"displayMoreResults(group)\"\n      >\n        <u>{{ 'igo.geo.search.displayMoreResults' | translate }}</u>\n      </span>\n    </ng-template>\n  </ng-template>\n</igo-list>\n\n<igo-list [navigation]=\"true\" *ngIf=\"tabsMode\">\n  <ng-container\n    *ngIf=\"\n      mode === searchResultMode.Grouped;\n      then tabsTemplate;\n      else flatTemplate\n    \"\n  ></ng-container>\n\n  <ng-template #tabsTemplate>\n    <mat-tab-group class=\"custom-tabs-view\" dynamicHeight>\n      <mat-tab\n        *ngFor=\"let group of results$ | async\"\n        [label]=\"computeGroupTitle(group)\"\n      >\n        <ng-container\n          *ngTemplateOutlet=\"storeItemTemplate; context: { group: group }\"\n        ></ng-container>\n      </mat-tab>\n    </mat-tab-group>\n  </ng-template>\n\n  <ng-template #flatTemplate>\n    <ng-template ngFor let-group [ngForOf]=\"results$ | async\">\n      <ng-container\n        *ngTemplateOutlet=\"storeItemTemplate; context: { group: group }\"\n      ></ng-container>\n    </ng-template>\n  </ng-template>\n\n  <ng-template #storeItemTemplate let-group=\"group\">\n    <ng-template ngFor let-result [ngForOf]=\"group.results\">\n      <igo-search-results-item\n        igoListItem\n        color=\"accent\"\n        [map]=\"map\"\n        [result]=\"result\"\n        [showIcons]=\"showIcons\"\n        [withZoomButton]=\"withZoomButton\"\n        [focused]=\"store.state.get(result).focused\"\n        [selected]=\"store.state.get(result).selected\"\n        (focus)=\"resultFocus.emit(result)\"\n        (unfocus)=\"resultUnfocus.emit(result)\"\n        (select)=\"onResultSelect(result)\"\n        (mouseenter)=\"resultFocus.emit(result)\"\n        (mouseleave)=\"resultUnfocus.emit(result)\"\n      >\n        <ng-container\n          igoSearchItemToolbar\n          [ngTemplateOutlet]=\"templateSearchToolbar\"\n          [ngTemplateOutletContext]=\"{ result: result }\"\n        >\n        </ng-container>\n      </igo-search-results-item>\n    </ng-template>\n    <span\n      class=\"moreResults mat-typography\"\n      *ngIf=\"isMoreResults(group)\"\n      (click)=\"displayMoreResults(group)\"\n    >\n      <u>{{ 'igo.geo.search.displayMoreResults' | translate }}</u>\n    </span>\n  </ng-template>\n</igo-list>\n", styles: [":host .moreResults{cursor:pointer;color:#00f;float:right;margin-right:10px;margin-top:5px}:host igo-list ::ng-deep mat-list{height:100%}:host igo-list ::ng-deep mat-list .custom-tabs-view .mat-mdc-tab-header-pagination{min-width:20px}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: SearchService }, { type: i2.ConfigService }]; }, propDecorators: { map: [{
                type: Input
            }], store: [{
                type: Input
            }], showIcons: [{
                type: Input
            }], mode: [{
                type: Input
            }], withZoomButton: [{
                type: Input
            }], tabsMode: [{
                type: Input
            }], term: [{
                type: Input
            }], settingsChange$: [{
                type: Input
            }], termSplitter: [{
                type: Input
            }], resultFocus: [{
                type: Output
            }], resultUnfocus: [{
                type: Output
            }], resultSelect: [{
                type: Output
            }], moreResults: [{
                type: Output
            }], resultMouseenter: [{
                type: Output
            }], resultMouseleave: [{
                type: Output
            }], templateSearchToolbar: [{
                type: ContentChild,
                args: ['igoSearchItemToolbar', /* TODO: add static flag */ {}]
            }] } });

/**
 * @ignore
 */
class IgoSearchResultsModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoSearchResultsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoSearchResultsModule, declarations: [SearchResultsComponent,
            SearchResultsItemComponent,
            SearchResultAddButtonComponent,
            SaveFeatureDialogComponent], imports: [CommonModule,
            IgoCollapsibleModule,
            IgoLanguageModule,
            IgoListModule,
            IgoMatBadgeIconModule,
            IgoMetadataModule,
            IgoStopPropagationModule,
            MatAutocompleteModule,
            MatBadgeModule,
            MatButtonModule,
            MatDialogModule,
            MatFormFieldModule,
            MatIconModule,
            MatInputModule,
            MatListModule,
            MatSelectModule,
            MatTabsModule,
            MatTooltipModule,
            ReactiveFormsModule], exports: [SearchResultsComponent, SearchResultAddButtonComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoSearchResultsModule, imports: [CommonModule,
            IgoCollapsibleModule,
            IgoLanguageModule,
            IgoListModule,
            IgoMatBadgeIconModule,
            IgoMetadataModule,
            IgoStopPropagationModule,
            MatAutocompleteModule,
            MatBadgeModule,
            MatButtonModule,
            MatDialogModule,
            MatFormFieldModule,
            MatIconModule,
            MatInputModule,
            MatListModule,
            MatSelectModule,
            MatTabsModule,
            MatTooltipModule,
            ReactiveFormsModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoSearchResultsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        IgoCollapsibleModule,
                        IgoLanguageModule,
                        IgoListModule,
                        IgoMatBadgeIconModule,
                        IgoMetadataModule,
                        IgoStopPropagationModule,
                        MatAutocompleteModule,
                        MatBadgeModule,
                        MatButtonModule,
                        MatDialogModule,
                        MatFormFieldModule,
                        MatIconModule,
                        MatInputModule,
                        MatListModule,
                        MatSelectModule,
                        MatTabsModule,
                        MatTooltipModule,
                        ReactiveFormsModule
                    ],
                    exports: [SearchResultsComponent, SearchResultAddButtonComponent],
                    declarations: [
                        SearchResultsComponent,
                        SearchResultsItemComponent,
                        SearchResultAddButtonComponent,
                        SaveFeatureDialogComponent
                    ]
                }]
        }] });

/**
 * This directive makes the mouse coordinate trigger a reverse search on available search sources.
 * The search results are placed into a label, on a cross icon, representing the mouse coordinate.
 * By default, no search sources. Config in config file must be defined.
 * the layer level.
 */
class SearchPointerSummaryDirective {
    component;
    searchService;
    searchSourceService;
    mediaService;
    store;
    lonLat;
    pointerSearchStore = new EntityStore([]);
    lastTimeoutRequest;
    store$$;
    layers$$;
    reverseSearch$$ = [];
    hasPointerReverseSearchSource = false;
    /**
     * Listener to the pointer move event
     */
    pointerMoveListener;
    searchPointerSummaryFeatureId = 'searchPointerSummaryFeatureId';
    /**
     * The delay where the mouse must be motionless before trigger the reverse search
     */
    igoSearchPointerSummaryDelay = 1000;
    /**
     * If the user has enabled or not the directive
     */
    igoSearchPointerSummaryEnabled = false;
    mouseleave() {
        clearTimeout(this.lastTimeoutRequest);
        this.clearLayer();
    }
    /**
     * IGO map
     * @internal
     */
    get map() {
        return this.component.map;
    }
    get mapProjection() {
        return this.component.map.projection;
    }
    constructor(component, searchService, searchSourceService, mediaService) {
        this.component = component;
        this.searchService = searchService;
        this.searchSourceService = searchSourceService;
        this.mediaService = mediaService;
    }
    /**
     * Start listening to pointermove and reverse search results.
     * @internal
     */
    ngOnInit() {
        this.listenToMapPointerMove();
        this.map.status$
            .pipe(first$1((status) => status === SubjectStatus.Done))
            .subscribe(() => {
            this.store = new FeatureStore([], { map: this.map });
            this.initStore();
            this.subscribeToPointerStore();
        });
        // To handle context change without using the contextService.
        this.layers$$ = this.map.layers$.subscribe((layers) => {
            if (this.store &&
                !layers.find((l) => l.id === 'searchPointerSummaryId')) {
                this.initStore();
            }
        });
    }
    /**
     * Initialize the pointer position store
     * @internal
     */
    initStore() {
        const store = this.store;
        const layer = new VectorLayer({
            isIgoInternalLayer: true,
            id: 'searchPointerSummaryId',
            title: 'searchPointerSummary',
            zIndex: 900,
            source: new FeatureDataSource(),
            showInLayerList: false,
            exportable: false,
            browsable: false,
            style: pointerPositionSummaryMarkerStyle
        });
        tryBindStoreLayer(store, layer);
    }
    ngAfterContentChecked() {
        if (!this.searchSourceService
            .getEnabledSources()
            .filter(sourceCanReverseSearchAsSummary).length) {
            this.hasPointerReverseSearchSource = false;
        }
        else {
            this.hasPointerReverseSearchSource = true;
        }
    }
    /**
     * Stop listening to pointermove and reverse search results.
     * @internal
     */
    ngOnDestroy() {
        this.unlistenToMapPointerMove();
        this.unsubscribeToPointerStore();
        this.unsubscribeReverseSearch();
        this.layers$$.unsubscribe();
    }
    /**
     * Subscribe to pointermove result store
     * @internal
     */
    subscribeToPointerStore() {
        this.store$$ = this.pointerSearchStore.entities$.subscribe((resultsUnderPointerPosition) => {
            this.entitiesToPointerOverlay(resultsUnderPointerPosition);
        });
    }
    /**
     * Build an object based on the closest feature by type (base on type and distance properties )
     * @param results SearchResult[]
     * @returns OL style function
     */
    computeSummaryClosestFeature(results) {
        const closestResultByType = {};
        results.map((result) => {
            if (result.data.properties.type && result.data.properties.distance >= 0) {
                if (closestResultByType.hasOwnProperty(result.data.properties.type)) {
                    const prevDistance = closestResultByType[result.data.properties.type].distance;
                    if (result.data.properties.distance < prevDistance) {
                        const title = result.meta.pointerSummaryTitle || result.meta.title;
                        closestResultByType[result.data.properties.type] = {
                            distance: result.data.properties.distance,
                            title
                        };
                    }
                }
                else {
                    const title = result.meta.pointerSummaryTitle || result.meta.title;
                    closestResultByType[result.data.properties.type] = {
                        distance: result.data.properties.distance,
                        title
                    };
                }
            }
        });
        return closestResultByType;
    }
    /**
     * convert store entities to a pointer position overlay with label summary on.
     * @param event OL map browser pointer event
     */
    entitiesToPointerOverlay(resultsUnderPointerPosition) {
        const closestResultByType = this.computeSummaryClosestFeature(resultsUnderPointerPosition);
        const summarizedClosestType = Object.keys(closestResultByType);
        const processedSummarizedClosestType = [];
        const summary = [];
        resultsUnderPointerPosition.map((result) => {
            const typeIndex = summarizedClosestType.indexOf(result.data.properties.type);
            if (typeIndex !== -1) {
                summary.push(closestResultByType[result.data.properties.type].title);
                summarizedClosestType.splice(typeIndex, 1);
                processedSummarizedClosestType.push(result.data.properties.type);
            }
            else {
                if (processedSummarizedClosestType.indexOf(result.data.properties.type) === -1) {
                    summary.push(result.meta.pointerSummaryTitle || result.meta.title);
                }
            }
        });
        if (summary.length) {
            this.addPointerOverlay(summary.join('\n'));
        }
    }
    /**
     * On map pointermove
     */
    listenToMapPointerMove() {
        this.pointerMoveListener = this.map.ol.on('pointermove', (event) => this.onMapEvent(event));
    }
    /**
     * Unsubscribe to pointer store.
     * @internal
     */
    unsubscribeToPointerStore() {
        this.store$$.unsubscribe();
    }
    /**
     * Unsubscribe to reverse seatch store.
     * @internal
     */
    unsubscribeReverseSearch() {
        this.reverseSearch$$.map((s) => s.unsubscribe());
        this.reverseSearch$$ = [];
    }
    /**
     * Stop listening for map pointermove
     * @internal
     */
    unlistenToMapPointerMove() {
        unByKey(this.pointerMoveListener);
        this.pointerMoveListener = undefined;
    }
    /**
     * Trigger reverse search when the mouse is motionless during the defined delay (pointerMoveDelay).
     * @param event OL map browser pointer event
     */
    onMapEvent(event) {
        if (event.dragging ||
            !this.igoSearchPointerSummaryEnabled ||
            !this.hasPointerReverseSearchSource ||
            this.mediaService.isTouchScreen()) {
            this.clearLayer();
            return;
        }
        if (typeof this.lastTimeoutRequest !== 'undefined') {
            // cancel timeout when the mouse moves
            clearTimeout(this.lastTimeoutRequest);
            this.clearLayer();
            this.unsubscribeReverseSearch();
        }
        this.lonLat = transform(event.coordinate, this.mapProjection, 'EPSG:4326');
        this.lastTimeoutRequest = setTimeout(() => {
            this.onSearchCoordinate();
        }, this.igoSearchPointerSummaryDelay);
    }
    /**
     * Sort the results by display order.
     * @param r1 First result
     * @param r2 Second result
     */
    sortByOrder(r1, r2) {
        return r1.source.displayOrder - r2.source.displayOrder;
    }
    onSearchCoordinate() {
        this.pointerSearchStore.clear();
        const results = this.searchService.reverseSearch(this.lonLat, { params: { geometry: 'false', icon: 'false' } }, true);
        for (const i in results) {
            if (results.length > 0) {
                this.reverseSearch$$.push(results[i].request.subscribe((_results) => {
                    this.onSearch({ research: results[i], results: _results });
                }));
            }
        }
    }
    onSearch(event) {
        const results = event.results;
        const newResults = this.pointerSearchStore
            .all()
            .filter((result) => result.source !== event.research.source)
            .concat(results);
        this.pointerSearchStore.load(newResults.sort(this.sortByOrder));
    }
    /**
     * Add a feature to the pointer store
     * @param text string
     */
    addPointerOverlay(text) {
        this.clearLayer();
        const geometry = new olgeom.Point(transform(this.lonLat, 'EPSG:4326', this.mapProjection));
        const feature = new OlFeature({ geometry });
        const geojsonGeom = new OlGeoJSON().writeGeometryObject(geometry, {
            featureProjection: this.mapProjection,
            dataProjection: this.mapProjection
        });
        const f = {
            type: FEATURE,
            geometry: geojsonGeom,
            projection: this.mapProjection,
            properties: {
                id: this.searchPointerSummaryFeatureId,
                pointerSummary: text
            },
            meta: {
                id: this.searchPointerSummaryFeatureId
            },
            ol: feature
        };
        this.store.setLayerFeatures([f], FeatureMotion.None);
    }
    /**
     * Clear the pointer store features
     */
    clearLayer() {
        if (this.store) {
            this.store.clearLayer();
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SearchPointerSummaryDirective, deps: [{ token: MapBrowserComponent, self: true }, { token: SearchService }, { token: SearchSourceService }, { token: i2.MediaService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: SearchPointerSummaryDirective, selector: "[igoSearchPointerSummary]", inputs: { igoSearchPointerSummaryDelay: "igoSearchPointerSummaryDelay", igoSearchPointerSummaryEnabled: "igoSearchPointerSummaryEnabled" }, host: { listeners: { "mouseleave": "mouseleave()" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SearchPointerSummaryDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igoSearchPointerSummary]'
                }]
        }], ctorParameters: function () { return [{ type: MapBrowserComponent, decorators: [{
                    type: Self
                }] }, { type: SearchService }, { type: SearchSourceService }, { type: i2.MediaService }]; }, propDecorators: { igoSearchPointerSummaryDelay: [{
                type: Input
            }], igoSearchPointerSummaryEnabled: [{
                type: Input
            }], mouseleave: [{
                type: HostListener,
                args: ['mouseleave']
            }] } });

/**
 * Search source factory
 * @ignore
 */
function searchSourceServiceFactory(sources) {
    return new SearchSourceService(sources);
}
/**
 * Function that returns a provider for the SearchSource service
 */
function provideSearchSourceService() {
    return {
        provide: SearchSourceService,
        useFactory: searchSourceServiceFactory,
        deps: [SearchSource]
    };
}

class GoogleLinks {
    static getGoogleMapsCoordLink(lon, lat) {
        return `https://www.google.com/maps/search/?api=1&query=${lat}%2C${lon}`;
    }
    static getGoogleStreetViewLink(lon, lat) {
        return `https://www.google.com/maps/@?api=1&map_action=pano&viewpoint=${lat}%2C${lon}`;
    }
    static getGoogleMapsNameLink(name) {
        const encodedName = encodeURI(name);
        return `https://www.google.com/maps/search/?api=1&query=${encodedName}`;
    }
}

class OsmLinks {
    static getOpenStreetMapLink(lon, lat, zoom = 17) {
        return `https://www.openstreetmap.org/?mlat=${lat}&mlon=${lon}#map=${zoom}/${lat}/${lon}`;
    }
    static getOpenStreetCamLink(lon, lat, zoom = 17) {
        return `https://openstreetcam.org/map/@${lat},${lon},${zoom}z`;
    }
}

class CoordinatesSearchResultFormatter {
    languageService;
    constructor(languageService) {
        this.languageService = languageService;
    }
    formatResult(result) {
        return result;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CoordinatesSearchResultFormatter, deps: [{ token: i2.LanguageService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CoordinatesSearchResultFormatter });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CoordinatesSearchResultFormatter, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i2.LanguageService }]; } });
/**
 * CoordinatesReverse search source
 */
class CoordinatesReverseSearchSource extends SearchSource {
    languageService;
    static id = 'coordinatesreverse';
    static type = FEATURE;
    projections;
    title$ = new BehaviorSubject('');
    get title() {
        return this.title$.getValue();
    }
    constructor(options, languageService, storageService, projections) {
        super(options, storageService);
        this.languageService = languageService;
        this.projections = projections;
        this.languageService.language$.subscribe(() => {
            this.title$.next(this.languageService.translate.instant(this.options.title));
        });
    }
    getId() {
        return CoordinatesReverseSearchSource.id;
    }
    getType() {
        return CoordinatesReverseSearchSource.type;
    }
    getDefaultOptions() {
        return {
            title: 'igo.geo.search.coordinates.name',
            order: 1,
            showInSettings: false
        };
    }
    /**
     * Search a location by coordinates
     * @param lonLat Location coordinates
     * @param options options of ReverseSearchOptions (distance, conf, zoom, params)
     * @returns Observable of <SearchResult<Feature>[]
     */
    reverseSearch(lonLat, options, reverseSearchCoordsFormatEnabled) {
        return of([
            this.dataToResult(lonLat, options, reverseSearchCoordsFormatEnabled)
        ]);
    }
    dataToResult(data, options, reverseSearchCoordsFormatEnabled) {
        const dataDMS = convertDDToDMS(data);
        const convertedCoord = lonLatConversion(data, this.projections);
        const coords = convertedCoord.reduce((obj, item) => ((obj[item.alias] = item.igo2CoordFormat), obj), {});
        const roundedCoordString = !reverseSearchCoordsFormatEnabled
            ? roundCoordTo(data, 6).join(', ')
            : roundCoordTo(data, 6).reverse().join(', ');
        const roundedCoordStringDMS = !reverseSearchCoordsFormatEnabled
            ? dataDMS.join(', ')
            : dataDMS.reverse().join(', ');
        let geometry = {
            type: 'Point',
            coordinates: [data[0], data[1]]
        };
        const properties = {};
        let subtitleHtml = '';
        if (options.distance) {
            const radiusKey = this.languageService.translate.instant('igo.geo.search.coordinates.radius');
            properties[radiusKey] = options.distance;
            subtitleHtml = '<br><small>Rayon: ' + options.distance + ' m</small>';
            // Create polygon
            const center = olproj.transform([data[0], data[1]], 'EPSG:4326', 'EPSG:3857');
            const circleGeometry = new OlCircle(center, options.distance);
            const polygonGeometry = fromCircle(circleGeometry);
            const writer = new olformat.GeoJSON();
            geometry = JSON.parse(writer.writeGeometry(polygonGeometry.transform('EPSG:3857', 'EPSG:4326')));
        }
        if (options.conf) {
            const confKey = this.languageService.translate.instant('igo.geo.search.coordinates.conf');
            properties[confKey] = options.conf;
            subtitleHtml += subtitleHtml === '' ? '<br>' : '<small> - </small>';
            subtitleHtml += '<small>Confiance: ' + options.conf + '%</small>';
        }
        const coordKey = !reverseSearchCoordsFormatEnabled
            ? this.languageService.translate.instant('igo.geo.search.coordinates.coord')
            : this.languageService.translate.instant('igo.geo.search.coordinates.reversedCoord');
        properties[coordKey] = roundedCoordString;
        const coordKeyDMS = !reverseSearchCoordsFormatEnabled
            ? this.languageService.translate.instant('igo.geo.search.coordinates.coordDMS')
            : this.languageService.translate.instant('igo.geo.search.coordinates.reversedCoordDMS');
        properties[coordKeyDMS] = roundedCoordStringDMS;
        return {
            source: this,
            data: {
                type: FEATURE,
                projection: 'EPSG:4326',
                geometry,
                extent: undefined,
                properties: Object.assign(properties, coords, {
                    GoogleMaps: GoogleLinks.getGoogleMapsCoordLink(data[0], data[1]),
                    GoogleStreetView: GoogleLinks.getGoogleStreetViewLink(data[0], data[1]),
                    OpenStreetMap: OsmLinks.getOpenStreetMapLink(data[0], data[1], 14),
                    Route: '<span class="routing"> <u>' +
                        this.languageService.translate.instant('igo.geo.seeRouting') +
                        '</u> </span>'
                }),
                meta: {
                    id: data[0].toString() + ',' + data[1].toString(),
                    title: roundedCoordString
                }
            },
            meta: {
                dataType: FEATURE,
                id: data[0].toString() + ',' + data[1].toString(),
                title: roundedCoordString,
                titleHtml: roundedCoordString + subtitleHtml,
                icon: 'map-marker',
                score: 100 // every coord exists
            }
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CoordinatesReverseSearchSource, deps: [{ token: 'options' }, { token: i2.LanguageService }, { token: i2.StorageService }, { token: 'projections' }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CoordinatesReverseSearchSource });
}
__decorate([
    Cacheable({
        maxCacheCount: 20
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, Object, Boolean]),
    __metadata("design:returntype", Observable)
], CoordinatesReverseSearchSource.prototype, "reverseSearch", null);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CoordinatesReverseSearchSource, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: ['options']
                }] }, { type: i2.LanguageService }, { type: i2.StorageService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['projections']
                }] }]; }, propDecorators: { reverseSearch: [] } });

/**
 * Coordinate search result formatter factory
 * @ignore
 */
function defaultCoordinatesSearchResultFormatterFactory(languageService) {
    return new CoordinatesSearchResultFormatter(languageService);
}
/**
 * Function that returns a provider for the Coordinates search result formatter
 */
function provideDefaultCoordinatesSearchResultFormatter() {
    return {
        provide: CoordinatesSearchResultFormatter,
        useFactory: defaultCoordinatesSearchResultFormatterFactory,
        deps: [LanguageService]
    };
}
/**
 * CoordinatesReverse search source factory
 * @ignore
 */
function CoordinatesReverseSearchSourceFactory(config, languageService, storageService, _projectionService) {
    return new CoordinatesReverseSearchSource(config.getConfig(`searchSources.${CoordinatesReverseSearchSource.id}`), languageService, storageService, config.getConfig('projections') || []);
}
/**
 * Function that returns a provider for the Coordinate search source
 */
function provideCoordinatesReverseSearchSource() {
    return {
        provide: SearchSource,
        useFactory: CoordinatesReverseSearchSourceFactory,
        multi: true,
        deps: [ConfigService, LanguageService, StorageService, ProjectionService]
    };
}

class IChercheSearchResultFormatter {
    languageService;
    constructor(languageService) {
        this.languageService = languageService;
    }
    formatResult(result) {
        return result;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IChercheSearchResultFormatter, deps: [{ token: i2.LanguageService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IChercheSearchResultFormatter });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IChercheSearchResultFormatter, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i2.LanguageService }]; } });
// Fix the "+" is replaced with space " " in a query string
// https://github.com/angular/angular/issues/11058
class IgoHttpParameterCodec {
    encodeKey(key) {
        return encodeURIComponent(key);
    }
    encodeValue(value) {
        return encodeURIComponent(value);
    }
    decodeKey(key) {
        return decodeURIComponent(key);
    }
    decodeValue(value) {
        return decodeURIComponent(value);
    }
}
/**
 * ICherche search source
 */
class IChercheSearchSource extends SearchSource {
    http;
    languageService;
    formatter;
    static id = 'icherche';
    static type = FEATURE;
    static propertiesBlacklist = [];
    title$ = new BehaviorSubject('');
    hashtagsLieuxToKeep = [];
    get title() {
        return this.title$.getValue();
    }
    constructor(http, languageService, storageService, options, formatter, injector) {
        super(options, storageService);
        this.http = http;
        this.languageService = languageService;
        this.formatter = formatter;
        const authService = injector.get(AuthService);
        if (this.settings.length) {
            if (!authService) {
                this.getAllowedTypes();
            }
            else {
                authService.authenticate$.subscribe(() => {
                    this.getAllowedTypes();
                });
            }
        }
        this.languageService.language$.subscribe(() => {
            this.title$.next(this.languageService.translate.instant(this.options.title));
        });
    }
    getId() {
        return IChercheSearchSource.id;
    }
    getType() {
        return IChercheSearchSource.type;
    }
    getDefaultOptions() {
        const limit = this.options.params && this.options.params.limit
            ? Number(this.options.params.limit)
            : undefined;
        const ecmax = this.options.params && this.options.params.ecmax
            ? Number(this.options.params.ecmax)
            : undefined;
        const types = this.options.params?.type
            ? this.options.params.type.replace(/\s/g, '').toLowerCase().split(',')
            : [
                'adresses',
                'codes-postaux',
                'routes',
                'intersections',
                'municipalites',
                'mrc',
                'regadmin',
                'lieux'
            ];
        const showAdvancedParams = this.options.showAdvancedSettings;
        return {
            title: 'igo.geo.search.icherche.name',
            searchUrl: 'https://geoegl.msp.gouv.qc.ca/apis/icherche',
            settings: [
                {
                    type: 'checkbox',
                    title: 'results type',
                    name: 'type',
                    values: [
                        {
                            title: 'igo.geo.search.icherche.type.address',
                            value: 'adresses',
                            enabled: types.indexOf('adresses') !== -1,
                            hashtags: ['adresse']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.oldAddress',
                            value: 'anciennes-adresses',
                            enabled: types.indexOf('anciennes-adresses') !== -1,
                            hashtags: ['anciennes-adresses']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.oldCity',
                            value: 'anciennes-municipalites',
                            enabled: types.indexOf('anciennes-municipalites') !== -1,
                            hashtags: ['anciennes-municipalites']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.cn',
                            value: 'bornes-cn',
                            enabled: types.indexOf('bornes-cn') !== -1,
                            hashtags: ['borne', 'bornes', 'cn']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.sumi',
                            value: 'bornes-sumi',
                            enabled: types.indexOf('bornes-sumi') !== -1,
                            hashtags: ['borne', 'bornes', 'sumi']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.cadastre',
                            value: 'cadastre',
                            enabled: types.indexOf('cadastre') !== -1,
                            hashtags: ['cadastre']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.postalCode',
                            value: 'codes-postaux',
                            enabled: types.indexOf('codes-postaux') !== -1,
                            hashtags: ['code-postal']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.entreprise',
                            value: 'entreprises',
                            enabled: types.indexOf('entreprises') !== -1,
                            available: false,
                            hashtags: ['entreprise']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.cycleStop',
                            value: 'haltes_cyclables',
                            enabled: types.indexOf('haltes_cyclables') !== -1,
                            hashtags: ['haltevelo', 'haltes_cyclables']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.restArea',
                            value: 'haltes_routieres',
                            enabled: types.indexOf('haltes_routieres') !== -1,
                            hashtags: ['halteroute', 'haltes_routieres']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.hq',
                            value: 'hq',
                            enabled: types.indexOf('hq') !== -1,
                            hashtags: ['hq']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.intersection',
                            value: 'intersections',
                            enabled: types.indexOf('intersections') !== -1,
                            hashtags: ['intersection', '+']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.place',
                            value: 'lieux',
                            enabled: types.indexOf('lieux') !== -1,
                            hashtags: ['lieu']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.mrc',
                            value: 'mrc',
                            enabled: types.indexOf('mrc') !== -1,
                            hashtags: ['mrc']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.city',
                            value: 'municipalites',
                            enabled: types.indexOf('municipalites') !== -1,
                            hashtags: ['municipalité', 'mun']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.regadmin',
                            value: 'regadmin',
                            enabled: types.indexOf('regadmin') !== -1,
                            hashtags: ['région-administrative', 'regadmin']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.gcc',
                            value: 'bornes-gcc',
                            enabled: types.indexOf('bornes-gcc') !== -1,
                            hashtags: ['borne', 'bornes', 'repère', 'gcc', 'ccg']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.km',
                            value: 'bornes-km',
                            enabled: types.indexOf('bornes-km') !== -1,
                            hashtags: ['borne', 'bornes', 'repère', 'km']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.road',
                            value: 'routes',
                            enabled: types.indexOf('routes') !== -1,
                            hashtags: ['route']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.exit',
                            value: 'sorties-autoroute',
                            enabled: types.indexOf('sorties-autoroute') !== -1,
                            hashtags: ['sortie', 'sorties', 'exit']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.cultpatri',
                            value: 'culture',
                            enabled: types.indexOf('culture') !== -1,
                            hashtags: ['grille', 'culture']
                        },
                        {
                            title: 'igo.geo.search.icherche.type.unites',
                            value: 'unites',
                            enabled: types.indexOf('unites') !== -1,
                            hashtags: ['unites']
                        }
                    ]
                },
                {
                    type: 'radiobutton',
                    title: 'results limit',
                    name: 'limit',
                    values: [
                        {
                            title: '1',
                            value: 1,
                            enabled: limit === 1
                        },
                        {
                            title: '5',
                            value: 5,
                            enabled: limit === 5 || !limit
                        },
                        {
                            title: '10',
                            value: 10,
                            enabled: limit === 10
                        },
                        {
                            title: '25',
                            value: 25,
                            enabled: limit === 25
                        },
                        {
                            title: '50',
                            value: 50,
                            enabled: limit === 50
                        }
                    ]
                },
                showAdvancedParams &&
                    ({
                        type: 'radiobutton',
                        title: 'ecmax',
                        name: 'ecmax',
                        values: [
                            {
                                title: '10 %',
                                value: 10,
                                enabled: ecmax === 10
                            },
                            {
                                title: '30 %',
                                value: 30,
                                enabled: ecmax === 30 || !ecmax
                            },
                            {
                                title: '50 %',
                                value: 50,
                                enabled: ecmax === 50
                            },
                            {
                                title: '75 %',
                                value: 75,
                                enabled: ecmax === 75
                            },
                            {
                                title: '100 %',
                                value: 100,
                                enabled: ecmax === 100
                            }
                        ]
                    }),
                {
                    type: 'radiobutton',
                    title: 'restrictExtent',
                    name: 'loc',
                    values: [
                        {
                            title: 'igo.geo.search.icherche.restrictExtent.map',
                            value: 'true',
                            enabled: false
                        },
                        {
                            title: 'igo.geo.search.icherche.restrictExtent.quebec',
                            value: 'false',
                            enabled: true
                        }
                    ]
                }
            ].filter(Boolean)
        };
    }
    /**
     * Search a location by name or keyword
     * @param term Location name or keyword
     * @returns Observable of <SearchResult<Feature>[]
     */
    search(term, options) {
        const params = this.computeRequestParams(term, options || {});
        if (!params.get('type').length) {
            return of([]);
        }
        this.options.params.page = params.get('page') || '1';
        return this.getSearch(term, params);
    }
    getSearch(term, params) {
        return this.http.get(`${this.searchUrl}/geocode`, { params }).pipe(map((response) => this.extractResults(response, term)), catchError((err) => {
            err.error.toDisplay = true;
            err.error.title = this.languageService.translate.instant(this.getDefaultOptions().title);
            throw err;
        }));
    }
    getAllowedTypes() {
        return this.http
            .get(`${this.searchUrl}/types`)
            .subscribe((types) => {
            const typeSetting = this.settings.find((s) => s.name === 'type');
            typeSetting.values.forEach((v) => {
                const regex = new RegExp(`^${v.value}(\\.|$)`);
                const typesMatched = types.filter((value) => regex.test(value));
                v.available = typesMatched.length > 0;
                if (v.value === 'lieux') {
                    this.hashtagsLieuxToKeep = [
                        ...new Set(typesMatched
                            .map((t) => t.split('.'))
                            .reduce((a, b) => a.concat(b))
                            .filter((t) => t !== 'lieux'))
                    ];
                }
            });
            this.setParamFromSetting(typeSetting, false);
        });
    }
    computeRequestParams(term, options) {
        const queryParams = Object.assign({
            geometry: true,
            bbox: true,
            icon: true,
            type: 'adresses,codes-postaux,municipalites,mrc,regadmin,lieux,entreprises,bornes-sumi'
        }, this.params, this.computeOptionsParam(term, options || {}).params, {
            q: this.computeTerm(term),
            page: options.page
        });
        if (queryParams.loc === 'true') {
            const [xMin, yMin, xMax, yMax] = options.extent;
            queryParams.loc = `${xMin},${yMin};${xMax},${yMin};${xMax},${yMax};${xMin},${yMax};${xMin},${yMin}`;
        }
        else if (queryParams.loc === 'false') {
            delete queryParams.loc;
        }
        if (/#[A-Za-z]+/.test(queryParams.q)) {
            queryParams.type = 'lieux';
        }
        return new HttpParams({
            fromObject: ObjectUtils.removeUndefined(queryParams),
            encoder: new IgoHttpParameterCodec()
        });
    }
    extractResults(response, term) {
        return response.features.map((data) => {
            return this.formatter.formatResult(this.dataToResult(data, term, response));
        });
    }
    dataToResult(data, term, response) {
        const properties = this.computeProperties(data);
        const id = [this.getId(), properties.type, properties.code].join('.');
        const titleHtml = data.highlight.title || data.properties.nom;
        const subtitleHtml = data.highlight.title2
            ? ' <small> ' + data.highlight.title2 + '</small>'
            : '';
        const subtitleHtml2 = data.highlight.title3
            ? '<br><small> ' + data.highlight.title3 + '</small>'
            : '';
        return {
            source: this,
            data: {
                type: FEATURE,
                projection: 'EPSG:4326',
                geometry: data.geometry,
                extent: data.bbox,
                properties,
                meta: {
                    id,
                    title: data.properties.nom
                }
            },
            meta: {
                dataType: FEATURE,
                id,
                title: data.properties.nom,
                titleHtml: titleHtml + subtitleHtml + subtitleHtml2,
                icon: data.icon || 'map-marker',
                score: data.score || computeTermSimilarity(term.trim(), data.properties.nom),
                nextPage: response.features.length % +this.options.params.limit === 0 &&
                    +this.options.params.page < 10
            }
        };
    }
    computeProperties(data) {
        const properties = ObjectUtils.removeKeys(data.properties, IChercheSearchSource.propertiesBlacklist);
        if (!data.geometry) {
            return Object.assign({ type: data.index }, properties);
        }
        const googleLinksProperties = {
            GoogleMaps: ''
        };
        let googleMaps;
        if (data.geometry.type === 'Point') {
            googleMaps = GoogleLinks.getGoogleMapsCoordLink(data.geometry.coordinates[0], data.geometry.coordinates[1]);
        }
        else {
            const point = pointOnFeature(data.geometry);
            googleMaps = GoogleLinks.getGoogleMapsCoordLink(point.geometry.coordinates[0], point.geometry.coordinates[1]);
        }
        let googleMapsNom;
        if (data.index === 'routes') {
            googleMapsNom = GoogleLinks.getGoogleMapsNameLink(data.properties.nom + ', ' + data.properties.municipalite);
        }
        else if (data.index === 'municipalites') {
            googleMapsNom = GoogleLinks.getGoogleMapsNameLink(data.properties.nom + ', ' + 'ville');
        }
        else if (data.index === 'mrc') {
            googleMapsNom = GoogleLinks.getGoogleMapsNameLink('mrc+' + data.properties.nom);
        }
        else if (data.index === 'regadmin') {
            googleMapsNom = GoogleLinks.getGoogleMapsNameLink(data.properties.nom + ',+QC');
        }
        else {
            googleMapsNom = GoogleLinks.getGoogleMapsNameLink(data.properties.nom || data.highlight.title);
        }
        googleLinksProperties.GoogleMaps =
            '<a href=' +
                googleMaps +
                ' target="_blank">' +
                this.languageService.translate.instant('igo.geo.searchByCoord') +
                '</a> <br /> <a href=' +
                googleMapsNom +
                ' target="_blank">' +
                this.languageService.translate.instant('igo.geo.searchByName') +
                '</a>';
        if (data.geometry.type === 'Point') {
            googleLinksProperties.GoogleStreetView =
                GoogleLinks.getGoogleStreetViewLink(data.geometry.coordinates[0], data.geometry.coordinates[1]);
        }
        const routing = {
            Route: '<span class="routing"> <u>' +
                this.languageService.translate.instant('igo.geo.seeRouting') +
                '</u> </span>'
        };
        return Object.assign({ type: data.index }, properties, googleLinksProperties, routing);
    }
    /**
     * Remove hashtag from query
     * @param term Query with hashtag
     */
    computeTerm(term) {
        // Keep hashtags for "lieux"
        const hashtags = term.match(/(#[A-Za-z]+)/g) || [];
        let keep = false;
        keep = hashtags.some((hashtag) => {
            const hashtagKey = hashtag.substring(1);
            return this.hashtagsLieuxToKeep.some((h) => h
                .toLowerCase()
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '') ===
                hashtagKey
                    .toLowerCase()
                    .normalize('NFD')
                    .replace(/[\u0300-\u036f]/g, ''));
        });
        if (!keep) {
            term = term.replace(/(#[A-Za-z]+)/g, '');
        }
        return term.replace(/[^\wÀ-ÿ !\-\+\(\)\.\/½¼¾,'#]+/g, '');
    }
    /**
     * Add hashtag to param if valid
     * @param term Query with hashtag
     * @param options TextSearchOptions
     */
    computeOptionsParam(term, options) {
        const hashtags = super.getHashtagsValid(term, 'type');
        if (hashtags) {
            options.params = Object.assign(options.params || {}, {
                type: hashtags.join(',')
            });
        }
        return options;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IChercheSearchSource, deps: [{ token: i1.HttpClient }, { token: i2.LanguageService }, { token: i2.StorageService }, { token: 'options' }, { token: IChercheSearchResultFormatter }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IChercheSearchSource });
}
__decorate([
    Cacheable({
        maxCacheCount: 20,
        cacheHasher: customCacheHasher
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, HttpParams]),
    __metadata("design:returntype", Observable)
], IChercheSearchSource.prototype, "getSearch", null);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IChercheSearchSource, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: i2.LanguageService }, { type: i2.StorageService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['options']
                }] }, { type: IChercheSearchResultFormatter, decorators: [{
                    type: Inject,
                    args: [IChercheSearchResultFormatter]
                }] }, { type: i0.Injector }]; }, propDecorators: { getSearch: [] } });
/**
 * IChercheReverse search source
 */
class IChercheReverseSearchSource extends SearchSource {
    http;
    languageService;
    static id = 'icherchereverse';
    static type = FEATURE;
    static propertiesBlacklist = [];
    title$ = new BehaviorSubject('');
    get title() {
        return this.title$.getValue();
    }
    constructor(http, languageService, storageService, options, injector) {
        super(options, storageService);
        this.http = http;
        this.languageService = languageService;
        this.languageService.language$.subscribe(() => {
            this.title$.next(this.languageService.translate.instant(this.options.title));
        });
        const authService = injector.get(AuthService);
        if (this.settings.length) {
            if (!authService) {
                this.getAllowedTypes();
            }
            else {
                authService.authenticate$.subscribe(() => {
                    this.getAllowedTypes();
                });
            }
        }
    }
    getId() {
        return IChercheReverseSearchSource.id;
    }
    getType() {
        return IChercheReverseSearchSource.type;
    }
    getDefaultOptions() {
        const types = this.options.params && this.options.params.type
            ? this.options.params.type.replace(/\s/g, '').toLowerCase().split(',')
            : ['adresses', 'municipalites', 'mrc', 'regadmin'];
        return {
            title: 'igo.geo.search.ichercheReverse.name',
            searchUrl: 'https://geoegl.msp.gouv.qc.ca/apis/terrapi',
            settings: [
                {
                    type: 'checkbox',
                    title: 'results type',
                    name: 'type',
                    values: [
                        {
                            title: 'igo.geo.search.icherche.type.address',
                            value: 'adresses',
                            enabled: types.indexOf('adresses') !== -1
                        },
                        {
                            title: 'igo.geo.search.icherche.type.road',
                            value: 'routes',
                            enabled: types.indexOf('routes') !== -1,
                            available: false
                        },
                        {
                            title: 'igo.geo.search.icherche.type.district',
                            value: 'arrondissements',
                            enabled: types.indexOf('arrondissements') !== -1
                        },
                        {
                            title: 'igo.geo.search.icherche.type.city',
                            value: 'municipalites',
                            enabled: types.indexOf('municipalites') !== -1
                        },
                        {
                            title: 'igo.geo.search.icherche.type.mrc',
                            value: 'mrc',
                            enabled: types.indexOf('mrc') !== -1
                        },
                        {
                            title: 'igo.geo.search.icherche.type.regadmin',
                            value: 'regadmin',
                            enabled: types.indexOf('regadmin') !== -1
                        },
                        {
                            title: 'igo.geo.search.icherche.type.unites',
                            value: 'unites',
                            enabled: types.indexOf('unites') !== -1
                        }
                    ]
                },
                {
                    type: 'radiobutton',
                    title: 'radius',
                    name: 'bufferInput',
                    values: [
                        {
                            title: '100 m',
                            value: 100,
                            enabled: !this.options.distance || this.options.distance === 100
                        },
                        {
                            title: '500 m',
                            value: 500,
                            enabled: this.options.distance === 500
                        },
                        {
                            title: '1 km',
                            value: 1000,
                            enabled: this.options.distance === 1000
                        },
                        {
                            title: '2 km',
                            value: 2000,
                            enabled: this.options.distance === 2000
                        },
                        {
                            title: '5 km',
                            value: 5000,
                            enabled: this.options.distance === 5000
                        }
                    ]
                }
            ]
        };
    }
    /**
     * Search a location by coordinates
     * @param lonLat Location coordinates
     * @param distance Search raidus around lonLat
     * @returns Observable of <SearchResult<Feature>[]
     */
    reverseSearch(lonLat, options) {
        const params = this.computeRequestParams(lonLat, options || {});
        if (!params.get('type').length) {
            return of([]);
        }
        return this.getReverseSearch(params);
    }
    getReverseSearch(params) {
        return this.http.get(`${this.searchUrl}/locate`, { params }).pipe(map((response) => {
            return this.extractResults(response);
        }));
    }
    getAllowedTypes() {
        return this.http
            .get(`${this.searchUrl}/types`)
            .subscribe((types) => {
            const typeSetting = this.settings.find((s) => s.name === 'type');
            typeSetting.values.forEach((v) => {
                v.available = types.indexOf(v.value) > -1;
            });
            this.setParamFromSetting(typeSetting, false);
        });
    }
    computeRequestParams(lonLat, options) {
        if (options.distance || this.options.distance) {
            options.params = Object.assign(options.params || {}, {
                bufferInput: options.distance || this.options.distance
            });
        }
        return new HttpParams({
            fromObject: Object.assign({
                loc: lonLat.join(','),
                sort: 'distance',
                geometry: true,
                icon: true
            }, options.params || {}, this.params)
        });
    }
    extractResults(response) {
        return response.features.map((data) => {
            return this.dataToResult(data);
        });
    }
    getSubtitle(data) {
        if (!this.settings.length) {
            return '';
        }
        let subtitle = '';
        switch (data.properties.type) {
            case 'arrondissements':
                subtitle = data.properties.municipalite + ' (Arrondissement)';
                break;
            default:
                const typeSetting = this.settings.find((s) => s.name === 'type');
                const type = typeSetting.values.find((t) => t.value === data.properties.type);
                if (type) {
                    subtitle = this.languageService.translate.instant(type.title);
                }
        }
        return subtitle;
    }
    dataToResult(data) {
        const properties = this.computeProperties(data);
        const extent = this.computeExtent(data);
        const id = [this.getId(), properties.type, properties.code].join('.');
        const titleHtml = data.properties.nom;
        const subtitleHtml = ' <small> ' + this.getSubtitle(data) + '</small>';
        return {
            source: this,
            data: {
                type: FEATURE,
                projection: 'EPSG:4326',
                geometry: data.geometry,
                extent,
                properties,
                meta: {
                    id,
                    title: data.properties.nom
                }
            },
            meta: {
                dataType: FEATURE,
                id,
                title: data.properties.nom,
                titleHtml: titleHtml + subtitleHtml,
                icon: data.icon || 'map-marker',
                pointerSummaryTitle: this.getSubtitle(data) + ': ' + data.properties.nom
            }
        };
    }
    computeProperties(data) {
        const properties = ObjectUtils.removeKeys(data.properties, IChercheReverseSearchSource.propertiesBlacklist);
        const routing = {
            Route: '<span class="routing"> <u>' +
                this.languageService.translate.instant('igo.geo.seeRouting') +
                '</u> </span>'
        };
        return Object.assign(properties, routing);
    }
    computeExtent(data) {
        return data.bbox
            ? [data.bbox[0], data.bbox[2], data.bbox[1], data.bbox[3]]
            : undefined;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IChercheReverseSearchSource, deps: [{ token: i1.HttpClient }, { token: i2.LanguageService }, { token: i2.StorageService }, { token: 'options' }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IChercheReverseSearchSource });
}
__decorate([
    Cacheable({
        maxCacheCount: 20,
        cacheHasher: customCacheHasher
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [HttpParams]),
    __metadata("design:returntype", Observable)
], IChercheReverseSearchSource.prototype, "getReverseSearch", null);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IChercheReverseSearchSource, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: i2.LanguageService }, { type: i2.StorageService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['options']
                }] }, { type: i0.Injector }]; }, propDecorators: { getReverseSearch: [] } });

/**
 * ICherche search result formatter factory
 * @ignore
 */
function defaultIChercheSearchResultFormatterFactory(languageService) {
    return new IChercheSearchResultFormatter(languageService);
}
/**
 * Function that returns a provider for the ICherche search result formatter
 */
function provideDefaultIChercheSearchResultFormatter() {
    return {
        provide: IChercheSearchResultFormatter,
        useFactory: defaultIChercheSearchResultFormatterFactory,
        deps: [LanguageService]
    };
}
/**
 * ICherche search source factory
 * @ignore
 */
function ichercheSearchSourceFactory(http, languageService, storageService, config, formatter, injector) {
    return new IChercheSearchSource(http, languageService, storageService, config.getConfig(`searchSources.${IChercheSearchSource.id}`), formatter, injector);
}
/**
 * Function that returns a provider for the ICherche search source
 */
function provideIChercheSearchSource() {
    return {
        provide: SearchSource,
        useFactory: ichercheSearchSourceFactory,
        multi: true,
        deps: [
            HttpClient,
            LanguageService,
            StorageService,
            ConfigService,
            IChercheSearchResultFormatter,
            Injector
        ]
    };
}
/**
 * IChercheReverse search source factory
 * @ignore
 */
function ichercheReverseSearchSourceFactory(http, languageService, storageService, config, injector) {
    return new IChercheReverseSearchSource(http, languageService, storageService, config.getConfig(`searchSources.${IChercheReverseSearchSource.id}`), injector);
}
/**
 * Function that returns a provider for the IChercheReverse search source
 */
function provideIChercheReverseSearchSource() {
    return {
        provide: SearchSource,
        useFactory: ichercheReverseSearchSourceFactory,
        multi: true,
        deps: [HttpClient, LanguageService, StorageService, ConfigService, Injector]
    };
}

class ILayerSearchResultFormatter {
    languageService;
    constructor(languageService) {
        this.languageService = languageService;
    }
    formatResult(data) {
        const allowedKey = [
            'title',
            'abstract',
            'groupTitle',
            'metadataUrl',
            'downloadUrl',
            'urlInfo',
            'name'
        ];
        const property = Object.entries(data.properties)
            .filter(([key]) => allowedKey.indexOf(key) !== -1)
            .reduce((out, entries) => {
            const [key, value] = entries;
            let newKey;
            try {
                newKey = this.languageService.translate.instant('igo.geo.search.ilayer.properties.' + key);
            }
            catch (e) {
                newKey = key;
            }
            out[newKey] = value ? value : '';
            return out;
        }, {});
        const dataR = Object.assign({}, data);
        dataR.properties = property;
        return dataR;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ILayerSearchResultFormatter, deps: [{ token: i2.LanguageService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ILayerSearchResultFormatter });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ILayerSearchResultFormatter, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i2.LanguageService }]; } });
/**
 * ILayer search source
 */
class ILayerSearchSource extends SearchSource {
    http;
    languageService;
    formatter;
    static id = 'ilayer';
    static type = LAYER;
    title$ = new BehaviorSubject('');
    get title() {
        return this.title$.getValue();
    }
    constructor(http, languageService, storageService, options, formatter) {
        super(options, storageService);
        this.http = http;
        this.languageService = languageService;
        this.formatter = formatter;
        this.languageService.language$.subscribe(() => {
            this.title$.next(this.languageService.translate.instant(this.options.title));
        });
    }
    getId() {
        return ILayerSearchSource.id;
    }
    getType() {
        return ILayerSearchSource.type;
    }
    getDefaultOptions() {
        const limit = this.options.params && this.options.params.limit
            ? Number(this.options.params.limit)
            : undefined;
        const ecmax = this.options.params && this.options.params.ecmax
            ? Number(this.options.params.ecmax)
            : undefined;
        const showAdvancedParams = this.options.showAdvancedSettings;
        return {
            title: 'igo.geo.search.ilayer.name',
            searchUrl: 'https://geoegl.msp.gouv.qc.ca/apis/layers/search',
            settings: [
                {
                    type: 'checkbox',
                    title: 'results type',
                    name: 'type',
                    values: [
                        {
                            title: 'igo.geo.search.ilayer.type.layer',
                            value: 'layer',
                            enabled: true,
                            hashtags: ['layer', 'layers', 'couche', 'couches']
                        },
                        {
                            title: 'igo.geo.search.ilayer.type.groupLayer',
                            value: 'group',
                            enabled: false,
                            hashtags: ['gr-layer', 'gr-layers', 'gr-couche', 'gr-couches']
                        }
                    ]
                },
                {
                    type: 'radiobutton',
                    title: 'results limit',
                    name: 'limit',
                    values: [
                        {
                            title: '1',
                            value: 1,
                            enabled: limit === 1
                        },
                        {
                            title: '5',
                            value: 5,
                            enabled: limit === 5 || !limit
                        },
                        {
                            title: '10',
                            value: 10,
                            enabled: limit === 10
                        },
                        {
                            title: '25',
                            value: 25,
                            enabled: limit === 25
                        },
                        {
                            title: '50',
                            value: 50,
                            enabled: limit === 50
                        }
                    ]
                },
                showAdvancedParams &&
                    ({
                        type: 'radiobutton',
                        title: 'ecmax',
                        name: 'ecmax',
                        values: [
                            {
                                title: '10 %',
                                value: 10,
                                enabled: ecmax === 10
                            },
                            {
                                title: '30 %',
                                value: 30,
                                enabled: ecmax === 30
                            },
                            {
                                title: '50 %',
                                value: 50,
                                enabled: ecmax === 50 || !ecmax
                            },
                            {
                                title: '75 %',
                                value: 75,
                                enabled: ecmax === 75
                            },
                            {
                                title: '100 %',
                                value: 100,
                                enabled: ecmax === 100
                            }
                        ]
                    })
            ].filter(Boolean)
        };
    }
    /**
     * Search a layer by name or keyword
     * @param term Layer name or keyword
     * @returns Observable of <SearchResult<LayerOptions>[]
     */
    search(term, options) {
        const params = this.computeSearchRequestParams(term, options || {});
        if (!params.get('q') || !params.get('type')) {
            return of([]);
        }
        this.options.params.page = params.get('page') || '1';
        return this.getSearch(term, params);
    }
    getSearch(term, params) {
        return this.http
            .get(this.searchUrl, { params })
            .pipe(map((response) => this.extractResults(response, term)));
    }
    computeSearchRequestParams(term, options) {
        return new HttpParams({
            fromObject: ObjectUtils.removeUndefined(Object.assign({
                q: this.computeTerm(term)
            }, this.params, this.computeOptionsParam(term, options || {}).params, {
                page: options.page
            }))
        });
    }
    /**
     * Remove hashtag from query
     * @param term Query with hashtag
     */
    computeTerm(term) {
        return term.replace(/(#[^\s]*)/g, '').replace(/[^\wÀ-ÿ !\-\(\),'#]+/g, '');
    }
    /**
     * Add hashtag to param if valid
     * @param term Query with hashtag
     * @param options TextSearchOptions
     */
    computeOptionsParam(term, options) {
        const hashtags = super.getHashtagsValid(term, 'type');
        if (hashtags) {
            options.params = Object.assign(options.params || {}, {
                type: hashtags.join(',')
            });
        }
        return options;
    }
    extractResults(response, term) {
        return response.items.map((data) => this.dataToResult(data, term, response));
    }
    dataToResult(data, term, response) {
        const layerOptions = this.computeLayerOptions(data);
        const titleHtml = data.highlight.title || data.properties.title;
        const groupTitle = data.highlight.groupTitle || data.properties.groupTitle;
        const subtitleHtml = groupTitle
            ? ' <small style="color: #6f6969"> ' + groupTitle + '</small>'
            : '';
        return {
            source: this,
            meta: {
                dataType: LAYER,
                id: [this.getId(), data.properties.id].join('.'),
                title: data.properties.title,
                titleHtml: titleHtml + subtitleHtml,
                icon: data.properties.type === 'Layer' ? 'layers' : 'map',
                score: data.score ||
                    computeTermSimilarity(term.trim(), data.properties.name),
                nextPage: response.items.length % +this.options.params.limit === 0 &&
                    +this.options.params.page < 10
            },
            data: layerOptions
        };
    }
    computeLayerOptions(data) {
        const url = data.properties.url;
        const queryParams = this.extractQueryParamsFromSourceUrl(url);
        return ObjectUtils.removeUndefined({
            sourceOptions: {
                id: data.properties.id,
                type: data.properties.format,
                url,
                queryFormat: queryParams.queryFormat,
                queryHtmlTarget: queryParams.queryHtmlTarget,
                params: data.properties.format === 'wms'
                    ? { LAYERS: data.properties.name }
                    : undefined,
                layer: data.properties.format === 'wms' ? undefined : data.properties.name,
                optionsFromCapabilities: true,
                crossOrigin: 'anonymous'
            },
            title: data.properties.title,
            maxResolution: getResolutionFromScale(Number(data.properties.maxScaleDenom)),
            minResolution: getResolutionFromScale(Number(data.properties.minScaleDenom)),
            metadata: {
                url: data.properties.metadataUrl,
                extern: data.properties.metadataUrl ? true : undefined,
                abstract: data.properties.abstract || undefined
            },
            properties: this.formatter.formatResult(data).properties
        });
    }
    extractQueryParamsFromSourceUrl(url) {
        let queryFormat;
        let queryHtmlTarget;
        const formatOpt = this.options.queryFormat;
        if (formatOpt) {
            for (const key of Object.keys(formatOpt)) {
                const value = formatOpt[key];
                if (value === '*') {
                    queryFormat = QueryFormat[key.toUpperCase()];
                    break;
                }
                const urls = value.urls;
                if (Array.isArray(urls)) {
                    urls.forEach((urlOpt) => {
                        if (url.indexOf(urlOpt) !== -1) {
                            queryFormat = QueryFormat[key.toUpperCase()];
                        }
                    });
                    break;
                }
            }
            if (queryFormat === QueryFormat.HTML ||
                queryFormat === QueryFormat.HTMLGML2) {
                queryHtmlTarget = 'iframe';
            }
        }
        return {
            queryFormat,
            queryHtmlTarget
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ILayerSearchSource, deps: [{ token: i1.HttpClient }, { token: i2.LanguageService }, { token: i2.StorageService }, { token: 'options' }, { token: ILayerSearchResultFormatter }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ILayerSearchSource });
}
__decorate([
    Cacheable({
        maxCacheCount: 20,
        cacheHasher: customCacheHasher
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, HttpParams]),
    __metadata("design:returntype", Observable)
], ILayerSearchSource.prototype, "getSearch", null);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ILayerSearchSource, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: i2.LanguageService }, { type: i2.StorageService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['options']
                }] }, { type: ILayerSearchResultFormatter, decorators: [{
                    type: Inject,
                    args: [ILayerSearchResultFormatter]
                }] }]; }, propDecorators: { getSearch: [] } });

/**
 * ILayer search result formatter factory
 * @ignore
 */
function ilayerSearchResultFormatterFactory(languageService) {
    return new ILayerSearchResultFormatter(languageService);
}
/**
 * Function that returns a provider for the ILayer search result formatter
 */
function provideILayerSearchResultFormatter() {
    return {
        provide: ILayerSearchResultFormatter,
        useFactory: ilayerSearchResultFormatterFactory,
        deps: [LanguageService]
    };
}
/**
 * ILayer search source factory
 * @ignore
 */
function ilayerSearchSourceFactory(http, languageService, storageService, config, formatter) {
    return new ILayerSearchSource(http, languageService, storageService, config.getConfig(`searchSources.${ILayerSearchSource.id}`), formatter);
}
/**
 * Function that returns a provider for the ILayer search source
 */
function provideILayerSearchSource() {
    return {
        provide: SearchSource,
        useFactory: ilayerSearchSourceFactory,
        multi: true,
        deps: [
            HttpClient,
            LanguageService,
            StorageService,
            ConfigService,
            ILayerSearchResultFormatter
        ]
    };
}

class IgoSearchModule {
    static forRoot() {
        return {
            ngModule: IgoSearchModule,
            providers: [
                SearchService,
                provideSearchSourceService(),
                provideDefaultIChercheSearchResultFormatter(),
                provideDefaultCoordinatesSearchResultFormatter(),
                provideILayerSearchResultFormatter()
            ]
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoSearchModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoSearchModule, declarations: [SearchPointerSummaryDirective], imports: [CommonModule,
            IgoSearchBarModule,
            IgoSearchSelectorModule,
            IgoSearchResultsModule,
            IgoSearchSettingsModule], exports: [IgoSearchBarModule,
            IgoSearchSelectorModule,
            IgoSearchResultsModule,
            IgoSearchSettingsModule,
            SearchPointerSummaryDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoSearchModule, imports: [CommonModule,
            IgoSearchBarModule,
            IgoSearchSelectorModule,
            IgoSearchResultsModule,
            IgoSearchSettingsModule, IgoSearchBarModule,
            IgoSearchSelectorModule,
            IgoSearchResultsModule,
            IgoSearchSettingsModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoSearchModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        IgoSearchBarModule,
                        IgoSearchSelectorModule,
                        IgoSearchResultsModule,
                        IgoSearchSettingsModule
                    ],
                    exports: [
                        IgoSearchBarModule,
                        IgoSearchSelectorModule,
                        IgoSearchResultsModule,
                        IgoSearchSettingsModule,
                        SearchPointerSummaryDirective
                    ],
                    declarations: [SearchPointerSummaryDirective]
                }]
        }] });

let STYLELIST_OPTIONS = new InjectionToken('styleListOptions');
function provideStyleListOptions(options) {
    return {
        provide: STYLELIST_OPTIONS,
        useValue: options
    };
}
function styleListFactory(styleListService, options) {
    return () => styleListService.load(options);
}
function provideStyleListLoader() {
    return {
        provide: APP_INITIALIZER,
        useFactory: styleListFactory,
        multi: true,
        deps: [StyleListService, STYLELIST_OPTIONS]
    };
}

class IgoStyleListModule {
    static forRoot() {
        return {
            ngModule: IgoStyleListModule,
            providers: [provideStyleListOptions({}), provideStyleListLoader()]
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoStyleListModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoStyleListModule });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoStyleListModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoStyleListModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [],
                    declarations: [],
                    exports: []
                }]
        }] });

class StyleModalLayerComponent {
    dialogRef;
    formBuilder;
    data;
    confirmFlag = false;
    form;
    styleModalData;
    linestringOnly;
    initialValues;
    defaultValues = {
        fillColor: 'rgba(255,255,255,0.4)',
        strokeColor: 'rgba(143,7,7,1)'
    };
    get layerOlStyle() {
        const style = this.data.layer.ol.getStyle();
        return style instanceof Function ? undefined : style.clone();
    }
    constructor(dialogRef, formBuilder, data) {
        this.dialogRef = dialogRef;
        this.formBuilder = formBuilder;
        this.data = data;
    }
    ngOnInit() {
        this.linestringOnly = true;
        for (const feature of this.data.layer.ol.getSource().getFeatures()) {
            if (feature.getGeometry()?.getType() !== 'LineString') {
                this.linestringOnly = false;
            }
        }
        this.buildStyleData();
        this.buildForm();
    }
    buildForm() {
        this.form = this.formBuilder.group({
            fill: [this.getLayerFillColor()],
            stroke: [this.getLayerStrokeColor()]
        });
    }
    buildStyleData() {
        this.styleModalData = {
            fillColor: this.getLayerFillColor(),
            strokeColor: this.getLayerStrokeColor()
        };
        this.initialValues = {
            fillColor: this.getLayerFillColor(),
            strokeColor: this.getLayerStrokeColor()
        };
    }
    getLayerFillColor() {
        let fillColor = this.defaultValues.fillColor;
        const style = this.layerOlStyle;
        if (style?.getFill()?.getColor()) {
            const arrayColor = style.getFill().getColor();
            fillColor = `rgba(${arrayColor[0]},${arrayColor[1]},${arrayColor[2]},${arrayColor[3] || 0.4})`;
        }
        return fillColor;
    }
    getLayerStrokeColor() {
        let strokeColor = this.defaultValues.strokeColor;
        const style = this.layerOlStyle;
        if (style?.getStroke()?.getColor()) {
            const arrayColor = style.getStroke().getColor();
            strokeColor = `rgba(${arrayColor[0]},${arrayColor[1]},${arrayColor[2]},${arrayColor[3] || 1})`;
        }
        return strokeColor;
    }
    setLayerFillColor(event) {
        const cAA = asArray(event);
        const s = this.layerOlStyle.clone();
        s.getImage().getFill().setColor(cAA);
        s.getFill().setColor(cAA);
        this.data.layer.ol.setStyle(s);
        this.styleModalData.fillColor = event;
    }
    setLayerStrokeColor(event) {
        const cAA = asArray(event);
        const s = this.layerOlStyle.clone();
        s.getImage().getStroke().setColor(cAA);
        s.getStroke().setColor(cAA);
        this.data.layer.ol.setStyle(s);
        this.styleModalData.strokeColor = event;
    }
    cancel() {
        this.dialogRef.close();
        this.setLayerFillColor(this.initialValues.fillColor);
        this.setLayerStrokeColor(this.initialValues.strokeColor);
    }
    confirm() {
        this.confirmFlag = true;
        if (this.form.get('fill').value) {
            this.styleModalData.fillColor = this.form.get('fill').value;
        }
        if (this.form.get('stroke').value) {
            this.styleModalData.strokeColor = this.form.get('stroke').value;
        }
        this.dialogRef.close(this.styleModalData);
    }
    openPicker() {
        this.dialogRef.disableClose = true;
    }
    closePicker() {
        this.dialogRef.disableClose = false;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: StyleModalLayerComponent, deps: [{ token: i1$2.MatDialogRef }, { token: i2$1.UntypedFormBuilder }, { token: MAT_DIALOG_DATA }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: StyleModalLayerComponent, selector: "igo-style-modal-layer", inputs: { confirmFlag: "confirmFlag" }, ngImport: i0, template: "<h2 mat-dialog-title class=\"mat-typography\">\n  {{ 'igo.geo.style.styleModal' | translate }}\n</h2>\n<div mat-dialog-content>\n  <div class=\"edition-drawing mat-typography\">\n    <form class=\"igo-form\" [formGroup]=\"form\">\n      <div\n        class=\"fill-color-picker mat-typography\"\n        *ngIf=\"linestringOnly !== true\"\n      >\n        <span>\n          <mat-icon class=\"stroke-palette-icon\" svgIcon=\"square\"></mat-icon>\n          {{ 'igo.geo.style.fill' | translate }}\n        </span>\n        <igo-color-picker-form-field\n          formControlName=\"fill\"\n          (colorChange)=\"setLayerFillColor($event)\"\n        ></igo-color-picker-form-field>\n      </div>\n\n      <div class=\"stroke-color-picker mat-typography\">\n        <span>\n          <mat-icon class=\"stroke-palette-icon\" svgIcon=\"square-outline\">\n          </mat-icon>\n          {{ 'igo.geo.style.stroke' | translate }}\n        </span>\n        <igo-color-picker-form-field\n          formControlName=\"stroke\"\n          (colorChange)=\"setLayerStrokeColor($event)\"\n        ></igo-color-picker-form-field>\n      </div>\n    </form>\n  </div>\n</div>\n<div mat-dialog-actions>\n  <button mat-raised-button (click)=\"cancel()\">\n    {{ 'igo.geo.style.cancel' | translate }}\n  </button>\n  <button mat-raised-button color=\"primary\" (click)=\"confirm()\">OK</button>\n</div>\n", styles: ["h2{font-weight:700;font-size:large}.igo-form{padding:10px}.fill-field,.stroke-field{width:130px}.fill-color-picker mat-icon{position:relative;top:7px}.fill-color-picker mat-form-field{left:8px}.stroke-color-picker mat-icon{position:relative;top:7px}.stroke-color-picker mat-form-field{left:35px}.box{width:25px;height:25px}.edition-drawing{padding:10px 0}.igo-input-container .mat-mdc-form-field+.mat-form-field{margin-left:8px}.igo-form-input-box{width:150px}button{margin-right:5px}\n"], dependencies: [{ kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2$1.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i4$1.MatButton, selector: "    button[mat-button], button[mat-raised-button], button[mat-flat-button],    button[mat-stroked-button]  ", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "directive", type: i1$2.MatDialogTitle, selector: "[mat-dialog-title], [matDialogTitle]", inputs: ["id"], exportAs: ["matDialogTitle"] }, { kind: "directive", type: i1$2.MatDialogContent, selector: "[mat-dialog-content], mat-dialog-content, [matDialogContent]" }, { kind: "directive", type: i1$2.MatDialogActions, selector: "[mat-dialog-actions], mat-dialog-actions, [matDialogActions]", inputs: ["align"] }, { kind: "directive", type: i2$1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "directive", type: i2$1.FormControlName, selector: "[formControlName]", inputs: ["formControlName", "disabled", "ngModel"], outputs: ["ngModelChange"] }, { kind: "component", type: i9$1.ColorPickerFormFieldComponent, selector: "igo-color-picker-form-field", inputs: ["outputFormat"], outputs: ["colorChange"] }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: StyleModalLayerComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-style-modal-layer', template: "<h2 mat-dialog-title class=\"mat-typography\">\n  {{ 'igo.geo.style.styleModal' | translate }}\n</h2>\n<div mat-dialog-content>\n  <div class=\"edition-drawing mat-typography\">\n    <form class=\"igo-form\" [formGroup]=\"form\">\n      <div\n        class=\"fill-color-picker mat-typography\"\n        *ngIf=\"linestringOnly !== true\"\n      >\n        <span>\n          <mat-icon class=\"stroke-palette-icon\" svgIcon=\"square\"></mat-icon>\n          {{ 'igo.geo.style.fill' | translate }}\n        </span>\n        <igo-color-picker-form-field\n          formControlName=\"fill\"\n          (colorChange)=\"setLayerFillColor($event)\"\n        ></igo-color-picker-form-field>\n      </div>\n\n      <div class=\"stroke-color-picker mat-typography\">\n        <span>\n          <mat-icon class=\"stroke-palette-icon\" svgIcon=\"square-outline\">\n          </mat-icon>\n          {{ 'igo.geo.style.stroke' | translate }}\n        </span>\n        <igo-color-picker-form-field\n          formControlName=\"stroke\"\n          (colorChange)=\"setLayerStrokeColor($event)\"\n        ></igo-color-picker-form-field>\n      </div>\n    </form>\n  </div>\n</div>\n<div mat-dialog-actions>\n  <button mat-raised-button (click)=\"cancel()\">\n    {{ 'igo.geo.style.cancel' | translate }}\n  </button>\n  <button mat-raised-button color=\"primary\" (click)=\"confirm()\">OK</button>\n</div>\n", styles: ["h2{font-weight:700;font-size:large}.igo-form{padding:10px}.fill-field,.stroke-field{width:130px}.fill-color-picker mat-icon{position:relative;top:7px}.fill-color-picker mat-form-field{left:8px}.stroke-color-picker mat-icon{position:relative;top:7px}.stroke-color-picker mat-form-field{left:35px}.box{width:25px;height:25px}.edition-drawing{padding:10px 0}.igo-input-container .mat-mdc-form-field+.mat-form-field{margin-left:8px}.igo-form-input-box{width:150px}button{margin-right:5px}\n"] }]
        }], ctorParameters: function () { return [{ type: i1$2.MatDialogRef }, { type: i2$1.UntypedFormBuilder }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [MAT_DIALOG_DATA]
                }] }]; }, propDecorators: { confirmFlag: [{
                type: Input
            }] } });

class StyleModalLayerButtonComponent {
    dialog;
    layer;
    constructor(dialog) {
        this.dialog = dialog;
    }
    /**
     * Open the style modal dialog box
     */
    openStyleModalDialog() {
        setTimeout(() => {
            // open the dialog box used to style features
            const data = { layer: this.layer };
            const dialogRef = this.dialog.open(StyleModalLayerComponent, {
                disableClose: false,
                data,
                autoFocus: false
            });
        }, 250);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: StyleModalLayerButtonComponent, deps: [{ token: i1$2.MatDialog }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: StyleModalLayerButtonComponent, selector: "igo-style-modal-layer-button", inputs: { layer: "layer" }, ngImport: i0, template: "<button\n  mat-icon-button\n  color=\"primary\"\n  (click)=\"openStyleModalDialog()\"\n  [matTooltip]=\"'igo.geo.style.styleModalTooltipLayer' | translate\"\n>\n  <mat-icon class=\"style-icon\" svgIcon=\"palette\"> </mat-icon>\n</button>\n", styles: [""], dependencies: [{ kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "directive", type: i4.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: StyleModalLayerButtonComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-style-modal-layer-button', changeDetection: ChangeDetectionStrategy.OnPush, template: "<button\n  mat-icon-button\n  color=\"primary\"\n  (click)=\"openStyleModalDialog()\"\n  [matTooltip]=\"'igo.geo.style.styleModalTooltipLayer' | translate\"\n>\n  <mat-icon class=\"style-icon\" svgIcon=\"palette\"> </mat-icon>\n</button>\n" }]
        }], ctorParameters: function () { return [{ type: i1$2.MatDialog }]; }, propDecorators: { layer: [{
                type: Input
            }] } });

class IgoStyleModule {
    static forRoot() {
        return {
            ngModule: IgoStyleModule,
            providers: [StyleService, DrawStyleService]
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoStyleModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoStyleModule, declarations: [StyleModalDrawingComponent,
            StyleModalLayerComponent,
            StyleModalLayerButtonComponent], imports: [CommonModule,
            FormsModule,
            IgoLanguageModule,
            MatFormFieldModule,
            MatIconModule,
            MatButtonModule,
            MatDialogModule,
            MatInputModule,
            MatSelectModule,
            MatTooltipModule,
            ReactiveFormsModule,
            ColorPickerFormFieldModule, IgoStyleListModule], exports: [IgoStyleListModule,
            StyleModalDrawingComponent,
            StyleModalLayerComponent,
            StyleModalLayerButtonComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoStyleModule, imports: [CommonModule,
            FormsModule,
            IgoLanguageModule,
            MatFormFieldModule,
            MatIconModule,
            MatButtonModule,
            MatDialogModule,
            MatInputModule,
            MatSelectModule,
            MatTooltipModule,
            ReactiveFormsModule,
            ColorPickerFormFieldModule,
            IgoStyleListModule.forRoot(), IgoStyleListModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoStyleModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        FormsModule,
                        IgoLanguageModule,
                        MatFormFieldModule,
                        MatIconModule,
                        MatButtonModule,
                        MatDialogModule,
                        MatInputModule,
                        MatSelectModule,
                        MatTooltipModule,
                        ReactiveFormsModule,
                        ColorPickerFormFieldModule,
                        IgoStyleListModule.forRoot()
                    ],
                    exports: [
                        IgoStyleListModule,
                        StyleModalDrawingComponent,
                        StyleModalLayerComponent,
                        StyleModalLayerButtonComponent
                    ],
                    declarations: [
                        StyleModalDrawingComponent,
                        StyleModalLayerComponent,
                        StyleModalLayerButtonComponent
                    ]
                }]
        }] });

class ToastComponent {
    static SWIPE_ACTION = {
        UP: 'swipeup',
        DOWN: 'swipedown'
    };
    format = new OlGeoJSON();
    get expanded() {
        return this._expanded;
    }
    set expanded(value) {
        this.state = value ? 'expanded' : 'collapsed';
        this._expanded = value;
    }
    _expanded;
    get map() {
        return this._map;
    }
    set map(value) {
        this._map = value;
    }
    _map;
    get feature() {
        return this._feature;
    }
    set feature(value) {
        this._feature = value;
    }
    _feature;
    opened = new EventEmitter();
    state;
    /**
     * @internal
     */
    get title() {
        return getEntityTitle(this.feature);
    }
    constructor() { }
    toggle() {
        this.expanded = !this.expanded;
        this.opened.emit(this.expanded);
    }
    zoomToFeatureExtent() {
        if (this.feature.geometry) {
            const olFeature = this.format.readFeature(this.feature, {
                dataProjection: this.feature.projection,
                featureProjection: this.map.projection
            });
            moveToOlFeatures(this.map.viewController, [olFeature], FeatureMotion.Zoom);
        }
    }
    swipe(action) {
        if (action === ToastComponent.SWIPE_ACTION.UP) {
            if (!this.expanded) {
                this.toggle();
            }
        }
        else if (action === ToastComponent.SWIPE_ACTION.DOWN) {
            if (this.expanded) {
                this.toggle();
            }
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ToastComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: ToastComponent, selector: "igo-toast", inputs: { expanded: "expanded", map: "map", feature: "feature" }, outputs: { opened: "opened" }, ngImport: i0, template: "<igo-flexible\n  #flex\n  collapsedMobile=\"51px\"\n  expandedMobile=\"300px\"\n  [state]=\"state\"\n  (swipeup)=\"swipe($event.type)\"\n  (swipedown)=\"swipe($event.type)\"\n>\n  <igo-panel [title]=\"title\">\n    <button mat-icon-button panelLeftButton (click)=\"toggle()\">\n      <mat-icon\n        [svgIcon]=\"\n          ['collapsed', 'initial'].indexOf(flex.state) >= 0\n            ? 'arrow_upward'\n            : 'arrow_downward'\n        \"\n      ></mat-icon>\n    </button>\n\n    <button\n      mat-icon-button\n      panelRightButton\n      class=\"igo-icon-button\"\n      (click)=\"zoomToFeatureExtent()\"\n      *ngIf=\"feature.geometry\"\n    >\n      <mat-icon svgIcon=\"zoom-in\"></mat-icon>\n    </button>\n\n    <igo-feature-details [feature]=\"feature\"></igo-feature-details>\n  </igo-panel>\n</igo-flexible>\n", styles: [":host{position:absolute;bottom:0;width:100%;max-height:calc(100% - 50px);background-color:#fff}igo-feature-details ::ng-deep table{width:100%}\n"], dependencies: [{ kind: "directive", type: i2$2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i2$3.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "component", type: i4$1.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "component", type: i9$1.PanelComponent, selector: "igo-panel", inputs: ["title", "withHeader", "cursorPointer"] }, { kind: "component", type: i9$1.FlexibleComponent, selector: "igo-flexible", inputs: ["initial", "collapsed", "expanded", "initialMobile", "collapsedMobile", "expandedMobile", "direction", "state"] }, { kind: "component", type: FeatureDetailsComponent, selector: "igo-feature-details", inputs: ["source", "map", "toolbox", "feature"], outputs: ["routeEvent", "selectFeature", "htmlDisplayEvent"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ToastComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-toast', template: "<igo-flexible\n  #flex\n  collapsedMobile=\"51px\"\n  expandedMobile=\"300px\"\n  [state]=\"state\"\n  (swipeup)=\"swipe($event.type)\"\n  (swipedown)=\"swipe($event.type)\"\n>\n  <igo-panel [title]=\"title\">\n    <button mat-icon-button panelLeftButton (click)=\"toggle()\">\n      <mat-icon\n        [svgIcon]=\"\n          ['collapsed', 'initial'].indexOf(flex.state) >= 0\n            ? 'arrow_upward'\n            : 'arrow_downward'\n        \"\n      ></mat-icon>\n    </button>\n\n    <button\n      mat-icon-button\n      panelRightButton\n      class=\"igo-icon-button\"\n      (click)=\"zoomToFeatureExtent()\"\n      *ngIf=\"feature.geometry\"\n    >\n      <mat-icon svgIcon=\"zoom-in\"></mat-icon>\n    </button>\n\n    <igo-feature-details [feature]=\"feature\"></igo-feature-details>\n  </igo-panel>\n</igo-flexible>\n", styles: [":host{position:absolute;bottom:0;width:100%;max-height:calc(100% - 50px);background-color:#fff}igo-feature-details ::ng-deep table{width:100%}\n"] }]
        }], ctorParameters: function () { return []; }, propDecorators: { expanded: [{
                type: Input
            }], map: [{
                type: Input
            }], feature: [{
                type: Input
            }], opened: [{
                type: Output
            }] } });

class IgoToastModule {
    static forRoot() {
        return {
            ngModule: IgoToastModule
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoToastModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoToastModule, declarations: [ToastComponent], imports: [CommonModule,
            MatIconModule,
            MatButtonModule,
            IgoPanelModule,
            IgoFlexibleModule,
            IgoFeatureModule], exports: [ToastComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoToastModule, imports: [CommonModule,
            MatIconModule,
            MatButtonModule,
            IgoPanelModule,
            IgoFlexibleModule,
            IgoFeatureModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoToastModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        MatIconModule,
                        MatButtonModule,
                        IgoPanelModule,
                        IgoFlexibleModule,
                        IgoFeatureModule
                    ],
                    exports: [ToastComponent],
                    declarations: [ToastComponent]
                }]
        }] });

class IgoWktModule {
    static forRoot() {
        return {
            ngModule: IgoWktModule,
            providers: []
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoWktModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoWktModule });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoWktModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoWktModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [],
                    exports: [],
                    declarations: []
                }]
        }] });

class ConfirmationPopupComponent {
    dialogRef;
    languageService;
    data;
    constructor(dialogRef, languageService, data) {
        this.dialogRef = dialogRef;
        this.languageService = languageService;
        this.data = data;
    }
    cancelAction() {
        this.data.cancel = true;
        this.dialogRef.close(this.data.cancel);
    }
    confirmedAction() {
        this.data.cancel = false;
        this.dialogRef.close(this.data.cancel);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ConfirmationPopupComponent, deps: [{ token: i1$2.MatDialogRef }, { token: i2.LanguageService }, { token: MAT_DIALOG_DATA }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: ConfirmationPopupComponent, selector: "igo-confirmation-popup-component", ngImport: i0, template: "<div mat-dialog-content>\n  <p class=\"mat-typography\">\n    {{\n      data.type === 'add'\n        ? languageService.translate.instant('igo.geo.workspace.addConfirmation')\n        : languageService.translate.instant(\n            'igo.geo.workspace.deleteConfirmation'\n          )\n    }}\n  </p>\n</div>\n<div mat-dialog-actions>\n  <button mat-raised-button color=\"primary\" (click)=\"confirmedAction()\">\n    Ok\n  </button>\n  <button mat-raised-button (click)=\"cancelAction()\">\n    {{ languageService.translate.instant('igo.geo.workspace.cancel') }}\n  </button>\n</div>\n", styles: ["div.mat-mdc-dialog-actions{justify-content:center}\n"], dependencies: [{ kind: "component", type: i4$1.MatButton, selector: "    button[mat-button], button[mat-raised-button], button[mat-flat-button],    button[mat-stroked-button]  ", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "directive", type: i1$2.MatDialogContent, selector: "[mat-dialog-content], mat-dialog-content, [matDialogContent]" }, { kind: "directive", type: i1$2.MatDialogActions, selector: "[mat-dialog-actions], mat-dialog-actions, [matDialogActions]", inputs: ["align"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ConfirmationPopupComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-confirmation-popup-component', template: "<div mat-dialog-content>\n  <p class=\"mat-typography\">\n    {{\n      data.type === 'add'\n        ? languageService.translate.instant('igo.geo.workspace.addConfirmation')\n        : languageService.translate.instant(\n            'igo.geo.workspace.deleteConfirmation'\n          )\n    }}\n  </p>\n</div>\n<div mat-dialog-actions>\n  <button mat-raised-button color=\"primary\" (click)=\"confirmedAction()\">\n    Ok\n  </button>\n  <button mat-raised-button (click)=\"cancelAction()\">\n    {{ languageService.translate.instant('igo.geo.workspace.cancel') }}\n  </button>\n</div>\n", styles: ["div.mat-mdc-dialog-actions{justify-content:center}\n"] }]
        }], ctorParameters: function () { return [{ type: i1$2.MatDialogRef }, { type: i2.LanguageService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [MAT_DIALOG_DATA]
                }] }]; } });

/**
 * @ignore
 */
class IgoConfirmationPopupModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoConfirmationPopupModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoConfirmationPopupModule, declarations: [ConfirmationPopupComponent], imports: [CommonModule,
            MatButtonModule,
            MatDialogModule,
            MatButtonToggleModule], exports: [ConfirmationPopupComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoConfirmationPopupModule, imports: [CommonModule,
            MatButtonModule,
            MatDialogModule,
            MatButtonToggleModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoConfirmationPopupModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        MatButtonModule,
                        MatDialogModule,
                        MatButtonToggleModule
                    ],
                    exports: [ConfirmationPopupComponent],
                    declarations: [ConfirmationPopupComponent]
                }]
        }] });

class OgcFilterComponent {
    cdRef;
    layer;
    map;
    /**
     * Event emitted on complete
     */
    complete = new EventEmitter();
    /**
     * Event emitted on cancel
     */
    cancel = new EventEmitter();
    constructor(cdRef) {
        this.cdRef = cdRef;
    }
    /**
     * Implemented as part of OnUpdateInputs
     */
    onUpdateInputs() {
        this.cdRef.detectChanges();
    }
    /**
     * On close, emit the cancel event
     */
    onClose() {
        this.cancel.emit();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OgcFilterComponent, deps: [{ token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: OgcFilterComponent, selector: "igo-ogc-filter", inputs: { layer: "layer", map: "map" }, outputs: { complete: "complete", cancel: "cancel" }, ngImport: i0, template: "<igo-ogc-filterable-item\n  igoListItem\n  [layer]=\"layer\"\n  [header]=\"false\"\n  [map]=\"map\"\n>\n</igo-ogc-filterable-item>\n", styles: [""], dependencies: [{ kind: "component", type: OgcFilterableItemComponent, selector: "igo-ogc-filterable-item", inputs: ["layer", "map", "header"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OgcFilterComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igo-ogc-filter', changeDetection: ChangeDetectionStrategy.OnPush, template: "<igo-ogc-filterable-item\n  igoListItem\n  [layer]=\"layer\"\n  [header]=\"false\"\n  [map]=\"map\"\n>\n</igo-ogc-filterable-item>\n" }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }]; }, propDecorators: { layer: [{
                type: Input
            }], map: [{
                type: Input
            }], complete: [{
                type: Output
            }], cancel: [{
                type: Output
            }] } });

/**
 * @ignore
 */
class IgoOgcFilterModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoOgcFilterModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoOgcFilterModule, declarations: [OgcFilterComponent], imports: [CommonModule, MatButtonModule, IgoLanguageModule, IgoFilterModule], exports: [OgcFilterComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoOgcFilterModule, imports: [CommonModule, MatButtonModule, IgoLanguageModule, IgoFilterModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoOgcFilterModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, MatButtonModule, IgoLanguageModule, IgoFilterModule],
                    exports: [OgcFilterComponent],
                    declarations: [OgcFilterComponent]
                }]
        }] });

const OgcFilterWidget = new InjectionToken('OgcFilterWidget');
function ogcFilterWidgetFactory(widgetService) {
    return widgetService.create(OgcFilterComponent);
}
function provideOgcFilterWidget() {
    return {
        provide: OgcFilterWidget,
        useFactory: ogcFilterWidgetFactory,
        deps: [WidgetService]
    };
}

class EditionWorkspace extends Workspace {
    dialog;
    configService;
    adding$;
    getDomainValues;
    options;
    inResolutionRange$ = new BehaviorSubject(true);
    get layer() {
        return this.options.layer;
    }
    get map() {
        return this.options.map;
    }
    drawControl;
    drawEnd$$;
    olDrawingLayerSource = new OlVectorSource();
    olDrawingLayer;
    geometryType = GeometryType; // Reference to the GeometryType enum
    modify; // Reference to the ol interaction
    modifyStyle = new olStyle.Style({
        stroke: new olStyle.Stroke({
            color: 'rgba(255,255,255,1)',
            width: 1
        }),
        fill: new olStyle.Fill({
            color: 'rgba(0,161,222,1)'
        }),
        image: new olStyle.Circle({
            radius: 7,
            stroke: new olStyle.Stroke({
                color: 'rgba(255,255,255,1)',
                width: 1
            }),
            fill: new olStyle.Fill({
                color: 'rgba(0,161,222,1)'
            })
        })
    });
    newFeaturefilterClauseFunc = (record) => {
        return record.state.newFeature === true;
    };
    editFeaturefilterClauseFunc = (record) => {
        return record.state.edit === true;
    };
    fillColor;
    strokeColor;
    strokeWidth;
    constructor(dialog, configService, adding$, getDomainValues, options) {
        super(options);
        this.dialog = dialog;
        this.configService = configService;
        this.adding$ = adding$;
        this.getDomainValues = getDomainValues;
        this.options = options;
        this.map.viewController.resolution$.subscribe((mapResolution) => {
            if (mapResolution > this.layer.minResolution &&
                mapResolution < this.layer.maxResolution) {
                this.inResolutionRange$.next(true);
            }
            else {
                this.inResolutionRange$.next(false);
            }
        });
        this.drawControl = this.createDrawControl();
        this.drawControl.setGeometryType(this.geometryType.Point);
        this.map.removeLayer(this.olDrawingLayer);
        this.olDrawingLayer = new VectorLayer({
            id: 'igo-draw-layer',
            title: 'edition',
            zIndex: 300,
            source: new FeatureDataSource(),
            showInLayerList: false,
            exportable: false,
            browsable: false,
            workspace: {
                enabled: false
            }
        });
    }
    deleteFeature(feature, workspace) {
        setTimeout(() => {
            const dialogRef = this.dialog.open(ConfirmationPopupComponent, {
                disableClose: false,
                data: { type: 'delete' }
            });
            dialogRef.afterClosed().subscribe((result) => {
                if (result === false) {
                    let id, url;
                    const baseUrl = workspace.layer.dataSource.options.edition.baseUrl;
                    const deleteUrl = workspace.layer.dataSource.options.edition.deleteUrl;
                    if (baseUrl.length) {
                        url = this.configService.getConfig('edition.url')
                            ? this.configService.getConfig('edition.url') +
                                baseUrl +
                                '?' +
                                deleteUrl
                            : baseUrl + '?' + deleteUrl;
                    }
                    else {
                        url = this.configService.getConfig('edition.url')
                            ? this.configService.getConfig('edition.url') + deleteUrl
                            : deleteUrl;
                    }
                    for (const column of workspace.meta.tableTemplate.columns) {
                        for (const property in feature.properties) {
                            let columnName = column.name;
                            if (columnName.includes('properties.')) {
                                columnName = columnName.split('.')[1];
                            }
                            if (columnName === property && column.primary === true) {
                                id = feature.properties[property];
                            }
                        }
                    }
                    if (url) {
                        url += id;
                        this.deleteFeature(workspace, url);
                    }
                }
            });
        }, 250);
    }
    editFeature(feature, workspace) {
        feature.edition = true;
        let id;
        let find = false;
        const editionOpt = workspace.layer.dataSource.options.edition;
        for (const column of workspace.meta.tableTemplate.columns) {
            // Update domain list
            if (column.type === 'list' || column.type === 'autocomplete') {
                this.getDomainValues(column.relation).subscribe((result) => {
                    column.domainValues = result;
                });
            }
            if (find === false) {
                for (const property in feature.properties) {
                    let columnName = column.name;
                    if (columnName.includes('properties.')) {
                        columnName = columnName.split('.')[1];
                    }
                    if (columnName === property && column.primary === true) {
                        id = feature.properties[property];
                        find = true;
                        break;
                    }
                }
            }
        }
        if (id) {
            feature.original_properties = JSON.parse(JSON.stringify(feature.properties));
            feature.original_geometry = feature.geometry;
            feature.idkey = id;
            workspace.entityStore.state.updateAll({ edit: false });
            workspace.entityStore.stateView.filter(this.editFeaturefilterClauseFunc);
            this.addFeatureToStore(feature, workspace);
        }
        else {
            // Only for edition with it's own geometry
            if (!feature.newFeature && editionOpt.geomType) {
                feature.newFeature = true;
                this.adding$.next(true);
                workspace.entityStore.state.updateAll({ newFeature: false });
                workspace.entityStore.stateView.filter(this.newFeaturefilterClauseFunc);
                if (editionOpt.addWithDraw) {
                    const geometryType = editionOpt.geomType;
                    this.onGeometryTypeChange(geometryType, feature, workspace);
                }
                else {
                    workspace.entityStore.insert(feature);
                    workspace.entityStore.state.update(feature, { newFeature: true }, true);
                }
            }
        }
    }
    /**
     * Create a Draw Control
     * @param fillColor the fill color
     * @param strokeColor the stroke color
     * @param strokeWidth the stroke width
     * @returns a Draw Control
     */
    createDrawControl(fillColor, strokeColor, strokeWidth) {
        const drawControl = new DrawControl({
            geometryType: undefined,
            drawingLayerSource: this.olDrawingLayerSource,
            drawingLayerStyle: new olStyle.Style({}),
            interactionStyle: createInteractionStyle(fillColor, strokeColor, strokeWidth)
        });
        return drawControl;
    }
    /**
     * Called when the user selects a new geometry type
     * @param geometryType the geometry type selected by the user
     */
    onGeometryTypeChange(geometryType, feature, workspace) {
        this.drawControl.setGeometryType(geometryType);
        this.toggleDrawControl(feature, workspace);
    }
    /**
     * Activate the correct control
     */
    toggleDrawControl(feature, workspace) {
        this.deactivateDrawControl();
        this.activateDrawControl(feature, workspace);
    }
    /**
     * Deactivate the active draw control
     */
    deactivateDrawControl() {
        if (!this.drawControl) {
            return;
        }
        if (this.drawEnd$$) {
            this.drawEnd$$.unsubscribe();
        }
        this.drawControl.setOlMap(undefined);
    }
    /**
     * Activate a given control
     */
    activateDrawControl(feature, workspace) {
        this.drawEnd$$ = this.drawControl.end$.subscribe((olGeometry) => {
            this.addFeatureToStore(feature, workspace, olGeometry);
        });
        this.drawControl.setOlMap(this.map.ol, true);
    }
    /**
     * Add a feature to layer. The loading strategy of the layer
     * will trigger and add the feature to the workspace store.
     * @internal
     */
    addFeatureToStore(feature, workspace, olGeometry) {
        const projection = this.map.ol.getView().getProjection();
        let geometry = feature.geometry;
        // If an olGeometry is passed, it means that it is a new feature
        if (olGeometry) {
            workspace.entityStore.insert(feature);
            workspace.entityStore.state.update(feature, { newFeature: true }, true);
            geometry = new OlGeoJSON().writeGeometryObject(olGeometry, {
                featureProjection: projection,
                dataProjection: 'EPSG:4326'
            });
            feature.geometry = geometry;
        }
        else {
            workspace.entityStore.state.update(feature, { edit: true }, true);
        }
        feature.projection = 'EPSG:4326';
        const featureOl = featureToOl(feature, projection.getCode());
        this.olDrawingLayer.dataSource.ol.clear();
        this.olDrawingLayer.dataSource.ol.addFeature(featureOl);
        this.map.addLayer(this.olDrawingLayer);
        this.deactivateDrawControl();
        this.createModifyInteraction(featureOl, feature, workspace);
    }
    /**
     * Delete drawings layer and source from the map AND feature from the entity store.
     * Layer refresh will automatically add the new feature into the store.
     */
    deleteDrawings() {
        this.map.removeLayer(this.olDrawingLayer);
        this.olDrawingLayerSource.clear();
        this.map.ol.removeInteraction(this.modify);
    }
    /**
     * Create a modify interaction to allow a geometry change one feature at the time (drag and drop)
     */
    createModifyInteraction(olFeature, feature, workspace) {
        this.map.ol.removeInteraction(this.modify);
        const olCollection = new Collection([olFeature], { unique: true });
        this.modify = new OlModify({
            features: olCollection
        });
        this.map.ol.addInteraction(this.modify);
        olCollection.forEach((feature) => {
            feature.setStyle(this.modifyStyle);
        });
        this.modify.on('modifyend', (event) => {
            const olGeometry = event.features.getArray()[0]?.getGeometry();
            if (olGeometry) {
                this.addFeatureToStore(feature, workspace, olGeometry);
            }
        });
    }
}

function getRowsInMapExtent(layerId, storageService) {
    return (storageService.get(`workspace.rowsInMapExtent.${layerId}`) ||
        true);
}
function setRowsInMapExtent(value, layerId, storageService) {
    storageService.set(`workspace.rowsInMapExtent.${layerId}`, value, StorageScope.SESSION);
}
function getSelectedOnly(layerId, storageService) {
    return (storageService.get(`workspace.selectedOnly.${layerId}`) ||
        false);
}
function setSelectedOnly(value, layerId, storageService) {
    storageService.set(`workspace.selectedOnly.${layerId}`, value, StorageScope.SESSION);
}
function mapExtentStrategyActiveToolTip(ws) {
    return ws.entityStore
        .getStrategyOfType(EntityStoreFilterCustomFuncStrategy)
        .active$.pipe(map((active) => active
        ? 'igo.geo.workspace.inMapExtent.active.tooltip'
        : 'igo.geo.workspace.inMapExtent.inactive.tooltip'));
}
function noElementSelected(ws) {
    return ws.entityStore.stateView
        .manyBy$((record) => {
        return record.state.selected === true;
    })
        .pipe(map((entities) => entities.length >= 1));
}
function addOrRemoveLayer(action, map, url, type, layerName, layerService) {
    const so = ObjectUtils.removeUndefined({
        sourceOptions: {
            type: type,
            url,
            optionsFromCapabilities: true,
            optionsFromApi: true,
            params: {
                LAYERS: type === 'wms' ? layerName : undefined,
                LAYER: type === 'wms' ? undefined : layerName
            }
        }
    });
    if (action === 'add') {
        layerService.createAsyncLayer(so).subscribe((layer) => {
            map.layersAddedByClick$.next([layer]);
            map.addLayer(layer);
        });
    }
    else if (action === 'remove') {
        const addedLayerId = generateIdFromSourceOptions(so.sourceOptions);
        map.removeLayer(map.layers.find((l) => l.id === addedLayerId));
    }
}
function getGeoServiceAction(workspace, layerService) {
    const geoServiceAction = [
        {
            name: 'geoServiceAction',
            title: undefined,
            tooltip: '',
            renderer: EntityTableColumnRenderer.ButtonGroup,
            valueAccessor: (entity, record) => {
                let geoServiceProperties = record.state.geoService;
                if (geoServiceProperties &&
                    geoServiceProperties.haveGeoServiceProperties &&
                    geoServiceProperties.url &&
                    geoServiceProperties.layerName) {
                    if (geoServiceProperties.added) {
                        return [
                            {
                                icon: 'delete',
                                color: 'warn',
                                click: (row, record) => {
                                    addOrRemoveLayer('remove', workspace.map, record.state.geoService.url, record.state.geoService.type, record.state.geoService.layerName, layerService);
                                    geoServiceProperties.added = false;
                                }
                            }
                        ];
                    }
                    else {
                        return [
                            {
                                icon: 'plus',
                                color: 'primary',
                                click: (row, record) => {
                                    addOrRemoveLayer('add', workspace.map, record.state.geoService.url, record.state.geoService.type, record.state.geoService.layerName, layerService);
                                    geoServiceProperties.added = true;
                                }
                            }
                        ];
                    }
                }
                else {
                    return [];
                }
            }
        }
    ];
    return geoServiceAction;
}
function createTableTemplate(workspace, layer, layerService, ws$) {
    const geoServiceAction = getGeoServiceAction(workspace, layerService);
    const fields = layer.dataSource.options.sourceFields || [];
    const relations = layer.dataSource.options.relations || [];
    if (fields.length === 0) {
        workspace.entityStore.entities$
            .pipe(skipWhile((val) => val.length === 0), take(1))
            .subscribe((entities) => {
            const ol = entities[0].ol;
            const columnsFromFeatures = ol
                .getKeys()
                .filter((col) => !col.startsWith('_') &&
                col !== 'geometry' &&
                col !== ol.getGeometryName() &&
                !col.match(/boundedby/gi))
                .map((key) => {
                return {
                    name: `properties.${key}`,
                    title: key,
                    renderer: EntityTableColumnRenderer.UnsanitizedHTML
                };
            });
            columnsFromFeatures.unshift(...geoServiceAction);
            workspace.meta.tableTemplate = {
                selection: true,
                sort: true,
                columns: columnsFromFeatures,
                tableHeight: '100%'
            };
        });
        return;
    }
    const columns = fields.map((field) => {
        return {
            name: `properties.${field.name}`,
            title: field.alias ? field.alias : field.name,
            renderer: EntityTableColumnRenderer.UnsanitizedHTML,
            tooltip: field.tooltip,
            cellClassFunc: () => {
                const cellClass = {};
                if (field.type) {
                    cellClass[`class_${field.type}`] = true;
                    return cellClass;
                }
            }
        };
    });
    const relationsColumn = relations.map((relation) => {
        return {
            name: `properties.${relation.name}`,
            title: relation.alias ? relation.alias : relation.name,
            renderer: EntityTableColumnRenderer.Icon,
            icon: relation.icon,
            parent: relation.parent,
            type: 'relation',
            tooltip: relation.tooltip,
            onClick: () => {
                ws$.next(relation.title);
            },
            cellClassFunc: () => {
                return { class_icon: true };
            }
        };
    });
    columns.push(...relationsColumn);
    columns.unshift(...geoServiceAction);
    workspace.meta.tableTemplate = {
        selection: true,
        sort: true,
        columns,
        tableHeight: '100%'
    };
}
function createFilterInMapExtentOrResolutionStrategy() {
    const filterClauseFunc = (record) => {
        return (record.state.inMapExtent === true && record.state.inMapResolution === true);
    };
    return new EntityStoreFilterCustomFuncStrategy({
        filterClauseFunc
    });
}

class EditionWorkspaceService {
    layerService;
    storageService;
    configService;
    messageService;
    http;
    dialog;
    styleService;
    authInterceptor;
    ws$ = new BehaviorSubject(undefined);
    adding$ = new BehaviorSubject(false);
    relationLayers$ = new BehaviorSubject(undefined);
    rowsInMapExtentCheckCondition$ = new BehaviorSubject(true);
    loading = false;
    wktFormat = new olWKT();
    geoJsonFormat = new OlGeoJSON();
    get zoomAuto() {
        return this.storageService.get('zoomAuto');
    }
    constructor(layerService, storageService, configService, messageService, http, dialog, styleService, authInterceptor) {
        this.layerService = layerService;
        this.storageService = storageService;
        this.configService = configService;
        this.messageService = messageService;
        this.http = http;
        this.dialog = dialog;
        this.styleService = styleService;
        this.authInterceptor = authInterceptor;
    }
    createWorkspace(layer, map) {
        if (layer.options.workspace?.enabled !== true ||
            layer.dataSource.options.edition.enabled !== true) {
            return;
        }
        let wksConfig;
        if (layer.options.workspace) {
            wksConfig = layer.options.workspace;
        }
        else {
            wksConfig = {};
        }
        wksConfig.srcId = layer.id;
        wksConfig.workspaceId = layer.id;
        wksConfig.enabled = true;
        wksConfig.pageSize = layer.options.workspace?.pageSize;
        wksConfig.pageSizeOptions = layer.options.workspace?.pageSizeOptions;
        const dataSource = layer.dataSource;
        const wmsLinkId = layer.id + '.WmsWorkspaceTableSrc';
        const wfsLinkId = layer.id + '.WfsWorkspaceTableDest';
        if (!layer.options.linkedLayers) {
            layer.options.linkedLayers = { linkId: wmsLinkId, links: [] };
        }
        const linkProperties = {
            syncedDelete: true,
            linkedIds: [wfsLinkId],
            properties: [LinkedProperties.ZINDEX, LinkedProperties.VISIBLE]
        };
        if (!layer.options.workspace?.minResolution) {
            linkProperties.properties.push(LinkedProperties.MINRESOLUTION);
        }
        let hasOgcFilters = false;
        if (dataSource.options.ogcFilters?.enabled) {
            linkProperties.properties.push(LinkedProperties.OGCFILTERS);
            hasOgcFilters = true;
        }
        if (!layer.options.workspace?.maxResolution) {
            linkProperties.properties.push(LinkedProperties.MAXRESOLUTION);
        }
        let clonedLinks = [];
        if (layer.options.linkedLayers.links) {
            clonedLinks = JSON.parse(JSON.stringify(layer.options.linkedLayers.links));
        }
        clonedLinks.push(linkProperties);
        (layer.options.linkedLayers.linkId = layer.options.linkedLayers.linkId
            ? layer.options.linkedLayers.linkId
            : wmsLinkId),
            (layer.options.linkedLayers.links = clonedLinks);
        let wks;
        this.layerService
            .createAsyncLayer({
            id: wfsLinkId,
            linkedLayers: {
                linkId: wfsLinkId
            },
            workspace: {
                srcId: layer.id,
                workspaceId: undefined,
                enabled: false,
                queryOptions: {
                    mapQueryOnOpenTab: layer.options.workspace?.queryOptions?.mapQueryOnOpenTab,
                    tabQuery: false
                },
                pageSize: layer.options.workspace?.pageSize,
                pageSizeOptions: layer.options.workspace?.pageSizeOptions
            },
            showInLayerList: false,
            opacity: 0,
            title: layer.title,
            minResolution: layer.options.workspace?.minResolution || layer.minResolution || 0,
            maxResolution: layer.options.workspace?.maxResolution ||
                layer.maxResolution ||
                Infinity,
            style: this.styleService.createStyle({
                fill: {
                    color: 'rgba(255, 255, 255, 0.01)'
                },
                stroke: {
                    color: 'rgba(255, 255, 255, 0.01)'
                },
                circle: {
                    fill: {
                        color: 'rgba(255, 255, 255, 0.01)'
                    },
                    stroke: {
                        color: 'rgba(255, 255, 255, 0.01)'
                    },
                    radius: 5
                }
            }),
            sourceOptions: {
                download: dataSource.options.download,
                type: 'wfs',
                url: dataSource.options.urlWfs || dataSource.options.url,
                queryable: true,
                relations: dataSource.options.relations,
                queryTitle: dataSource.options
                    .queryTitle,
                params: dataSource.options.paramsWFS,
                ogcFilters: Object.assign({}, dataSource.ogcFilters, {
                    enabled: hasOgcFilters
                }),
                sourceFields: dataSource.options.sourceFields || undefined,
                edition: dataSource.options.edition
            }
        })
            .subscribe((workspaceLayer) => {
            map.addLayer(workspaceLayer);
            layer.ol.setProperties({
                linkedLayers: {
                    linkId: layer.options.linkedLayers.linkId,
                    links: clonedLinks
                }
            }, false);
            workspaceLayer.dataSource.ol.refresh();
            wks = new EditionWorkspace(this.dialog, this.configService, this.adding$, (relation) => this.getDomainValues(relation), {
                id: layer.id,
                title: layer.title,
                layer: workspaceLayer,
                map,
                entityStore: this.createFeatureStore(workspaceLayer, map),
                actionStore: new ActionStore([]),
                meta: {
                    tableTemplate: undefined
                }
            });
            this.createTableTemplate(wks, workspaceLayer);
            workspaceLayer.options.workspace.workspaceId = workspaceLayer.id;
            layer.options.workspace = Object.assign({}, layer.options.workspace, {
                wksConfig
            });
            delete dataSource.options.download;
            return wks;
        });
        return wks;
    }
    createFeatureStore(layer, map) {
        const store = new FeatureStore([], { map });
        store.bindLayer(layer);
        const loadingStrategy = new FeatureStoreLoadingLayerStrategy({});
        const inMapExtentStrategy = new FeatureStoreInMapExtentStrategy({});
        const inMapResolutionStrategy = new FeatureStoreInMapResolutionStrategy({});
        const selectedRecordStrategy = new EntityStoreFilterSelectionStrategy({});
        const selectionStrategy = new FeatureStoreSelectionStrategy({
            layer: new VectorLayer({
                zIndex: 300,
                source: new FeatureDataSource(),
                style: undefined,
                showInLayerList: false,
                exportable: false,
                browsable: false
            }),
            map,
            hitTolerance: 15,
            motion: this.zoomAuto ? FeatureMotion.Default : FeatureMotion.None,
            many: true,
            dragBox: true
        });
        store.addStrategy(loadingStrategy, true);
        store.addStrategy(inMapExtentStrategy, true);
        store.addStrategy(inMapResolutionStrategy, true);
        store.addStrategy(selectionStrategy, true);
        store.addStrategy(selectedRecordStrategy, false);
        store.addStrategy(createFilterInMapExtentOrResolutionStrategy(), true);
        return store;
    }
    createTableTemplate(workspace, layer) {
        const fields = layer.dataSource.options.sourceFields || [];
        const relations = layer.dataSource.options.relations || [];
        let rendererType = EntityTableColumnRenderer.UnsanitizedHTML;
        let buttons = [];
        let columns = [];
        let relationsColumn = [];
        buttons = [
            {
                name: 'edition',
                title: undefined,
                renderer: EntityTableColumnRenderer.ButtonGroup,
                primary: false,
                valueAccessor: () => {
                    return [
                        {
                            editMode: false,
                            icon: 'pencil',
                            color: 'primary',
                            disabled: layer.dataSource.options.edition.modifyButton === false
                                ? true
                                : false,
                            click: (feature) => {
                                workspace.editFeature(feature, workspace);
                            }
                        },
                        {
                            editMode: false,
                            icon: 'delete',
                            color: 'warn',
                            disabled: layer.dataSource.options.edition.deleteButton === false
                                ? true
                                : false,
                            click: (feature) => {
                                workspace.deleteFeature(feature, workspace);
                            }
                        },
                        {
                            editMode: true,
                            icon: 'check',
                            color: 'primary',
                            disabled: this.loading,
                            click: (feature) => {
                                this.saveFeature(feature, workspace);
                            }
                        },
                        {
                            editMode: true,
                            icon: 'alpha-x',
                            color: 'primary',
                            disabled: this.loading,
                            click: (feature) => {
                                this.cancelEdit(workspace, feature);
                            }
                        }
                    ];
                }
            }
        ];
        if (fields.length === 0) {
            workspace.entityStore.entities$
                .pipe(skipWhile((val) => val.length === 0), take(1))
                .subscribe((entities) => {
                const ol = entities[0].ol;
                const columnsFromFeatures = ol
                    .getKeys()
                    .filter((col) => !col.startsWith('_') &&
                    col !== 'geometry' &&
                    col !== ol.getGeometryName() &&
                    !col.match(/boundedby/gi))
                    .map((key) => {
                    return {
                        name: `properties.${key}`,
                        title: key,
                        renderer: rendererType
                    };
                });
                workspace.meta.tableTemplate = {
                    selection: false,
                    sort: true,
                    columns: columnsFromFeatures
                };
            });
            return;
        }
        columns = fields.map((field) => {
            let column = {
                name: `properties.${field.name}`,
                title: field.alias ? field.alias : field.name,
                renderer: rendererType,
                valueAccessor: undefined,
                cellClassFunc: () => {
                    const cellClass = {};
                    if (field.type) {
                        cellClass[`class_${field.type}`] = true;
                        return cellClass;
                    }
                },
                primary: field.primary === true ? true : false,
                visible: field.visible,
                validation: field.validation,
                linkColumnForce: field.linkColumnForce,
                type: field.type,
                domainValues: undefined,
                relation: undefined,
                multiple: field.multiple,
                step: field.step,
                tooltip: field.tooltip
            };
            if (field.type === 'list' || field.type === 'autocomplete') {
                this.getDomainValues(field.relation).subscribe((result) => {
                    column.domainValues = result;
                    column.relation = field.relation;
                });
            }
            return column;
        });
        relationsColumn = relations.map((relation) => {
            return {
                name: `properties.${relation.name}`,
                title: relation.alias ? relation.alias : relation.name,
                renderer: EntityTableColumnRenderer.Icon,
                icon: relation.icon,
                parent: relation.parent,
                type: 'relation',
                tooltip: relation.tooltip,
                onClick: () => {
                    if (this.adding$.getValue() === false) {
                        this.ws$.next(relation.title);
                    }
                },
                cellClassFunc: () => {
                    return { class_icon: true };
                }
            };
        });
        columns.push(...relationsColumn);
        columns.push(...buttons);
        workspace.meta.tableTemplate = {
            selection: false,
            sort: true,
            columns
        };
    }
    saveFeature(feature, workspace) {
        if (!this.validateFeature(feature, workspace)) {
            return false;
        }
        this.sanitizeParameter(feature, workspace);
        const baseUrl = workspace.layer.dataSource.options.edition.baseUrl;
        let url = this.configService.getConfig('edition.url');
        if (!url) {
            url = baseUrl;
        }
        else {
            url += baseUrl ? baseUrl : '';
        }
        if (feature.newFeature) {
            url += workspace.layer.dataSource.options.edition.addUrl;
            const addHeaders = workspace.layer.dataSource.options.edition.addHeaders;
            const headers = new HttpHeaders(addHeaders);
            this.addFeature(feature, workspace, url, headers);
        }
        else {
            if (workspace.layer.dataSource.options.edition.modifyProtocol !== 'post') {
                url +=
                    '?' +
                        workspace.layer.dataSource.options.edition.modifyUrl +
                        feature.idkey;
            }
            else {
                url += workspace.layer.dataSource.options.edition.modifyUrl;
            }
            const protocole = workspace.layer.dataSource.options.edition.modifyProtocol;
            const modifyHeaders = workspace.layer.dataSource.options.edition.modifyHeaders;
            const headers = new HttpHeaders(modifyHeaders);
            this.modifyFeature(feature, workspace, url, headers, protocole);
        }
    }
    addFeature(feature, workspace, url, headers) {
        if (workspace.layer.dataSource.options.edition.hasGeometry) {
            const projDest = workspace.layer.options.sourceOptions.edition.geomDatabaseProj;
            feature.properties[workspace.layer.dataSource.options.params.fieldNameGeometry] =
                'SRID=' +
                    projDest.replace('EPSG:', '') +
                    ';' +
                    this.wktFormat.writeGeometry(this.geoJsonFormat
                        .readFeature(feature.geometry)
                        .getGeometry()
                        .transform('EPSG:4326', projDest), { dataProjection: projDest });
        }
        for (const property in feature.properties) {
            for (const sf of workspace.layer.dataSource.options.sourceFields) {
                if ((sf.name === property && sf.validation?.readonly) ||
                    (sf.name === property && sf.validation?.send === false)) {
                    delete feature.properties[property];
                }
            }
        }
        this.loading = true;
        this.http
            .post(`${url}`, feature.properties, { headers: headers })
            .subscribe(() => {
            this.loading = false;
            workspace.entityStore.stateView.clear();
            workspace.deleteDrawings();
            workspace.entityStore.delete(feature);
            this.messageService.success('igo.geo.workspace.addSuccess');
            this.refreshMap(workspace.layer, workspace.layer.map);
            this.adding$.next(false);
            this.rowsInMapExtentCheckCondition$.next(true);
        }, (error) => {
            this.loading = false;
            error.error.caught = true;
            const messages = workspace.layer.dataSource.options.edition.messages;
            if (messages) {
                let text;
                messages.forEach((message) => {
                    const key = Object.keys(message)[0];
                    if (error.error.message.includes(key)) {
                        text = message[key];
                        this.messageService.error(text);
                    }
                });
                if (!text) {
                    this.messageService.error('igo.geo.workspace.addError');
                }
            }
            else {
                this.messageService.error('igo.geo.workspace.addError');
            }
        });
    }
    deleteFeature(workspace, url) {
        this.loading = true;
        this.http.delete(`${url}`, {}).subscribe(() => {
            this.loading = false;
            this.messageService.success('igo.geo.workspace.deleteSuccess');
            this.refreshMap(workspace.layer, workspace.layer.map);
            for (const relation of workspace.layer.options.sourceOptions
                .relations) {
                workspace.map.layers.forEach((layer) => {
                    if (layer.title === relation.title) {
                        layer.dataSource.ol.refresh();
                    }
                });
            }
        }, (error) => {
            this.loading = false;
            error.error.caught = true;
            const messages = workspace.layer.dataSource.options.edition.messages;
            if (messages) {
                let text;
                messages.forEach((message) => {
                    const key = Object.keys(message)[0];
                    if (error.error.message.includes(key)) {
                        text = message[key];
                        this.messageService.error(text);
                    }
                });
                if (!text) {
                    this.messageService.error('igo.geo.workspace.addError');
                }
            }
            else {
                this.messageService.error('igo.geo.workspace.addError');
            }
        });
    }
    modifyFeature(feature, workspace, url, headers, protocole = 'patch') {
        if (workspace.layer.dataSource.options.edition.hasGeometry) {
            const projDest = workspace.layer.options.sourceOptions.edition.geomDatabaseProj;
            // Remove 3e dimension
            feature.geometry.coordinates = removeZ(feature.geometry.coordinates);
            feature.properties[workspace.layer.dataSource.options.params.fieldNameGeometry] =
                'SRID=' +
                    projDest.replace('EPSG:', '') +
                    ';' +
                    this.wktFormat.writeGeometry(this.geoJsonFormat
                        .readFeature(feature.geometry)
                        .getGeometry()
                        .transform('EPSG:4326', projDest), { dataProjection: projDest });
        }
        for (const property in feature.properties) {
            for (const sf of workspace.layer.dataSource.options.sourceFields) {
                if ((sf.name === property && sf.validation?.readonly) ||
                    (sf.name === property && sf.validation?.send === false) ||
                    property === 'boundedBy') {
                    delete feature.properties[property];
                }
            }
        }
        this.loading = true;
        this.http[protocole](`${url}`, feature.properties, {
            headers: headers
        }).subscribe(() => {
            this.loading = false;
            this.cancelEdit(workspace, feature, true);
            this.messageService.success('igo.geo.workspace.modifySuccess');
            this.refreshMap(workspace.layer, workspace.layer.map);
            let relationLayers = [];
            for (const relation of workspace.layer.options.sourceOptions
                .relations) {
                workspace.map.layers.forEach((layer) => {
                    if (layer.title === relation.title) {
                        relationLayers.push(layer);
                        layer.dataSource.ol.refresh();
                    }
                });
            }
            this.relationLayers$.next(relationLayers);
        }, (error) => {
            this.loading = false;
            error.error.caught = true;
            const messages = workspace.layer.dataSource.options.edition.messages;
            if (messages) {
                let text;
                messages.forEach((message) => {
                    const key = Object.keys(message)[0];
                    if (error.error.message.includes(key)) {
                        text = message[key];
                        this.messageService.error(text);
                    }
                });
                if (!text) {
                    this.messageService.error('igo.geo.workspace.addError');
                }
            }
            else {
                this.messageService.error('igo.geo.workspace.addError');
            }
        });
    }
    cancelEdit(workspace, feature, fromSave = false) {
        feature.edition = false;
        this.adding$.next(false);
        workspace.deleteDrawings();
        workspace.entityStore.stateView.clear();
        if (feature.newFeature) {
            workspace.entityStore.delete(feature);
            workspace.deactivateDrawControl();
            this.rowsInMapExtentCheckCondition$.next(true);
        }
        else {
            if (!fromSave) {
                feature.properties = feature.original_properties;
                feature.geometry = feature.original_geometry;
            }
            delete feature.original_properties;
            delete feature.original_geometry;
        }
    }
    getDomainValues(relation) {
        let url = relation.url;
        if (!url) {
            url = this.configService.getConfig('edition.url')
                ? this.configService.getConfig('edition.url') + relation.table
                : relation.table;
        }
        return this.http.get(url).pipe(map((result) => {
            return result;
        }), catchError((err) => {
            err.error.caught = true;
            return throwError(err);
        }));
    }
    /*
     * Refresh both wms and wfs layer
     * A new wfs loader is used to ensure cache is not retrieving old data
     * WMS params are updated to ensure layer is correctly refreshed
     */
    refreshMap(layer, map) {
        const wfsOlLayer = layer.dataSource.ol;
        const loader = (extent, resolution, proj, success, failure) => {
            layer.customWFSLoader(layer.ol.getSource(), layer.options.sourceOptions, this.authInterceptor, extent, resolution, proj, success, failure, true);
        };
        wfsOlLayer.setLoader(loader);
        wfsOlLayer.refresh();
        for (const lay of map.layers) {
            if (lay.id !== layer.id &&
                lay.options.linkedLayers?.linkId.includes(layer.id.substr(0, layer.id.indexOf('.') - 1)) &&
                lay.options.linkedLayers?.linkId.includes('WmsWorkspaceTableSrc')) {
                const wmsOlLayer = lay.dataSource.ol;
                let params = wmsOlLayer.getParams();
                params._t = new Date().getTime();
                wmsOlLayer.updateParams(params);
            }
        }
    }
    validateFeature(feature, workspace) {
        let message;
        let key;
        let valid = true;
        workspace.meta.tableTemplate.columns.forEach((column) => {
            if (column.hasOwnProperty('validation') && column.validation) {
                key = getColumnKeyWithoutPropertiesTag(column.name);
                Object.keys(column.validation).forEach((type) => {
                    switch (type) {
                        case 'mandatory': {
                            if (column.validation[type] &&
                                (!feature.properties.hasOwnProperty(key) ||
                                    !feature.properties[key])) {
                                valid = false;
                                this.messageService.error('igo.geo.formValidation.mandatory', undefined, undefined, { column: column.title });
                            }
                            break;
                        }
                        case 'minValue': {
                            if (feature.properties.hasOwnProperty(key) &&
                                feature.properties[key] &&
                                feature.properties[key] < column.validation[type]) {
                                valid = false;
                                this.messageService.error('igo.geo.formValidation.minValue', undefined, undefined, {
                                    column: column.title,
                                    value: column.validation[type]
                                });
                            }
                            break;
                        }
                        case 'maxValue': {
                            if (feature.properties.hasOwnProperty(key) &&
                                feature.properties[key] &&
                                feature.properties[key] > column.validation[type]) {
                                valid = false;
                                this.messageService.error('igo.geo.formValidation.maxValue', undefined, undefined, {
                                    column: column.title,
                                    value: column.validation[type]
                                });
                            }
                            break;
                        }
                        case 'minLength': {
                            if (feature.properties.hasOwnProperty(key) &&
                                feature.properties[key] &&
                                feature.properties[key].length < column.validation[type]) {
                                valid = false;
                                this.messageService.error('igo.geo.formValidation.minLength', undefined, undefined, {
                                    column: column.title,
                                    value: column.validation[type]
                                });
                            }
                            break;
                        }
                        case 'maxLength': {
                            if (feature.properties.hasOwnProperty(key) &&
                                feature.properties[key] &&
                                feature.properties[key].length > column.validation[type]) {
                                valid = false;
                                this.messageService.error('igo.geo.formValidation.maxLength', undefined, undefined, {
                                    column: column.title,
                                    value: column.validation[type]
                                });
                            }
                            break;
                        }
                    }
                });
            }
        });
        return valid;
    }
    sanitizeParameter(feature, workspace) {
        workspace.meta.tableTemplate.columns.forEach((column) => {
            if (column.type === 'list' &&
                feature.properties[getColumnKeyWithoutPropertiesTag(column.name)]) {
                feature.properties[getColumnKeyWithoutPropertiesTag(column.name)] =
                    feature.properties[getColumnKeyWithoutPropertiesTag(column.name)].toString();
            }
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: EditionWorkspaceService, deps: [{ token: LayerService }, { token: i2.StorageService }, { token: i2.ConfigService }, { token: i2.MessageService }, { token: i1.HttpClient }, { token: i1$2.MatDialog }, { token: StyleService }, { token: i6$1.AuthInterceptor }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: EditionWorkspaceService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: EditionWorkspaceService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: LayerService }, { type: i2.StorageService }, { type: i2.ConfigService }, { type: i2.MessageService }, { type: i1.HttpClient }, { type: i1$2.MatDialog }, { type: StyleService }, { type: i6$1.AuthInterceptor }]; } });
function getColumnKeyWithoutPropertiesTag(column) {
    if (column.includes('properties.')) {
        return column.split('.')[1];
    }
    return column;
}
function removeZ(coords) {
    if (coords.length === 0)
        return coords;
    if (typeof coords[0] === 'number')
        return coords.slice(0, 2);
    return coords.map(removeZ);
}

/**
 * Generate a style for selected features
 * @param feature The feature to generate the style
 * @returns A olStyle
 */
function getCommonVectorSelectedStyle({ feature, markerColor = [0, 161, 222], markerOpacity = 1, markerOutlineColor = [0, 255, 255], fillColor, fillOpacity = 0.15, strokeColor = [0, 255, 255], strokeOpacity = 0.5, strokeWidth = 4 }) {
    return getCommonVectorStyle({
        feature,
        markerColor,
        markerOpacity,
        markerOutlineColor,
        fillColor,
        fillOpacity,
        strokeColor,
        strokeOpacity,
        strokeWidth
    });
}
/**
 * Generate a basic style for features
 * @param feature The feature to generate the style
 * @returns A olStyle
 */
function getCommonVectorStyle({ feature, markerColor = [0, 161, 222], markerOpacity = 0.5, markerOutlineColor, fillColor = [0, 161, 222], fillOpacity = 0.15, strokeColor = [0, 161, 222], strokeOpacity = 0.5, strokeWidth = 2 }) {
    const isOlFeature = feature instanceof OlFeature;
    let geometry;
    let text;
    if (isOlFeature) {
        feature = feature;
        geometry = feature.getGeometry();
    }
    else {
        feature = feature;
        geometry = feature.geometry;
        text = feature.meta.mapTitle;
    }
    const geometryType = isOlFeature ? geometry.getType() : geometry.type;
    if (!geometry || geometryType === 'Point') {
        const markerColorAsArray = asArray(markerColor).slice(0);
        const markerColorRGB = markerColorAsArray.slice(0, 3);
        if (markerColorAsArray.length === 4 &&
            (typeof markerColor !== 'string' ||
                /^#[0-9A-F]{8}$/i.test(markerColor))) {
            markerOpacity = markerColorAsArray[3];
        }
        return createOverlayMarkerStyle({
            text,
            opacity: markerOpacity,
            markerOutlineColor,
            markerColor: markerColorRGB
        });
    }
    else {
        const fillWithOpacity = asArray(fillColor).slice(0);
        const strokeWithOpacity = asArray(strokeColor).slice(0);
        if (!(fillWithOpacity.length === 4 &&
            (typeof fillColor !== 'string' ||
                /^#[0-9A-F]{8}$/i.test(fillColor)))) {
            fillWithOpacity[3] = fillOpacity;
        }
        if (!(strokeWithOpacity.length === 4 &&
            (typeof strokeColor !== 'string' ||
                /^#[0-9A-F]{8}$/i.test(strokeColor)))) {
            strokeWithOpacity[3] = strokeOpacity;
        }
        return createOverlayDefaultStyle({
            text,
            strokeWidth,
            strokeColor: strokeWithOpacity,
            fillColor: fillWithOpacity
        });
    }
}

class PropertyTypeDetectorService {
    regexService;
    geoServiceRegexes = [];
    constructor(regexService) {
        this.regexService = regexService;
        this.geoServiceRegexes = this.getGeoServiceRegexes();
    }
    getPropertyType(value) {
        return typeof value;
    }
    isUrl(value) {
        const regex = /^https?:\/\//;
        return regex.test(value.toString());
    }
    isGeoService(value) {
        let isGeoService = false;
        if (!this.isUrl) {
            return;
        }
        for (const geoServiceRegex of this.geoServiceRegexes) {
            const domainRegex = new RegExp(geoServiceRegex.url);
            if (domainRegex.test(value)) {
                isGeoService = true;
                break;
            }
        }
        return isGeoService;
    }
    getGeoService(url, availableProperties) {
        if (!this.isGeoService(url)) {
            return;
        }
        let matchingGeoservice;
        for (const geoServiceRegex of this.geoServiceRegexes) {
            const domainRegex = new RegExp(geoServiceRegex.url);
            if (domainRegex.test(url)) {
                // providing the the first matching regex;
                const matchingProperties = availableProperties.filter((p) => geoServiceRegex.propertiesForLayerName.includes(p));
                matchingGeoservice = matchingProperties ? geoServiceRegex : undefined;
                if (matchingGeoservice) {
                    break;
                }
            }
        }
        return matchingGeoservice;
    }
    getGeoServiceRegexes() {
        return (this.regexService.get('geoservice') ||
            []);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PropertyTypeDetectorService, deps: [{ token: i2.RegexService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PropertyTypeDetectorService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PropertyTypeDetectorService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i2.RegexService }]; } });

class FeatureWorkspace extends Workspace {
    options;
    inResolutionRange$ = new BehaviorSubject(true);
    get layer() {
        return this.options.layer;
    }
    get map() {
        return this.options.map;
    }
    constructor(options) {
        super(options);
        this.options = options;
        this.map.viewController.resolution$.subscribe((mapResolution) => {
            if (mapResolution > this.layer.minResolution &&
                mapResolution < this.layer.maxResolution) {
                this.inResolutionRange$.next(true);
            }
            else {
                this.inResolutionRange$.next(false);
            }
        });
    }
    getLayerWksOptionTabQuery() {
        if (this.layer.options.workspace.queryOptions?.tabQuery !== undefined) {
            return this.layer.options.workspace.queryOptions.tabQuery;
        }
        return true;
    }
    getLayerWksOptionMapQuery() {
        if (this.layer.options.workspace.queryOptions?.mapQueryOnOpenTab !== undefined) {
            return this.layer.options.workspace.queryOptions.mapQueryOnOpenTab;
        }
        return true;
    }
    getInResolutionRange() {
        return this.inResolutionRange$.value;
    }
}

class FeatureWorkspaceService {
    storageService;
    configService;
    layerService;
    propertyTypeDetectorService;
    capabilitiesService;
    get zoomAuto() {
        return this.storageService.get('zoomAuto');
    }
    ws$ = new BehaviorSubject(undefined);
    constructor(storageService, configService, layerService, propertyTypeDetectorService, capabilitiesService) {
        this.storageService = storageService;
        this.configService = configService;
        this.layerService = layerService;
        this.propertyTypeDetectorService = propertyTypeDetectorService;
        this.capabilitiesService = capabilitiesService;
    }
    createWorkspace(layer, map) {
        if (layer.options.workspace?.enabled === false ||
            layer.dataSource.options.edition) {
            return;
        }
        layer.options.workspace = Object.assign({}, layer.options.workspace, {
            srcId: layer.id,
            workspaceId: layer.id,
            enabled: true
        });
        const wks = new FeatureWorkspace({
            id: layer.id,
            title: layer.title,
            layer,
            map,
            entityStore: this.createFeatureStore(layer, map),
            actionStore: new ActionStore([]),
            meta: {
                tableTemplate: undefined
            }
        });
        createTableTemplate(wks, layer, this.layerService, this.ws$);
        return wks;
    }
    createFeatureStore(layer, map) {
        const store = new FeatureStore([], { map });
        store.bindLayer(layer);
        const loadingStrategy = new FeatureStoreLoadingLayerStrategy({});
        const searchStrategy = new FeatureStoreSearchIndexStrategy({
            percentDistinctValueRatio: 2,
            sourceFields: layer.dataSource.options.sourceFields
        });
        const inMapExtentStrategy = new FeatureStoreInMapExtentStrategy({});
        const geoPropertiesStrategy = new GeoPropertiesStrategy({ map }, this.propertyTypeDetectorService, this.capabilitiesService);
        const inMapResolutionStrategy = new FeatureStoreInMapResolutionStrategy({});
        const selectedRecordStrategy = new EntityStoreFilterSelectionStrategy({});
        const confQueryOverlayStyle = this.configService.getConfig('queryOverlayStyle');
        const selectionStrategy = new FeatureStoreSelectionStrategy({
            layer: new VectorLayer({
                zIndex: 300,
                source: new FeatureDataSource(),
                style: (feature) => {
                    return getCommonVectorSelectedStyle(Object.assign({}, { feature }, confQueryOverlayStyle?.selection || {}));
                },
                showInLayerList: false,
                exportable: false,
                browsable: false
            }),
            map,
            hitTolerance: 15,
            motion: this.zoomAuto ? FeatureMotion.Default : FeatureMotion.None,
            many: true,
            dragBox: true
        });
        if (layer.options.workspace?.searchIndexEnabled) {
            store.addStrategy(searchStrategy, true);
        }
        store.addStrategy(loadingStrategy, true);
        store.addStrategy(inMapExtentStrategy, true);
        store.addStrategy(geoPropertiesStrategy, true);
        store.addStrategy(inMapResolutionStrategy, true);
        store.addStrategy(selectionStrategy, true);
        store.addStrategy(selectedRecordStrategy, false);
        store.addStrategy(createFilterInMapExtentOrResolutionStrategy(), true);
        return store;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FeatureWorkspaceService, deps: [{ token: i2.StorageService }, { token: i2.ConfigService }, { token: LayerService }, { token: PropertyTypeDetectorService }, { token: CapabilitiesService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FeatureWorkspaceService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: FeatureWorkspaceService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i2.StorageService }, { type: i2.ConfigService }, { type: LayerService }, { type: PropertyTypeDetectorService }, { type: CapabilitiesService }]; } });

class WfsWorkspace extends Workspace {
    options;
    inResolutionRange$ = new BehaviorSubject(true);
    get layer() {
        return this.options.layer;
    }
    get map() {
        return this.options.map;
    }
    constructor(options) {
        super(options);
        this.options = options;
        this.map.viewController.resolution$.subscribe((mapResolution) => {
            if (mapResolution > this.layer.minResolution &&
                mapResolution < this.layer.maxResolution) {
                this.inResolutionRange$.next(true);
            }
            else {
                this.inResolutionRange$.next(false);
            }
        });
    }
    getLayerWksOptionTabQuery() {
        if (this.layer.options.workspace.queryOptions?.tabQuery !== undefined) {
            return this.layer.options.workspace.queryOptions.tabQuery;
        }
        return true;
    }
    getLayerWksOptionMapQuery() {
        if (this.layer.options.workspace.queryOptions?.mapQueryOnOpenTab !== undefined) {
            return this.layer.options.workspace.queryOptions.mapQueryOnOpenTab;
        }
        return true;
    }
    getInResolutionRange() {
        return this.inResolutionRange$.value;
    }
}

class WfsWorkspaceService {
    storageService;
    configService;
    layerService;
    propertyTypeDetectorService;
    capabilitiesService;
    get zoomAuto() {
        return this.storageService.get('zoomAuto');
    }
    ws$ = new BehaviorSubject(undefined);
    constructor(storageService, configService, layerService, propertyTypeDetectorService, capabilitiesService) {
        this.storageService = storageService;
        this.configService = configService;
        this.layerService = layerService;
        this.propertyTypeDetectorService = propertyTypeDetectorService;
        this.capabilitiesService = capabilitiesService;
    }
    createWorkspace(layer, map) {
        if (layer.options.workspace?.enabled === false ||
            layer.dataSource.options.edition) {
            return;
        }
        layer.options.workspace = Object.assign({}, layer.options.workspace, {
            srcId: layer.id,
            workspaceId: layer.id,
            enabled: true
        });
        const wks = new WfsWorkspace({
            id: layer.id,
            title: layer.title,
            layer,
            map,
            entityStore: this.createFeatureStore(layer, map),
            actionStore: new ActionStore([]),
            meta: {
                tableTemplate: undefined
            }
        });
        createTableTemplate(wks, layer, this.layerService, this.ws$);
        return wks;
    }
    createFeatureStore(layer, map) {
        const store = new FeatureStore([], { map });
        store.bindLayer(layer);
        const loadingStrategy = new FeatureStoreLoadingLayerStrategy({});
        const inMapExtentStrategy = new FeatureStoreInMapExtentStrategy({});
        const geoPropertiesStrategy = new GeoPropertiesStrategy({ map }, this.propertyTypeDetectorService, this.capabilitiesService);
        const inMapResolutionStrategy = new FeatureStoreInMapResolutionStrategy({});
        const selectedRecordStrategy = new EntityStoreFilterSelectionStrategy({});
        const confQueryOverlayStyle = this.configService.getConfig('queryOverlayStyle');
        const selectionStrategy = new FeatureStoreSelectionStrategy({
            layer: new VectorLayer({
                zIndex: 300,
                source: new FeatureDataSource(),
                style: (feature) => {
                    return getCommonVectorSelectedStyle(Object.assign({}, { feature }, confQueryOverlayStyle?.selection || {}));
                },
                showInLayerList: false,
                exportable: false,
                browsable: false
            }),
            map,
            hitTolerance: 15,
            motion: this.zoomAuto ? FeatureMotion.Default : FeatureMotion.None,
            many: true,
            dragBox: true
        });
        store.addStrategy(loadingStrategy, true);
        store.addStrategy(inMapExtentStrategy, true);
        store.addStrategy(geoPropertiesStrategy, true);
        store.addStrategy(inMapResolutionStrategy, true);
        store.addStrategy(selectionStrategy, true);
        store.addStrategy(selectedRecordStrategy, false);
        store.addStrategy(createFilterInMapExtentOrResolutionStrategy(), true);
        return store;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: WfsWorkspaceService, deps: [{ token: i2.StorageService }, { token: i2.ConfigService }, { token: LayerService }, { token: PropertyTypeDetectorService }, { token: CapabilitiesService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: WfsWorkspaceService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: WfsWorkspaceService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i2.StorageService }, { type: i2.ConfigService }, { type: LayerService }, { type: PropertyTypeDetectorService }, { type: CapabilitiesService }]; } });

class WmsWorkspaceService {
    layerService;
    storageService;
    capabilitiesService;
    styleService;
    configService;
    propertyTypeDetectorService;
    get zoomAuto() {
        return this.storageService.get('zoomAuto');
    }
    ws$ = new BehaviorSubject$1(undefined);
    constructor(layerService, storageService, capabilitiesService, styleService, configService, propertyTypeDetectorService) {
        this.layerService = layerService;
        this.storageService = storageService;
        this.capabilitiesService = capabilitiesService;
        this.styleService = styleService;
        this.configService = configService;
        this.propertyTypeDetectorService = propertyTypeDetectorService;
    }
    createWorkspace(layer, map) {
        if (!layer.options.workspace ||
            map.layers.find((lay) => lay.id === layer.id + '.WfsWorkspaceTableDest') ||
            layer.dataSource.options.edition) {
            return;
        }
        const dataSource = layer.dataSource;
        const wmsLinkId = layer.id + '.WmsWorkspaceTableSrc';
        const wfsLinkId = layer.id + '.WfsWorkspaceTableDest';
        if (!layer.options.linkedLayers) {
            layer.options.linkedLayers = { linkId: wmsLinkId, links: [] };
        }
        const linkProperties = {
            syncedDelete: true,
            linkedIds: [wfsLinkId],
            properties: [LinkedProperties.ZINDEX, LinkedProperties.VISIBLE]
        };
        if (!layer.options.workspace?.minResolution) {
            linkProperties.properties.push(LinkedProperties.MINRESOLUTION);
        }
        let hasOgcFilters = false;
        if (dataSource.options.ogcFilters?.enabled) {
            linkProperties.properties.push(LinkedProperties.OGCFILTERS);
            hasOgcFilters = true;
        }
        if (!layer.options.workspace?.maxResolution) {
            linkProperties.properties.push(LinkedProperties.MAXRESOLUTION);
        }
        let clonedLinks = [];
        if (layer.options.linkedLayers.links) {
            clonedLinks = JSON.parse(JSON.stringify(layer.options.linkedLayers.links));
        }
        clonedLinks.push(linkProperties);
        (layer.options.linkedLayers.linkId = layer.options.linkedLayers.linkId
            ? layer.options.linkedLayers.linkId
            : wmsLinkId),
            (layer.options.linkedLayers.links = clonedLinks);
        let wks;
        let wksLayerOption = {
            printable: layer.options.workspace?.printable,
            srcId: layer.id,
            workspaceId: undefined,
            enabled: false,
            queryOptions: {
                mapQueryOnOpenTab: layer.options.workspace?.queryOptions?.mapQueryOnOpenTab,
                tabQuery: layer.options.workspace?.queryOptions?.tabQuery
            },
            pageSize: layer.options.workspace?.pageSize,
            pageSizeOptions: layer.options.workspace?.pageSizeOptions
        };
        this.layerService
            .createAsyncLayer({
            isIgoInternalLayer: true,
            id: wfsLinkId,
            linkedLayers: {
                linkId: wfsLinkId
            },
            workspace: wksLayerOption,
            showInLayerList: false,
            opacity: 0,
            title: layer.title,
            minResolution: layer.options.workspace?.minResolution || layer.minResolution || 0,
            maxResolution: layer.options.workspace?.maxResolution ||
                layer.maxResolution ||
                Infinity,
            style: this.styleService.createStyle({
                fill: {
                    color: 'rgba(255, 255, 255, 0.01)'
                },
                stroke: {
                    color: 'rgba(255, 255, 255, 0.01)'
                },
                circle: {
                    fill: {
                        color: 'rgba(255, 255, 255, 0.01)'
                    },
                    stroke: {
                        color: 'rgba(255, 255, 255, 0.01)'
                    },
                    radius: 5
                }
            }),
            sourceOptions: {
                download: dataSource.options.download,
                type: 'wfs',
                url: dataSource.options.urlWfs || dataSource.options.url,
                queryable: true,
                relations: dataSource.options.relations,
                queryTitle: dataSource.options
                    .queryTitle,
                queryFormatAsWms: layer.options.workspace?.enabled
                    ? dataSource.options
                        .queryFormatAsWms
                    : true,
                params: dataSource.options.paramsWFS,
                ogcFilters: Object.assign({}, dataSource.ogcFilters, {
                    enabled: hasOgcFilters
                }),
                sourceFields: dataSource.options.sourceFields || undefined
            }
        })
            .subscribe((workspaceLayer) => {
            map.addLayer(workspaceLayer);
            layer.ol.setProperties({
                linkedLayers: {
                    linkId: layer.options.linkedLayers.linkId,
                    links: clonedLinks
                }
            }, false);
            workspaceLayer.dataSource.ol.refresh();
            if (!layer.options.workspace?.enabled) {
                return;
            }
            wks = new WfsWorkspace({
                id: layer.id,
                title: layer.title,
                layer: workspaceLayer,
                map,
                entityStore: this.createFeatureStore(workspaceLayer, map),
                actionStore: new ActionStore([]),
                meta: {
                    tableTemplate: undefined
                }
            });
            createTableTemplate(wks, workspaceLayer, this.layerService, this.ws$);
            workspaceLayer.options.workspace.workspaceId = workspaceLayer.id;
            layer.options.workspace = Object.assign({}, layer.options.workspace, {
                enabled: true,
                srcId: layer.id,
                workspaceId: workspaceLayer.id,
                queryOptions: {
                    mapQueryOnOpenTab: layer.options.workspace?.queryOptions?.mapQueryOnOpenTab,
                    tabQuery: layer.options.workspace?.queryOptions?.tabQuery
                },
                pageSize: layer.options.workspace?.pageSize,
                pageSizeOptions: layer.options.workspace?.pageSizeOptions
            });
            delete dataSource.options.download;
            return wks;
        });
        return wks;
    }
    createFeatureStore(layer, map) {
        const store = new FeatureStore([], { map });
        store.bindLayer(layer);
        const loadingStrategy = new FeatureStoreLoadingLayerStrategy({});
        const inMapExtentStrategy = new FeatureStoreInMapExtentStrategy({});
        const geoPropertiesStrategy = new GeoPropertiesStrategy({ map }, this.propertyTypeDetectorService, this.capabilitiesService);
        const inMapResolutionStrategy = new FeatureStoreInMapResolutionStrategy({});
        const selectedRecordStrategy = new EntityStoreFilterSelectionStrategy({});
        const confQueryOverlayStyle = this.configService.getConfig('queryOverlayStyle');
        const selectionStrategy = new FeatureStoreSelectionStrategy({
            layer: new VectorLayer({
                zIndex: 300,
                source: new FeatureDataSource(),
                style: (feature) => {
                    return getCommonVectorSelectedStyle(Object.assign({}, { feature }, confQueryOverlayStyle?.selection || {}));
                },
                showInLayerList: false,
                exportable: false,
                browsable: false
            }),
            map,
            hitTolerance: 15,
            motion: this.zoomAuto ? FeatureMotion.Default : FeatureMotion.None,
            many: true,
            dragBox: true
        });
        store.addStrategy(loadingStrategy, true);
        store.addStrategy(inMapExtentStrategy, true);
        store.addStrategy(geoPropertiesStrategy, true);
        store.addStrategy(inMapResolutionStrategy, true);
        store.addStrategy(selectionStrategy, true);
        store.addStrategy(selectedRecordStrategy, false);
        store.addStrategy(createFilterInMapExtentOrResolutionStrategy(), true);
        return store;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: WmsWorkspaceService, deps: [{ token: LayerService }, { token: i2.StorageService }, { token: CapabilitiesService }, { token: StyleService }, { token: i2.ConfigService }, { token: PropertyTypeDetectorService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: WmsWorkspaceService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: WmsWorkspaceService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: LayerService }, { type: i2.StorageService }, { type: CapabilitiesService }, { type: StyleService }, { type: i2.ConfigService }, { type: PropertyTypeDetectorService }]; } });

class WorkspaceSelectorDirective {
    component;
    wfsWorkspaceService;
    wmsWorkspaceService;
    editionWorkspaceService;
    featureWorkspaceService;
    layers$$;
    entities$$ = [];
    map;
    changeWorkspace = new EventEmitter();
    disableSwitch = new EventEmitter();
    relationLayers = new EventEmitter();
    rowsInMapExtentCheckCondition = new EventEmitter();
    get workspaceStore() {
        return this.component.store;
    }
    constructor(component, wfsWorkspaceService, wmsWorkspaceService, editionWorkspaceService, featureWorkspaceService) {
        this.component = component;
        this.wfsWorkspaceService = wfsWorkspaceService;
        this.wmsWorkspaceService = wmsWorkspaceService;
        this.editionWorkspaceService = editionWorkspaceService;
        this.featureWorkspaceService = featureWorkspaceService;
    }
    ngOnInit() {
        this.layers$$ = this.map.layers$
            .pipe(debounceTime(50))
            .subscribe((layers) => this.onLayersChange(layers));
        this.featureWorkspaceService.ws$.subscribe((ws) => {
            this.changeWorkspace.emit(ws);
        });
        this.wmsWorkspaceService.ws$.subscribe((ws) => {
            this.changeWorkspace.emit(ws);
        });
        this.wfsWorkspaceService.ws$.subscribe((ws) => {
            this.changeWorkspace.emit(ws);
        });
        this.editionWorkspaceService.ws$.subscribe((ws) => {
            this.changeWorkspace.emit(ws);
        });
        this.editionWorkspaceService.adding$.subscribe((adding) => {
            this.disableSwitch.emit(adding);
        });
        this.editionWorkspaceService.relationLayers$.subscribe((layers) => {
            this.relationLayers.emit(layers);
        });
        this.editionWorkspaceService.rowsInMapExtentCheckCondition$.subscribe((condition) => {
            this.rowsInMapExtentCheckCondition.emit(condition);
        });
    }
    ngOnDestroy() {
        this.layers$$.unsubscribe();
        this.entities$$.map((entities) => entities.unsubscribe());
    }
    onLayersChange(layers) {
        const editableLayers = layers.filter((layer) => this.layerIsEditable(layer));
        const editableLayersIds = editableLayers.map((layer) => layer.id);
        const workspacesToAdd = editableLayers
            .map((layer) => this.getOrCreateWorkspace(layer))
            .filter((workspace) => workspace !== undefined);
        const workspacesToRemove = this.workspaceStore
            .all()
            .filter((workspace) => {
            return editableLayersIds.indexOf(workspace.id) < 0;
        });
        if (workspacesToRemove.length > 0) {
            workspacesToRemove.forEach((workspace) => {
                workspace.entityStore.deactivateStrategyOfType(FeatureStoreInMapExtentStrategy);
                workspace.deactivate();
            });
            this.workspaceStore.state.updateMany(workspacesToRemove, {
                active: false,
                selected: false
            });
            this.workspaceStore.deleteMany(workspacesToRemove);
        }
        if (workspacesToAdd.length > 0) {
            this.workspaceStore.insertMany(workspacesToAdd);
        }
    }
    getOrCreateWorkspace(layer) {
        const workspace = this.workspaceStore.get(layer.id);
        if (workspace !== undefined) {
            return;
        }
        if (layer.dataSource instanceof WFSDataSource &&
            layer.dataSource.options.edition?.enabled !== true) {
            const wfsWks = this.wfsWorkspaceService.createWorkspace(layer, this.map);
            return wfsWks;
        }
        else if (layer.dataSource instanceof WMSDataSource &&
            layer.dataSource.options.edition?.enabled !== true) {
            if (!layer.dataSource.options.paramsWFS) {
                return;
            }
            const wmsWks = this.wmsWorkspaceService.createWorkspace(layer, this.map);
            wmsWks?.inResolutionRange$.subscribe((inResolutionRange) => {
                layer.dataSource.options.queryable =
                    !inResolutionRange;
                wmsWks.layer.dataSource.options.queryable = inResolutionRange;
            });
            return wmsWks;
        }
        else if (layer.dataSource instanceof FeatureDataSource &&
            layer.exportable === true &&
            layer.dataSource.options.edition?.enabled !== true) {
            const featureWks = this.featureWorkspaceService.createWorkspace(layer, this.map);
            return featureWks;
        }
        else if (layer.dataSource instanceof WMSDataSource &&
            layer.dataSource.options.edition?.enabled === true) {
            const editionWks = this.editionWorkspaceService.createWorkspace(layer, this.map);
            return editionWks;
        }
        return;
    }
    layerIsEditable(layer) {
        const dataSource = layer.dataSource;
        if (dataSource instanceof WFSDataSource) {
            return true;
        }
        if (dataSource instanceof FeatureDataSource) {
            return true;
        }
        if (dataSource instanceof WMSDataSource) {
            const dataSourceOptions = (dataSource.options ||
                {});
            return (dataSourceOptions.ogcFilters?.enabled ||
                dataSource.options.paramsWFS?.featureTypes !== undefined);
        }
        return false;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: WorkspaceSelectorDirective, deps: [{ token: i9$1.WorkspaceSelectorComponent }, { token: WfsWorkspaceService }, { token: WmsWorkspaceService }, { token: EditionWorkspaceService }, { token: FeatureWorkspaceService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: WorkspaceSelectorDirective, selector: "[igoWorkspaceSelector]", inputs: { map: "map" }, outputs: { changeWorkspace: "changeWorkspace", disableSwitch: "disableSwitch", relationLayers: "relationLayers", rowsInMapExtentCheckCondition: "rowsInMapExtentCheckCondition" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: WorkspaceSelectorDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igoWorkspaceSelector]'
                }]
        }], ctorParameters: function () { return [{ type: i9$1.WorkspaceSelectorComponent }, { type: WfsWorkspaceService }, { type: WmsWorkspaceService }, { type: EditionWorkspaceService }, { type: FeatureWorkspaceService }]; }, propDecorators: { map: [{
                type: Input
            }], changeWorkspace: [{
                type: Output
            }], disableSwitch: [{
                type: Output
            }], relationLayers: [{
                type: Output
            }], rowsInMapExtentCheckCondition: [{
                type: Output
            }] } });

/**
 * @ignore
 */
class IgoWorkspaceSelectorModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoWorkspaceSelectorModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoWorkspaceSelectorModule, declarations: [WorkspaceSelectorDirective], imports: [CommonModule], exports: [WorkspaceSelectorDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoWorkspaceSelectorModule, imports: [CommonModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoWorkspaceSelectorModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    exports: [WorkspaceSelectorDirective],
                    declarations: [WorkspaceSelectorDirective]
                }]
        }] });

class WorkspaceUpdatorDirective {
    wfsWorkspaceService;
    wmsWorkspaceService;
    editionWorkspaceService;
    featureWorkspaceService;
    layers$$;
    entities$$ = [];
    map;
    workspaceStore;
    constructor(wfsWorkspaceService, wmsWorkspaceService, editionWorkspaceService, featureWorkspaceService) {
        this.wfsWorkspaceService = wfsWorkspaceService;
        this.wmsWorkspaceService = wmsWorkspaceService;
        this.editionWorkspaceService = editionWorkspaceService;
        this.featureWorkspaceService = featureWorkspaceService;
    }
    ngOnInit() {
        this.layers$$ = this.map.layers$
            .pipe(debounceTime(50))
            .subscribe((layers) => this.onLayersChange(layers));
    }
    ngOnDestroy() {
        this.layers$$.unsubscribe();
        this.entities$$.map((entities) => entities.unsubscribe());
    }
    onLayersChange(layers) {
        const editableLayers = layers.filter((layer) => this.layerIsEditable(layer));
        const editableLayersIds = editableLayers.map((layer) => layer.id);
        const workspacesToAdd = editableLayers
            .map((layer) => this.getOrCreateWorkspace(layer))
            .filter((workspace) => workspace !== undefined);
        const workspacesToRemove = this.workspaceStore
            .all()
            .filter((workspace) => {
            return editableLayersIds.indexOf(workspace.id) < 0;
        });
        if (workspacesToRemove.length > 0) {
            workspacesToRemove.forEach((workspace) => {
                workspace.entityStore.deactivateStrategyOfType(FeatureStoreInMapExtentStrategy);
                workspace.deactivate();
            });
            this.workspaceStore.state.updateMany(workspacesToRemove, {
                active: false,
                selected: false
            });
            this.workspaceStore.deleteMany(workspacesToRemove);
        }
        if (workspacesToAdd.length > 0) {
            this.workspaceStore.insertMany(workspacesToAdd);
        }
    }
    getOrCreateWorkspace(layer) {
        const workspace = this.workspaceStore.get(layer.id);
        if (workspace !== undefined) {
            return;
        }
        if (layer.dataSource instanceof WFSDataSource &&
            layer.dataSource.options.edition?.enabled !== true) {
            const wfsWks = this.wfsWorkspaceService.createWorkspace(layer, this.map);
            return wfsWks;
        }
        else if (layer.dataSource instanceof WMSDataSource &&
            layer.dataSource.options.edition?.enabled !== true) {
            if (!layer.dataSource.options.paramsWFS) {
                return;
            }
            const wmsWks = this.wmsWorkspaceService.createWorkspace(layer, this.map);
            wmsWks?.inResolutionRange$.subscribe((inResolutionRange) => {
                if (layer.dataSource.options
                    ?.queryFormatAsWms) {
                    wmsWks.layer.dataSource.options.queryable = true;
                    return wmsWks;
                }
                layer.dataSource.options.queryable =
                    !inResolutionRange;
                wmsWks.layer.dataSource.options.queryable = inResolutionRange;
            });
            return wmsWks;
        }
        else if (layer.dataSource instanceof FeatureDataSource &&
            layer.exportable === true &&
            layer.dataSource.options.edition?.enabled !== true) {
            const featureWks = this.featureWorkspaceService.createWorkspace(layer, this.map);
            return featureWks;
        }
        else if (layer.dataSource instanceof WMSDataSource &&
            layer.dataSource.options.edition?.enabled === true) {
            const editionWks = this.editionWorkspaceService.createWorkspace(layer, this.map);
            return editionWks;
        }
        return;
    }
    layerIsEditable(layer) {
        const dataSource = layer.dataSource;
        if (dataSource instanceof WFSDataSource) {
            return true;
        }
        if (dataSource instanceof FeatureDataSource) {
            return true;
        }
        if (dataSource instanceof WMSDataSource) {
            const dataSourceOptions = (dataSource.options ||
                {});
            return (dataSourceOptions.ogcFilters?.enabled ||
                dataSource.options.paramsWFS?.featureTypes !== undefined);
        }
        return false;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: WorkspaceUpdatorDirective, deps: [{ token: WfsWorkspaceService }, { token: WmsWorkspaceService }, { token: EditionWorkspaceService }, { token: FeatureWorkspaceService }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: WorkspaceUpdatorDirective, selector: "[igoWorkspaceUpdator]", inputs: { map: "map", workspaceStore: "workspaceStore" }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: WorkspaceUpdatorDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igoWorkspaceUpdator]'
                }]
        }], ctorParameters: function () { return [{ type: WfsWorkspaceService }, { type: WmsWorkspaceService }, { type: EditionWorkspaceService }, { type: FeatureWorkspaceService }]; }, propDecorators: { map: [{
                type: Input
            }], workspaceStore: [{
                type: Input
            }] } });

/**
 * @ignore
 */
class IgoWorkspaceUpdatorModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoWorkspaceUpdatorModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoWorkspaceUpdatorModule, declarations: [WorkspaceUpdatorDirective], imports: [CommonModule], exports: [WorkspaceUpdatorDirective] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoWorkspaceUpdatorModule, imports: [CommonModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoWorkspaceUpdatorModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    exports: [WorkspaceUpdatorDirective],
                    declarations: [WorkspaceUpdatorDirective]
                }]
        }] });

class IgoGeoWorkspaceModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoGeoWorkspaceModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoGeoWorkspaceModule, imports: [CommonModule,
            IgoLanguageModule,
            IgoWidgetModule,
            IgoWorkspaceSelectorModule,
            IgoWorkspaceUpdatorModule,
            IgoOgcFilterModule,
            MatDialogModule], exports: [IgoWorkspaceSelectorModule,
            IgoWorkspaceUpdatorModule,
            IgoOgcFilterModule,
            IgoConfirmationPopupModule] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoGeoWorkspaceModule, providers: [provideOgcFilterWidget()], imports: [CommonModule,
            IgoLanguageModule,
            IgoWidgetModule,
            IgoWorkspaceSelectorModule,
            IgoWorkspaceUpdatorModule,
            IgoOgcFilterModule,
            MatDialogModule, IgoWorkspaceSelectorModule,
            IgoWorkspaceUpdatorModule,
            IgoOgcFilterModule,
            IgoConfirmationPopupModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoGeoWorkspaceModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        IgoLanguageModule,
                        IgoWidgetModule,
                        IgoWorkspaceSelectorModule,
                        IgoWorkspaceUpdatorModule,
                        IgoOgcFilterModule,
                        MatDialogModule
                    ],
                    exports: [
                        IgoWorkspaceSelectorModule,
                        IgoWorkspaceUpdatorModule,
                        IgoOgcFilterModule,
                        IgoConfirmationPopupModule
                    ],
                    declarations: [],
                    providers: [provideOgcFilterWidget()]
                }]
        }] });

class IgoGeoModule {
    static forRoot() {
        return {
            ngModule: IgoGeoModule,
            providers: []
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoGeoModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: IgoGeoModule, exports: [IgoCatalogModule,
            IgoDataSourceModule,
            IgoDownloadModule,
            IgoDrawingToolModule,
            IgoFeatureModule,
            IgoFilterModule,
            IgoGeometryModule,
            IgoImportExportModule,
            IgoLayerModule,
            IgoMapModule,
            IgoMeasureModule,
            IgoMetadataModule,
            IgoOverlayModule,
            IgoPrintModule,
            IgoQueryModule,
            IgoDirectionsModule,
            IgoSearchModule,
            IgoToastModule,
            IgoGeoWorkspaceModule,
            IgoStyleModule,
            IgoWktModule] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoGeoModule, imports: [IgoCatalogModule,
            IgoDataSourceModule,
            IgoDownloadModule,
            IgoDrawingToolModule,
            IgoFeatureModule,
            IgoFilterModule,
            IgoGeometryModule,
            IgoImportExportModule,
            IgoLayerModule,
            IgoMapModule,
            IgoMeasureModule,
            IgoMetadataModule,
            IgoOverlayModule,
            IgoPrintModule,
            IgoQueryModule,
            IgoDirectionsModule,
            IgoSearchModule,
            IgoToastModule,
            IgoGeoWorkspaceModule,
            IgoStyleModule,
            IgoWktModule] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IgoGeoModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [],
                    declarations: [],
                    exports: [
                        IgoCatalogModule,
                        IgoDataSourceModule,
                        IgoDownloadModule,
                        IgoDrawingToolModule,
                        IgoFeatureModule,
                        IgoFilterModule,
                        IgoGeometryModule,
                        IgoImportExportModule,
                        IgoLayerModule,
                        IgoMapModule,
                        IgoMeasureModule,
                        IgoMetadataModule,
                        IgoOverlayModule,
                        IgoPrintModule,
                        IgoQueryModule,
                        IgoDirectionsModule,
                        IgoSearchModule,
                        IgoToastModule,
                        IgoGeoWorkspaceModule,
                        IgoStyleModule,
                        IgoWktModule
                    ]
                }]
        }] });

var LayerListToolControlsEnum;
(function (LayerListToolControlsEnum) {
    LayerListToolControlsEnum["always"] = "always";
    LayerListToolControlsEnum["never"] = "never";
    LayerListToolControlsEnum["default"] = "default";
})(LayerListToolControlsEnum || (LayerListToolControlsEnum = {}));

class OsrmDirectionsSource extends DirectionsSource {
    http;
    config;
    get enabled() {
        return this.options.enabled !== false;
    }
    set enabled(value) {
        this.options.enabled = value;
    }
    static _name = 'OSRM Québec';
    directionsUrl = 'https://geoegl.msp.gouv.qc.ca/services/itineraire/route/v1/driving/';
    options;
    constructor(http, config) {
        super();
        this.http = http;
        this.config = config;
        this.options = this.config.getConfig('directionsSources.osrm') || {};
        this.directionsUrl = this.options.url || this.directionsUrl;
    }
    getName() {
        return OsrmDirectionsSource._name;
    }
    route(coordinates, directionsOptions = {}) {
        const directionsParams = this.getRouteParams(directionsOptions);
        return this.getRoute(coordinates, directionsParams);
    }
    getRoute(coordinates, params) {
        return this.http
            .get(this.directionsUrl + coordinates.join(';'), {
            params
        })
            .pipe(map((res) => this.extractRoutesData(res)));
    }
    extractRoutesData(response) {
        const routeResponse = [];
        response.routes.forEach((route) => {
            routeResponse.push(this.formatRoute(route, response.waypoints));
        });
        return routeResponse;
    }
    getRouteParams(directionsOptions = {}) {
        directionsOptions.alternatives =
            directionsOptions.alternatives !== undefined
                ? directionsOptions.alternatives
                : true;
        directionsOptions.steps =
            directionsOptions.steps !== undefined ? directionsOptions.steps : true;
        directionsOptions.geometries =
            directionsOptions.geometries !== undefined
                ? directionsOptions.geometries
                : 'geojson';
        directionsOptions.overview =
            directionsOptions.overview !== undefined
                ? directionsOptions.overview
                : false;
        directionsOptions.continue_straight =
            directionsOptions.continue_straight !== undefined
                ? directionsOptions.continue_straight
                : false;
        return new HttpParams({
            fromObject: {
                alternatives: directionsOptions.alternatives ? 'true' : 'false',
                overview: directionsOptions.overview ? 'simplified' : 'full',
                steps: directionsOptions.steps ? 'true' : 'false',
                geometries: directionsOptions.geometries
                    ? directionsOptions.geometries
                    : 'geojson',
                continue_straight: directionsOptions.continue_straight
                    ? 'true'
                    : 'false'
            }
        });
    }
    formatRoute(roadNetworkRoute, waypoints) {
        const stepsUI = [];
        roadNetworkRoute.legs.forEach((leg) => {
            leg.steps.forEach((step) => {
                stepsUI.push(step);
            });
        });
        return {
            id: uuid(),
            title: roadNetworkRoute.legs[0].summary,
            source: OsrmDirectionsSource._name,
            sourceType: SourceDirectionsType.Route,
            order: 1,
            format: DirectionsFormat.GeoJSON,
            icon: 'directions',
            projection: 'EPSG:4326',
            waypoints,
            distance: roadNetworkRoute.distance,
            duration: roadNetworkRoute.duration,
            geometry: roadNetworkRoute.geometry,
            legs: roadNetworkRoute.legs,
            steps: stepsUI,
            weight: roadNetworkRoute.weight,
            weight_name: roadNetworkRoute.weight_name
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OsrmDirectionsSource, deps: [{ token: i1.HttpClient }, { token: i2.ConfigService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OsrmDirectionsSource });
}
__decorate([
    Cacheable({
        maxCacheCount: 20,
        cacheHasher: customCacheHasher
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, HttpParams]),
    __metadata("design:returntype", Observable)
], OsrmDirectionsSource.prototype, "getRoute", null);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OsrmDirectionsSource, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: i2.ConfigService }]; }, propDecorators: { getRoute: [] } });

function osrmDirectionsSourcesFactory(http, config) {
    return new OsrmDirectionsSource(http, config);
}
function provideOsrmDirectionsSource() {
    return {
        provide: DirectionsSource,
        useFactory: osrmDirectionsSourcesFactory,
        multi: true,
        deps: [HttpClient, ConfigService]
    };
}

/**
 * Cadastre search source
 */
class CadastreSearchSource extends SearchSource {
    http;
    languageService;
    static id = 'cadastre';
    static type = FEATURE;
    constructor(http, languageService, storageService, options) {
        super(options, storageService);
        this.http = http;
        this.languageService = languageService;
    }
    getId() {
        return CadastreSearchSource.id;
    }
    getType() {
        return CadastreSearchSource.type;
    }
    /*
     * Source : https://wiki.openstreetmap.org/wiki/Key:amenity
     */
    getDefaultOptions() {
        return {
            title: 'Cadastre (Québec)',
            searchUrl: 'https://carto.cptaq.gouv.qc.ca/php/find_lot_v1.php?'
        };
    }
    /**
     * Search a place by name
     * @param term Place name
     * @returns Observable of <SearchResult<Feature>[]
     */
    search(term, options) {
        term = term.endsWith(',') ? term.slice(0, -1) : term;
        term = term.startsWith(',') ? term.substr(1) : term;
        term = term.replace(/ /g, '');
        const params = this.computeSearchRequestParams(term, options || {});
        if (!params.get('numero') || !params.get('numero').match(/^[0-9,]+$/g)) {
            return of([]);
        }
        return this.getCadastre(term, params);
    }
    getCadastre(term, params) {
        return this.http
            .get(this.searchUrl, { params, responseType: 'text' })
            .pipe(map((response) => this.extractResults(response, term)));
    }
    computeSearchRequestParams(term, options) {
        return new HttpParams({
            fromObject: Object.assign({
                numero: term,
                epsg: '4326'
            }, this.params, options.params || {})
        });
    }
    extractResults(response, term) {
        return response
            .split('<br />')
            .filter((lot) => lot.length > 0)
            .map((lot) => this.dataToResult(lot, term));
    }
    dataToResult(data, term) {
        const lot = data.split(';');
        const numero = lot[0];
        const wkt = lot[7];
        const geometry = this.computeGeometry(wkt);
        const properties = {
            NoLot: numero,
            Route: '<span class="routing"> <u>' +
                this.languageService.translate.instant('igo.geo.seeRouting') +
                '</u> </span>'
        };
        const id = [this.getId(), 'cadastre', numero].join('.');
        return {
            source: this,
            meta: {
                dataType: FEATURE,
                id,
                title: numero,
                score: computeTermSimilarity(term.trim(), numero),
                icon: 'map-marker'
            },
            data: {
                type: FEATURE,
                projection: 'EPSG:4326',
                geometry,
                properties,
                meta: {
                    id,
                    title: numero
                }
            }
        };
    }
    computeGeometry(wkt) {
        const feature = new olWKT().readFeature(wkt, {
            dataProjection: 'EPSG:4326',
            featureProjection: 'EPSG:4326'
        });
        return {
            type: feature.getGeometry().getType(),
            coordinates: feature.getGeometry().getCoordinates()
        };
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CadastreSearchSource, deps: [{ token: i1.HttpClient }, { token: i2.LanguageService }, { token: i2.StorageService }, { token: 'options' }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CadastreSearchSource });
}
__decorate([
    Cacheable({
        maxCacheCount: 20,
        cacheHasher: customCacheHasher
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, HttpParams]),
    __metadata("design:returntype", Observable)
], CadastreSearchSource.prototype, "getCadastre", null);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: CadastreSearchSource, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: i2.LanguageService }, { type: i2.StorageService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['options']
                }] }]; }, propDecorators: { getCadastre: [] } });

/**
 * Cadastre search source factory
 * @ignore
 */
function cadastreSearchSourceFactory(http, languageService, storageService, config) {
    return new CadastreSearchSource(http, languageService, storageService, config.getConfig(`searchSources.${CadastreSearchSource.id}`));
}
/**
 * Function that returns a provider for the Cadastre search source
 */
function provideCadastreSearchSource() {
    return {
        provide: SearchSource,
        useFactory: cadastreSearchSourceFactory,
        multi: true,
        deps: [HttpClient, LanguageService, StorageService, ConfigService]
    };
}

/**
 * Nominatim search source
 */
class NominatimSearchSource extends SearchSource {
    http;
    static id = 'nominatim';
    static type = FEATURE;
    constructor(http, options, storageService) {
        super(options, storageService);
        this.http = http;
    }
    getId() {
        return NominatimSearchSource.id;
    }
    getType() {
        return NominatimSearchSource.type;
    }
    /*
     * Source : https://wiki.openstreetmap.org/wiki/Key:amenity
     */
    getDefaultOptions() {
        return {
            title: 'Nominatim (OSM)',
            searchUrl: 'https://nominatim.openstreetmap.org/search',
            settings: [
                {
                    type: 'checkbox',
                    title: 'results type',
                    name: 'amenity',
                    values: [
                        {
                            title: 'igo.geo.search.nominatim.type.food',
                            value: 'bar,bbq,biergaten,cafe,drinking_water,fast_food,food_court,ice_cream,pub,restaurant',
                            enabled: false
                        },
                        {
                            title: 'igo.geo.search.nominatim.type.health',
                            value: 'baby_hatch,clinic,dentist,doctors,hospital,nursing_home,pharmacy,social_facility,veterinary',
                            enabled: false
                        },
                        {
                            title: 'igo.geo.search.nominatim.type.entertainment',
                            value: 'arts_centre,brothel,casino,cinema,community_center_fountain,gambling,nightclub,planetarium \
                          ,public_bookcase,social_centre,stripclub,studio,swingerclub,theatre,internet_cafe',
                            enabled: false
                        },
                        {
                            title: 'igo.geo.search.nominatim.type.finance',
                            value: 'atm,bank,bureau_de_change',
                            enabled: false
                        }
                    ]
                },
                {
                    type: 'radiobutton',
                    title: 'results limit',
                    name: 'limit',
                    values: [
                        {
                            title: '10',
                            value: 10,
                            enabled: true
                        },
                        {
                            title: '20',
                            value: 20,
                            enabled: false
                        },
                        {
                            title: '50',
                            value: 50,
                            enabled: false
                        }
                    ]
                },
                {
                    type: 'radiobutton',
                    title: 'restrictExtent',
                    name: 'countrycodes',
                    values: [
                        {
                            title: 'igo.geo.search.nominatim.country.canada',
                            value: 'CA',
                            enabled: true
                        },
                        {
                            title: 'igo.geo.search.nominatim.country.all',
                            value: null,
                            enabled: false
                        }
                    ]
                },
                {
                    type: 'radiobutton',
                    title: 'multiple object',
                    name: 'dedupe',
                    values: [
                        {
                            title: 'igo.geo.search.searchSources.settings.true',
                            value: 0,
                            enabled: false
                        },
                        {
                            title: 'igo.geo.search.searchSources.settings.false',
                            value: 1,
                            enabled: true
                        }
                    ]
                }
            ]
        };
    }
    /**
     * Search a place by name
     * @param term Place name
     * @returns Observable of <SearchResult<Feature>[]
     */
    search(term, options) {
        const params = this.computeSearchRequestParams(term, options || {});
        if (!params.get('q')) {
            return of([]);
        }
        return this.getSearch(term, params);
    }
    getSearch(term, params) {
        return this.http
            .get(this.searchUrl, { params })
            .pipe(map((response) => this.extractResults(response, term)));
    }
    computeSearchRequestParams(term, options) {
        return new HttpParams({
            fromObject: Object.assign({
                q: this.computeTerm(term),
                format: 'json'
            }, this.params, options.params || {})
        });
    }
    extractResults(response, term) {
        return response.map((data) => this.dataToResult(data, term));
    }
    dataToResult(data, term) {
        const properties = this.computeProperties(data);
        const geometry = this.computeGeometry(data);
        const extent = this.computeExtent(data);
        const id = [this.getId(), 'place', data.place_id].join('.');
        return {
            source: this,
            meta: {
                dataType: FEATURE,
                id,
                title: data.display_name,
                icon: 'map-marker',
                score: computeTermSimilarity(term.trim(), data.display_name)
            },
            data: {
                type: FEATURE,
                projection: 'EPSG:4326',
                geometry,
                extent,
                properties,
                meta: {
                    id,
                    title: data.display_name
                }
            }
        };
    }
    computeProperties(data) {
        return {
            display_name: data.display_name,
            place_id: data.place_id,
            osm_type: data.osm_type,
            class: data.class,
            type: data.type
        };
    }
    computeGeometry(data) {
        return {
            type: 'Point',
            coordinates: [parseFloat(data.lon), parseFloat(data.lat)]
        };
    }
    computeExtent(data) {
        return [
            parseFloat(data.boundingbox[2]),
            parseFloat(data.boundingbox[0]),
            parseFloat(data.boundingbox[3]),
            parseFloat(data.boundingbox[1])
        ];
    }
    computeTerm(term) {
        return this.computeTermTags(term);
    }
    /**
     * Add hashtag from query in Nominatim's format (+[])
     * @param term Query with hashtag
     */
    computeTermTags(term) {
        const hashtags = super.getHashtagsValid(term, 'amenity');
        if (!hashtags) {
            return this.computeTermSettings(term);
        }
        if (!hashtags.length) {
            return null;
        }
        term = term.replace(/(#[^\s]*)/g, '');
        hashtags.forEach((tag) => {
            term += '+[' + tag + ']';
        });
        return term;
    }
    /**
     * Add hashtag from settings in Nominatim's format (+[])
     * @param term Query
     */
    computeTermSettings(term) {
        this.options.settings.forEach((settings) => {
            if (settings.name === 'amenity') {
                settings.values.forEach((conf) => {
                    if (conf.enabled && typeof conf.value === 'string') {
                        const splitted = conf.value.split(',');
                        splitted.forEach((value) => {
                            term += '+[' + value + ']';
                        });
                    }
                });
            }
        });
        return term;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: NominatimSearchSource, deps: [{ token: i1.HttpClient }, { token: 'options' }, { token: i2.StorageService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: NominatimSearchSource });
}
__decorate([
    Cacheable({
        maxCacheCount: 20,
        cacheHasher: customCacheHasher
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, HttpParams]),
    __metadata("design:returntype", Observable)
], NominatimSearchSource.prototype, "getSearch", null);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: NominatimSearchSource, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['options']
                }] }, { type: i2.StorageService }]; }, propDecorators: { getSearch: [] } });

/**
 * Nominatim search source factory
 * @ignore
 */
function nominatimSearchSourceFactory(http, config, storageService) {
    return new NominatimSearchSource(http, config.getConfig(`searchSources.${NominatimSearchSource.id}`), storageService);
}
/**
 * Function that returns a provider for the Nominatim search source
 */
function provideNominatimSearchSource() {
    return {
        provide: SearchSource,
        useFactory: nominatimSearchSourceFactory,
        multi: true,
        deps: [HttpClient, ConfigService, StorageService]
    };
}

/**
 * StoredQueries search source
 */
class StoredQueriesSearchSource extends SearchSource {
    http;
    languageService;
    static id = 'storedqueries';
    static type = FEATURE;
    static propertiesBlacklist = [
        'boundedBy',
        'id',
        'coord_x',
        'coord_y'
    ];
    resultTitle;
    storedQueriesOptions;
    multipleFieldsQuery;
    constructor(http, languageService, storageService, options) {
        super(options, storageService);
        this.http = http;
        this.languageService = languageService;
        this.storedQueriesOptions = options;
        if (this.storedQueriesOptions && !this.storedQueriesOptions.available) {
            return;
        }
        const defaultStoredqueryId = 'rtss';
        const defaultFieldSplitter = [
            { name: 'rtss', defaultValue: '-99' },
            { name: 'chainage', defaultValue: '0', splitPrefix: '\\+' }
        ];
        const defaultOutputformat = 'text/xml; subtype=gml/3.1.1';
        const defaultSrsname = 'EPSG:4326';
        const defaultResultTitle = 'title';
        if (!this.storedQueriesOptions) {
            console.log(' No configuration for this search source (storedqueries). You will use the default values');
            this.storedQueriesOptions = {
                storedquery_id: defaultStoredqueryId,
                fields: defaultFieldSplitter,
                outputformat: defaultOutputformat,
                srsname: defaultSrsname,
                resultTitle: defaultResultTitle
            };
            this.resultTitle = defaultResultTitle;
            console.log('Default values', this.storedQueriesOptions);
        }
        if (!this.storedQueriesOptions.storedquery_id) {
            const err = 'Stored Queries :You have to set "storedquery_id" into StoredQueries options. ex: storedquery_id: "nameofstoredquerie"';
            throw new Error(err);
        }
        if (!this.storedQueriesOptions.fields) {
            throw new Error('Stored Queries :You have to set "fields" into options. ex: fields: {"name": "rtss", "defaultValue": "-99"}');
        }
        this.storedQueriesOptions.outputformat =
            this.storedQueriesOptions.outputformat || 'text/xml; subtype=gml/3.1.1';
        this.storedQueriesOptions.srsname =
            this.storedQueriesOptions.srsname || 'EPSG:4326';
        const storedQueryId = this.storedQueriesOptions.storedquery_id.toLowerCase();
        if (storedQueryId.includes('getfeaturebyid') &&
            this.storedQueriesOptions.outputformat
                .toLowerCase()
                .includes('getfeaturebyid')) {
            let err = 'You must set a geojson format for your stored query. This is due to an openlayers issue)';
            err += ' (wfs 1.1.0 & gml 3.1.1 limitation)';
            throw new Error(err);
        }
        if (!(this.storedQueriesOptions.fields instanceof Array)) {
            this.storedQueriesOptions.fields = [this.storedQueriesOptions.fields];
        }
        this.multipleFieldsQuery =
            this.storedQueriesOptions.fields.length > 1 ? true : false;
        this.storedQueriesOptions.fields.forEach((field, index) => {
            if (this.multipleFieldsQuery && !field.splitPrefix && index !== 0) {
                throw new Error('Stored Queries :You must set a field spliter into your field definition (optional for the first one!)');
            }
            if (!field.defaultValue) {
                throw new Error('Stored Queries :You must set a field default value into your field definition');
            }
        });
        this.storedQueriesOptions.resultTitle =
            this.storedQueriesOptions.resultTitle || this.resultTitle;
    }
    getId() {
        return StoredQueriesSearchSource.id;
    }
    getType() {
        return StoredQueriesSearchSource.type;
    }
    getDefaultOptions() {
        return {
            title: 'Stored Queries',
            searchUrl: 'https://ws.mapserver.transports.gouv.qc.ca/swtq'
        };
    }
    // URL CALL EXAMPLES:
    //  GetFeatureById (mandatory storedquery for wfs server) (outputformat must be in geojson)
    /* eslint-disable max-len */
    //  https://ws.mapserver.transports.gouv.qc.ca/swtq?service=wfs&version=2.0.0&request=GetFeature&storedquery_id=urn:ogc:def:query:OGC-WFS::GetFeatureById&srsname=epsg:4326&outputformat=geojson&ID=a_num_route.132
    //  Custom StoredQuery
    /* eslint-disable max-len */
    //  https://ws.mapserver.transports.gouv.qc.ca/swtq?service=wfs&version=1.1.0&request=GetFeature&storedquery_id=rtss&srsname=epsg:4326&outputformat=text/xml;%20subtype=gml/3.1.1&rtss=0013801110000c&chainage=12
    /**
     * Search a location by name or keyword
     * @param term Location name or keyword
     * @returns Observable of <SearchResult<Feature>[]
     */
    search(term, options) {
        const storedqueriesParams = this.termSplitter(term, this.storedQueriesOptions.fields);
        const params = this.computeRequestParams(options || {}, storedqueriesParams);
        this.options.params = this.options.params ? this.options.params : {};
        this.options.params.page = options.page ? String(options.page) : '1';
        return this.getSearch(term, params);
    }
    getSearch(term, params) {
        return new RegExp('.*?gml.*?', 'i').test(this.storedQueriesOptions.outputformat)
            ? this.http.get(this.searchUrl, { params, responseType: 'text' }).pipe(map((response) => {
                let resultArray = this.extractResults(this.extractWFSData(response), term);
                resultArray.sort((a, b) => a.meta.score > b.meta.score
                    ? 1
                    : a.meta.score === b.meta.score
                        ? a.meta.titleHtml < b.meta.titleHtml
                            ? 1
                            : -1
                        : -1);
                resultArray.reverse();
                if (resultArray.length > Number(this.options.params.limit)) {
                    const idxEnd = Number(this.options.params.limit) *
                        Number(this.options.params.page);
                    const resultTotLenght = resultArray.length;
                    resultArray = resultArray.slice(0, idxEnd);
                    if (idxEnd < resultTotLenght) {
                        resultArray[resultArray.length - 1].meta.nextPage = true;
                    }
                    else {
                        resultArray[resultArray.length - 1].meta.nextPage = false;
                    }
                }
                return resultArray;
            }))
            : this.http.get(this.searchUrl, { params }).pipe(map((response) => {
                return this.extractResults(this.extractWFSData(response), term);
            }));
    }
    getFormatFromOptions() {
        let olFormatCls;
        const outputFormat = this.storedQueriesOptions.outputformat;
        const patternGml3 = new RegExp('.*?gml.*?', 'i');
        const patternGeojson = new RegExp('.*?json.*?', 'i');
        if (patternGeojson.test(outputFormat)) {
            olFormatCls = olformat.GeoJSON;
        }
        if (patternGml3.test(outputFormat)) {
            olFormatCls = olformat.WFS;
        }
        return new olFormatCls();
    }
    extractWFSData(res) {
        const olFormat = this.getFormatFromOptions();
        const geojson = olformat.GeoJSON;
        const wfsfeatures = olFormat.readFeatures(res);
        const features = JSON.parse(new geojson().writeFeatures(wfsfeatures));
        return features;
    }
    termSplitter(term, fields) {
        const splittedTerm = {};
        let remainingTerm = term;
        let cnt = 0;
        // Used to build the default values
        fields.forEach((field) => {
            splittedTerm[field.name] = field.defaultValue;
            const splitterRegex = new RegExp(field.splitPrefix + '(.+)', 'i');
            if (splitterRegex.test(remainingTerm)) {
                cnt = field.splitPrefix ? (cnt += 1) : cnt;
                remainingTerm = remainingTerm.split(splitterRegex)[1];
            }
        });
        if (cnt === 0) {
            splittedTerm[fields[0].name] = term;
            return splittedTerm;
        }
        remainingTerm = term;
        const localFields = [...fields].reverse();
        localFields.forEach((field) => {
            const splitterRegex = new RegExp(field.splitPrefix || '' + '(.+)', 'i');
            if (remainingTerm || remainingTerm !== '') {
                const values = remainingTerm.split(splitterRegex);
                remainingTerm = values[0];
                if (values[1]) {
                    splittedTerm[field.name] = values[1].trim();
                }
            }
        });
        return splittedTerm;
    }
    computeRequestParams(options, queryParams) {
        const wfsversion = this.storedQueriesOptions.storedquery_id
            .toLowerCase()
            .includes('getfeaturebyid')
            ? '2.0.0'
            : '1.1.0';
        return new HttpParams({
            fromObject: Object.assign({
                service: 'wfs',
                version: wfsversion,
                request: 'GetFeature',
                storedquery_id: this.storedQueriesOptions.storedquery_id,
                srsname: this.storedQueriesOptions.srsname,
                outputformat: this.storedQueriesOptions.outputformat
            }, queryParams, this.params, options.params || {})
        });
    }
    extractResults(response, term) {
        return response.features.map((data) => {
            return this.dataToResult(data, term);
        });
    }
    dataToResult(data, term) {
        const properties = this.computeProperties(data);
        const id = [this.getId(), properties.type, data.id].join('.');
        const title = data.properties[this.storedQueriesOptions.resultTitle]
            ? this.storedQueriesOptions.resultTitle
            : this.resultTitle;
        return {
            source: this,
            data: {
                type: FEATURE,
                projection: 'EPSG:4326',
                geometry: data.geometry,
                // extent: data.bbox,
                properties,
                meta: {
                    id,
                    title: data.properties[title]
                }
            },
            meta: {
                dataType: FEATURE,
                id,
                title: data.properties.title,
                titleHtml: data.properties[title],
                icon: 'map-marker',
                score: data.properties.title
                    ? computeTermSimilarity(term.trim(), data.properties.title)
                    : computeTermSimilarity(term.trim(), data.properties[title])
            }
        };
    }
    computeProperties(data) {
        const properties = Object.assign({}, ObjectUtils.removeKeys(data.properties, StoredQueriesSearchSource.propertiesBlacklist), {
            Route: '<span class="routing"> <u>' +
                this.languageService.translate.instant('igo.geo.seeRouting') +
                '</u> </span>'
        });
        return properties;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: StoredQueriesSearchSource, deps: [{ token: i1.HttpClient }, { token: i2.LanguageService }, { token: i2.StorageService }, { token: 'options' }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: StoredQueriesSearchSource });
}
__decorate([
    Cacheable({
        maxCacheCount: 20,
        cacheHasher: customCacheHasher
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, HttpParams]),
    __metadata("design:returntype", Observable)
], StoredQueriesSearchSource.prototype, "getSearch", null);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: StoredQueriesSearchSource, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: i2.LanguageService }, { type: i2.StorageService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['options']
                }] }]; }, propDecorators: { getSearch: [] } });
/**
 * StoredQueriesReverse search source
 */
// EXAMPLE CALLS
/* eslint-disable max-len */
// https://ws.mapserver.transports.gouv.qc.ca/swtq?service=wfs&version=1.1.0&request=GetFeature&storedquery_id=lim_adm&srsname=epsg:4326&outputformat=text/xml;%20subtype=gml/3.1.1&long=-71.292469&lat=46.748107
//
class StoredQueriesReverseSearchSource extends SearchSource {
    http;
    languageService;
    static id = 'storedqueriesreverse';
    static type = FEATURE;
    static propertiesBlacklist = [];
    resultTitle;
    storedQueriesOptions;
    multipleFieldsQuery;
    constructor(http, languageService, storageService, options) {
        super(options, storageService);
        this.http = http;
        this.languageService = languageService;
        this.storedQueriesOptions =
            options;
        if (!this.storedQueriesOptions ||
            (this.storedQueriesOptions && !this.storedQueriesOptions.available)) {
            return;
        }
        if (!this.storedQueriesOptions.storedquery_id) {
            const err = 'Stored Queries :You have to set "storedquery_id" into StoredQueries options. ex: storedquery_id: "nameofstoredquerie"';
            throw new Error(err);
        }
        if (!this.storedQueriesOptions.longField) {
            throw new Error('Stored Queries :You have to set "longField" to map the longitude coordinate to the query params.');
        }
        if (!this.storedQueriesOptions.latField) {
            throw new Error('Stored Queries :You have to set "latField" to map the latitude coordinate to the query params.');
        }
        this.storedQueriesOptions.outputformat =
            this.storedQueriesOptions.outputformat || 'text/xml; subtype=gml/3.1.1';
        this.storedQueriesOptions.srsname =
            this.storedQueriesOptions.srsname || 'EPSG:4326';
        this.storedQueriesOptions.resultTitle =
            this.storedQueriesOptions.resultTitle || this.resultTitle;
    }
    getId() {
        return StoredQueriesReverseSearchSource.id;
    }
    getType() {
        return StoredQueriesReverseSearchSource.type;
    }
    getDefaultOptions() {
        return {
            title: 'Stored Queries (reverse)',
            searchUrl: 'https://ws.mapserver.transports.gouv.qc.ca/swtq'
        };
    }
    /**
     * Search a location by coordinates
     * @param lonLat Location coordinates
     * @param distance Search raidus around lonLat
     * @returns Observable of <SearchResult<Feature>[]
     */
    reverseSearch(lonLat, options) {
        const params = this.computeRequestParams(lonLat, options || {});
        return this.getReverseSearch(params);
    }
    getReverseSearch(params) {
        const isGml = new RegExp('.*?gml.*?', 'i').test(this.storedQueriesOptions.outputformat);
        const request$ = isGml
            ? this.http.get(this.searchUrl, { params, responseType: 'text' })
            : this.http.get(this.searchUrl, { params });
        return request$.pipe(map((response) => {
            return this.extractResults(this.extractWFSData(response));
        }));
    }
    getFormatFromOptions() {
        let olFormatCls;
        const outputFormat = this.storedQueriesOptions.outputformat;
        const patternGml3 = new RegExp('.*?gml.*?', 'i');
        const patternGeojson = new RegExp('.*?json.*?', 'i');
        if (patternGeojson.test(outputFormat)) {
            olFormatCls = olformat.GeoJSON;
        }
        if (patternGml3.test(outputFormat)) {
            olFormatCls = olformat.WFS;
        }
        return new olFormatCls();
    }
    extractWFSData(res) {
        const olFormat = this.getFormatFromOptions();
        const geojson = olformat.GeoJSON;
        const wfsfeatures = olFormat.readFeatures(res);
        const features = JSON.parse(new geojson().writeFeatures(wfsfeatures));
        return features;
    }
    computeRequestParams(lonLat, options) {
        const longLatParams = {};
        longLatParams[this.storedQueriesOptions.longField] = lonLat[0];
        longLatParams[this.storedQueriesOptions.latField] = lonLat[1];
        return new HttpParams({
            fromObject: Object.assign({
                service: 'WFS',
                version: '1.1.0',
                request: 'GetFeature',
                storedquery_id: this.storedQueriesOptions.storedquery_id,
                srsname: this.storedQueriesOptions.srsname,
                outputformat: this.storedQueriesOptions.outputformat
            }, longLatParams, this.params, options.params || {})
        });
    }
    extractResults(response) {
        return response.features.map((data) => {
            return this.dataToResult(data);
        });
    }
    dataToResult(data) {
        const properties = this.computeProperties(data);
        const id = [this.getId(), properties.type, data.id].join('.');
        const title = data.properties[this.storedQueriesOptions.resultTitle]
            ? this.storedQueriesOptions.resultTitle
            : this.resultTitle;
        return {
            source: this,
            data: {
                type: FEATURE,
                projection: 'EPSG:4326',
                geometry: data.geometry,
                properties,
                meta: {
                    id,
                    title: data.properties[title]
                }
            },
            meta: {
                dataType: FEATURE,
                id,
                title: data.properties[title],
                icon: 'map-marker'
            }
        };
    }
    computeProperties(data) {
        const properties = ObjectUtils.removeKeys(data.properties, StoredQueriesReverseSearchSource.propertiesBlacklist);
        const routing = {
            Route: '<span class="routing"> <u>' +
                this.languageService.translate.instant('igo.geo.seeRouting') +
                '</u> </span>'
        };
        return Object.assign(properties, { type: data.properties.doc_type }, routing);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: StoredQueriesReverseSearchSource, deps: [{ token: i1.HttpClient }, { token: i2.LanguageService }, { token: i2.StorageService }, { token: 'options' }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: StoredQueriesReverseSearchSource });
}
__decorate([
    Cacheable({
        maxCacheCount: 20,
        cacheHasher: customCacheHasher
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [HttpParams]),
    __metadata("design:returntype", Observable)
], StoredQueriesReverseSearchSource.prototype, "getReverseSearch", null);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: StoredQueriesReverseSearchSource, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: i2.LanguageService }, { type: i2.StorageService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['options']
                }] }]; }, propDecorators: { getReverseSearch: [] } });

/**
 * StoredQueries search source factory
 * @ignore
 */
function storedqueriesSearchSourceFactory(http, languageService, storageService, config) {
    return new StoredQueriesSearchSource(http, languageService, storageService, config.getConfig(`searchSources.${StoredQueriesSearchSource.id}`));
}
/**
 * Function that returns a provider for the StoredQueries search source
 */
function provideStoredQueriesSearchSource() {
    return {
        provide: SearchSource,
        useFactory: storedqueriesSearchSourceFactory,
        multi: true,
        deps: [HttpClient, LanguageService, StorageService, ConfigService]
    };
}
/**
 * StoredQueriesReverse search source factory
 * @ignore
 */
function storedqueriesReverseSearchSourceFactory(http, languageService, storageService, config) {
    return new StoredQueriesReverseSearchSource(http, languageService, storageService, config.getConfig(`searchSources.${StoredQueriesReverseSearchSource.id}`));
}
/**
 * Function that returns a provider for the StoredQueriesReverse search source
 */
function provideStoredQueriesReverseSearchSource() {
    return {
        provide: SearchSource,
        useFactory: storedqueriesReverseSearchSourceFactory,
        multi: true,
        deps: [HttpClient, LanguageService, StorageService, ConfigService]
    };
}

/**
 * Workspace search source
 */
class WorkspaceSearchSource extends SearchSource {
    languageService;
    static id = 'workspace';
    static type = FEATURE;
    title$ = new BehaviorSubject('');
    get title() {
        return this.title$.getValue();
    }
    constructor(languageService, storageService, options) {
        super(options, storageService);
        this.languageService = languageService;
        this.languageService.translate
            .get(this.options.title)
            .subscribe((title) => this.title$.next(title));
    }
    getId() {
        return WorkspaceSearchSource.id;
    }
    getType() {
        return WorkspaceSearchSource.type;
    }
    getDefaultOptions() {
        const limit = 5;
        return {
            title: 'igo.geo.search.workspace.name',
            searchUrl: undefined,
            settings: [
                {
                    type: 'checkbox',
                    title: 'datasets',
                    name: 'datasets',
                    values: []
                },
                {
                    type: 'radiobutton',
                    title: 'results limit',
                    name: 'limit',
                    values: [
                        { title: '1', value: 1, enabled: limit === 1 },
                        { title: '5', value: 5, enabled: limit === 5 || !limit },
                        { title: '10', value: 10, enabled: limit === 10 },
                        { title: '25', value: 25, enabled: limit === 25 },
                        { title: '50', value: 50, enabled: limit === 50 }
                    ]
                }
            ]
        };
    }
    /**
     * Search a location by name or keyword
     * @param term Location name or keyword
     * @returns Observable of <SearchResult<Feature>[]
     */
    search(term, options) {
        const limitSetting = this.settings.find((s) => s.name === 'limit');
        const limitValue = limitSetting.values.find((v) => v.enabled).value || 5;
        this.options.params.limit = limitValue.toLocaleString();
        const results = [];
        this.options.params.page = (options.page || 1).toLocaleString();
        const page = options.page || 1;
        const datasets = this.options.params.datasets.split(',');
        this.featureStoresWithIndex
            .filter((fswi) => fswi.searchDocument && datasets.includes(fswi.layer.title))
            .map((fswi) => {
            const termToUse = term;
            fswi.searchDocument
                .search(termToUse, { limit: page * limitValue })
                .map((i) => {
                const foundIn = i;
                const field = foundIn.field;
                foundIn.result.map((index) => {
                    const feature = fswi.index.get(index);
                    const score = computeTermSimilarity(termToUse.trim(), feature.properties[field]);
                    results.push({ index, feature, layer: fswi.layer, field, score });
                });
            });
        });
        results.sort((a, b) => (a.score > b.score ? -1 : 1));
        const gettedIndex = [];
        const sortedResultToProcess = [];
        results.map((r) => {
            if (!gettedIndex.includes(r.index)) {
                gettedIndex.push(r.index);
                sortedResultToProcess.push(r);
            }
        });
        return of(this.extractResults(sortedResultToProcess
            .sort((a, b) => (a.score > b.score ? -1 : 1))
            .slice(0, page * limitValue)));
    }
    extractResults(results) {
        return results.map((result) => this.dataToResult(result, results.length));
    }
    dataToResult(data, resultsCnt) {
        const properties = this.computeProperties(data);
        const id = [this.getId(), properties.type, data.index].join('.');
        const titleHtml = data.feature.properties[data.field];
        const subtitleHtml2 = '<br><small> ' + data.layer.title + '</small>';
        return {
            source: this,
            data: {
                type: FEATURE,
                projection: 'EPSG:4326',
                geometry: data.feature.geometry,
                extent: data.feature.extent,
                properties,
                meta: {
                    id,
                    title: data.feature.properties[data.field],
                    alias: this.getAllowedFieldsAndAlias(data.layer)
                }
            },
            meta: {
                dataType: FEATURE,
                id,
                title: data.feature.meta.title,
                titleHtml: titleHtml + subtitleHtml2,
                icon: 'map-marker',
                score: data.score,
                nextPage: resultsCnt % +this.options.params.limit === 0 &&
                    +this.options.params.page < 10
            }
        };
    }
    getAllowedFieldsAndAlias(layer) {
        let allowedFieldsAndAlias;
        if (layer.options?.source?.options?.sourceFields &&
            layer.options.source.options.sourceFields.length >= 1) {
            allowedFieldsAndAlias = {};
            layer.options.source.options.sourceFields.forEach((sourceField) => {
                const alias = sourceField.alias ? sourceField.alias : sourceField.name;
                allowedFieldsAndAlias[sourceField.name] = alias;
            });
        }
        return allowedFieldsAndAlias;
    }
    computeProperties(data) {
        if (!data.feature.geometry) {
            return Object.assign({ type: data.layer.title + '.' + data.field }, data.feature.properties);
        }
        const googleLinksProperties = {
            GoogleMaps: ''
        };
        let googleMaps;
        if (data.feature.geometry.type === 'Point') {
            googleMaps = GoogleLinks.getGoogleMapsCoordLink(data.feature.geometry.coordinates[0], data.feature.geometry.coordinates[1]);
        }
        else {
            const point = pointOnFeature(data.feature.geometry);
            googleMaps = GoogleLinks.getGoogleMapsCoordLink(point.geometry.coordinates[0], point.geometry.coordinates[1]);
        }
        googleLinksProperties.GoogleMaps =
            '<a href=' +
                googleMaps +
                ' target="_blank">' +
                this.languageService.translate.instant('igo.geo.searchByCoord') +
                '</a>';
        if (data.feature.geometry.type === 'Point') {
            googleLinksProperties.GoogleStreetView =
                GoogleLinks.getGoogleStreetViewLink(data.feature.geometry.coordinates[0], data.feature.geometry.coordinates[1]);
        }
        const routing = {
            Route: '<span class="routing"> <u>' +
                this.languageService.translate.instant('igo.geo.seeRouting') +
                '</u> </span>'
        };
        return Object.assign({ type: data.feature.sourceId }, data.feature.properties, googleLinksProperties, routing);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: WorkspaceSearchSource, deps: [{ token: i2.LanguageService }, { token: i2.StorageService }, { token: 'options' }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: WorkspaceSearchSource });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: WorkspaceSearchSource, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i2.LanguageService }, { type: i2.StorageService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: ['options']
                }] }]; } });

/**
 * Workspace search source factory
 * @ignore
 */
function workspaceSearchSourceFactory(languageService, storageService, config) {
    return new WorkspaceSearchSource(languageService, storageService, config.getConfig(`searchSources.${WorkspaceSearchSource.id}`));
}
/**
 * Function that returns a provider for the Workspace search source
 */
function provideWorkspaceSearchSource() {
    return {
        provide: SearchSource,
        useFactory: workspaceSearchSourceFactory,
        multi: true,
        deps: [LanguageService, StorageService, ConfigService]
    };
}

class ConfigFileToGeoDBService {
    http;
    geoDBService;
    messageService;
    constructor(http, geoDBService, messageService) {
        this.http = http;
        this.geoDBService = geoDBService;
        this.messageService = messageService;
    }
    load(url) {
        let downloadMessage;
        this.http
            .get(url)
            .pipe(catchError((error) => {
            this.messageService.error(`GeoData file ${url} could not be read`);
            error.error.caught = true;
            throw error;
        }), concatMap((datasToIDB) => {
            const datas$ = [];
            let firstDownload = true;
            if (datasToIDB?.geoDatas) {
                const currentDate = new Date();
                datasToIDB?.geoDatas.map((geoData) => {
                    if (typeof geoData.triggerDate === 'string') {
                        geoData.triggerDate = new Date(Date.parse(geoData.triggerDate));
                    }
                    if (currentDate >= geoData.triggerDate) {
                        if (geoData.action === 'update') {
                            const insertEvent = `${geoData.source || InsertSourceInsertDBEnum.System} (${geoData.triggerDate})`;
                            geoData.urls.map((url) => {
                                datas$.push(this.geoDBService.getByID(url).pipe(concatMap((res) => {
                                    if (res?.insertEvent !== insertEvent) {
                                        if (firstDownload) {
                                            downloadMessage = this.messageService.info('igo.geo.indexedDb.data-download-start', undefined, {
                                                disableTimeOut: true,
                                                progressBar: false,
                                                closeButton: true,
                                                tapToDismiss: false
                                            });
                                            firstDownload = false;
                                        }
                                        let responseType = 'json';
                                        const isZip = this.isZip(url);
                                        if (isZip) {
                                            responseType = 'arraybuffer';
                                        }
                                        return this.http.get(url, { responseType }).pipe(catchError((error) => {
                                            this.messageService.remove(downloadMessage.toastId);
                                            this.messageService.error('igo.geo.indexedDb.data-download-failed', undefined, { timeOut: 40000 });
                                            error.error.caught = true;
                                            throw error;
                                        }), concatMap((r) => {
                                            if (isZip) {
                                                const observables$ = [
                                                    this.geoDBService.update(url, url, {}, InsertSourceInsertDBEnum.System, insertEvent)
                                                ];
                                                JSZip.loadAsync(r).then((zipped) => {
                                                    zipped.forEach((relativePath) => {
                                                        if (relativePath
                                                            .toLocaleLowerCase()
                                                            .endsWith('.geojson')) {
                                                            zipped
                                                                .file(relativePath)
                                                                .async('text')
                                                                .then((r) => {
                                                                const geojson = JSON.parse(r);
                                                                const subUrl = geoData.zippedBaseUrl || '';
                                                                const zippedUrl = subUrl +
                                                                    (subUrl.endsWith('/')
                                                                        ? ''
                                                                        : '/') +
                                                                    relativePath;
                                                                observables$.push(this.geoDBService.update(zippedUrl, url, geojson, InsertSourceInsertDBEnum.System, insertEvent));
                                                            });
                                                        }
                                                    });
                                                });
                                                return zip(observables$);
                                            }
                                            return this.geoDBService.update(url, url, r, InsertSourceInsertDBEnum.System, insertEvent);
                                        }));
                                    }
                                    else {
                                        return of(false);
                                    }
                                })));
                            });
                        }
                        else if (geoData.action === 'delete') {
                            geoData.urls.map((url) => {
                                datas$.push(this.geoDBService.deleteByKey(url));
                            });
                        }
                    }
                });
            }
            return zip(...datas$);
        }))
            .subscribe(() => {
            if (downloadMessage) {
                setTimeout(() => {
                    this.messageService.remove(downloadMessage.toastId);
                    this.messageService.success('igo.geo.indexedDb.data-download-completed', undefined, { timeOut: 40000 });
                }, 2500);
            }
        });
    }
    isZip(value) {
        const regex = /(zip)$/;
        return typeof value === 'string' && regex.test(value.toLowerCase());
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ConfigFileToGeoDBService, deps: [{ token: i1.HttpClient }, { token: GeoDBService }, { token: i2.MessageService }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ConfigFileToGeoDBService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ConfigFileToGeoDBService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: GeoDBService }, { type: i2.MessageService }]; } });

/*
 * Public API Surface of geo
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AddCatalogDialogComponent, ArcGISRestDataSource, BaseLayersSwitcherComponent, CadastreSearchSource, CapabilitiesService, CartoDataSource, Catalog, CatalogBrowserComponent, CatalogItemType, CatalogLibaryComponent, CatalogService, ClusterDataSource, ConfigFileToGeoDBService, ConfirmationPopupComponent, CoordinatesReverseSearchSource, CoordinatesReverseSearchSourceFactory, CoordinatesSearchResultFormatter, CoordinatesUnit, DDtoDMS, DataService, DataSource, DataSourceService, DirectionRelativePositionType, DirectionType, DirectionsButtonsComponent, DirectionsComponent, DirectionsFormat, DirectionsInputsComponent, DirectionsResultsComponent, DirectionsService, DirectionsSource, DownloadButtonComponent, DownloadService, DrawComponent, DrawControl, DrawIconService, DrawStyleService, DropGeoFileDirective, EditionWorkspace, EditionWorkspaceService, EncodingFormat, EsriStyleGenerator, ExportButtonComponent, ExportError, ExportFormat, ExportInvalidFileError, ExportNothingToExportError, ExportService, FEATURE, FeatureDataSource, FeatureDetailsComponent, FeatureDetailsDirective, FeatureFormComponent, FeatureMotion, FeatureStore, FeatureStoreInMapExtentStrategy, FeatureStoreInMapResolutionStrategy, FeatureStoreLoadingLayerStrategy, FeatureStoreLoadingStrategy, FeatureStoreSearchIndexStrategy, FeatureStoreSelectionStrategy, FeatureWorkspace, FeatureWorkspaceService, FilterableDataSourcePipe, GeoDBService, GeoNetworkService, GeoPropertiesStrategy, GeolocateButtonComponent, GeolocationOverlayType, GeometryFormFieldComponent, GeometryFormFieldInputComponent, GeometrySliceError, GeometrySliceLineStringError, GeometrySliceMultiPolygonError, GeometrySliceTooManyIntersectionError, GeometryType, GoogleLinks, HomeExtentButtonComponent, HoverFeatureDirective, IChercheReverseSearchSource, IChercheSearchResultFormatter, IChercheSearchSource, ILayerSearchResultFormatter, ILayerSearchSource, IgoCatalogBrowserModule, IgoCatalogLibraryModule, IgoCatalogModule, IgoConfirmationPopupModule, IgoDataSourceModule, IgoDirectionsModule, IgoDownloadModule, IgoDrawModule, IgoDrawingToolModule, IgoFeatureDetailsModule, IgoFeatureFormModule, IgoFeatureModule, IgoFilterModule, IgoGeoModule, IgoGeoWorkspaceModule, IgoGeometryFormFieldModule, IgoGeometryModule, IgoHttpParameterCodec, IgoImportExportModule, IgoLayerModule, IgoMap, IgoMapModule, IgoMeasureModule, IgoMeasurerModule, IgoMetadataModule, IgoOgcFilterModule, IgoOverlayModule, IgoPrintModule, IgoQueryModule, IgoSearchBarModule, IgoSearchModule, IgoSearchResultsModule, IgoSearchSelectorModule, IgoSearchSettingsModule, IgoStyleListModule, IgoStyleModule, IgoToastModule, IgoWktModule, IgoWorkspaceSelectorModule, IgoWorkspaceUpdatorModule, ImageArcGISRestDataSource, ImageLayer, ImageWatcher, ImportError, ImportExportComponent, ImportInvalidFileError, ImportNothingToImportError, ImportOgreServerError, ImportSRSError, ImportService, ImportSizeError, ImportUnreadableFileError, InfoSectionComponent, InsertSourceInsertDBEnum, LAYER, LabelType, Layer, LayerDBService, LayerItemComponent, LayerLegendComponent, LayerLegendItemComponent, LayerLegendListBindingDirective, LayerLegendListComponent, LayerListBindingDirective, LayerListComponent, LayerListControlsEnum, LayerListDisplacement, LayerListSelectVisibleEnum, LayerListToolComponent, LayerListToolControlsEnum, LayerListToolService, LayerService, LinkedProperties, MEASURE_UNIT_AUTO, MVTDataSource, MapBase, MapBrowserComponent, MapCenterComponent, MapController, MapGeolocationController, MapOfflineDirective, MapService, MapViewAction, MapViewController, MeasureAreaUnit, MeasureAreaUnitAbbreviation, MeasureFormatPipe, MeasureLengthUnit, MeasureLengthUnitAbbreviation, MeasureType, MeasurerComponent, MenuButtonComponent, MetadataAbstractComponent, MetadataButtonComponent, MetadataService, MiniBaseMapComponent, ModifyControl, NominatimSearchSource, OGCFilterService, OSMDataSource, OfflineButtonComponent, OgcFilterButtonComponent, OgcFilterComponent, OgcFilterFormComponent, OgcFilterOperator, OgcFilterOperatorType, OgcFilterSelectionComponent, OgcFilterTimeComponent, OgcFilterTimeSliderComponent, OgcFilterWidget, OgcFilterWriter, OgcFilterableFormComponent, OgcFilterableItemComponent, OgcFilterableListBindingDirective, OgcFilterableListComponent, OlDragSelectInteraction, OptionsApiService, OptionsService, OsmLinks, OsrmDirectionsSource, Overlay, OverlayAction, OverlayDirective, OverlayService, PointerPositionDirective, PrintComponent, PrintFormComponent, PrintLegendPosition, PrintOrientation, PrintOutputFormat, PrintPaperFormat, PrintResolution, PrintSaveImageFormat, PrintService, ProjectionService, PropertyTypeDetectorService, ProposalType, QueryDirective, QueryFormat, QueryFormatMimeType, QueryHtmlTarget, QuerySearchSource, QueryService, ResponseType, RotationButtonComponent, RoutesFeatureStore, SEARCH_TYPES, STYLELIST_OPTIONS, SearchBarComponent, SearchPointerSummaryDirective, SearchResultAddButtonComponent, SearchResultMode, SearchResultsComponent, SearchResultsItemComponent, SearchSelectorComponent, SearchService, SearchSettingsComponent, SearchSource, SearchSourceService, SliceControl, SourceDirectionsType, SpatialFilterItemComponent, SpatialFilterItemType, SpatialFilterListComponent, SpatialFilterQueryType, SpatialFilterService, SpatialFilterType, SpatialFilterTypeComponent, StepFeatureStore, StopsFeatureStore, StopsStore, StoredQueriesReverseSearchSource, StoredQueriesSearchSource, StyleListService, StyleModalDrawingComponent, StyleModalLayerButtonComponent, StyleModalLayerComponent, StyleService, SwipeControlComponent, TileArcGISRestDataSource, TileDebugDataSource, TileLayer, TileWatcher, TimeFilterButtonComponent, TimeFilterFormComponent, TimeFilterItemComponent, TimeFilterListBindingDirective, TimeFilterListComponent, TimeFilterService, TimeFilterStyle, TimeFilterType, ToastComponent, TooltipType, TrackFeatureButtonComponent, TypeCapabilities, TypeCatalog, VectorLayer, VectorTileLayer, VectorWatcher, WFSDataSource, WFSService, WMSDataSource, WMTSDataSource, WakeLockButtonComponent, WebSocketDataSource, WfsWorkspace, WfsWorkspaceService, WktService, WorkspaceSearchSource, WorkspaceSelectorDirective, WorkspaceUpdatorDirective, XYZDataSource, ZoomButtonComponent, addDirectionToRoutesFeatureStore, addLayerAndFeaturesStyledToMap, addLayerAndFeaturesToMap, addLinearRingToOlPolygon, addOrRemoveLayer, addStopToStopsFeatureStore, addStopToStore, buildUrl, cadastreSearchSourceFactory, checkWfsParams, clearOlGeometryMidpoints, computeBestAreaUnit, computeBestLengthUnit, computeLayerTitleFromFile, computeMVTOptionsOnHover, computeOlFeatureExtent, computeOlFeaturesDiff, computeOlFeaturesExtent, computeProjectionsConstraints, computeRelativePosition, computeStopsPosition, computeTermSimilarity, convertDDToDMS, createDefaultTileGrid, createDrawHoleInteractionStyle, createDrawInteractionStyle, createFilterInMapExtentOrResolutionStrategy, createInteractionStyle, createMeasureInteractionStyle, createMeasureLayerStyle, createOlTooltipAtPoint, createOlTooltipDrawAtPoint, createOverlayDefaultStyle, createOverlayLayer, createOverlayLayerStyle, createOverlayMarkerStyle, createTableTemplate, ctrlKeyDown, defaultCoordinatesSearchResultFormatterFactory, defaultEpsg, defaultFieldNameGeometry, defaultIChercheSearchResultFormatterFactory, defaultMaxFeatures, defaultWfsVersion, directionsStyle, entitiesToRowData, exportToCSV, featureFromOl, featureRandomStyle, featureRandomStyleFunction, featureToOl, featureToSearchResult, featuresAreOutOfView, featuresAreTooDeepInView, findDiff, formatDistance, formatDuration, formatInstruction, formatMeasure, formatScale, formatWFSQueryString, generateArcgisRestIdFromSourceOptions, generateFeatureIdFromSourceOptions, generateId, generateIdFromSourceOptions, generateWMSIdFromSourceOptions, generateWMTSIdFromSourceOptions, generateWfsIdFromSourceOptions, generateXYZIdFromSourceOptions, getAllChildLayersByDeletion, getAllChildLayersByProperty, getCommonVectorSelectedStyle, getCommonVectorStyle, getDirectChildLayersByDeletion, getDirectChildLayersByProperty, getDirectParentLayerByDeletion, getDirectParentLayerByProperty, getFileExtension, getFormatFromOptions, getGeoServiceAction, getIgoLayerByLinkId, getLayersLegends, getLinkedLayersOptions, getMousePositionFromOlGeometryEvent, getOlTooltipAtCenter, getOlTooltipsAtMidpoints, getResolutionFromScale, getRootParentByDeletion, getRootParentByProperty, getRowsInMapExtent, getScaleFromResolution, getSelectedOnly, getTooltipsOfOlGeometry, gmlRegex, handleFileExportError, handleFileExportSuccess, handleFileImportError, handleFileImportSuccess, handleInvalidFileImportError, handleLayerPropertyChange, handleNothingToExportError, handleNothingToImportError, handleOgreServerImportError, handleSRSImportError, handleSizeFileImportError, handleUnreadbleFileImportError, hideOlFeature, hoverFeatureMarkerStyle, ichercheReverseSearchSourceFactory, ichercheSearchSourceFactory, ilayerSearchResultFormatterFactory, ilayerSearchSourceFactory, initLayerSyncFromRootParentLayers, initRoutesFeatureStore, initStepFeatureStore, initStopsFeatureStore, jsonRegex, layerFeatureIsQueryable, layerHasLinkDeletion, layerHasLinkWithProperty, layerIsQueryable, lonLatConversion, mapExtentStrategyActiveToolTip, measureOlGeometry, measureOlGeometryArea, measureOlGeometryLength, metersToFeet, metersToKilometers, metersToMiles, metersToUnit, moveToOlFeatures, mtmZoneFromLonLat, noElementSelected, nominatimSearchSourceFactory, ogcFilterWidgetFactory, olLayerFeatureIsQueryable, olLayerIsQueryable, olStyleToBasicIgoStyle, optionsApiFactory, osrmDirectionsSourcesFactory, pointerPositionSummaryMarkerStyle, provideCadastreSearchSource, provideCoordinatesReverseSearchSource, provideDefaultCoordinatesSearchResultFormatter, provideDefaultIChercheSearchResultFormatter, provideIChercheReverseSearchSource, provideIChercheSearchSource, provideILayerSearchResultFormatter, provideILayerSearchSource, provideNominatimSearchSource, provideOgcFilterWidget, provideOptionsApi, provideOsrmDirectionsSource, provideSearchSourceService, provideStoredQueriesReverseSearchSource, provideStoredQueriesSearchSource, provideStyleListLoader, provideStyleListOptions, provideWorkspaceSearchSource, removeStopFromStore, renderFeatureFromOl, roundCoordTo, roundCoordToString, scaleExtent, searchSourceServiceFactory, setRowsInMapExtent, setSelectedOnly, sliceOlGeometry, sliceOlLineString, sliceOlPolygon, sourceCanReverseSearch, sourceCanReverseSearchAsSummary, sourceCanSearch, squareMetersToAcres, squareMetersToHectares, squareMetersToSquareFeet, squareMetersToSquareKilometers, squareMetersToSquareMiles, squareMetersToUnit, standardizeUrl, storedqueriesReverseSearchSourceFactory, storedqueriesSearchSourceFactory, stringToLonLat, styleListFactory, translateBearing, translateModifier, tryAddLoadingStrategy, tryAddSelectionStrategy, tryBindStoreLayer, updateOlGeometryCenter, updateOlGeometryMidpoints, updateOlTooltipAtCenter, updateOlTooltipDrawAtCenter, updateOlTooltipsAtMidpoints, updateOlTooltipsDrawAtMidpoints, updateStoreSorting, utmZoneFromLonLat, viewStatesAreEqual, workspaceSearchSourceFactory, zoneMtm, zoneUtm };
//# sourceMappingURL=igo2-geo.mjs.map
